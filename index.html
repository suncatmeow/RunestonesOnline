<!DOCTYPE html>
  <html>
    <head>
      <meta charset="utf-8"/>
      <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
      <title>Battle-Mage</title>
      <style>
        html,body {
          width:100%;
          height: 100%;
          margin: 0px;
          border: 0;
          overflow: hidden;
          display:block;
                 touch-action: none;             
          -webkit-user-select: none;      
          user-select: none;
          -webkit-tap-highlight-color: transparent;
        }
      </style>
      
      <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>    </head>

    </head>
    <body>
<canvas id ="c" style = "position:absolute; left:0px; top:0px;"></canvas>
<script>
if (localStorage.getItem('battlemage_banned')) {
    document.body.innerHTML = "<h1>SUNCAT BANISHED YOU</h1>";
    throw new Error("Banned");
}
//////////////////////[VARIABLE DECLARATIONS]///////////////////////////
var canvas = document.getElementById("c");
var ctx = canvas.getContext("2d");
var wX = 0; //window length
var wY = 0; //window height
var tL = 0; //table length
var tH = 0; //table height
var tX = 0; //table top-left x coordinate(0,0)
var tY = 0; //table top-left x coordinate(0,0)
var cc = 0; //hand counter
var startGame = 0;
var timer = 0;
var s = 0;
var t = '';
var test1 = -22;
let lastTriggerTime = Date.now();
let lastTriggerTime2 = Date.now();
let lastSongTime = Date.now();
let lastTouchTime = 0;
let lastrandom = rnd(0,21);
var lastInputTime = 0;
const eIMG = {BLANK:0,LOGO:1,HEART:2,CHEST:3,TOME:4,SWORD:5,SHIELD:6,STAFF:7,WBOOT:8,GOBLIN:9}
const eLOOK = {F:0,D:1,M:2,H:3,A:4,R:5,S:6,STAT:7,INDEX:8}//field,deck,monster,hand,action,roll,stone
const eSTAT = {S:0,C:1,I:2,A:3}
const eDICE = {MIN:0, MAX:1, MOD:2,TXT:3}
const eTYPE = {MONSTER:0,ITEM:1,SPELL:2,NULL:3}
const eSUBTYPE = {NONE:0, EFFECT:1, USE:2, EQUIP:3,TREASURE:4}
var cL = 2.25; //card length
var cH = 3.5; //card height

var cY = 6.5;//card y
var arY = cY + 1.3; //arrow y
var abY = cY -.77; //action button Y
var aLH = .57; // hand arrow height and length

var hX = .875;//hand x
var halX = hX -.35;//hand l arrow x
var harX = hX+2.04;//hand r arrow x
var huX = hX *.96; //hand use x
var heX = hX + cL / 1.39; //hand examine x

var mX = 3.875; //monster x
var malX = mX -.35;//monster l arrow x
var marX = mX + 2.04;//monster r arrow x
var maX = mX * .99; //monstermonster attack x
var meX = mX + cL / 1.39; //monsterexamine x

  
var actLH = .66; //use/examine/attack button LH
var actY = cY - actLH-.16;//use/examine/attack Y
let lastFrameTime = Date.now();
let coinanix = 5;
let coinaniy = 5;
let coinaniz = 1;
let coinanir = 1;
let coinswitch = 0;
let debug = 0;
let spellcheck = 0;
let winSpellTie = 0;
let winTie = 0;
let foeWinsTie = 0;
let dragonHoard = 0;
let songcount = 43;
let grimIndex = 0;
var preGame = 0;
var viewingFullDeck = false;
var currentOracleText = "";  // Holds the text so it doesn't flicker
var lastViewedCardID = -1;   // Remembers which card we just generated text for
var activePlaylist = []; // Holds the IDs of allowed cards (e.g. [22, 23, 24...])
var playlistIndex = 0;   // Which page of the playlist we are on (0, 1, 2...)
var rankList = ['All', 'Ace', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Page', 'Knight', 'Queen', 'King'];
var rankFilterIndex = 0; // 0 = 'All'
var resize = 0;
var globalDt = 0;
let ani = 0;
let lastanitime = Date.now();
let portraitani = 0;
let lastsfxtime = Date.now();
let dragY = 0;
let activeM = 0;
let defender = 0;
let attacker = 0;
let myState = 0;
let oppState = 0;
let spread = 0;
//ONLINE
const socket = io("https://battlemage.onrender.com"); 
window.pendingChallengerDeck = [];
endBattle = 0;
window.remotePlayers = {};
//SUNCAT AI
const AI_MEMORY_KEY = "Suncat_Memory_v1";
const CORE_MEMORY_KEY = "Suncat_Core_Facts";
const FAVOR_KEY = "Suncat_Favor_v1";
let lastSenderName = "";
let lastMessageTimeReceived = 0;
// --- CHAT GLOBALS ---
var playerSprite = 0;   // The ID of the sprite you look like
var ps = 0;
var playerName = "Fool"; // Default Name
var chatLog = [];
var chatDraft = "";
var isChatActive = false;
var chatInput = document.createElement('input'); // Create it immediately
chatInput.type = 'text';
chatInput.style.position = 'absolute';
chatInput.style.opacity = '0'; 
chatInput.style.top = '0px';    // <--- SAFE
chatInput.style.left = '0px';   // <--- SAFE
chatInput.style.width = '1px';  // <--- SAFE
chatInput.style.height = '1px'; // <--- SAFE
chatInput.style.pointerEvents = 'none'; // Lets clicks pass through if needed
document.body.appendChild(chatInput); // <--- THIS IS THE MISSING KEY!
var lastChatTime = Date.now(); // Tracks the last time chat was active
var cardIDO = 0;
var cardIDI = 0;
chatInput.addEventListener('input', function(e) {
    chatDraft = chatInput.value;
    lastChatTime = Date.now(); // <--- ADD THIS (Keep awake while typing)
    console.log("Typing:", chatDraft); // Check your console when you type!
});
chatInput.addEventListener('input', function(e) {
    chatDraft = chatInput.value;
});


// Keydown listener for Desktop "Enter" key
window.addEventListener('keydown', function(e) {
    if (e.key === "Enter") {
        if (isChatActive) {
          // --- NEW LOGIC FOR CHARACTER SELECT ---
            if (startGame == 'charSelect') {
                if (chatDraft.trim() !== "") {
                    playerName = chatDraft; // Save the name
                    
                }
                chatInput.blur();
                isChatActive = false;
                return; // Stop here! Don't send as chat.
            }
            // --------------------------------------
            // SEND
            let msg = chatDraft.trim(); 

            if (msg !== "") {
                
                // === COMMAND CHECK: TELEPORT ===
                // Usage: .//teleport 5
                if (msg.toLowerCase().startsWith('.hack//teleport')) {
                    let parts = msg.split(" ");
                    let targetID = parseInt(parts[1]);

                    if (!isNaN(targetID)) {
                        Dungeon.loadMap(targetID); // Teleport!
                        chatLog.push(`[SYSTEM]: Teleporting to Map ${targetID}...`);
                    } else {
                        chatLog.push(`[SYSTEM]: Invalid Map ID.`);
                    }
                }
                if (msg.toLowerCase().startsWith('.hack//transform')) {
                    let parts2 = msg.split(" ");
                    let targetp = parseInt(parts2[1]);

                    if (!isNaN(targetp)) {
                        switch(targetp){
                    case 0:
                      playerSprite = 0;
                      break;
                      case 1:
                        playerSprite = 1;
                      break;
                      case 2:
                        playerSprite = 2;
                      break;
                      case 3:
                        playerSprite = 3;
                      break;
                      case 4:
                        playerSprite = 4;
                      break;
                      case 5:
                      playerSprite = 5;
                      break;
                      case 6:
                        playerSprite = 8;
                      break;
                      case 7:
                        playerSprite = 9.1;
                      break;
                      case 8:
                        playerSprite = 10;
                      break;
                      case 9:
                        playerSprite = 13;
                      break;
                      case 10:
                        playerSprite = 23.1;
                      break;
                      case 11:
                        playerSprite = 32.1;
                      break;
                      case 12:
                        playerSprite = 33.1;
                      break;
                      case 13:
                        playerSprite = 34.1;
                      break;
                      case 14:
                        playerSprite = 35.1;
                      break;
                      case 15:
                        playerSprite = 37.1;
                      break;
                      case 16:
                        playerSprite = 46.1;
                      break;
                      case 17:
                        playerSprite = 48.1;
                      break;
                      case 18:
                        playerSprite = 54;
                      break;
                      case 19:
                        playerSprite = 56.1;
                      break;
                      case 20:
                        playerSprite = 57.1;
                      break;
                      case 21:
                        playerSprite = 60.1;
                      break;
                      case 22:
                        playerSprite = 61.1;
                      break;
                      case 23:
                        playerSprite = 61.2;
                      break;
                      case 24:
                        playerSprite = 50;
                      break;
                      case 25:
                        playerSprite = 23;
                      break;
                      case 26:
                        playerSprite = 77.1;
                      break;
                      case 27:
                        playerSprite = 77.2;
                      break;
                      case 28:
                        playerSprite = 75.1;
                      break;
                      case 29:
                        playerSprite = 81;
                      break;
                      case 30:
                        playerSprite = 82;
                      break;
                      case 31:
                        playerSprite = 56;
                      break;
                      case 32:
                        playerSprite = 28888;
                      break;
                      

                  }
   
                    } else {
                        chatLog.push(`[SYSTEM]: Invalid Sprite Index`);
                    }
                }
                 
                else if (msg.toLowerCase() === '.hack//delete') {
                  // Clear the save data
                  localStorage.removeItem('battlemage_save'); 
                  
                  // Optional: Clear everything if you have other keys
                  // localStorage.clear(); 
                  
                  // Reload to force the "New Game" state
                  location.reload(); 
                }
                else if (msg.toLowerCase() === '.hack//vanquish') {
                  if(startGame == 'battle'){
                    Player[1].option = 10.1;
                    Player[0].option = 10;
                  }
                }
                else if (msg.toLowerCase() === '.hack//sign') {
                  if(Dbug == 0){
                    Dbug = 1;
                  }
                  else if(Dbug == 1){
                    Dbug = 0;
                  }
                }
                else if (msg.toLowerCase() === '.hack//respawn') {
                  // A. Identify the prefix for this map (e.g., "1_" for Map 1)
                  let prefix = Dungeon.mapID + "_";
                  
                  // B. Clear memory of dead NPCs ONLY on this map
                  // (We don't want to reset bosses on other maps we already killed)
                  for (let key in Dungeon.memory) {
                      if (key.startsWith(prefix)) {
                          delete Dungeon.memory[key];
                      }
                  }

        // C. Now reload the map (The game will see no memory of death, so they spawn)
        Dungeon.loadMap(Dungeon.mapID);
        
        chatLog.push(`[SYSTEM]: Local NPCs respawned.`);
    }
                else if (msg.toLowerCase() === '.hack//reset') {
                  Dungeon.refreshNPCs()
                  // C. Now reload the map (The game will see no memory of death, so they spawn)
                  Dungeon.loadMap(Dungeon.mapID);
                  chatLog.push(`[SYSTEM]: Monsters roam the land...`);
                }
                else if (msg.toLowerCase().startsWith('.hack//card')){
                  let parts3 = msg.split(" ");
                    let targetID3 = parseInt(parts3[1]);

                    if (!isNaN(targetID3)) {
                      Dungeon.spawnPersistentNPC(Dungeon.mapID, Dungeon.npcs.length, Dungeon.x, Dungeon.y-1, -27, 'stationary', '#ffff00',[targetID3]);    
                        chatLog.push(`[SYSTEM]: A card meterializes out of thin air...`);
                    } else {
                        chatLog.push(`[SYSTEM]: The spell fizzles into smoke.`);
                    }

                }
                else if (msg.toLowerCase().startsWith('.hack//song')) {
                    let parts4 = msg.split(" ");
                    let targetID4 = parseInt(parts4[1]);

                    if (!isNaN(targetID4)) {
                        chatLog.push(`[SYSTEM]: A melody fills the air only I can hear...`);
                        MusicEngine.stop();
                        MusicEngine.play(targetID4)
                    } else {
                        chatLog.push(`[SYSTEM]: Invalid Song (pick from tracks 0-42) .`);
                    }
                }
                else if (msg.toLowerCase() === '.hack//ssong') {
                  MusicEngine.stop();
                  MusicEngine.play(rnd(0,songcount - 1))
                }
                else if (msg.toLowerCase().startsWith('.hack//sfx')) {
                    let parts5 = msg.split(" ");
                    let targetID5 = parseInt(parts5[1]);

                    if (!isNaN(targetID5)) {
                      chatLog.push(`[SYSTEM]: A strange sound fills the air...`);
                      MusicEngine.play3DSFX(targetID5, Dungeon.x, Dungeon.y,Dungeon.x+1, Dungeon.y+1,Dungeon.dir)
                      socket.emit('playerAction_SFX', {
                        id: targetID5,
                        x: Dungeon.x,
                        y: Dungeon.y,
                        dir: Dungeon.dir
                      });
                    }
                    else {
                        chatLog.push(`[SYSTEM]: Invalid SFX (pick from 0-8) .`);
                    }
                }
                
                // === NORMAL CHAT MESSAGE ===
                // === NORMAL CHAT MESSAGE ===
                else {
                    // 1. Define the limit (How many chars fit nicely on one line?)
                    // Adjust this number (e.g., 40, 50, 60) based on your UI width.
                    const MAX_LEN = 60; 
                    
                    // 2. Split the message into chunks by word
                    let chunks = [];
                    let words = msg.split(" ");
                    let currentLine = "";

                    words.forEach(word => {
                        // Check if adding the next word exceeds the limit
                        if ((currentLine + word).length < MAX_LEN) {
                            currentLine += (currentLine.length > 0 ? " " : "") + word;
                        } else {
                            // Current line is full, push it and start a new one
                            chunks.push(currentLine);
                            currentLine = word;
                        }
                    });
                    // Push the final remaining line
                    if (currentLine.length > 0) chunks.push(currentLine);

                    // 3. Process and Send EACH chunk individually
                    chunks.forEach(chunkMsg => {
                        
                        // --- SUNCAT MEMORY LOGIC START ---
                        if (typeof socket !== 'undefined') {
                            let history = getAiMemory();
                            let lastWasSuncat = (history.length > 0 && history[history.length - 1].role === 'model');
                            let finalMsg = chunkMsg;

                            // Note: We check the ORIGINAL 'msg' for the keyword to ensure context isn't lost
                            // if the word "suncat" happened to be in a previous chunk.
                            let isTalkingToCat = msg.toLowerCase().includes("suncat");

                            if (lastWasSuncat && !isTalkingToCat) {
                                finalMsg = "[REPLY]: " + chunkMsg; 
                            }
                            
                            if (isTalkingToCat || lastWasSuncat) {
                                saveInteraction("user", chunkMsg);
                            }

                            // 4. Send to server
                            socket.emit('chat_message', finalMsg); 
                        }
                        // --- SUNCAT MEMORY LOGIC END ---
                    });
                }
                // === CLEANUP ===
                lastChatTime = Date.now(); // Keep awake
                chatInput.value = "";
                chatDraft = "";
            }

            // Close Chat Mode
            chatInput.blur();
            isChatActive = false;
            
        } else {
            // OPEN Chat Mode
            chatInput.focus();
            isChatActive = true;
        }
    }
});
/////////////////////
const rankMeanings = {
    "Ace": ["A potent new beginning in matters of", "Raw potential in", "A spark of inspiration in matters of"],
    "Two": ["A duality in matters relating to", "A partnership that has to do with", "The need for balance regarding"],
    "Three": ["Collaboration in matters to do with", "Initial growth in", "Expansion surrounding"],
    "Four": ["Stability in matters concerning", "A solid foundation for", "Establishing boundaries in matters of"],
    "Five": ["Conflict surrounding", "Instability regarding", "A necessary change in matters of"],
    "Six": ["Harmony in matters of", "Nostalgia in matters to do with", "Overcoming past difficulties regarding"],
    "Seven": ["A strategic approach to", "Assessment of one's", "Choices surrounding"],
    "Eight": ["Rapid movement in matters of", "Repetition of something to do with", "Hard work in things done regarding"],
    "Nine": ["Near-completion of a matter relating to", "Solitary reflection on", "Fulfillment in the realm of"],
    "Ten": ["The end of a cycle in regards to", "Final culmination of", "Full realization of"],
    "Page": ["Youthful curiosity when dealing with matters of", "New messages about", "Exploration of realms related to"],
    "Knight": ["Action taken in matters of", "Determination when dealing with matters of", "Charging forward in things to do with"],
    "Queen": ["Mastery over", "Internal power cultivated through", "Nurturing influence in matters of"],
    "King": ["Authority in matters concerning", "Control over one's", "External leadership in things having to do with"]
};
const majorMeanings = {
    "The Fool": ["A leap of faith", "New beginnings", "Infinite potential"],
    "The Magician": ["Manifestation", "Resourcefulness", "Inspired action"],
    "The High Priestess": ["Intuition", "Sacred knowledge", "The subconscious mind"],
    "The Empress": ["Femininity", "Beauty", "Nature", "Abundance"],
    "The Emperor": ["Authority", "Structure", "A solid foundation"],
    "The Heirophant": ["Spiritual wisdom", "Religious beliefs", "Conformity"],
    "The Lovers": ["Love", "Harmony", "Alignment of values"],
    "The Chariot": ["Control", "Willpower", "Victory through assertion"],
    "Strength": ["Courage", "Persuasion", "Influence"],
    "The Hermit": ["Soul-searching", "Introspection", "Inner guidance"],
    "The Wheel of Fortune": ["Good luck", "Karma", "A turning point"],
    "Justice": ["Fairness", "Truth", "Cause and effect"],
    "The Hanged Man": ["Pause", "Surrender", "Letting go"],
    "Death": ["Endings", "Change", "Transformation"],
    "Temperance": ["Balance", "Moderation", "Patience"],
    "Temptation": ["Shadow self", "Attachment", "Restriction"], 
    "The Tower": ["Sudden change", "Upheaval", "Chaos"],
    "The Star": ["Hope", "Faith", "Purpose", "Renewal"],
    "The Moon": ["Illusion", "Fear", "Anxiety"],
    "The Sun": ["Positivity", "Fun", "Warmth", "Success"],
    "Judgement": ["Rebirth", "Inner calling", "Absolution"],
    "The World": ["Completion", "Integration", "Accomplishment"]
};
const suitContexts = {
    "Wands": ["creativity", " passion", "will"],
    "Cups": ["emotions", "relationships", "intuition"],
    "Swords": ["intellect", "hard truths", "mental conflict"],
    "Pentacles": ["material wealth", "physical health", "career"]
};
const majorMeaningsRev = {
    "The Fool": ["recklessness", "negligence", "being taken advantage of"],
    "The Magician": ["manipulation", "poor planning", "wasted talent"],
    "The High Priestess": ["secrets revealed", "ignored intuition", "withdrawal"],
    "The Empress": ["dependence", "creative block", "smothering behavior"],
    "The Emperor": ["tyranny", "rigidity", "lack of discipline"],
    "The Heirophant": ["rebellion", "unconventional beliefs", "poor advice"],
    "The Lovers": ["disharmony", "imbalance", "bad choices"],
    "The Chariot": ["lack of control", "aggression", "defeat"],
    "Strength": ["weakness", "self-doubt", "raw emotion"],
    "The Hermit": ["isolation", "loneliness", "rejection"],
    "The Wheel of Fortune": ["bad luck", "resistance to change", "breaking cycles"],
    "Justice": ["dishonesty", "unfairness", "lack of accountability"],
    "The Hanged Man": ["stalling", "resistance", "useless sacrifice"],
    "Death": ["resistance to change", "stagnation", "decay"],
    "Temperance": ["imbalance", "excess", "lack of vision"],
    "Temptation": ["breaking free", "detachment", "reclaiming power"], 
    "The Tower": ["averting disaster", "fear of suffering", "delaying the inevitable"],
    "The Star": ["despair", "lack of faith", "discouragement"],
    "The Moon": ["confusion", "deception", "fear"],
    "The Sun": ["temporary sadness", "unrealistic expectations", "burning out"],
    "Judgement": ["self-doubt", "refusal to answer a call", "lack of self-awareness"],
    "The World": ["incompletion", "lack of closure", "emptiness"]
};
const rankMeaningsRev = {
    // --- PASSIVE RANKS (The Suit is the Cause) ---
    // Structure: [Rank State] <--- caused by <--- [Suit Problem]
    
    "Ace": [ // Blocked Potential
        "Missed opportunities due to", 
        "Blocked potential caused by", 
        "A false start characterized by"
    ],
    "Two": [ // Imbalance
        "An imbalance stemming from", 
        "Broken partnerships due to", 
        "Indecision aggravating" // (This one implies the Rank makes it worse, which fits 2s)
    ],
    "Three": [ // Stunted Growth
        "Stunted growth following", 
        "Delays caused by", 
        "Group conflict centering on"
    ],
    "Four": [ // Stagnation
        "Instability caused by", 
        "Feeling trapped by", 
        "Rigidity in the face of"
    ],
    "Six": [ // Nostalgia/Past
        "Clinging to the past to avoid", 
        "Unrealistic expectations about", 
        "Stagnation caused by"
    ],
    "Eight": [ // Restriction
        "Frustration exacerbated", 
        "Feeling paralyzed by", 
        "Exhaustion caused by"
    ],
    "Nine": [ // Anxiety
        "Deep despair concerning", 
        "Isolation driven by", 
        "Overwhelming fear of"
    ],
    "Ten": [ // Burden
        "The heavy burden of", 
        "A total collapse caused by", 
        "A refusal to acknowledge"
    ],

    // --- ACTIVE RANKS (The Rank is the Cause) ---
    // Structure: [Rank Action] ---> results in ---> [Suit Problem]

    "Five": [ // Conflict
        "An inability to overcome", 
        "Lingering resentment causing", // Active emotion creating the problem
        "Avoiding the reality of"
    ],
    "Seven": [ // Deception/giving up
        "Deception leading to", 
        "Surrendering to", 
        "A fear of confronting"
    ],
    "Page": [ // Immaturity
        "Bad news regarding", 
        "Immaturity leading to", 
        "A lack of progress due"
    ],
    "Knight": [ // Recklessness
        "Recklessness resulting in", 
        "Impulsiveness causing", 
        "Arrogance leading to"
    ],
    "Queen": [ // Internal/Emotional
        "Jealousy causing", 
        "Overbearing behavior resulting in", 
        "Emotional manipulation involving"
    ],
    "King": [ // External/Authority
        "Tyrannical control leading to", 
        "Weakness in handling", 
        "An abuse of power causing"
    ]
};
const suitContextsRev = {
    "Wands": ["creative burnout", "lack of passion", "delays in action"],
    "Cups": ["emotional blockage", "moodiness", "relationship tension"],
    "Swords": ["confusion", "cruelty", "mental exhaustion"],
    "Pentacles": ["financial loss", "greed", "laziness or waste"]
};
resizeCanvas(); //INITIALIZE CANVAS
////////////////////////////////////////////////////////////////////
//////////////////////[CLASS DECLARATIONS]///////////////////////////
////////////////////////////////////////////////////////////////////
let Dbug = 0;
class NPC {
  constructor(index,x, y, type, state = 'wandering',minimapColor = '#ff0000',deck = []) {
    this.x = x;
    this.y = y;
    this.originx = x;
    this.originy = y;
    this.index = index;
    this.type = type; 
    this.deck = deck; // Store the custom deck
    this.color = minimapColor; 
    this.visible = true; 
    // --- NEW: AUDIO TIMERS ---
    this.stepTimer = 0;     // Tracks footstep rhythm
    this.gruntTimer = Math.random() * 500; // Random start for grunts
    this.wispTimer = 0;     // Continuous wisp sound
    // -------------------------
// --- NEW: RESPAWN LOGIC ---
    this.isDead = false;          // Is the NPC currently dead?
    this.respawnTime = 0;         // Timestamp when they should return
    this.respawnDelay = 360000;    // 30 Seconds (Adjust as needed)
    // ---------------------------
    this.dirX = Math.random() - 0.5;
    this.dirY = Math.random() - 0.5;
    this.speed = .5; 
    this.radius = 0.1;
    // --- NEW: 3D MODEL LOGIC ---
    this.model = null;
    this.bobOffset = 0; // For the up/down animation
    this.zHeight = 0;   // Height from floor
    this.chasing = false;

    if (this.type === 'Fire Elemental') {
        this.model = new Dice('d4');
        
        // Base color (Inner core of the fire)
        this.model.setColor(1, 0, 1); 
        
        // Glow color (Outer halo - Orange/Red)
        this.model.setGlow('#660033'); 
        
        this.model.rs = 99; 
        this.state = 'wandering';
    }
    if (this.type === 99) {
        this.model = new Dice('d4');
        this.model.setColor(0, 1, 1); // Cyan color
        this.model.setGlow('#00ffff'); // Cyan glow
        this.model.rs = 0.02; // Slow spin
        this.state = 'stationary';
    }
  
    this.preState = state;
    this.state = state; 
  }


  checkCollision(maze, x, y) {
    const points = [
        {x: x + this.radius, y: y}, 
        {x: x - this.radius, y: y}, 
        {x: x, y: y + this.radius}, 
        {x: x, y: y - this.radius}  
    ];
    for (let p of points) {
        // Boundary checks...
        if (p.y < 0 || p.y >= maze.length) return true; 
        if (p.x < 0 || p.x >= maze[0].length) return true; 

        // Get the tile
        const tile = maze[Math.floor(p.y)][Math.floor(p.x)];

        // --- UPDATED COLLISION LOGIC ---
        // 1. Solid Wall (>0)
        if (tile > 0) return true; 

        // 2. Unwalkable Floor (Negative Odd: -1, -3, etc.)
        if (tile < 0 && Math.abs(tile) % 2 === 1) return true;
    }
    return false;
}

  triggerInteraction(dungeon,index = 0) {
        

    //Portals in order: 4D, cave brown, castle red, castle blue, cave gray,
    if (this.type === 99||this.type ===-29||this.type==-30||this.type == 23.1||this.type == -31||this.type == -32||this.type == -33||this.type == -34||this.type == -35) {
     
      //0=N, 1=E, 2=S, 3=W
      console.log("Teleporting...");
      //MAP 0: Tutorial
      if (dungeon.mapID === 0) {
        //to Outer Dungeon (Magician Area)
            dungeon.loadMap(1);
            MusicEngine.stop()
            MusicEngine.playSFX('warp');
            MusicEngine.play(Dungeon.mapSong[Dungeon.mapID]); 
        } 
      //MAP 1: Outer Dungeon (Magician Area)
      else if (dungeon.mapID === 1){
        //portal back to map 0
        if(this.index ===2){
              dungeon.loadMap(0);
              dungeon.x = 9.5;dungeon.y = 1.5;
              dungeon.dir = 2;
              MusicEngine.stop()
              MusicEngine.playSFX('warp');
              MusicEngine.play(Dungeon.mapSong[Dungeon.mapID]); 
          }
        //portals to magician's item cards
        else if (this.index ===7){
            dungeon.x = 2.5;dungeon.y = 6.5;dungeon.dir = 0;
            MusicEngine.playSFX('warp');
        }
        else if (this.index ===8){
            dungeon.x = 12.5;dungeon.y = 2.5;dungeon.dir = 3;
            MusicEngine.playSFX('warp');
        }
        else if (this.index ===9){
            dungeon.x = 1.5;dungeon.y = 13.5;dungeon.dir = 1;
            MusicEngine.playSFX('warp');
        }
        else if (this.index ===10){
            dungeon.x = 2.5;dungeon.y = 8.5;dungeon.dir = 2;
            MusicEngine.playSFX('warp');
        }
        //magician area exit portal to map 2
        else if (this.index ===11){
            dungeon.loadMap(2);
            MusicEngine.stop()
            MusicEngine.playSFX('warp');
            MusicEngine.play(Dungeon.mapSong[Dungeon.mapID]); 
            
        }
      }
      //MAP 2: Tintagel Forest (Hermit Area)
      else if (dungeon.mapID === 2){
        //portal back to map 1
        if (this.index ===6){
            dungeon.loadMap(1);
            dungeon.x = 6.5;dungeon.y = 1.5;
            dungeon.dir = 2;
            MusicEngine.stop()
            MusicEngine.playSFX('warp');
            MusicEngine.play(Dungeon.mapSong[Dungeon.mapID]); 
            
        }
        //cavern entrance to map 3
        if (this.index ===7){
            dungeon.loadMap(3);
            dungeon.x = 8.5;dungeon.y = 20.5;
            dungeon.dir = 0;
            MusicEngine.stop()
            MusicEngine.playSFX('warp');
            MusicEngine.play(Dungeon.mapSong[Dungeon.mapID]); 
            
        }
      }
      //MAP 3: Goblin Caverns
      else if (dungeon.mapID === 3){
        //cavern exit to map 2
        if (this.index ===1){
            dungeon.loadMap(2);
            dungeon.x = 1.5;dungeon.y = 1.5;
            dungeon.dir = 2;
            MusicEngine.stop()
            MusicEngine.playSFX('warp');
            MusicEngine.play(Dungeon.mapSong[Dungeon.mapID]); 
        }
        //snake portal back to map3 entrance
        if (this.index ===3){
            dungeon.loadMap(3);
            MusicEngine.stop()
            MusicEngine.playSFX('warp');
            MusicEngine.play(30)
        }
        //Apprentice portal to map 4
        if (this.index ===6){
            dungeon.loadMap(4);
            MusicEngine.stop()
            MusicEngine.playSFX('warp');
            MusicEngine.play(32)
        }
      }
      //MAP 4: Realm of the Witch Queen (Desert)
      else if (dungeon.mapID === 4){
        //Portal to Map 3
        if (this.index ===0){
            dungeon.loadMap(3);
            dungeon.x = 8.5;dungeon.y = 1.5;
            dungeon.dir = 2;
            MusicEngine.stop()
            MusicEngine.playSFX('warp');
            MusicEngine.play(Dungeon.mapSong[Dungeon.mapID]); 
        }
        //Door to Map 5
        if (this.index ===1){
            dungeon.loadMap(5);
            MusicEngine.stop()
            MusicEngine.playSFX('warp');
            MusicEngine.play(Dungeon.mapSong[Dungeon.mapID]); 
        }
        //Mirage
        if (this.type ===23.1){
          if(Dbug == 0){
            dungeon.loadMap(4);
            MusicEngine.playSFX('warp');
          }
        }
              
      }
      //MAP 5: Witch Queen's Castle
      else if (dungeon.mapID === 5){
        //back to Map 4: Realm of the Witch Queen
        if(this.index == 2){
            dungeon.loadMap(4);
            dungeon.x = 8.5;dungeon.y = 2;
            dungeon.dir = 2;
            MusicEngine.stop()
            MusicEngine.playSFX('warp');
            MusicEngine.play(Dungeon.mapSong[Dungeon.mapID]); 
        }
        //To Map 6: Realm of the Ice Queen (spawned by WQ)
        if (this.index == 12){
            dungeon.loadMap(6);
            MusicEngine.stop()
            MusicEngine.playSFX('warp');
            MusicEngine.play(Dungeon.mapSong[Dungeon.mapID]); 
        }
        
              
      }
      //MAP 6: Realm of the Ice Queen (Cairn Gorm)
      else if (dungeon.mapID === 6) {
        //Portal back to Map 5: Witch Queen's Castle
        if (this.index == 0){
            dungeon.loadMap(5);
            MusicEngine.stop()
            MusicEngine.playSFX('warp');
            MusicEngine.play(Dungeon.mapSong[Dungeon.mapID]); 
            dungeon.x = 8.5; dungeon.y = 1.5; dungeon.dir = 2;
        }  
        //Entrance to Map 7: Ice Cave
        if (this.index == 1){
            dungeon.loadMap(7);
            MusicEngine.stop()
            MusicEngine.playSFX('warp');
            MusicEngine.play(Dungeon.mapSong[Dungeon.mapID]); 
        }
        //Entrance to Map 8: Ice Queen's Fortress
        if (this.index == 2){
            dungeon.loadMap(8);
            MusicEngine.stop()
            MusicEngine.playSFX('warp');
            MusicEngine.play(Dungeon.mapSong[Dungeon.mapID]); 
        }


      }         
      //MAP 7: Ice Cave
      else if (dungeon.mapID === 7) {
        //Cave Door back to Map 6: Realm of the Ice Queen (Cairn Gorm)
        if (this.index == 0){
            dungeon.loadMap(6);
            MusicEngine.stop()
            MusicEngine.playSFX('warp');
            MusicEngine.play(Dungeon.mapSong[Dungeon.mapID]); 
            dungeon.x = 10.5; dungeon.y = 15.5; dungeon.dir = 2;
        }  
      }
      //MAP 8: Ice Queen's Fortess         
      else if (dungeon.mapID === 8) {
        //Castle Door back to Map 6: Realm of the Ice Queen (Cairn Gorm)
        if (this.index == 0){
            dungeon.loadMap(6);
            MusicEngine.stop()
            MusicEngine.playSFX('warp');
            MusicEngine.play(Dungeon.mapSong[Dungeon.mapID]); 
            dungeon.x = 8.5; dungeon.y = 8.5; dungeon.dir = 2;
        }  
        //Portal to Map 8: Realm of the Kraken (Boreal Sea)
        if (this.index == 6){
            dungeon.loadMap(9);
            MusicEngine.stop()
            MusicEngine.playSFX('warp');
            MusicEngine.play(Dungeon.mapSong[Dungeon.mapID]);        
        }
        


      }         
      //MAP 9: Realm of the Kraken (Boreal Sea)        
      else if (dungeon.mapID === 9) {
        //Portal back to Map 8: Ice Queen's Fortress
        if (this.index == 0){
            dungeon.loadMap(8);
            MusicEngine.stop()
            MusicEngine.playSFX('warp');
            MusicEngine.play(dungeon.mapSong[dungeon.mapID])
            dungeon.x = 5.5; dungeon.y = 1.5; dungeon.dir = 2;
        }  
        //Portal to Map 10: Avalon (spawned after kraken? or just tele there no return to sea?)
        if (this.index == 5){
            dungeon.loadMap(10);
            MusicEngine.stop()
            MusicEngine.playSFX('warp');
            MusicEngine.play(dungeon.mapSong[dungeon.mapID])
        }
        


      }         
      //MAP 10: Avalon   
      else if (dungeon.mapID === 10) {
        //Portal  to Map 11: Fairy Queen's Castle
        if (this.index == 0){
            dungeon.loadMap(11);
            MusicEngine.stop()
            MusicEngine.playSFX('warp');
            MusicEngine.play(dungeon.mapSong[dungeon.mapID])
        }  
        //Portal to Map 12: Dragon's Lair
        if (this.index == 1){
            dungeon.loadMap(12);
            MusicEngine.stop()
            MusicEngine.playSFX('warp');
            MusicEngine.play(dungeon.mapSong[dungeon.mapID])
        }
        //Portal to Map 13: Tomb of the High King
        if (this.index == 2){
            dungeon.loadMap(13);
            MusicEngine.stop()
            MusicEngine.playSFX('warp');
            MusicEngine.play(dungeon.mapSong[dungeon.mapID])
        }


      }         
      //MAP 11: Fairy Queen's Castle
      else if (dungeon.mapID === 11) {
        //Portal  to Map 11: Fairy Queen's Castle
        if (this.index == 0){
            dungeon.loadMap(10);
            MusicEngine.stop()
            MusicEngine.playSFX('warp');
            MusicEngine.play(dungeon.mapSong[dungeon.mapID])
            dungeon.x = 17.5; dungeon.y = 3.5; dungeon.dir = 2;

        }  
        if (this.index == 5){
            dungeon.loadMap(14);
            MusicEngine.stop()
            MusicEngine.playSFX('warp');
            MusicEngine.play(dungeon.mapSong[dungeon.mapID])

        }  


      }         
      //MAP 12: Dragon's Lair
      else if (dungeon.mapID === 12) {
        //Exit to Map 10
        if (this.index == 0){
            dungeon.loadMap(10);
            MusicEngine.stop()
            MusicEngine.playSFX('warp');
            MusicEngine.play(dungeon.mapSong[dungeon.mapID])
            dungeon.x = 1.5; dungeon.y = 11.5; dungeon.dir = 1;

        }  
      }
      //MAP 13: Tomb of the High King
      else if (dungeon.mapID === 13) {
        //Exit to Map 10
        if (this.index == 0){
            dungeon.loadMap(10);
            MusicEngine.stop()
            MusicEngine.playSFX('warp');
            MusicEngine.play(dungeon.mapSong[dungeon.mapID])
            dungeon.x = 17.5; dungeon.y = 20.5; dungeon.dir = 3;

        }  
      }
      //MAP 14: Elf Queen's Forest
      else if (dungeon.mapID === 14) {
        //Exit to Map 11 Fairy Queen's Castle
        if (this.index == 0){
            dungeon.loadMap(11);
            MusicEngine.stop()
            MusicEngine.playSFX('warp');
            MusicEngine.play(dungeon.mapSong[dungeon.mapID])
            dungeon.x = 5.5; dungeon.y = 1.5; dungeon.dir = 2;

        }  
        //To Cultivator area
        if (this.index == 1){
            
            MusicEngine.stop()
            MusicEngine.playSFX('warp');
            MusicEngine.play(dungeon.mapSong[dungeon.mapID])
            dungeon.x = 5.5; dungeon.y = 1.5; dungeon.dir = 3;
            return;
        }  
        //Back to cultivator area entrance
        if (this.index == 2){
            
            MusicEngine.stop()
            MusicEngine.playSFX('warp');
            MusicEngine.play(dungeon.mapSong[dungeon.mapID])
            dungeon.x = 33.5; dungeon.y = 20.5; dungeon.dir = 3;
            return
        }
        //to Map 15 Dark Emperor's Tower
        if (this.index == 16){
            dungeon.loadMap(15);
            MusicEngine.stop()
            MusicEngine.playSFX('warp');
            MusicEngine.play(dungeon.mapSong[dungeon.mapID])
            
            return;
        }  
          
      }
      //MAP 15: Dark Tower Entrancer
      else if (dungeon.mapID === 15) {
        //Backto Map 14 Elf Queen's Castle
        if (this.index == 0){
            dungeon.loadMap(14);
            MusicEngine.stop()
            MusicEngine.playSFX('warp');
            MusicEngine.play(dungeon.mapSong[dungeon.mapID])
            dungeon.x = 17.5; dungeon.y = 8.5; dungeon.dir = 2;

        }  
        //To Map 16: Dark Tower Floor 1
        if (this.index == 1){
            
            dungeon.loadMap(16);
            MusicEngine.stop()
            MusicEngine.playSFX('warp');
            MusicEngine.play(dungeon.mapSong[dungeon.mapID])
        }  
        //Treasure snake portal
        if (this.index == 3){
            
            MusicEngine.playSFX('warp');
            dungeon.x = 5.5; dungeon.y = 8.5; dungeon.dir = 0;
            return
        }
       
          
      }
      //MAP 16: Dark Tower Floor 1
      else if (dungeon.mapID === 16) {
        //To Map 17: Djinn Room
        if (this.index == 3){
            dungeon.loadMap(17);
            MusicEngine.stop()
            MusicEngine.playSFX('warp');
            MusicEngine.play(dungeon.mapSong[dungeon.mapID])

        }  
        //To Map 15: Dark Tower Entrance
        else{
            
            dungeon.loadMap(15);
            MusicEngine.stop()
            MusicEngine.playSFX('warp');
            MusicEngine.play(dungeon.mapSong[dungeon.mapID])
        }  
        
       
          
      }
       //MAP 17: Djinn Room
      else if (dungeon.mapID === 17) {
            dungeon.loadMap(18);
            MusicEngine.stop()
            MusicEngine.playSFX('warp');
            MusicEngine.play(dungeon.mapSong[dungeon.mapID])
      }
      //MAP 18: Kraken Room
      else if (dungeon.mapID === 18) {
        dungeon.loadMap(19);
            MusicEngine.stop()
            MusicEngine.playSFX('warp');
            MusicEngine.play(dungeon.mapSong[dungeon.mapID])
      }
       //MAP 19: Dragon Room
      else if (dungeon.mapID === 19) {
        dungeon.loadMap(20);
            MusicEngine.stop()
            MusicEngine.playSFX('warp');
            MusicEngine.play(dungeon.mapSong[dungeon.mapID])
      }
       //MAP 20: Giant Room
      else if (dungeon.mapID === 20) {
        dungeon.loadMap(21);
            MusicEngine.stop()
            MusicEngine.playSFX('warp');
            MusicEngine.play(dungeon.mapSong[dungeon.mapID])
      }
      //MAP 21: Dark Emperor Throne/Top of Tower
      else if (dungeon.mapID === 21) {
        dungeon.loadMap(22);
            MusicEngine.stop()
            MusicEngine.playSFX('warp');
            MusicEngine.play(dungeon.mapSong[dungeon.mapID])
      }
      return; // Stop here
      
    }
    //Cards
    if (this.type == -27) {
      const cardID = this.deck[0]; // The ID of the card this NPC holds

      // Check if the card ID exists in the dungeon deck
      const alreadyHas = dungeon.deck.some(card => card.index === cardID);

      if (alreadyHas) {
        // CASE: PLAYER HAS CARD
        if (typeof MusicEngine !== 'undefined') MusicEngine.playSFX('cancel'); // Cancel Sound
        dungeon.killNPC(this, true);
        this.isDuplicate = true; // Set flag for dialogue
        this.startDialogue(dungeon);
        // Note: We do NOT call dungeon.killNPC here, so it stays on the map
      } else {
        // CASE: NEW CARD
        if (typeof MusicEngine !== 'undefined') MusicEngine.playSFX('heal'); // Heal Sound
        dungeon.deck.push(new Card(cardID));
        dungeon.killNPC(this, true); // Remove from map permanently
        this.isDuplicate = false; // Ensure flag is off
        this.startDialogue(dungeon);
      }
    }
    else{
    //high priestess
    //first interaction
    if((this.index == 0&&dungeon.MainQuest == 0&&dungeon.mapID ==  0)){
      this.startDialogue(dungeon);
        MusicEngine.stop()
        MusicEngine.play(7)
       // MusicEngine.play3DSFX('talk')
      }
    //after tutorial question yes or no
    if((this.index == 0&&dungeon.MainQuest == 1&&dungeon.mapID ==  0)){
      this.startDialogue(dungeon);
        MusicEngine.stop()
        MusicEngine.play(22)
      }
    //magician 
    //in dungeon
    if((this.index == 1&&dungeon.mapID ==  1)){
      this.startDialogue(dungeon);
      MusicEngine.stop()
      MusicEngine.play(28)
    }
    //in next map forest outside tintagel
    if((this.index == 0&&dungeon.mapID ==  2)){
      this.startDialogue(dungeon);
      
    }
    //emperor 
    //before talking to high priestess
    if((this.index == 3&&dungeon.MainQuest == 0&&dungeon.mapID ==  0)){
      this.startDialogue(dungeon);
      //MusicEngine.stop()
      //MusicEngine.play(7)
    }
    //after talking to High Priestess
    if((this.index == 3&&dungeon.MainQuest == 1&&dungeon.mapID ==  0)){
      this.startDialogue(dungeon);
      MusicEngine.stop()
      MusicEngine.play(7)
    }
    //Empress
    if((this.index == 2&&dungeon.mapID ==  0)){
      this.startDialogue(dungeon);
    }
    //Heirophant
    if((this.index == 4&&dungeon.mapID ==  0)){
      this.startDialogue(dungeon);
    }
    //Hermit
    if((this.index == 1&&dungeon.mapID ==  2)){
      this.startDialogue(dungeon);
    }
    //Pixie
    if((this.index == 13&&dungeon.mapID ==  2)){
      MusicEngine.stop();
        MusicEngine.play(33);
      this.startDialogue(dungeon);
      return;
    }
    //Apprentice
    if((this.type == 32)){
      if(dungeon.mapID == 3){
        MusicEngine.stop();
        MusicEngine.play(33);
      }
      this.startDialogue(dungeon);
    }
    //Treasure Snake
    if((this.type == 21.1)){
      this.startDialogue(dungeon);
    }
    //Imp
    if((this.index == 4&&dungeon.mapID ==  3)){
      this.startDialogue(dungeon);
      return;
    }
    //Djinn
    if(this.type == 35.1&& this.index == 0){
      if (dungeon.mapID != 17){
      MusicEngine.stop();
      MusicEngine.play(33);
      }
      this.startDialogue(dungeon);
      return;
    }
    //Witch Queen
    if(this.type == 34.1){
      MusicEngine.stop();
      MusicEngine.play(12);
      this.startDialogue(dungeon);
      return;
    }
    //Ice Queen
    if(this.type == 48){
      
      this.startDialogue(dungeon);
      return;
    }
    //Fairy Queen
    if(this.type == 62){
      if(dungeon.mapID == 11){
        MusicEngine.stop();
        MusicEngine.play(28);
      }
      this.startDialogue(dungeon);
      return;
    }
    //Dragon
    if(this.type == 63.1&&((this.index == 1&&dungeon.mapID == 12)||(this.index == 0&&dungeon.mapID == 19))){
      //MusicEngine.stop();
      //MusicEngine.play(12);
      this.startDialogue(dungeon);
      return;
    }
    //arthur
    if(this.type == 4.1&&(this.index == 2 ||this.index == 4)){
      //MusicEngine.stop();
      //MusicEngine.play(12);
      this.startDialogue(dungeon);
      return;
    }
    //giant's daughter
    if(this.type == 77.2 &&this.chasing == false){
      this.startDialogue(dungeon);
      return;
    }
    //Elf Queen
    if(this.type == 76){
      this.startDialogue(dungeon);
      return;
    }
    //Giant
    if(this.type == 77.1&&((this.index == 15&&dungeon.mapID == 14)||(this.index == 0&&dungeon.mapID == 20))){
      this.startDialogue(dungeon);
      return;
    }
    //Gnome villager 
    if(this.type == 75.1||this.type == 70.1){
      this.startDialogue(dungeon);
      return;
    }
    //Fool
    if(this.type == 0&&this.index == 0){
      this.startDialogue(dungeon);
      return;
    }
  
  }
    // --- BATTLE LOGIC ---
    //in order: Shade, Imp, Wisp, Goblin, Spider,
    // Pixie2,Fire imp,Salamander,Neophyte,Djinn
    //Frost golem, Undine, Skeleton, Tentacle,Siren,
    //Sea Serpent, Kraken,dragon,dark sylph,arthur
    if (this.type === 42 || this.type == 56 ||this.type ===23||this.type ===54||this.type== 57.1||
        this.type == 60.1||this.type == 56.1||this.type==33.1||this.type==32.1||this.type ==35.1||
        this.type == 81  ||this.type == 47.1||this.type == 82||this.type == 83||this.type == 37.1||
        this.type == 46.1||this.type == 49.1||this.type == 63.1||this.type == 61.2||this.type == 4.1||
      this.type == 74.1||this.type == 77.1||this.type == 0
      ) {
      dungeon.npcs.forEach(npc => npc.visible = false);
      dungeon.currentEnemy = this;
      if (startGame !== 'battle') {
        console.log("Starting Battle...");
        startGame = 'battle';
        preGame = 'explore';
        if (typeof MusicEngine !== 'undefined') MusicEngine.playSFX('slash');
           if (typeof Field !== 'undefined') {
             Player[0] = new Field(0, 0); // 0 = Player Side, 0 = Human
             Player[1] = new Field(1, 1);    // 1 = Foe Side,    1 = CPU
              Player[1].opponent = Player[0];
              Player[0].opponent = Player[1];
            }
        song = rnd(0,4)
            if (this.type == 60.1&& this.index == 14){song = 5}
            if (this.type == 54 && this.index == 4){song = 5}
            if (this.type == 56&& this.index == 5){song = 5}
            if (this.type == 35.1||this.type == 49.1||this.type == 63.1){song = 6}
            if (this.type == 35.1&&dungeon.mapID == 17){song = 1}
            if (this.type == 49.1&&dungeon.mapID == 18){song = 6}
            if (this.type == 36.1&&dungeon.mapID == 19){song = 7}
            if (this.type == 77.1&&dungeon.mapID == 20){song = 3}
            if (this.type == 0&&dungeon.mapID == 21){song = 8}
            if (this.type == 4.1){song = 7}


            if (song == 0){
              MusicEngine.stop();
              MusicEngine.play(5);
            }
            if (song == 1){
              MusicEngine.stop();
              MusicEngine.play(15);
            }
            if (song == 2){
              MusicEngine.stop();
              MusicEngine.play(16);
            }
            if (song == 3){
              MusicEngine.stop();
              MusicEngine.play(25);
            }    
            if (song == 4){
              MusicEngine.stop();
              MusicEngine.play(26);
            }    
             if (song == 5){
              MusicEngine.stop();
              MusicEngine.play(27);
            }    
            if (song == 6){
              MusicEngine.stop();
              MusicEngine.play(35);
            }  
            if (song == 7){
              MusicEngine.stop();
              MusicEngine.play(40);
            }
            if (song == 8){
              MusicEngine.stop();
              MusicEngine.play(42);
            }
            
        Player[0].deck = [];     // Clear any leftovers
        Player[0].hand = [];     // Clear hand
        Player[0].aMonster = []; // Clear field
        sRune = new stone(1.545,4.545,1,eSTAT.S);
        cRune = new stone(7.625,4.625,1,eSTAT.C);
        iRune = new stone(3.545,4.49,1,eSTAT.I);
        aRune = new stone(5.545,4.53,1,eSTAT.A);
        // CORRECTION: Use 'dungeon.deck', not 'dungeon.library'
        if (dungeon.deck) {
          // 'c' is the card object from your master list
          for (let c of dungeon.deck) {
            // We create a new Battle Card using the ID (c.index)
            Player[0].deck.push(new Card(c.index, 0)); 
          }

    let currentIndex2 = dungeon.deck.length; 
    let randomIndex2;
    while (currentIndex2 !== 0) {
        randomIndex2 = Math.floor(Math.random() * currentIndex2);
        currentIndex2--; 

        [Player[0].deck[currentIndex2], Player[0].deck[randomIndex2]] = [
            Player[0].deck[randomIndex2], Player[0].deck[currentIndex2]
        ];        
    }


          for(let i = 0; i < Player[0].deck.length;i++){
            Player[0].deck[i].locIndex = i; 
            Player[0].deck[i].locCount = i;
            Player[0].deck[i].location = 'deck';
          }
          if(Dbug == 1){
            Player[0].deck.length = 0;
            Player[0].deck.push(new Card(63,0))
            Player[0].deck[0].locIndex = 0; 
            Player[0].deck[0].locCount = 0;
            Player[0].deck[0].location = 'deck';
            Player[0].deck[0].stat[0][2] = 100;
            Player[0].deck[0].stat[1][2] = 100;
            Player[0].deck[0].stat[2][2] = 100;
            Player[0].deck[0].stat[3][2] = 100;
          }


          
        }
        console.log("Player Deck Built:", Player[0].deck); // Debug check
        // ==================================================
        // 2. SETUP FOE
        // ==================================================
        Player[1].deck = [];
        Player[1].hand = [];
        Player[1].aMonster = [];
        Player[1].isCPU =1; 
        // Load Custom Deck (or Default Wisp)
        if (this.deck && this.deck.length > 0) {
        // We assume the last card in your custom array is the Monster
        for (let cardIndex of this.deck) {  
          Player[1].deck.push(new Card(cardIndex, 1));
        }
         let currentIndex3 = this.deck.length; 
          let randomIndex3;
        while (currentIndex3 !== 0) {
        
        randomIndex3 = Math.floor(Math.random() * currentIndex3);
        currentIndex3--; 

        [Player[1].deck[currentIndex3], Player[1].deck[randomIndex3]] = [
            Player[1].deck[randomIndex3], Player[1].deck[currentIndex3]
        ];        
        
    }
        for(let i = 0; i < Player[1].deck.length;i++){
          Player[1].deck[i].locIndex = i; 
          Player[1].deck[i].locCount = i;
          Player[1].deck[i].location = 'deck'
        }
        } 
        else if (this.type === 2322) {
          // Wisp Loadout
          Player[1].deck.push(new Card(26, 1)); // Fire (Spell) -> Hand
          Player[1].deck.push(new Card(26, 1)); // Scry (Spell) -> Hand
          Player[1].deck.push(new Card(23, 1)); // Wisp (Monster) -> Field
        }
        // --- NEW: ROTATE TO FACE OPEN SPACE ---
        // This ensures we aren't staring at a wall when the battle starts
        for (let i = 0; i < 4; i++) {
          let targetX = Math.floor(dungeon.x);
          let targetY = Math.floor(dungeon.y);
          // Check the tile directly in front of current direction
          if (dungeon.dir === 0) targetY -= 1;      // North
          else if (dungeon.dir === 1) targetX += 1; // East
          else if (dungeon.dir === 2) targetY += 1; // South
          else if (dungeon.dir === 3) targetX -= 1; // West
          // If it's NOT a wall, we are good! Stop rotating.
          if (!dungeon.isWall(targetX, targetY)) {
            break; 
          }
          // If it IS a wall, turn right (clockwise) and try again
          dungeon.dir = (dungeon.dir + 1) % 4;
        }
        // -------------------------------------
      }
    }
    
    else {
      if (this.state !== 'stationary') this.state = 'wandering';
    }
  }
  startDialogue(dungeon) {

      dungeon.npcs.forEach(npc => npc.visible = false);
      dungeon.currentSpeaker = this;
      console.log("Starting dialogue...");
      startGame = 'dialogue';
      if(typeof MusicEngine !== 'undefined') MusicEngine.playSFX('click');
  }
  
  update(maze, playerX, playerY, dungeon, dt) {
    // --- RESPAWN CHECK ---
    if (this.isDead) {
      if (Date.now() > this.respawnTime) {
        this.isDead = false;
        this.visible = true;
      }
      return;
    }

    // =========================================================
    // 1. TARGET SELECTION
    // =========================================================
    
    let targetX = playerX;
    let targetY = playerY;
    let isChasingNPC = false; // Flag to know if we are hunting an NPC
    this.chasing = isChasingNPC
    // --- CONFIG: Define who hates who here ---
    let preyType = null;
    if (this.type === 74.1) preyType = 77.2; // Goblin chases Wisp
    if (this.type === 77.2) preyType = 74.1;

    // Add more here: if (this.type === X) preyType = Y;

    // Search for prey
    if (preyType !== null) {
        let closestDistSq = Infinity;
        let closestPrey = null;

        for (let other of dungeon.npcs) {
            if (other.type === preyType && !other.isDead && other.visible) {
                const dx = other.x - this.x;
                const dy = other.y - this.y;
                const dSq = (dx * dx) + (dy * dy);
                
                // Detection range: 10 tiles (squared = 100)
                if (dSq < 100 && dSq < closestDistSq) { 
                    closestDistSq = dSq;
                    closestPrey = other;
                }
            }
        }

        if (closestPrey) {
            targetX = closestPrey.x;
            targetY = closestPrey.y;
            isChasingNPC = true;
            this.chasing = true;
        }
    }

    // =========================================================
    // 2. CALCULATE VECTORS
    // =========================================================

    const diffX = targetX - this.x;
    const diffY = targetY - this.y;
    const distSq = (diffX * diffX) + (diffY * diffY); 
    const dist = Math.sqrt(distSq);

    if (startGame === 'explore' && !this.isDead) this.visible = true;

    // Normalized vector to CURRENT TARGET
    const toTargetX = diffX / dist; 
    const toTargetY = diffY / dist;
    
    // Dot Product (View Angle)
    // 1.0 = looking directly at target, -1.0 = target is behind
    const dotProd = (this.dirX * toTargetX) + (this.dirY * toTargetY);


    // =========================================================
    // 3. STATE LOGIC
    // =========================================================

    // --- CASE A: STOP CHASING ---
    if (this.state === 'chasing') {
        // Logic for Player Chasing (Stricter)
        if (!isChasingNPC) {
            if ((dist > 4 || dotProd < 0.6) || startGame !== 'explore') {
                this.state = this.preState || 'wandering';
                this.speed = 0.5;
            }
        } 
        
        // Logic for NPC Chasing (Stickier - doesn't care about angle/dotProd)
        else {
            // Give up only if very far away (distance > 8)
            if (dist > 3) {
                this.state = 'wandering'; // Default back to wandering
                this.speed = 0.5;
            }
        }
    }

      // wandering to chasing, in order: Goblin, wisp, mirage,fire imp
    //Ice Golem, Undine, Skeleton, Tentacle, Sea Serpent,dark sylph//pixie
   
    if (this.state === 'wandering') {
        
        // 1. NPC vs NPC Aggro (Priority)
        if (isChasingNPC && dist < 6) { 
            // If I have a target and I'm within 6 tiles, CHASE.
            // No dotProd check here = 360 degree vision for NPC targets.
            this.state = 'chasing';
            this.preState = 'wandering';
            this.speed = 2; 
        }

        // 2. NPC vs Player Aggro (Original Logic)
        else if (!isChasingNPC && dist < 4 && dotProd > 0.0) {
            if ((this.type === 54 || this.type === 23 || this.type === 23.1|| this.type === 56.1|| 
            this.type === 81 || this.type === 47.1|| this.type === 82|| this.type === 83|| 
            this.type === 46.1||this.type == 61.2||this.type == 60.1||this.type == 77.2||this.type == 74.1
            ) && startGame === 'explore') {
                this.state = 'chasing';
                this.preState = 'wandering';
                this.speed = 2;
                if (this.type === 54) { MusicEngine.play3DSFX('grunt', this.x, this.y, playerX, playerY, dungeon.dir); }
            }
        }
    }

     //Stationary to chasing filter by type 
      //in order: Shade, Imp, Goblin,Spider 
      // Pixie, Apprentice,Fire Imp,mirage,Neophyte,
      // Djinn,Undine,Kraken,dragon
    if (this.state === 'stationary') {
         // Face the target if close
        if (dist < 4) {
            this.dirX = toTargetX;
            this.dirY = toTargetY;
        }
        
        // NPC vs NPC Stationary Wakeup
        if (isChasingNPC && dist < 4) {
             this.state = 'chasing';
             this.preState = 'stationary';
             this.speed = 2;
        }
        // Player Wakeup logic...
        else if ((this.type == 42 || this.type == 56 || this.type == 54 || this.type === 57.1 || 
                  this.type ==60.1|| this.type == 32 || this.type == 56.1 || this.type == 32.1 || 
                  (this.type === 35.1&&Dungeon.mapID == 5) || this.type ==47.1|| this.type == 49.1||(this.type == 63.1&&Dungeon.mapID == 12)||this.type == 4.1

        ) && startGame == 'explore') {
            if (dist < 4 && dotProd > .3) {
                this.state = 'chasing';
                this.preState = 'stationary';
                this.speed = 2;
                if (this.type === 54 || this.type === 56 || this.type === 56.1|| this.type === 57.1||this.type == 63.1||this.type == 49.1||this.type == 35.1) { MusicEngine.play3DSFX('grunt', this.x, this.y, playerX, playerY, dungeon.dir); }
            }
        }
    }
    
    //Fleering to Wandering (salamander)
    if (this.state == 'fleeing' && dist > 4) {
      this.state = this.preState || 'wandering';
      this.speed = .5;
    }

    // =========================================================
    // 4. MOVEMENT APPLICATION
    // =========================================================

    if (this.state === 'chasing') {
      this.dirX = toTargetX;
      this.dirY = toTargetY;
    }
    
    // Fleeing logic (unchanged)
    if (this.state === 'fleeing') {
      if (this.fleeStuckTimer > 0) this.fleeStuckTimer--; 
      else {
         this.dirX = -toTargetX;
         this.dirY = -toTargetY;
      }
    }

    // Salamander fleeing logic (Specific case)
    if (dist <= 3 && this.state == 'wandering' && ((this.type == 33.1 && dungeon.mapID == 4)||(this.type == 99 && dungeon.mapID == 16&&this.index != 3))) {
      this.speed = 3;
      this.state = 'fleeing';
      this.preState = 'wandering';
      this.dirX = -toTargetX + (Math.random() - 0.5);
      this.dirY = -toTargetY + (Math.random() - 0.5);
    }

    // Proximity / Collision with Target
    // If chasing an NPC, stop slightly before hitting them so they don't merge
    if (dist < 0.8) {
      if (isChasingNPC) {
          // We caught the prey! Stop moving or attack?
          // For now, let's just push them back slightly so they don't overlap
          this.dirX = -toTargetX; 
          this.dirY = -toTargetY;
      } else {
          // Player Interaction
          if (startGame === 'explore' && this.state == 'chasing') {
            this.triggerInteraction(dungeon);
          }
      }
      
      if (this.state == 'wandering') {
        this.dirX = -toTargetX + (Math.random() - 0.5);
        this.dirY = -toTargetY + (Math.random() - 0.5);
      }
    }

    // --- VISUALS (3D Model Rotation) ---
    if (this.model) {
      this.model.rx += 0.05;
      this.model.ry += 0.03;
      this.bobOffset += 0.1;
      this.zHeight = Math.abs(Math.sin(this.bobOffset)) * 0.2;
    }

    // --- AUDIO (UNCHANGED) ---
// --- AUDIO TIMERS ---
    if (!this.isDead && typeof MusicEngine !== 'undefined') {
      if (this.type === 23 || this.type === 23.1 || this.type === 42) {
        this.wispTimer++;
        if (this.wispTimer > 180) {
          if (Math.random() > 0.25) {
            MusicEngine.play3DSFX('ghost', this.x, this.y, playerX, playerY, dungeon.dir);
            this.wispTimer = 0 - (Math.random() * 60);
          }
        }
      }
      if (this.type === 74.1 ||this.type === 77.2 ||this.type === 54 || this.type === 56 || this.type == 56.1||this.type ==81||this.type == 37.1||this.type == 61.2) {
        this.gruntTimer++;
        
          
            if(this.type == 37.1){
              if (this.gruntTimer > 100) {
                if (Math.random() > 0) {
                  MusicEngine.play3DSFX('musical2', this.x, this.y, playerX, playerY, dungeon.dir);
                  this.gruntTimer = 0;
                }
              }
            }
            else if(this.type == 77.2&&isChasingNPC == true){
              if (this.gruntTimer > 100) {
                if (Math.random() > 0) {
                  MusicEngine.play3DSFX('scream', this.x, this.y, playerX, playerY, dungeon.dir);
                  this.gruntTimer = 0;
                }
              }
            }
            else{
              if (this.gruntTimer > 600) {
                if (Math.random() > 0.25) {
                  MusicEngine.play3DSFX('grunt', this.x, this.y, playerX, playerY, dungeon.dir);
                  this.gruntTimer = 0;
                }
              }
            }
          
        }
      
    }
    // --- PHYSICS / COLLISION ---
    if (this.state !== 'stationary') {
      const prevX = this.x;
      const prevY = this.y;
      const moveStep = this.speed * dt;

      // SEPARATION (Keep your existing separation logic here)
      let sepX = 0; let sepY = 0;
      if (this.state === 'chasing' || this.state === 'fleeing' || this.state === 'wandering') {
          for (let other of dungeon.npcs) {
              if (other === this || !other.visible || other.isDead) continue;
              let dx = this.x - other.x;
              let dy = this.y - other.y;
              let dSq = dx*dx + dy*dy;
              if (dSq < 0.49) { sepX += dx; sepY += dy; }
          }
      }

      let finalDirX = this.dirX + (sepX * 2.0);
      let finalDirY = this.dirY + (sepY * 2.0);

      // Normalize
      const len = Math.sqrt(finalDirX*finalDirX + finalDirY*finalDirY);
      if (len > 0) { finalDirX /= len; finalDirY /= len; }

      const newX = this.x + (finalDirX * moveStep);
      const newY = this.y + (finalDirY * moveStep);

      // Wall Collision
      if (this.checkCollision(maze, newX, newY)) {
        if (this.state === 'wandering') {
          this.dirX = Math.random() - 0.5;
          this.dirY = Math.random() - 0.5;
        } else {
          // Slide
          if (!this.checkCollision(maze, newX, this.y)) this.x = newX;
          else if (!this.checkCollision(maze, this.x, newY)) this.y = newY;
        }
      } else {
        this.x = newX;
        this.y = newY;
      }
    
      if (Math.abs(this.x - prevX) > 0.001 || Math.abs(this.y - prevY) > 0.001) {
        this.stepTimer += dt;
        if (this.stepTimer += dt) {
          if (this.type === 54 || this.type === 9.1 || this.type === 1) {
            MusicEngine.play3DSFX('step', this.x, this.y, playerX, playerY, dungeon.dir);
          }
          
          this.stepTimer += dt;
        }
      }
    }
    // Final Normalize
    const length = Math.sqrt(this.dirX * this.dirX + this.dirY * this.dirY);
    if (length !== 0) { this.dirX /= length; this.dirY /= length; }
}
}
class Explore {
  constructor() {
    this.dSense = 0;
    this.MainQuest = 0;
    this.gd = 0;    //0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16,17,18,19,20,21,22
    this.mapSong = [  4, 0,18,30,32,34,31,21,20,36,37,11,38,39, 2,41, 1,32,36,39,34,41,10];
    this.memory = {};
    //////ONLINE
    this.status = 'normal'; // Can be 'normal' or 'dueling'
    this.isChallenger = false; // <--- ADD THIS LINE
    ////////
    //tutorial w high priestess stuff
    this.card= [];
    this.card[0] = new Card(2, 0);//hp
    this.card[1] = new Card(0, 0);//fool
    this.card[2] = new Card(6, 0);//lovers
    this.card[3] = new Card(8, 0)//str
    this.card[4] = new Card(13, 0)//death
    //
    this.deck = [];
    if(Dbug == 0){
    this.deck[0] = new Card(0, 0); // fool 

    }else{
      this.deck[0] = new Card(63, 0);
    }
     
    Player[0].deck = []; 
    Player[0].hand = [];
    Player[0].aMonster = [];
    for(let c of this.deck){
        Player[0].deck.push(new Card(c.index, 0));
    }
    //this.deck = deck; // Store the custom deck
    this.at = 0;
    this.az = 0;
    this.ay = 0;
    this.reroll = 0;
    this.tutorialFinished = 0;
    this.option = 0;
    this.mc = 0;
    this.npcs = [
      new NPC(7.5, 5.5, 2,'stationary'),//north high priestess
      new NPC(1.5, 1.5, 9.1),//west
      new NPC(7.5, 9.5, 3,'stationary'),//south
      new NPC(5.5, 7.5, 4,'stationary'),//south
      new NPC(9.5, 7.5, 5,'stationary'),//east
      new NPC(7.5, 5.5, 23, 'stationary', [26, 24, 23]),
      new NPC(1.5, 7.5, 99, 'stationary')
      //new NPC(1.5, 1.5, 3)
    ];
    this.dCounter = 0;
    this.x = 3.5;
    this.y = 7.5;
    this.dir = 0; 
    this.frame = 0;
    this.currentEnemy = null;
    this.currentSpeaker = null; // NEW: Track who we are talking to
    this.clickInput = null;
    // Initialize Z-Buffer (Depth Buffer)
    this.zBuffer = [];
    // Map Data
    this.weather = new WeatherSystem(tL);
    //odd solid even walkthru 0 is default open space floor color set in map id
    this.wallColors = {
        1: 'rgba(128,64,0,1)', // Standard Brown
        2: 'rgba(255,128,64,1)', // tree pass thru
        3: 'rgba(128,64,0,1)', // tree
        5: 'rgba(255,0,0,1)',  // witch queen castle walls
        7: 'rgba(255,128,0,1)', // tan for goblin wall
        
        9: 'rgba(0,0,255,1)',//blue walls for ice queens castle
        11: 'rgba(209,168,148,1)',//light brown
        13: 'rgba(255,255,255,1)',//white(snow walls)
        
        17: 'rgba(0,0,64,1)', //dark blue ice cave
        19: 'rgba(0,0,0,1)',//black
        21: '#FFD700',//Fairy queen castle walls
        23: '#228B22',//green trees for avalon
        25: '#696969',//Avalon border colors
        27: '#363636', //gray for avalon burnt trees
        29: "#2E2B5F",
        31: "rgb(0,255,0)",
        33:'#333333',
        
    };
    this.noiseLevels = {
      1:0,  // Green Wall: Very Rough (Moss/Vines)
      2:1,   // tree walk thru
      3:0, //tree 
      5:0,
      7:0,
      19:5,//water wall
      9:0,
      11:0,
      13:0,
      15:0,
      25:1,
      17:0,
      21:0,
      23: 2,//white(snow walls)
      27:0,
      29:0,
      31:0,
      33:1
    };
    this.floorColors = {
      "-1": '#0000FF', // Blue (Water/Void) - UNWALKABLE
      "-2": '#000000', // black             - WALKABLE
      "-3": '#8B0000', // Black (Pit)       - UNWALKABLE
      "-4": '#ff0000', // red               - WALKABLE
      "-14": 'rgba(63,16,9)',
      "-6": '#ff0000', // Lawn Green (Grass)- WALKABLE
      "-8": '#663300', // Lawn Green (Grass)- WALKABLE
      "-10": '#1a0d00', // Lawn Green (Grass)- WALKABLE
      "-12": '#0000FF', // Blue (Water/Void) - UNWALKABLE
    };// Define Sky/Floor colors (Global defaults)
    this.skyColor = 'rgba(255,255,255,1)';   // Dark Night
    this.floorColor = 'rgba(255,255,255,1)'; // Dark Ground
    // --- LOAD INITIAL MAP (0 = Original) ---
    this.mapID = 0;
    this.loadMap(0);
    if (typeof socket !== 'undefined') {
        socket.emit("join_game", {
            name: playerName,
            aiHistory: getAiMemory()
        });
    }

    
  }
  //ONLINE
  get players() {
      // Convert remotePlayers object to an Array
      let playerList = Object.values(window.remotePlayers || {});
      
      // Map them to include your Helper Functions
      return playerList.map(p => {
          return {
              name: p.name,
              id: p.id, // This assumes remotePlayers stores the socketID as .id
              
              // 1. Kick
              kick: () => {
                  console.log(`Kicking ${p.name}...`);
                  socket.emit("admin_action", { targetId: p.id, action: 'kick' });
              },
              
              // 2. Banish
              banish: () => {
                  console.log(`Banishing ${p.name}...`);
                  socket.emit("admin_action", { targetId: p.id, action: 'banish' });
              },
              
              // 3. Vanquish (Delete Save)
              vanquish: () => {
                  console.log(`Vanquishing ${p.name}...`);
                  socket.emit("admin_action", { targetId: p.id, action: 'vanquish' });
              },
              
              // 4. Deck Access (Proxy)
              deck: {
                  push: (cardOrId) => {
                      // Handle "new Card(10)" or just "10"
                      let val = (typeof cardOrId === 'object') ? cardOrId.index : cardOrId;
                      console.log(`Giving card ${val} to ${p.name}...`);
                      socket.emit("admin_action", { targetId: p.id, action: 'give_card', payload: val });
                  }
              }
          };
      });
  }
  
  // Helper to refresh NPCs via console: Dungeon.refreshNPCs()
  refreshNPCs() {
      socket.emit("admin_refresh_npcs");
  }
  // --- SAVE SYSTEM ---
  saveGame() {
      // 1. Convert complex Deck objects into simple ID list
      // We only save the IDs, because we re-create the Card objects on load
      let simpleDeck = this.deck.map(card => card.index);

      const saveData = {
          x: this.x,
          y: this.y,
          dir: this.dir,
          mapID: this.mapID,
          deckIDs: simpleDeck,        // Save just the IDs
          MainQuest: this.MainQuest,
          name: playerName,
          sprite:playerSprite,
          gd: this.gd,                // Giant Daughter quest status
          dSense: this.dSense,        // Divine Sense status
          memory: this.memory,        // Which NPCs/Chests are dead/opened
          tutorialFinished: this.tutorialFinished
      };

      localStorage.setItem('battlemage_save', JSON.stringify(saveData));
      console.log("Game Saved!", saveData);
      
      // Optional: Visual feedback
      if(typeof MessageBox !== 'undefined') {
          // MessageBox.show(0.5, 8, 1, 9, 2, 'Game Saved.', 'dialogue', 1, 0);
      }
  }
  deleteGame() {
      // 1. Remove the specific save file key
      localStorage.removeItem('battlemage_save');
      
      console.log("Save file deleted.");
      
      // 2. Optional: Return true so your UI knows it finished
      return true;
  }
  loadGame() {
    const json = localStorage.getItem('battlemage_save');
    if (!json) {
        console.log("No save file found.");
        return false;
    }

    try {
        const data = JSON.parse(json);
        console.log("Loading Save:", data);

        // 1. Restore Simple Variables
        this.x = data.x;
        this.y = data.y;
        this.dir = data.dir;
        this.MainQuest = data.MainQuest || 0;
        this.gd = data.gd || 0;
        this.dSense = data.dSense || 0;
        this.tutorialFinished = data.tutorialFinished || 0;

        // --- NEW: Restore Player Name ---
        // If we don't do this, the server will see "Wanderer"
        if (data.name) {
            playerName = data.name; // Update global variable
            playerSprite = data.sprite;
            Player[0].name = data.name; // Update local player object
        }
        // --------------------------------

        // 2. Restore Memory (Dead NPCs)
        this.memory = { ...this.memory, ...data.memory };

        // 3. Restore Deck
        if (data.deckIDs) {
            this.deck = [];
            data.deckIDs.forEach(id => {
                this.deck.push(new Card(id, 0)); 
            });
            Player[0].deck = [];
            this.deck.forEach(c => Player[0].deck.push(new Card(c.index, 0)));
        }

        // 4. Load the Map & Apply Position
        this.loadMap(data.mapID); 
        
        this.x = data.x;
        this.y = data.y;
        this.dir = data.dir;

        // 5. Update Server
        if (typeof socket !== 'undefined') {
            
            // --- A. ANNOUNCE ARRIVAL (The code you wanted) ---
            // --- A. ANNOUNCE ARRIVAL & UPLOAD BRAIN ---
            socket.emit("join_game", {
                name: playerName,
                aiHistory: getAiMemory() // Send the browser's stored memory
            });
            // -------------------------------------------------

            // B. Sync Position
            socket.emit("move", {
                x: this.x,
                y: this.y,
                dir: this.dir,
                mapID: this.mapID,
                name: playerName,
                type: playerSprite
            });
        }

        return true;
    } catch (e) {
        console.error("Failed to load save:", e);
        return false;
    }
}
  loadMap(id) {
    //0=N, 1=E, 2=S, 3=W

    this.mapID = id;
    this.npcs = [];
    this.maze = [];
    this.explored = [];
    if (id === 6) this.weather.setMode('snow');
    else if (id === 9) this.weather.setMode('storm');
    else if(id == 14||id == 22) this.weather.setMode('leaves');
    else if(id == 15||id == 21) this.weather.setMode('lightning');
    else if(id == 16||id == 17||id == 18||id == 19||id == 20) this.weather.setMode('space');
    else this.weather.setMode('clear');

    for (let r = 0; r < this.maze.length; r++) {
        this.explored[r] = new Array(this.maze[0].length).fill(0);
    }
    //MAP 0: Tutorial
    if (id === 0) {
     this.skyColor = 'rgba(0,0,0,1)';   // Dark Blue Sky
      this.floorColor = 'rgba(32,16,0,1)'; // Blue Floor
        this.maze = [
          [1,1,1,1,1,1,1,1,1,1,1],
          [1,0,0,0,1,0,1,0,0,0,1],
          [1,0,0,0,1,0,1,0,0,0,1],
          [1,0,0,0,1,0,1,0,0,0,1],
          [1,1,1,1,0,0,0,0,0,0,1],
          [1,0,0,0,0,0,0,0,0,0,1],
          [1,1,1,1,0,0,0,1,1,1,1],
          [1,0,0,0,1,0,1,0,0,0,1],
          [1,0,0,0,1,0,1,0,0,0,1],
          [1,0,0,0,1,0,1,0,0,0,1],
          [1,1,1,1,1,1,1,1,1,1,1]
        ];
        this.npcs = [
          new NPC(0,5.5, 1.4, 2,'stationary','#00ff00'), // High Priestess
          //new NPC(1,2.5, 9.5, 9.1), // Old NPC
          new NPC(2,1.5, 5.5, 3,'stationary','#00ff00'), // Empress
          new NPC(3,5.5, 9.5, 4,'stationary','#00ff00'), // Emperor
          new NPC(4,9.5, 5.5, 5,'stationary','#00ff00'), // Hierophant
          // --- NEW: THE PORTAL ---
          // Located at (1.5, 7.5), near the NE wall
          new NPC(1,9.5, 1.5, 99, 'stationary','#66ccff') 
        ];
        this.x = 5.5; 
        this.y = 5.5;
    }
    //MAP 1: Dungeon (Magician Area)
    else if (id === 1) {
        this.skyColor = 'rgba(0,0,0,1)';   // Dark Blue Sky
        this.floorColor = 'rgba(32,16,0,1)'; // Blue Floor
        this.maze = [
        // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],//0
          [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1],//1
          [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1],//2
          [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1],//3
          [1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1],//4
          [1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1],//5
          [1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1],//6
          [1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1],//7
          [1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1],//8
          [1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1],//9
          [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],//10
          [1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1],//11
          [1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1],//12
          [1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1],//13
          [1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1],//14
          [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1],//15
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] //16
        ];
        this.npcs = [
            // Wisp 
            new NPC(0,6.5, 1.5, 23, 'wandering','#660066', [26, 26, 23]),
            //Magician
            new NPC(1,5.5, 12.5, 1.1, 'stationary','#00ff00'),
            // Portal back to Main Map
            new NPC(2,9.5, 15.5, 99, 'stationary','#66ccff'),
            //Cards
            //Sword Card
             new NPC(3,2.5, 4.5, -27, 'stationary','#ffff00', [50]),
             //Wand Card
             new NPC(4,12.5, 1.5, -27, 'stationary', '#ffff00',[22]),
             //Hourglass Card
             new NPC(5,3.5, 13.5, -27, 'stationary','#ffff00', [36]),
             //Shield Card
             new NPC(6,6.5, 8.5, -27, 'stationary','#ffff00', [64]),
            
            // Portal 1 EAST
            new NPC(7,11.5, 10.5, 99, 'stationary','#66ccff'),
            // Portal 2 NW
            new NPC(8,1.5, 4.5, 99, 'stationary','#66ccff'),
            // Portal 3 NE
            new NPC(9,10.5, 2.5, 99, 'stationary','#66ccff'),
            // Portal 4 SW
            new NPC(10,1.5, 15.5, 99, 'stationary','#66ccff'),
            //Exit
            new NPC(11,6.5, 1.5, 99, 'stationary','#66ccff')

        ];
        this.x = 9.5; this.y = 15.5; this.dir = 0;
    }
    //MAP 2: Tintagel Forest (Hermit Area)
    else if(id === 2){
      this.skyColor = 'rgba(0,16,0,1)';   // Dark Blue Sky
      this.floorColor = 'rgba(32,32,16,1)'; // Blue Floor
        
        this.maze = [
        // 0, 1, 3, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16
          [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],//0
          [3, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],//1
          [3, 0, 0, 0, 0, 0, 3, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3],//2
          [3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3],//3
          [3, 0, 3, 0, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 3],//4
          [3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 3],//5
          [3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 3, 3],//6
          [3, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 3, 3, 3, 0, 3],//7
          [3, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3],//8
          [3, 0, 0, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 0, 3, 3],//9
          [3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 3],//10
          [3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3],//11
          [3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 3],//12
          [3, 0, 0, 3, 0, 0, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 3],//13
          [3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3],//14
          [3, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 3],//15
          [3, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 3, 0, 3],//16
          [3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3],//17
          [3, 0, 7, 7, 0, 7, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3],//18
          [3, 7, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3],//19
          [3, 7, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 3, 3],//20
          [3, 7, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 3],//21
          [3, 7, 7, 7, 7, 7, 7, 7, 0, 0, 3, 0, 0, 3, 0, 0, 3],//22
          [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3] //23
        ];
        this.npcs = [
          new NPC(0,9.5, 8.5, 1,'stationary','#00ff00'), // Magician
          new NPC(1,15.5, 5.5, 9.1,'stationary','#404040'), // Hermit
          new NPC(2,3.5, 16.5, 54, 'wandering','#660066', [40, 41, 54]),//goblin
          new NPC(3,13.5, 19.5, 54, 'wandering','#660066', [58, 52, 54]),//goblin
          new NPC(4,4.5, 21.5, 54, 'stationary','#660066', [40, 41, 54,58, 52, 54,51,54]),//goblin chief
          new NPC(5,1.5, 3.5, 23, 'wandering','#660066', [26, 26, 23,15]),//wisp
          new NPC(6,9.5, 12.5, 99, 'stationary','#66ccff'),//portal back to map 1
          new NPC(7,1.5, 1.5, -29, 'stationary','#66ccff'),//cave entrance
          //Ruin
          new NPC(8,14.5, 4.5, -27, 'stationary','#404040', [16]),
          //Bind
          new NPC(9,15.5, 7.5, -27, 'stationary', '#ffff00',[12]),
          //Camp
          new NPC(10,15.5, 22.5, -27, 'stationary','#ffff00', [53]),
          //Treasure Chest
          new NPC(11,6.5, 21.5, -27, 'stationary','#ffff00', [10]),
          //lunacy
          new NPC(12,10.5, 3.5, -27, 'stationary','#ffff00', [18]),
          //Pixie spawns from hermit dialogue Index 13 AND 14
          new NPC(15,14.5, 21.5, 57.1, 'stationary','#660066', [57, 12, 52,59]),//spider
        ];
        this.x = 9.5; 
        this.y = 12.5;
    }
    //MAP 3: Goblin Caverns
    else if(id === 3){
      this.skyColor = 'rgba(0,0,0,1)';   // Dark Blue Sky
      this.floorColor = 'rgba(32,16,8,1)'; // Blue Floor
        
        this.maze = [
        // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],//0
          [1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1],//1
          [1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1],//2
          [1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1],//3
          [1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1],//4
          [1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1],//5
          [1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1],//6
          [1, 1, 0, 0, 0, 1, 1,-2, 0,-2, 1, 1, 0, 1],//7
          [1, 1, 0, 0, 0, 1, 1,-2, 0,-2, 1, 1, 0, 1],//8
          [1, 1, 0, 0, 0, 1, 1,-2, 0,-2, 1, 1, 0, 1],//9
          [1, 1, 0, 0, 0, 1, 1,-2, 0,-2, 1, 1, 2, 1],//10
          [1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1],//11
          [1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1],//12
          [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1],//13
          [1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1],//14
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],//15
          [1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1],//16
          [1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1],//17
          [1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1],//18
          [1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1],//19
          [1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1],//20
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]//21
          
        ];
        this.npcs = [
          new NPC(0,8.5, 2.5, 32,'stationary','#00ff00'), // Apprentice
          new NPC(1,8.5, 20.5, -29, 'stationary','#66ccff'),//cave entrance
          new NPC(2,3.5, 2.5, 21.1, 'stationary','#00ff00'),//Treasure Snake
          //index 3 is portal spawned after snake quest
          new NPC(4,8.5, 3.5, 56, 'stationary','#ff0000'),//Imp 
          //index 5 is imp battle
          //index 6 is portal to map 4 spawned by apprentice
          new NPC(7,1.5, 15.5, 56, 'stationary','#660066',[56,40,26,58,68,50]),//imp W
          new NPC(8,5.5, 19.5, 56, 'stationary','#660066',[56,59,26,68,50,15]),//imp W
          new NPC(9,12.5, 16.5, 56, 'stationary','#660066',[56,26,12,50,15]),//imp E
          new NPC(10,8.5, 14.5, 23, 'wandering','#660066',[26, 26, 15,23]),//wisp N1
          new NPC(11,11.5, 12.5, 23, 'wandering','#660066',[26, 23,26,26,15,24]),//wisp E
          new NPC(12,8.5, 8.5, 23, 'wandering','#660066',[26, 26, 15,23]),//wisp N2
          new NPC(13,12.5, 5.5, 42, 'stationary','#404040',[42,68,26,26,26,26,42,24,42,15,16,18]),//shade 
          
          //Cards
            //Protect Orb
             new NPC(14,12.5, 4.5, -27, 'stationary','#ffff00', [30]),
             //Steal
             new NPC(15,6.5, 19.5, -27, 'stationary', '#ffff00',[40]),
             //Backstab
             new NPC(16,1.5, 14.5, -27, 'stationary','#ffff00', [52]),
             //Intimidate
             new NPC(17,12.5, 13.5, -27, 'stationary','#ffff00', [58]),
             //Loot
             new NPC(18,12.5, 17.5, -27, 'stationary','#ffff00', [41])
        ];
        this.x = 8.5; 
        this.y = 20.5;
        this.dir = 0;
    }
    //Map 4: Realm of the Witch Queen (Desert Area)
    else if(id === 4){
      this.skyColor = 'rgba(0,0,64,1)';   // Dark Blue Sky
      this.floorColor = 'rgba(210,180,140,1)'; // Blue Floor
        
        this.maze = [
        // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16
          [1, 1, 1, 1, 5, 5, 5, 5, 5, 5, 5, 5, 5, 1, 1, 1, 1],//0
          [1, 1, 1, 1, 5, 5, 5, 5, 0, 5, 5, 5, 5, 1, 1, 1, 1],//1
          [1, 1, 1, 1, 5, 5, 5, 0, 0, 0, 5, 5, 5, 1, 1, 1, 1],//2
          [1, 1, 1, 1, 5, 5, 0, 0, 0, 0, 0, 5, 5, 1, 1, 1, 1],//3
          [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],//4
          [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],//5
          [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1],//6
          [1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1],//7
          [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1],//8
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1],//9
          [1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],//10
          [1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],//11
          [1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1],//12
          [1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1],//13
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],//14
          [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1],//15
          [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],//16
          [1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1],//17
          [1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1],//18
          [1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1],//19
          [1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1],//20
          [1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1],//21
          [1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1],//22
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] //23
        ];
        this.npcs = [
          //Portals
          //portal to map 3
          new NPC(0,8.5, 22.5, 99, 'stationary','#66ccff'),
          //portal to map 4
          new NPC(1,8.5, 2, -30, 'stationary','#66ccff'),
          // Apprentice
          new NPC(2,8.5, 18.5, 32,'stationary','#00ff00'), 
          // Mirage S
          new NPC(3,1.5, 20.5, 23.1,'wandering','#660066'), 
          // Mirage E
          new NPC(4,15.5, 18.5, 23.1,'wandering','#660066'), 
          // Mirage N
          new NPC(5,7.5, 6.5, 23.1,'wandering','#660066'), 
          //Enemies
          // fire imp SE
          new NPC(6,13.5, 14.5, 56.1,'stationary','#660066',[79,68,52,40,26,26,15,16]),
          // fire imp SW
          new NPC(7,3.5, 16.5, 56.1,'stationary','#660066',[79,68,52,40,26,26,15,16]), 
          // fire imp NW
          new NPC(8,2.5, 7.5, 56.1,'stationary','#660066',[79,68,52,40,26,26,15,16]), 
          // fire imp NE
          new NPC(9,9.5, 2.5, 56.1,'stationary','#660066',[79,68,52,40,26,26,15,16]), 
          // fire imp N
          new NPC(10,7.5, 2.5, 56.1,'stationary','#660066',[79,68,52,40,26,26,15,16]), 
          // fire imp S     
          new NPC(11,7.5, 12.5, 56.1,'stationary','#660066',[79,68,52,40,26,26,15,16]), 
          // salamander
          new NPC(12,9.5, 10.5, 33.1,'wandering','#660066',[33,26,29,26,26,26,26,26]), 
          //Cards
          //Haste
          new NPC(13,15.5, 19.5, -27, 'stationary','#ffff00', [29]),
          //Solar Rite
          new NPC(14,1.5, 21.5, -27, 'stationary', '#ffff00',[19]),
          //Elixer
          new NPC(15,1.5, 11.5, -27, 'stationary','#ffff00', [25]),
        ];
        this.x = 8.5; 
        this.y = 22.5;
        this.dir = 0;
    }
    //MAP 5: Witch Queen's Castle
    else if (id === 5) {
     this.skyColor = 'rgba(8,0,0,1)';   // Dark Blue Sky
      this.floorColor = 'rgba(255,191,191,1)'; // Gray
        this.maze = [
        // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16
          [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],//0
          [5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5],//1
          [5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5],//2
          [5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5, 5],//3
          [5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5, 5],//4
          [5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5, 5],//5
          [5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5, 5],//6
          [5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5, 5],//7
          [5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5],//8
          [5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5],//9
          [5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5],//10
          [5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5],//11
          [5, 0, 0, 0, 0, 0, 5, 0, 0, 0, 5, 0, 0, 0, 0, 0, 5],//12
          [5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5],//13
          [5, 0, 0, 0, 0, 0, 5, 0, 0, 0, 5, 0, 0, 0, 0, 0, 5],//14
          [5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5],//15
          [5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5],//16
          [5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5],//17
          [5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5],//18
          [5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5],//19
          [5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5],//20
          [5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5],//21
          [5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5],//22
          [5, 5, 5, 5, 5, 5, 5, 5, 0, 5, 5, 5, 5, 5, 5, 5, 5],//23
          [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5] //24
          
        ];
        this.npcs = [
          //Main npcs
          //Djinn
          new NPC(0,8.5, 2.5, 35.1,'stationary','#ff0000',[35,35,35,16,18,26,26,26,26,15,28,44,19]), 
          //Witch Queen
          new NPC(1,8.5, 1.5, 34.1,'stationary','#00ff00'), 
          //portals
          //Door to map 4
          new NPC(2,8.5, 23.5, -30, 'stationary','#66ccff') ,
          //Enemies
          //Neophyte
          new NPC(3,2.5, 13.5, 32.1,'stationary','#00ff00',[78,28,26,26,25,12,15,24]), 
          new NPC(4,14.5, 13.5, 32.1,'stationary','#00ff00',[78,28,26,26,25,12,15,24]), 
          //Fire Imp N
          new NPC(5,8.5, 6.5, 56.1,'wandering','#660066',[79,68,52,40,26,26,15,16]),
          // fire imp S
          new NPC(6,8.5, 15.5, 56.1,'wandering','#660066',[79,68,52,40,26,26,15,16]), 
          // fire imp W
          new NPC(7,3.5, 13.5, 56.1,'wandering','#660066',[79,68,52,40,26,26,15,16]), 
          // fire imp E
          new NPC(8,13.5, 13.5, 56.1,'wandering','#660066',[79,68,52,40,26,26,15,16]), 
          //cards
           //Tome E
          new NPC(9,15.5, 13.5, -27, 'stationary', '#ffff00',[31]),
          //Amulet W
          new NPC(10,1.5, 13.5, -27, 'stationary','#ffff00', [27]),
          //11 is djinn spawn
          //12 is witch queen portal
        ];
        this.x = 8.5; 
        this.y = 23.5;
    }
    //MAP 6: Cairn Gorm (Snow Level)
    else if (id === 6) {
     this.skyColor = 'rgba(193,193,193,1)';   //light gray
      this.floorColor = 'rgba(255,255,255,1)'; // white
      this.maze = [
        // 0, 13,2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16
          [13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13],//0
          [13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,13],//1
          [13, 0, 0, 0, 0,11,11, 0,11,11, 0, 0, 0, 0, 0, 0,13],//2
          [13, 0, 0, 0, 0,11, 0,11, 0, 0,11,11, 0, 0, 0, 0,13],//3
          [13, 0, 0, 0, 0,11, 0, 0, 0, 0, 0, 0,11, 0, 0, 0,13],//4
          [13, 0, 0, 0,11, 0, 0, 0, 9, 0, 0, 0,11, 0, 0, 0,13],//5
          [13, 0, 0, 0,11, 0, 0, 9, 9, 9, 0, 0, 0,11, 0, 0,13],//6
          [13, 0, 0,11, 0, 0, 9, 9, 9, 9, 9, 0,11, 0, 0,11,13],//7
          [13, 0, 0,11, 0, 9, 9, 9, 0, 9, 9, 9,11, 0, 0,11,13],//8
          [13, 0, 0,11, 0, 0, 0, 0, 0, 0, 0, 0,11, 0, 0,11,13],//9
          [13, 0, 0, 0,11, 0, 0, 0, 0, 0, 0, 0,11, 0, 0,11,13],//10
          [13, 0, 0, 0, 0,11,11, 0, 0, 0, 0, 0,11, 0, 0,11,13],//11
          [13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,11, 0,11,13],//12
          [13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,11, 0,11,13],//13
          [13, 0, 0, 0, 0, 0, 0,11, 0, 0,11, 0,11, 0, 0,11,13],//14
          [13,11,11,11, 0, 0, 0,11,11,11, 0,11, 0, 0, 0,11,13],//15
          [13, 0, 0, 0, 0, 0,11,11, 0, 0, 0, 0, 0, 0, 0,11,13],//16
          [13, 0, 0, 0, 0,11, 0, 0, 0, 0, 0, 0, 0, 0,11, 0,13],//17
          [13, 0, 0, 0, 0,11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,13],//18
          [13,-1, 0, 0, 0,11, 0, 0, 0, 0, 0, 0, 0,11, 0, 0,13],//19
          [13,-1,-1, 0, 0,11, 0, 0, 0, 0, 0,11,11, 0, 0, 0,13],//20
          [13,-1,-1,-1, 0, 0,11, 0, 0, 0,11, 0, 0, 0, 0, 0,13],//21
          [13,-1,-1,-1,-1, 0, 0,11, 0,11, 0, 0, 0, 0, 0, 0,13],//22
          [13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13] //23
        ];
        this.npcs = [
          //portals
          //to map 5
          new NPC(0,8.5, 22.5, 99, 'stationary','#66ccff'), 
          //ice cave map 7
          new NPC(1,10.5, 15.5, -32, 'stationary','#66ccff'),
          //ice queen fortress map 8 
          new NPC(2,8.5, 8.5, -31, 'stationary','#66ccff'), 
          //cards
          //defense
          new NPC(3,11.5, 22.5, -27, 'stationary', '#ffff00',[28]),
          //lovers
          new NPC(4,6.5, 22.5, -27, 'stationary', '#ffff00',[6]),
          //lucky charm
          new NPC(5,11.5, 7.5, -27, 'stationary', '#ffff00',[45]),
          //npcs
          //Ice Golem
          new NPC(6,14.5, 21.5, 81, 'wandering', '#660066',[81,64,50,52,28]),
          new NPC(7,14.5, 2.5, 81, 'wandering', '#660066',[81,64,50,52,28]),
          new NPC(8,1.5, 9.5, 81, 'wandering', '#660066',[81,64,50,52,28]),
          //undine
          new NPC(9,2.5, 19.5, 47.1, 'stationary', '#660066',[47,52,59,28,29,6]),
          //ice golem
          new NPC(10,5.5, 10.5, 81, 'wandering', '#660066',[81,64,50,52,28]),

        ];
        this.x = 8.5; 
        this.y = 22.5;
    }
    //MAP 7: Ice Cave
    else if (id === 7) {
     this.skyColor = 'rgba(0,0,32,1)';   // Dark Blue Sky
      this.floorColor = 'rgba(174,174,255,1)'; // Blue Floor
        this.maze = [
        // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
          [15,15,15,15,15,15,15,15,15,15,15],// 0
          [15, 0, 0,15, 0, 0, 0,15, 0, 0,15],//1
          [15, 0, 0,15, 0, 0, 0,15, 0, 0,15],//2
          [15, 0, 0,15, 0, 0, 0,15, 0, 0,15],//3
          [15, 0, 0, 0,15, 0,15, 0, 0, 0,15],//4
          [15, 0, 0, 0, 0, 0, 0, 0, 0, 0,15],//5
          [15,15,15,15, 0, 0, 0,15,15,15,15],//6
          [15, 0, 0,15, 0, 0, 0,15, 0, 0,15],//7
          [15, 0, 0, 0, 0, 0, 0, 0, 0, 0,15],//8
          [15, 0, 0,15,15, 0,15,15, 0, 0,15],//9
          [15,15,15,15,15,15,15,15,15,15,15]//1 0
        ];
        this.npcs = [
          
          //Portals
          //exit to map 6
          new NPC(0,5.5, 9.5, -32, 'stationary','#66ccff'), 
          //cards
          //death
          new NPC(1,5.5, 1.5, -27, 'stationary', '#ffff00',[13]),
          //enemies
          //shade
          new NPC(2,5.5, 2.5, 42, 'stationary', '#660066',[42,42,42,26,26,26,15,28,52,68]),
          //skeleton
          new NPC(3,1.5, 8.5, 82, 'wandering', '#660066',[82,50,64,59,58]),
          new NPC(4,1.5, 1.5, 82, 'wandering', '#660066',[82,50,64,59,58]),
          new NPC(5,9.5, 1.5, 82, 'wandering', '#660066',[82,50,64,59,58]),
          new NPC(6,9.5, 8.5, 82, 'wandering', '#660066',[82,50,64,59,58]),

        ];
        this.x = 5.5; 
        this.y = 9.5;
    }
    //Map 8: Ice Queen's Castle
    else if (id === 8) {
     this.skyColor = 'rgba(0,0,39,1)';   // Dark Blue Sky
      this.floorColor = 'rgba(139,139,255,1)'; // Blue Floor
        this.maze = [
          [9,9,9,9,9,9,9,9,9,9,9],
          [9,9,9,9,9,0,9,9,9,9,9],
          [9,9,9,9,0,0,0,9,9,9,9],
          [9,9,9,0,0,0,0,0,9,9,9],
          [9,9,0,0,0,0,0,0,0,9,9],
          [9,0,0,0,0,0,0,0,0,0,9],
          [9,9,0,0,0,0,0,0,0,9,9],
          [9,9,9,0,0,0,0,0,9,9,9],
          [9,9,9,9,0,0,0,9,9,9,9],
          [9,9,9,9,9,0,9,9,9,9,9],
          [9,9,9,9,9,9,9,9,9,9,9]
        ];
        this.npcs = [
          //exit to map 6
          new NPC(0,5.5, 9.5, -31, 'stationary','#66ccff'),
          //cards
          //charity 
          new NPC(1,1.5, 5.5, -27, 'stationary', '#ffff00',[69]),
          //teleport crystal
          new NPC(1,9.5, 5.5, -27, 'stationary', '#ffff00',[43]),
          //sailboat
         // new NPC(2,5.5, 1.5, -27, 'stationary', '#ffff00',[55]),
          //ice queen
          new NPC(4,5.5, 1.5, 48,'stationary','#00ff00'), 
        ];
        this.x = 5.5; 
        this.y = 9.5;
    }
    //Map 9: Boreal Sea
    else if (id === 9) {
     this.skyColor = 'rgba(0,0,0,1)';   // Dark Blue Sky
      this.floorColor = 'rgba(0,0,64,1)'; // Blue Floor
        this.maze = [
        // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33
         [19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19],//0
         [19, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,19],//1
         [19, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,15, 0, 0, 0, 0, 0, 0,19],//2
         [19, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,19],//3
         [19, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,19],//4
         [19, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,19],//5
         [19,-10,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,19],//6
         [19,-10,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,19],//7
         [19,-10,0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,19],//8
         [19, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,19],//9
         [19, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,15,15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,19],//10
         [19, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,15,15,15,15,15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,19],//11
         [19, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,15, 0, 0, 0,15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,19],//12
         [19, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,15, 0, 0, 0, 0, 0, 0, 0, 0,19],//13
         [19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19]//14
        ];
        this.npcs = [
          //exit to map 8
          new NPC(0,33.5, 7.5, 99, 'stationary','#66ccff'),
          //Enemies
          //kraken
          new NPC(1,6.5, 7.5, 49.1, 'stationary', '#ff0000',[52,52,52,52,40,40,10,10,58,51,51,58,83,83,83,49]),
          //tentacles
          new NPC(2,10.5, 9.5, 83, 'wandering', '#ff0000',[59,52,40,83]),
          new NPC(3,21.5, 12.5, 83, 'wandering', '#ff0000',[59,52,40,83]),
          new NPC(4,26.5, 2.5, 83, 'wandering', '#ff0000',[59,52,40,83]),

          //siren
          new NPC(5,13.5, 13.5, 37.1, 'stationary', '#00ff00',[13,15,52,40,37]),
          //sea serpent
          new NPC(6,19.5, 6.5, 46.1, 'wandering', '#660066',[52,52,40,29,46]),
          new NPC(7,6.5, 3.5, 46.1, 'wandering', '#660066',[52,52,40,29,46]),
          
          //undine
          //new NPC(8,26.5, 13.5, 47.1, 'wandering', '#660066',[52,59,58,28,29,6,47]),

          //sailboat
         // new NPC(2,5.5, 1.5, -27, 'stationary', '#ffff00',[55]),
          //ice queen
          //new NPC(4,5.5, 1.5, 48,'stationary','#00ff00'), 
        ];
        this.x = 33.5; 
        this.y = 7.5;
        this.dir = 3; 
    }
    //MAP 10: Realm of the Fairy Queen (Avalon)
    else if (id === 10) {
     this.skyColor = '#2E2B5F';   // Dark Blue Sky
      this.floorColor = '#152015'; // Blue Floor
        this.maze = [
        // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33
        [25,25,25,25,25,25,25,25,25,25,21,21,21,21,25,25,25,25,25,25,25,21,21,21,21,25,25,25,25,25,25,25,25,25,25],//0
         [25,25,25,25,25,25,25,25,25,21, 0, 0, 0, 0,21,25,25,25,25,25,21, 0, 0, 0, 0,21,25,25,25,25,25,25,25,25,25],//1
         [25,25,25,25,25,25,25,25, 0,21, 0, 0, 0, 0, 0,21,25,21,25,21, 0, 0, 0, 0, 0,21,25,25,25,25,25,25,25,25,25],//2
         [25,25,25,25,25,25,25, 0, 0, 0,21, 0, 0, 0, 0, 0,21, 0,21, 0, 0, 0, 0, 0,21, 0, 0,25,25,25,25,25,25,25,25],//3
         [25,25,25,25,25,25, 0, 0, 0, 0, 0,21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,21, 0, 0, 0, 0,25,25,25,25,25,25,25],//4
         [25,25,25,25,25, 0, 0, 0,19, 0, 0, 0,21, 0, 0, 0, 0, 0, 0, 0, 0, 0,21, 0, 0, 0, 0, 0, 0,25,25,25,25,25,25],//5
         [25,25,25,25,25, 0, 0,19, 0, 0, 0, 0, 0,21, 0, 0, 0, 0, 0, 0, 0,21, 0, 0, 0, 0, 0, 0, 0, 0,25,25,25,25,25],//6
         [25,25,25,25,25,19, 0, 0, 0, 0, 0, 0, 0, 0,21, 0, 0, 0, 0, 0,21, 0, 0, 0, 0, 0, 0, 0,23, 0, 0,25,25,25,25],//7
         [25,25,25, 0, 0, 0, 0, 0,19, 0, 0, 0, 0, 0, 0,21,21, 0,21,21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,25,25,25],//8
         [25,25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,23, 0, 0, 0, 0, 0, 0, 0,25,25],//9
         [25,25, 0, 0, 0,19, 0, 0, 0, 0,19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,23, 0, 0, 0, 0, 0,25],//10
         [25, 0, 0, 0, 0, 0, 0,19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,25],//11
         [25,25, 0, 0,19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,25],//12
         [25,25,25, 0, 0, 0,19, 0, 0,19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,25],//13
         [25,25,25,25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,23, 0, 0, 0, 0, 0,25,25],//14
         [25,25,25,25,25,25, 0,19, 0, 0, 0,19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,23, 0, 0,25,25],//25
         [25,25,25,25,25,25,25, 0,19, 0, 0, 0, 0, 0,23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-12,29],//16
         [25,25,25,25,25,25,25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-12,29],//17
         [25,25,25,25,25,25,25,25, 0, 0,19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-12,29],//18
         [25,25,25,25,25,25,25,25,25, 0, 0, 0,25,25,25,25,25,25,25,25, 0, 0, 0, 0,23, 0, 0, 0, 0, 0, 0, 0, 0,25,25],//19
         [25,25,25,25,25,25,25,25,25,25,25, 0, 0, 0, 0, 0, 0, 0,25,25,25, 0, 0, 0, 0, 0,25,25,25,25,25,25,25,25,25],//20
         [25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25]//21
         
        ];
        this.npcs = [
          new NPC(0,17.5, 3.5, -33,'stationary','#66ccff'), // castle entrance
          new NPC(1,1.5, 11.5, -34,'stationary','#66ccff'), // dragon lair
          new NPC(2,17.5, 20.5, -34,'stationary','#66ccff'), // tomb
          new NPC(3,18.5, 4.5, 61.1,'wandering','#00ff00'), // Sylph
          new NPC(4,14.5, 4.5, 61.1,'wandering','#00ff00'), // Sylph
          new NPC(5,2.5, 10.5, 60.1,'stationary','#660066',[6,50,51,59,60]), // Pixie
          new NPC(6,2.5, 12.5, 60.1,'stationary','#660066',[6,50,51,59,60]), // Pixie
          new NPC(7,10.5, 19.5, 57.1,'stationary','#660066',[59,58,52,51,12,57]), // Spider
          new NPC(8,28.5, 6.5, 57.1,'stationary','#660066',[59,58,52,51,12,57]), // Spider
          new NPC(9,25.5, 20.5, 57.1,'stationary','#660066',[59,58,52,51,12,57]), // Spider
          new NPC(10,5.5, 7.5, 57.1,'stationary','#660066',[59,58,52,51,12,57]), // Spider
          new NPC(11,7.5, 5.5, 57.1,'stationary','#660066',[59,58,52,51,12,57]), // Spider
 
          new NPC(12,22.5, 13.5, 60.1,'wandering','#660066',[6,50,51,59,60]), // Pixie
          new NPC(13,11.5, 12.5, 60.1,'wandering','#660066',[6,50,51,59,60]), // Pixie
          new NPC(14,6.5, 11.5, 60.1,'wandering','#660066',[6,50,51,59,60]), // Pixie

          
        ];
        this.x = 33.5; 
        this.y = 17.5;
        this.dir = 3;
    }
    //Map 11: Fairy Queen's Castle
    else if (id === 11) {
     this.skyColor = 'rgba(32,32,0,1)';   // Dark Blue Sky
      this.floorColor = 'rgba(255,255,163,1)'; // Blue Floor
        this.maze = [
          [21,21,21,21,21,21,21,21,21,21,21],
          [21,21,21,21,21, 0,21,21,21,21,21],
          [21,21,21,21, 0, 0, 0,21,21,21,21],
          [21,21,21, 0, 0, 0, 0, 0,21,21,21],
          [21,21, 0, 0, 0, 0, 0, 0, 0,21,21],
          [21, 0, 0, 0, 0, 0, 0, 0, 0, 0,21],
          [21,21, 0, 0, 0, 0, 0, 0, 0,21,21],
          [21,21,21, 0, 0, 0, 0, 0,21,21,21],
          [21,21,21,21, 0, 0, 0,21,21,21,21],
          [21,21,21,21,21, 0,21,21,21,21,21],
          [21,21,21,21,21,21,21,21,21,21,21]
        ];
        this.npcs = [
          //exit to map 10
          new NPC(0,5.5, 9.5, -33, 'stationary','#66ccff'),
          //cards
          //Strength 
          new NPC(2,1.5, 5.5, -27, 'stationary', '#ffff00',[8]),
          //Winged Boots
          new NPC(3,9.5, 5.5, -27, 'stationary', '#ffff00',[7]),
          //sailboat
         // new NPC(2,5.5, 1.5, -27, 'stationary', '#ffff00',[55]),
          //Fairy Queen
          new NPC(1,5.5, 1.5, 62,'stationary','#00ff00'), 
        ];
        this.x = 5.5; 
        this.y = 9.5;
    }
    //MAP 12: Dragon's Lair
    else if (id === 12) {
        this.skyColor = 'rgba(0,0,0,1)';   // Dark Blue Sky
        this.floorColor = 'rgba(32,16,0,1)'; // Blue Floor
        this.maze = [
        // 0, 0, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],//0
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],//1
          [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1],//2
          [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],//3
          [1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1],//4
          [1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1],//5
          [1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1],//6
          [1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1],//7
          [1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1],//8
          [1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1],//9
          [1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1],//10
          [1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1],//11
          [1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1],//12
          [1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1],//13
          [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1],//14
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],//15
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] //16
        ];
        this.npcs = [
            
            // Exit to map 10
            new NPC(0,12.5, 15.5, -29, 'stationary','#66ccff'),
            new NPC(1,6.5, 7.5, 63.1,'stationary','#ff0000',[39,39,51,59,58,26,26,28,19,63,63,63]), // Dragon
            //Cards
            //Dragon Hoard
            new NPC(2,6.5, 6.5, -27, 'stationary','#ffff00', [67]),
             //Enemies
            new NPC(3,12.5, 1.5, 61.2,'wandering','#660066',[59,52,51,58,50,64,28,29,7,86]), // Dark Sylph
            new NPC(4,1.5, 1.5, 61.2,'wandering','#660066',[59,52,51,58,50,64,28,29,7,86]), // Dark Sylph
            new NPC(5,1.5, 15.5, 61.2,'wandering','#660066',[59,52,51,58,50,64,28,29,7,86]), // Dark Sylph
            new NPC(6,10.5, 15.5, 61.2,'wandering','#660066',[59,52,51,58,50,64,28,29,7,86]), // Dark Sylph
            new NPC(7,10.5, 3.5, 61.2,'wandering','#660066',[59,52,51,58,50,64,28,29,7,86]), // Dark Sylph
            new NPC(8,10.5, 3.5, 61.2,'wandering','#660066',[59,52,51,58,50,64,28,29,7,86]), // Dark Sylph
            new NPC(9,3.5, 3.5, 61.2,'wandering','#660066',[59,52,51,58,50,64,28,29,7,86]), // Dark Sylph
            new NPC(10,3.5, 13.5, 61.2,'wandering','#660066',[59,52,51,58,50,64,28,29,7,86]), // Dark Sylph
            new NPC(11,6.5, 13.5, 61.2,'wandering','#660066',[59,52,51,58,50,64,28,29,7,86]), // Dark Sylph

            
            

        ];
        this.x = 12.5; this.y = 15.5; this.dir = 0;
    }
     //MAP 13: Tomb of the Sleeping King
    else if (id === 13) {
     this.skyColor = 'rgba(0,0,32,1)';   // Dark Blue Sky
      this.floorColor = 'rgba(174,174,255,1)'; // Blue Floor
        this.maze = [
        // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
          [25,25,25,25,25,25,25,25,25,25,25],// 0
          [25,25,25,25, 0, 0, 0,25,25,25,25],//1
          [25,25,25,25, 0, 0, 0,25,25,25,25],//2
          [25,25,25,25, 0, 0, 0,25,25,25,25],//3
          [25,25,25,25,25, 0,25,25,25,25,25],//4
          [25,25,25,25, 0, 0, 0,25,25,25,25],//5
          [25,25,25,25, 0, 0, 0,25,25,25,25],//6
          [25,25,25,25, 0, 0, 0,25,25,25,25],//7
          [25,25,25,25, 0, 0, 0,25,25,25,25],//8
          [25,25,25,25,25, 0,25,25,25,25,25],//9
          [25,25,25,25,25,25,25,25,25,25,25]//1 0
        ];
        this.npcs = [
          
          //Portals
          //exit to map 10
          new NPC(0,5.5, 9.5, -34, 'stationary','#66ccff'), 
          //cards
          //Excalibur
          new NPC(1,5.5, 1.5, -27, 'stationary', '#ffff00',[84]),
          //enemies
          //Arthur
          new NPC(2,5.5, 2.5, 4.1, 'stationary', '#00ff00',[50,64,59,51,8,28,85]),
          
        ];
        this.x = 5.5; 
        this.y = 9.5;
        this.dir = 0;
    }
    //MAP 14: Realm of the Elf Queen
    else if (id === 14) {
     this.skyColor = '#4d3900';   // Dark Blue Sky
      this.floorColor = '#336600'; // Blue Floor
        this.maze = [
        //0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33
         [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,31,31,31,31,31,31, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],//0
         [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,31, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1],//1
         [1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,31,31,31,31,31, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1],//2
         [1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1],//3
         [1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,31,31, 0,31,31, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1],//4
         [1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,31,31, 0, 0, 0,31,31, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1],//5
         [1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,31,31, 0, 0, 0, 0, 0,31,31, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],//6
         [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,31, 0, 0, 0, 0, 0, 0, 0,31, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],//7
         [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1],//8
         [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,31, 0, 0, 0, 0, 0, 0, 0,31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],//9
         [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,31,31, 0, 0, 0, 0, 0,31,31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],//10
         [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,31,31, 0, 0, 0,31,31, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1],//11
         [1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0,31,31, 0,31,31, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1],//12
         [1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1],//13
         [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1],//14
         [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1],//25
         [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],//16
         [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],//17
         [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],//18
         [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],//19
         [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],//20
         [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]//31
         
        ];
        this.npcs = [
          new NPC(0,1.5, 14.5, 99,'stationary','#66ccff'), // to Map 11 Elf Queen's Castle
          new NPC(1,33.5, 20.5, 99,'stationary','#66ccff'), // to cultivator
          new NPC(2,5.5, 1.5, 99,'stationary','#66ccff'), // to map

          new NPC(3,17.5, 8.5, 76,'stationary','#66ccff'), // Elf Queen
          new NPC(4,32.5, 2.5, -27,'stationary','#66ccff',[71]), // Forge
          new NPC(5,20.5, 1.5, -27,'stationary','#66ccff',[66]), // armor
          new NPC(6,3.5, 16.5, 77.2,'wandering','#66ccff'), // Giant's daughter
          new NPC(7,3.5, 17.5, 74.1,'wandering','#66ccff',[74]), // gargoyle chasing 
          new NPC(8,3.5, 18.5, 74.1,'wandering','#66ccff',[74]), // gargyle chasing
          new NPC(9,4.5, 16.5, 74.1,'wandering','#66ccff',[74]), // gargoyle chasing
          new NPC(10,29.5, 13.5, 75.1,'stationary','#66ccff',[74]), // Gnome Villager1
          new NPC(11,27.5, 3.5, 75.1,'stationary','#66ccff',[74]), // Gnome Villager2
          new NPC(12,32.5, 6.5, 75.1,'stationary','#66ccff',[74]), // Gnome Smith
          new NPC(13,21.5, 1.5, 74.1,'stationary','#66ccff',[74]), // gargoyle guard
          //14 giant battle
          //15 giant dialogue
          //16 portal to Dark Emperor's tower
           new NPC(17,1.5, 1.5, 70.1,'stationary','#66ccff',[74]), // gargoyle guard

        ];
        this.x = 1.5; 
        this.y = 16.5;
        this.dir = 1;
    }
    //MAP 15: Dark Tower Entrance
    else if (id === 15) {
     this.skyColor = 'rgba(0,0,0,1)';   // Dark Blue Sky
      this.floorColor = 'rgba(32,16,0,1)'; // Blue Floor
        this.maze = [
          [19,19,19,19,33,33,33,19,19,19,19],
          [19,19, 0,19,33, 0,33,19, 0,19,19],
          [19,19, 0,19,-2, 0,-2,19, 0,19,19],
          [19,19, 0,19,-2, 0,-2,19, 0,19,19],
          [19,19, 0,19,-2, 0,-2,19, 0,19,19],
          [19,19, 0,19,-2, 0,-2,19, 0,19,19],
          [19,19, 0,19,19, 0,19,19, 0,19,19],
          [19, 0, 0, 0,19, 0,19, 0, 0, 0,19],
          [19, 0, 0, 0,19, 0,19, 0, 0, 0,19],
          [19, 0, 0, 0,19, 0,19, 0, 0, 0,19],
          [19,19,19,19,19,19,19,19,19,19,19]
        ];
          this.npcs = [
          //Back to Map 14: Elf Queen Forest
          new NPC(0,5.5, 9.5, 99,'stationary','#66ccff'), 
          //To Map 16: Dark Tower Floor 1
          new NPC(1,5.5, 1.5, -35, 'stationary','#66ccff'),
          //Treasure Snake
          new NPC(2,8.5, 8.5, 21.1, 'stationary','#00ff00'),//Treasure Snake
          //3 is Portal from treasure snake back to map
          
          
        ];
        this.x = 5.5; 
        this.y = 9.5;
        this.dir = 0;

    }
    //MAP 16: Dark Tower Floor 1
    else if (id === 16) {
     this.skyColor = 'rgba(0,0,0,1)';   // Dark Blue Sky
      this.floorColor = 'rgba(0,0,0,1)'; // Blue Floor
        this.maze = [
        //0,19, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33
        [19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19],//0
        [19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,19],//1
        [19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,19],//2
        [19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,19],//3
        [19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,19],//4
        [19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,19],//5
        [19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,19],//6
        [19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,19],//7
        [19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,19],//8
        [19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,19],//9
        [19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,19],//10
        [19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,19],//11
        [19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,19],//12
        [19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,19],//13
        [19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,19],//14
        [19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,19],//25
        [19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,19],//16
        [19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,19],//17
        [19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,19],//18
        [19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,19],//19
        [19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,19],//20
        [19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19]//31
         
        ];
          this.npcs = [
          //Back to Map 14: Elf Queen Forest
          new NPC(0,3.5, 1.5, 99,'wandering','#66ccff'), 
          new NPC(1,9.5, 13.5, 99,'wandering','#66ccff'), 
          new NPC(2,13.5, 6.5, 99,'wandering','#66ccff'), 
          new NPC(3,6.5, 13.5, 99,'fleeing','#66ccff'), 
          new NPC(4,30.5, 16.5, 99,'wandering','#66ccff'), 
          new NPC(5,12.5, 11.5, 99,'wandering','#66ccff'), 
          new NPC(6,3.5, 11.5, 99,'wandering','#66ccff'), 
          new NPC(7,9.5, 11.5, 99,'wandering','#66ccff'), 
        
          
        ];
        this.x = 5.5; 
        this.y = 9.5;
        this.dir = 0;

    }
    //MAP 17 Djinn room.
    else if (id === 17) {
     this.skyColor = 'rgba(0,0,0,1)';   // Dark Blue Sky
      this.floorColor = 'rgba(0,0,0,1)'; // Blue Floor
        this.maze = [
        // 0,1,2,3,4
          [19,19,19,19,19],//0
          [19, 0, 0, 0,19],//1
          [19, 0, 0, 0,19],//2
          [19, 0, 0, 0,19],//3
          [19, 0, 0, 0,19],//4
          [19, 0, 0, 0,19],//5
          [19, 0, 0, 0,19],//6
          [19,19,19,19,19] //7
        ];
        this.npcs = [
          new NPC(0,2.5, 2.5, 35.1,'stationary','#00ff00'), // High Priestess
        ];
        this.x = 2.5; 
        this.y = 6.5;
        this.dir = 0;
    }
    //MAP 18: Kraken room
    else if (id === 18) {
     this.skyColor = 'rgba(0,0,0,1)';   // Dark Blue Sky
      this.floorColor = 'rgba(0,0,0,1)'; // Blue Floor
        this.maze = [
        // 0,1,2,3,4
          [19,19,19,19,19],//0
          [19, 0, 0, 0,19],//1
          [19, 0, 0, 0,19],//2
          [19, 0, 0, 0,19],//3
          [19, 0, 0, 0,19],//4
          [19, 0, 0, 0,19],//5
          [19, 0, 0, 0,19],//6
          [19,19,19,19,19] //7
        ];
        let waterDeck = [];
                for (let i = 36; i <= 49; i++) {
                    waterDeck.push(i);
                }
        this.npcs = [
          new NPC(0,2.5, 2.5, 49.1,'stationary','#00ff00',waterDeck), // High Priestess
        ];
        this.x = 2.5; 
        this.y = 6.5;
        this.dir = 0;
    }
    //MAP 19: Dragon room
    else if (id === 19) {
     this.skyColor = 'rgba(0,0,0,1)';   // Dark Blue Sky
      this.floorColor = 'rgba(0,0,0,1)'; // Blue Floor
        this.maze = [
        // 0,1,2,3,4
          [19,19,19,19,19],//0
          [19, 0, 0, 0,19],//1
          [19, 0, 0, 0,19],//2
          [19, 0, 0, 0,19],//3
          [19, 0, 0, 0,19],//4
          [19, 0, 0, 0,19],//5
          [19, 0, 0, 0,19],//6
          [19,19,19,19,19] //7
        ];
        this.npcs = [
          new NPC(0,2.5, 2.5, 63.1,'stationary','#00ff00'), // High Priestess
        ];
        this.x = 2.5; 
        this.y = 6.5;
        this.dir = 0;
    }
    //MAP 20: Giant room 
    else if (id === 20) {
     this.skyColor = 'rgba(0,0,0,1)';   // Dark Blue Sky
      this.floorColor = 'rgba(0,6,13,1)'; // Blue Floor
        this.maze = [
        // 0, 1, 2, 3, 4
          [19,19,19,19,19],//0
          [19,19, 0,19,19],//1
          [19,19, 0,19,19],//2
          [19,19, 0,19,19],//3
          [19,19, 0,19,19],//4
          [19,19, 0,19,19],//5
          [19,19, 0,19,19],//6
          [19,19, 0,19,19],//7
          [19,19, 0,19,19],//8
          [19,19, 0,19,19],//9
          [19,19, 0,19,19],//10
          [19,19, 0,19,19],//11
          [19,19, 0,19,19],//12
          [19,19, 0,19,19],//13
          [19, 0, 0, 0,19],//14
          [19, 0, 0, 0,19],//15
          [19, 0, 0, 0,19],//16
          [19, 0, 0, 0,19],//17
          [19, 0, 0, 0,19],//18
          [19, 0, 0, 0,19],//19
          [19, 0, 0, 0,19],//20
          [19, 0, 0, 0,19],//21
          [19,19,19,19,19] //22
        ];
        
        this.npcs = [
          new NPC(0,2.5, 14.5, 77.1,'stationary','#00ff00'), 
          new NPC(2,2.5, 1.5, 99,'stationary','#00ff00'),
          new NPC(3,2.5, 5.5, -27,'stationary','#00ff00',[14]),
        ];
        this.x = 2.5; 
        this.y = 21.5;
        this.dir = 0;
        
    }
    //MAP 21: Top of Tower
    else if (id === 21) {
     this.skyColor = 'rgba(0,0,0,1)';   // Dark Blue Sky
      this.floorColor = '#333333'; // Blue Floor
        this.maze = [
        // 0,1,2,3,4
          [19,19,19,19,19],//0
          [19, 0, 0, 0,19],//1
          [19, 0, 0, 0,19],//2
          [19, 0, 0, 0,19],//3
          [19, 0, 0, 0,19],//4
          [19, 0, 0, 0,19],//5
          [19, 0, 0, 0,19],//6
          [19,19,19,19,19] //7
        ];
        this.npcs = [
          new NPC(0,2.5, 1.5, 0,'stationary','#00ff00'), // High Priestess
        ];
        this.x = 2.5; 
        this.y = 6.5;
        this.dir = 0;
    }
    //MAP 22: Suncat's realm
    else if (id === 22) {
     this.skyColor = '#4d3900';   // Dark Blue Sky
      this.floorColor = '#336600'; // Blue Floor
        this.maze = [
        //0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33
         [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],//0
         [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1],//1
         [1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],//2
         [1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],//3
         [1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1],//4
         [1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1],//5
         [1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],//6
         [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],//7
         [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],//8
         [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],//9
         [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],//10
         [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1],//11
         [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1],//12
         [1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1],//13
         [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],//14
         [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1],//25
         [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],//16
         [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],//17
         [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],//18
         [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],//19
         [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],//20
         [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]//31
         
        ];
        this.npcs = [
          
        ];
        this.x = 16.5; 
        this.y = 9.5;
        this.dir = 1;
    }
    
    
    // --- NEW: LOAD PERSISTENT NPCS ---
    const memoryKey = 'spawned_' + id;
  if (this.memory[memoryKey]) {
      this.memory[memoryKey].forEach(data => {
          // Recreate the NPC from saved data
          const restoredNPC = new NPC(
              data.index, 
              data.x, 
              data.y, 
              data.type, 
              data.state, 
              data.color, 
              data.deck
          );
          this.npcs.push(restoredNPC);
      });
  }
    // --- NEW: APPLY MEMORY ---
    // After creating fresh NPCs, check if they should be dead
    this.npcs.forEach(npc => {
        // Create a unique ID for this specific NPC (e.g. "1_0" for Map 1, NPC 0)
        let uniqueID = this.mapID + "_" + npc.index;
        if (this.memory[uniqueID]) {
            let data = this.memory[uniqueID];

            // Case 1: Permanent Death (Cards, Story NPCs)
            if (data.permanent) {
                npc.isDead = true;
                npc.visible = false;
                npc.x = -999; // Move them to the void so you can't click them
            }
            // Case 2: Respawning Enemy (Wisp)
            else if (data.respawnAt) {
                if (Date.now() < data.respawnAt) {
                    // Still dead, waiting for timer
                    npc.isDead = true;
                    npc.visible = false;
                    npc.respawnTime = data.respawnAt; // Sync timer
                } else {
                    // Timer finished! It spawns alive.
                    // We remove it from memory so it's "fresh" again.
                    delete this.memory[uniqueID];
                }
            }
        }
                if(npc.isDead == true && npc.type == 49.1&&this.mapID == 9){
                  this.weather.setMode('clear');
                  this.skyColor = 'rgba(0,0,255,1)';
                  
                }

    });
    // -------------------------
  }
  
  registerClick(x, y) {
    this.clickInput = { x: x, y: y };
    // --- CHECK BUTTON PRESS ---
   
      
     
    
  }
  //Collision checking
  isWall(mapX, mapY) {
    // 1. Boundary Check
    if (mapX < 0 || mapX >= this.maze[0].length || mapY < 0 || mapY >= this.maze.length) return true;

    const tile = this.maze[mapY][mapX];

    // 2. POSITIVE NUMBERS (Walls)
    // Your existing logic: Odds are solid, Evens are pass-through
    if (tile > 0) {
        if (tile % 2 === 0) return false; // Pass-through wall
        return true; // Solid wall
    }

    // 3. --- NEW: NEGATIVE NUMBERS (Floors) ---
    if (tile < 0) {
        // Get absolute value to ignore the negative sign
        const absTile = Math.abs(tile);
        
        // If ODD (-1, -3, -5), it is Unwalkable (Water, Cliff)
        if (absTile % 2 === 1) return true; 

        // If EVEN (-2, -4, -6), it is Walkable (Rug, Dirt path)
        return false; 
    }

    // 4. Zero is default Walkable Floor
    return false;
  }
  checkLineOfSight(targetX, targetY) {
    // 1. Get integer coordinates
    let x0 = Math.floor(this.x);
    let y0 = Math.floor(this.y);
    let x1 = Math.floor(targetX);
    let y1 = Math.floor(targetY);

    // If in the same tile, it's visible
    if (x0 === x1 && y0 === y1) return true;

    // 2. Setup DDA (Digital Differential Analyzer) variables
    let dx = Math.abs(x1 - x0);
    let dy = Math.abs(y1 - y0);
    let sx = (x0 < x1) ? 1 : -1;
    let sy = (y0 < y1) ? 1 : -1;
    let err = dx - dy;

    // 3. Walk the grid from Player to NPC
    while (true) {
      // If we hit a wall, LOS is blocked
      if (this.isWall(x0, y0)) return false;

      // If we reached the target tile, LOS is clear
      if (x0 === x1 && y0 === y1) return true;

      // Move to next tile
      let e2 = 2 * err;
      if (e2 > -dy) { err -= dy; x0 += sx; }
      if (e2 < dx) { err += dx; y0 += sy; }
    }
  }
  checkFloorTriggers() {
    // 1. Get the integer tile coordinates
    let tx = Math.floor(this.x);
    let ty = Math.floor(this.y);

    // 2. Safety Check: Ensure we are inside the map bounds
    if (ty < 0 || ty >= this.maze.length || tx < 0 || tx >= this.maze[0].length) return;

    // 3. Get the tile ID
    let tile = this.maze[ty][tx];
    //0=N, 1=E, 2=S, 3=W
    // 4. Run the Switch Statement
    switch (tile) {
        case -2: // The "Void" or "Pit" tile
            if (this.mapID == 3){
            MusicEngine.play3DSFX('musical2')
            setTimeout(() => {
              this.x = 3.5;this.y = 12.5;this.dir = 0;
              MusicEngine.playSFX('cancel')}, 500);
            }
            else if(this.mapID == 15){
              MusicEngine.play3DSFX('musical2')
            setTimeout(() => {
              this.x = 8.5;this.y = 1.5;this.dir = 2;
              MusicEngine.playSFX('cancel')}, 500);
            }
            break;

       
            
        case -10: // To Map 10 Avalon from Map 9 Stormy Sea
             this.loadMap(10);
             MusicEngine.stop();
             MusicEngine.playSFX('warp');
             MusicEngine.play(this.mapSong[10]);
             break;
             
        case -12: // To Map 9 Stormy Sea from Map 10 Avalon
             this.loadMap(9);
             this.dir = 1;
             this.x = 1.5;
             this.y = 7.5
             MusicEngine.stop();
             MusicEngine.playSFX('warp');
             MusicEngine.play(this.mapSong[9]);
             break;
             
    }
}
  //rendering
  render(dt) {
    const resStep = 1; // 1 = High Qual, 2 = Medium (Retro), 4 = Fast (Blocky)
    this.frame++;

    this.npcs.forEach(npc => npc.update(this.maze, this.x, this.y, this,dt));
    //0=N, 1=E, 2=S, 3=W
    
    // 2. Read Global Table Dimensions (from your resizeCanvas)
    // Safety check: if tL is 0 (first frame), default to 400 to prevent errors
    const viewW = (tL > 0) ? tL : 400;
    const viewH = (tH > 0) ? tH : 400;
    const viewX = tX; // Top-left X
    const viewY = tY; // Top-left Y

    // Reset Z-Buffer for this frame
    this.zBuffer = new Array(viewW).fill(0);

    // 3. Draw Background (Floor/Ceiling)
    // Draw Sky (Top Half)
  ctx.fillStyle = this.skyColor;
ctx.fillRect(viewX, viewY, viewW, viewH / 2);

  // FLOOR: Gradient (Fades from black at horizon to floorColor at bottom)
const floorGrad = ctx.createLinearGradient(0, viewY + viewH / 2, 0, viewY + viewH);
if (this.mapID == 10) {
        // AVALON FOG: The floor fades into the dark violet sky color at the horizon
        floorGrad.addColorStop(0, '#1a1838');       // Horizon: Dark Purple (blends with Sky)
        floorGrad.addColorStop(0.2, '#0d1a0d');     // Mid: Dark Shadow
        floorGrad.addColorStop(1, this.floorColor); // Feet: Wet Earth
    } 
    else if (this.mapID == 14||this.mapID == 22) {
      
        // AVALON FOG: The floor fades into the dark violet sky color at the horizon
        floorGrad.addColorStop(0, '#2e0f05');       // Horizon: Dark Purple (blends with Sky)
        floorGrad.addColorStop(0.13, '#333300');
        floorGrad.addColorStop(1, this.floorColor); // Feet: Wet Earth
    }
    else {
        // STANDARD FOG: Fades to black
        floorGrad.addColorStop(0, '#000000');       
        floorGrad.addColorStop(0.2, '#050505');     
        floorGrad.addColorStop(1, this.floorColor); 
    }
ctx.fillStyle = floorGrad;
ctx.fillRect(viewX, viewY + viewH / 2, viewW, viewH / 2);

    // 4. Raycasting Variables
    const angle = this.dir * Math.PI / 2;
    const dirX = Math.sin(angle);
    const dirY = -Math.cos(angle);
    const planeX = -dirY * 0.66; // Negative dirY
const planeY = dirX * 0.66;  // Positive dirX

    // 5. Cast Rays for Walls
    for (let x = 0; x < viewW; x += resStep) {
      const cameraX = 2 * x / viewW - 1;
      const rayDirX = dirX + planeX * cameraX;
      const rayDirY = dirY + planeY * cameraX;
      
this.castWallRay(rayDirX, rayDirY, x, viewX, viewY, viewW, viewH, resStep);    }
// 1. Ensure weather system matches current table size (tL)
    // tL is your square size calculated in resizeCanvas
    this.weather.resize(tL,tL); 

    // 2. Update Physics
    this.weather.update(dt);

    // 3. Draw
    // Pass tX (Start X) and tY (Start Y) so it draws perfectly inside the square
    this.weather.draw(ctx, tX, tY);
    // --- ONLINE NETWORK: SEND MY POSITION ---
  // Allow multiplayer on any map (or keep if(this.mapID === 0) if you only want it in lobby)
  if (this.frame % 3 === 0) { 
          socket.emit("move", {
            x: this.x,
            y: this.y,
            dir: this.dir,
            mapID: this.mapID,
            status: this.status, // <--- SEND THIS!
            type: playerSprite,
            name: playerName // Your name
        });
    }

    // --- RENDERING: COMBINE NPCs AND PLAYERS ---

    // 1. Create a temporary list of things to draw
    let renderList = this.npcs.filter(npc => npc.visible && !npc.isDead);
    // 2. Add net Players (from the global window.remotePlayers)
        if (window.remotePlayers) {
        for (let id in window.remotePlayers) {
            let p = window.remotePlayers[id];
    let isOpponent = (this.currentSpeaker && this.currentSpeaker.socketId === id);
            // Only draw them if they are on the SAME MAP
            if (p.mapID === this.mapID && p.x !== undefined) {
                
                if (p.status === 'dueling' && !isOpponent) {
                    continue; 
                }

                p.visible = true; 
                renderList.push(p);
            
            }
        }
    }
    // 3. Draw everything
    this.drawCombinedSprites(ctx, viewX, viewY, viewW, viewH, dirX, dirY, planeX, planeY, renderList); // 7. Draw Minimap
    this.drawMinimap(ctx, viewX, viewY, viewW, viewH);
    btnDeck.show(9, 9, 1, 1, 1, 'Deck', 'jrpg_btn', 1, 0);
   
         //drawPortrait(-27,5,5,.25)
    let sfxtimer = Date.now();
    

    if (sfxtimer - lastsfxtime> 550){
      
       if (this.weather.mode == 'storm'||this.weather.mode == 'lightning'||this.weather.mode == 'apocalypse'){
            if (Math.random() > 0.25) {
            MusicEngine.playSFX('lightning')
            }
          }
      lastsfxtime = Date.now();}
     
    
  
   
  }
  castWallRay(rayDirX, rayDirY, stripX, viewX, viewY, viewW, viewH,width = 1) {
    let mapX = this.x | 0;
    let mapY = Math.floor(this.y);
    const deltaDistX = Math.abs(1 / rayDirX);
    const deltaDistY = Math.abs(1 / rayDirY);
    let stepX, stepY, sideDistX, sideDistY;

    if (rayDirX < 0) { stepX = -1; sideDistX = (this.x - mapX) * deltaDistX; }
    else { stepX = 1; sideDistX = (mapX + 1 - this.x) * deltaDistX; }
    if (rayDirY < 0) { stepY = -1; sideDistY = (this.y - mapY) * deltaDistY; }
    else { stepY = 1; sideDistY = (mapY + 1 - this.y) * deltaDistY; }

    let hit = 0, side;
    let wallID = 1;

    while (!hit) {
      if (sideDistX < sideDistY) { sideDistX += deltaDistX; mapX += stepX; side = 0; }
      else { sideDistY += deltaDistY; mapY += stepY; side = 1; }
      if (this.explored[mapY] && this.explored[mapY][mapX] !== undefined) {
          this.explored[mapY][mapX] = 1;
      }
      const tileID = this.maze[mapY][mapX];
      if (tileID > 0) { 
        hit = 1;
        wallID = tileID;
      }
      
      if (this.explored[mapY] && this.explored[mapY][mapX] !== undefined) {
          this.explored[mapY][mapX] = 1;
      }
      
    }

    let perpWallDist;
    if (side === 0) perpWallDist = (mapX - this.x + (1 - stepX) / 2) / rayDirX;
    else perpWallDist = (mapY - this.y + (1 - stepY) / 2) / rayDirY;

    this.zBuffer[stripX] = perpWallDist;

    const lineHeight = viewH / perpWallDist;
    const drawStart = Math.max(0, -lineHeight / 2 + viewH / 2);
    const drawEnd = Math.min(viewH, lineHeight / 2 + viewH / 2);

    // --- COLOR & TEXTURE LOGIC ---
  let colorStr = this.wallColors[wallID] || '#8b4513';
   let { r: baseR, g: baseG, b: baseB } = this.parseColor(colorStr);

    // 1. CALCULATE WHERE WE HIT THE WALL (0.0 to 1.0)
    // This tells us if we hit the left edge, right edge, or center of the block.
    let wallHitX; 
    if (side == 0) wallHitX = this.y + perpWallDist * rayDirY;
    else           wallHitX = this.x + perpWallDist * rayDirX;
    wallHitX -= Math.floor(wallHitX); // Keep only decimal part

    // 2. EFFECT: BRICK BORDER
    // If we hit the very edge of the block (< 0.02 or > 0.98), make it dark.
    // This draws a "border" around every wall tile.
    //let isEdge = 0;//(wallHitX < 0.02 || wallHitX > 0.96);

    // 3. EFFECT: NOISE / GRIT
    // Generate a random grain factor. 
    // We multiply by perpWallDist so noise doesn't "shimmer" too much at a distance.
   let intensity = this.noiseLevels[wallID] !== undefined ? this.noiseLevels[wallID] : 20;

    // Generate noise using that specific intensity
    let noise = (Math.random() - 0.5) * intensity; 
    
    if (perpWallDist > 5) noise = 0; // Still fade it out at distance
    // 4. APPLY LIGHTING (Your Hybrid Math)
    let shade = 150 / (perpWallDist + 0.5);
    if (shade > 255) shade = 255;
    if (side === 1) shade *= 0.7; // Darken sides

    // 5. COMBINE EFFECTS
   // if (isEdge) {
        // If it's an edge, make it almost black (grout line)
    //    shade *= 0.5; 
    //}

    let brightness = shade / 255;
    
    // Apply brightness + add noise
    let r = Math.floor(baseR * brightness + noise);
    let g = Math.floor(baseG * brightness + noise);
    let b = Math.floor(baseB * brightness + noise);

    // Clamp values (ensure 0-255)
    r = Math.max(0, Math.min(255, r));
    g = Math.max(0, Math.min(255, g));
    b = Math.max(0, Math.min(255, b));

    ctx.fillStyle = `rgb(${r},${g},${b})`;
    
    // 1. DRAW THE WALL
ctx.fillStyle = `rgb(${r},${g},${b})`;
ctx.fillRect(viewX + stripX, viewY + drawStart, width + 0.5, drawEnd - drawStart);// 2. --- NEW: FLOOR CASTING ---
// We only draw the floor if there is space below the wall
if (drawEnd < viewH) {
    
    // Calculate the coordinates of the wall's base on the map
    let floorXWall, floorYWall;
    if (side === 0 && rayDirX > 0) { floorXWall = mapX;       floorYWall = mapY + wallHitX; }
    else if (side === 0 && rayDirX < 0) { floorXWall = mapX + 1.0; floorYWall = mapY + wallHitX; }
    else if (side === 1 && rayDirY > 0) { floorXWall = mapX + wallHitX; floorYWall = mapY; }
    else                                { floorXWall = mapX + wallHitX; floorYWall = mapY + 1.0; }

    let distWall = perpWallDist;
    let distPlayer = 0.0;

    // Iterate pixels from bottom of wall to bottom of screen
    for (let y = drawEnd; y < viewH; y++) {
        // Calculate distance to this specific floor pixel
        let currentDist = viewH / (2.0 * y - viewH); 

        let weight = (currentDist - distPlayer) / (distWall - distPlayer);

        let currentFloorX = weight * floorXWall + (1.0 - weight) * this.x;
        let currentFloorY = weight * floorYWall + (1.0 - weight) * this.y;

        // Get the tile at this floor position
        let floorMapX = Math.floor(currentFloorX);
        let floorMapY = Math.floor(currentFloorY);

        // 1. Boundary Check
        if (floorMapX < 0 || floorMapX >= this.maze[0].length || floorMapY < 0 || floorMapY >= this.maze.length) {
            continue; // Skip boundaries
        }

        let tile = this.maze[floorMapY][floorMapX];

        // 2. THE GOLDEN RULE: 
        // If it's a standard floor (0), DON'T DRAW ANYTHING!
        // Let the background gradient show through.
        if (tile === 0) continue; 

        // 3. Only if it is special (like -1), do we pay the cost to draw it
        let color = this.floorColors[tile];
        
        if (color) {
            ctx.fillStyle = color;
          ctx.fillRect(viewX + stripX, viewY + y, width + 0.5, 1);        
        }
    }
}} 
  drawMinimap(ctx, viewX, viewY, viewW, viewH) {
    const size = viewW * 0.2; 
    const padding = 10;
    const cellSize = size / 15;
    
    const startX = viewX + viewW - size - padding;
    const startY = viewY + padding;

    // Background
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(startX, startY, size, size);

    const range = 7;
    
    // --- 1. DRAW TILES ---
    for (let y = -range; y <= range; y++) {
      for (let x = -range; x <= range; x++) {
        const mapX = Math.floor(this.x) + x;
        const mapY = Math.floor(this.y) + y;

        // Boundary Check
        if (mapX >= 0 && mapX < this.maze[0].length && mapY >= 0 && mapY < this.maze.length) {
          
          // --- VISIBILITY CHECK ---
          let isVisible = false;
          
          // A. Check Divine Sense (Distance Check)
          // We calculate raw distance from player to this tile
          const dist = Math.sqrt(x*x + y*y);
          
          if (this.dSense > 0 && dist <= this.dSense) {
             isVisible = true; // Divine Sense reveals it!
          } 
          // B. Normal Line of Sight Check
          else {
             isVisible = this.checkLineOfSight(mapX + 0.5, mapY + 0.5);
          }

          // If not visible, skip drawing
          if (!isVisible) continue;

          // --- DRAWING ---
          const screenX = startX + size / 2 + x * cellSize;
          const screenY = startY + size / 2 + y * cellSize;
          
          // Clip to minimap box
          if (screenX >= startX && screenX < startX + size && screenY >= startY && screenY < startY + size) {
             const tileID = this.maze[mapY][mapX];

             // Case 1: It is a Wall (Odd numbers usually, or based on your isWall logic)
             if (this.isWall(mapX, mapY)) {
                // Get the specific color for this wall ID from your wallColors list
                // Default to Brown if ID is missing
                ctx.fillStyle = this.wallColors[tileID] || '#8b4513'; 
                ctx.fillRect(screenX, screenY, cellSize, cellSize);
             } 
             // Case 2: It is a Floor
             else {
                ctx.fillStyle = 'rgba(200,200,200,0.3)'; // Faint visible floor
                ctx.fillRect(screenX, screenY, cellSize, cellSize);
             }
          }
        }
      }
    }

    // --- 2. DRAW NPCs ---
    this.npcs.forEach(npc => {
      if (!npc.visible) return;
      if (npc.isDead) return;

      const diffX = npc.x - this.x;
      const diffY = npc.y - this.y;
      const dist = Math.sqrt(diffX*diffX + diffY*diffY);

      if(Math.abs(diffX) < range && Math.abs(diffY) < range) {
          
          // --- NPC VISIBILITY CHECK ---
          let canSeeNPC = false;
          
          // 1. Divine Sense: Sees through walls within radius
          if (this.dSense > 0 && dist <= this.dSense) {
              canSeeNPC = true;
          } 
          // 2. Normal Sight: Needs Line of Sight AND must be close enough
          else {
              // CHANGE: Added "&& dist < 10" to prevent seeing across the whole map
              if (dist < 10) { 
                  canSeeNPC = this.checkLineOfSight(npc.x, npc.y);
              }
          }

          if (!canSeeNPC) return;

          const screenX = startX + size/2 + diffX * cellSize;
          const screenY = startY + size/2 + diffY * cellSize;
          
          // Use the NPC's custom color
          ctx.fillStyle = npc.color;
          ctx.beginPath();
          ctx.arc(screenX + cellSize/2, screenY + cellSize/2, cellSize/3, 0, Math.PI*2);
          ctx.fill();
      }
    });

    // Player Arrow
    const playerScreenX = startX + size / 2;
    const playerScreenY = startY + size / 2;
    ctx.save();
    ctx.translate(playerScreenX + cellSize / 2, playerScreenY + cellSize / 2);
    ctx.rotate(this.dir * Math.PI / 2);
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.moveTo(0, -cellSize);
    ctx.lineTo(-cellSize / 2, cellSize / 2);
    ctx.lineTo(cellSize / 2, cellSize / 2);
    ctx.fill();
    ctx.restore();
}
//online and sprite rendering
  drawCombinedSprites(ctx, viewX, viewY, viewW, viewH, dirX, dirY, planeX, planeY, spriteList) {
    spriteList.forEach(npc => {
        npc.dist = ((this.x - npc.x) * (this.x - npc.x) + (this.y - npc.y) * (this.y - npc.y));
    });
    spriteList.sort((a, b) => b.dist - a.dist);

    // 2. Loop through the list
    for (let i = 0; i < spriteList.length; i++) {
        const sprite = spriteList[i]; // Use spriteList instead of this.npcs
        // Transform sprite position to camera space
        const spriteX = sprite.x - this.x;
        const spriteY = sprite.y - this.y;

        const invDet = 1.0 / (planeX * dirY - dirX * planeY);
        const transformX = invDet * (dirY * spriteX - dirX * spriteY);
        const transformY = invDet * (-planeY * spriteX + planeX * spriteY); // Depth

        // --- FIX 1: NEAR PLANE CLIPPING ---
        if (transformY <= 0.2) continue; 

        // --- FIX 3: FAR PLANE CLIPPING (FOG) ---
        // If the sprite is more than 15 tiles away, don't draw it.
        // This prevents seeing tiny dots on the horizon.
        if (transformY > 7) continue;

        // --- NEW: CUSTOM SCALING LOGIC ---
        let scale = 1.0; 
        let vMove = 1.0; // Vertical shift (optional)

        // If it is a Card (Type -27), shrink it!
        if (sprite.type === -27) {
            scale = 0.25; // 40% of standard size
            // Optional: You can make it hover slightly higher/lower by changing vMove
            // vMove = 0.0; 
        }
        

        // Calculate Screen Dimensions with SCALE applied
        const spriteScreenX = Math.floor((viewW / 2) * (1 + transformX / transformY));
        
        // Apply scale here
        const spriteSize = Math.abs(Math.floor(viewH / transformY)) * scale; 

        const yOffset = (sprite.zHeight || 0) * spriteSize;

        // drawStartY calculation:
        // -spriteSize / 2 centers it vertically on the horizon
        // + vMove shifts it up/down
        const drawStartY = Math.floor(-spriteSize / 2 + viewH / 2 + viewY - yOffset + vMove);
        const drawStartX = Math.floor(-spriteSize / 2 + spriteScreenX + viewX);

        if (drawStartX >= viewX + viewW || drawStartX + spriteSize <= viewX) continue;
        
        if (sprite.model) {
            if (spriteScreenX > 0 && spriteScreenX < viewW) {
                if (transformY < this.zBuffer[spriteScreenX]) {
                    const centerX = drawStartX + spriteSize / 2;
                    const centerY = drawStartY + spriteSize / 2;
                    sprite.model.draw(ctx, centerX, centerY, spriteSize * 0.5, 4);
                }
            }
            // Interaction Check for 3D
            if (this.clickInput) {
                if (transformY < 1.0 && 
                    this.clickInput.x >= drawStartX && this.clickInput.x <= drawStartX + spriteSize &&
                    this.clickInput.y >= drawStartY && this.clickInput.y <= drawStartY + spriteSize) 
                {
                    if (sprite.type === 99 ) {
                         //sprite.triggerInteraction(this);
                         this.clickInput = null;
                    }
                }
            }
            continue; 
        }

        // --- 2D RENDER BRANCH ---

        const toPlayerX = this.x - sprite.x;
        const toPlayerY = this.y - sprite.y;
        const dotProd = (sprite.dirX * toPlayerX) + (sprite.dirY * toPlayerY);
        const isBackTurned = dotProd < 0;

        // ONLINE--- INTERACTION CHECK (PLAYERS ONLY) ---
        if (this.clickInput) {
            
            // 1. Check if click is inside the sprite box
            let inBounds = (
                this.clickInput.x >= drawStartX && 
                this.clickInput.x <= drawStartX + spriteSize &&
                this.clickInput.y >= drawStartY && 
                this.clickInput.y <= drawStartY + spriteSize
            );

            if (inBounds) {
                // Debug Log (Press F12 to see this)
                  console.log(`[Click Debug] Type: ${sprite.type} | ID: ${sprite.socketId} | Dist: ${transformY.toFixed(2)}`);
                // 2. Distance Check (Increased to 2.5 so you don't have to be touching)
                if (transformY < 2.5) {
                    
                    // 3. Wall Check (Prevent clicking through walls)
                    const localClickX = Math.floor(this.clickInput.x - viewX);
                    let wallBlock = false;
                    if (localClickX >= 0 && localClickX < viewW) {
                        if (this.zBuffer[localClickX] < transformY) wallBlock = true;
                    }

                    if (!wallBlock) {
                        // 4. PLAYER CHALLENGE LOGIC
                        if (sprite.socketId) {
                          // NEW CHECK: Is the target already busy?
                            if (sprite.status === 'dueling') {
                                console.log("Target is already in a battle.");
                                MessageBox.show(0.5, 8, 1, 9, 2, 'That player is busy fighting!', 'dialogue', 1, 0);
                                this.clickInput = null;
                                continue;
                            }
                            /*
                            console.log(">> SENDING CHALLENGE...");
                      // 1. Sanitize Deck: Convert complex Card objects to simple ID array
                          let mySimpleDeck = Dungeon.deck.map(c => c.index);

                          // 2. Send Challenge + Deck
                          socket.emit("challenge_request", {
                              targetId: sprite.socketId,
                              deck: mySimpleDeck
                          });                            
                          // 2. Set Game State (CRITICAL FIX)
                    this.currentSpeaker = sprite; 
                    this.dCounter = 0; 
                    this.status = 'dueling'; // Mark myself as busy
                    this.isChallenger = true; // <--- MARK AS SENDER
                    startGame = 'dialogue';  // STOP exploring, START talking
                            MessageBox.show(0.5, 8, 1, 9, 2, 'Challenge sent!', 'dialogue', 1, 0);
                            this.clickInput = null; // Consume click
                            continue;*/
                        } else {
                            console.log("-- Ignored: Not a Player[0].");
                        }
                    } else {
                        console.log("-- Ignored: Blocked by wall.");
                    }
                } else {
                    console.log("-- Ignored: Too far away.");
                }
            }
        }

       // --- Z-BUFFER PRE-SCAN ---
       let visibleColumns = 0;
       let hiddenColumns = 0;
       
       const spriteLeftLocal = Math.floor(-spriteSize / 2 + spriteScreenX);
       const spriteRightLocal = spriteLeftLocal + spriteSize;

       const loopStart = Math.max(0, spriteLeftLocal);
       const loopEnd = Math.min(viewW, spriteRightLocal);

       for (let col = loopStart; col < loopEnd; col++) {
           if (transformY < this.zBuffer[col]) {
               visibleColumns++;
           } else {
               hiddenColumns++;
           }
       }

       if (visibleColumns === 0) continue; 

       // --- DRAWING ---
       ctx.save();
       
       // 1. Viewport Clipping
       ctx.beginPath();
       ctx.rect(viewX, viewY, viewW, viewH);
       ctx.clip();

       // 2. Wall Clipping
       if (hiddenColumns > 0) {
           ctx.beginPath();
           for (let x = 0; x < spriteSize; x++) {
               const localCol = Math.floor(-spriteSize / 2 + spriteScreenX) + x;
               if (localCol >= 0 && localCol < viewW) {
                   if (transformY < this.zBuffer[localCol]) {
                       ctx.rect(viewX + localCol, drawStartY, 1, spriteSize);
                   }
               }
           }
           ctx.clip();
       }

       // Set Globals for drawPortrait
       const oldTX = tX; const oldTY = tY; const oldTL = tL; const oldTH = tH;
       tX = drawStartX; tY = drawStartY; tL = spriteSize; tH = spriteSize;

       if (typeof drawPortrait === 'function') {
    if (sprite.type == -27){
         let cardID = sprite.deck[0];
         drawPortrait(-27, 0, 0, 1, cardID); 
    } else {
       // --- SIMPLIFIED LOGIC ---
       // Now everyone (Player or Monster) uses .type
       let imageToDraw = (sprite.type !== undefined) ? sprite.type : 0;
        
       if (!isBackTurned) {
           drawPortrait(imageToDraw, 0, 0, 1);
           

       }
       else if (isBackTurned && imageToDraw != 21.1 && imageToDraw != 33.1) {
           ctx.filter = 'brightness(10%) contrast(90%) sepia(0%) hue-rotate(0deg)'; 
           drawPortrait(imageToDraw, 0, 0, 1);
           ctx.filter = 'none'; 
       }
       if (sprite.name && sprite.name !== "undefined") {
           drawText(2.5, 0, 5, .69, ''+sprite.name, 'green', 1, 'center')
           } 
    }
}

       // Restore Globals
       tX = oldTX; tY = oldTY; tL = oldTL; tH = oldTH;
       ctx.restore(); 
   
       this.clickInput = null;
    }
  }
 ///NPC Interaction rendering
  dialogue() {
    let cardID = 0;
    let alldead = 0;
    if (!this.currentSpeaker) return;
     // --- NEW: PVP DIALOGUE ---
   if (this.currentSpeaker.socketId) {
        
        // Draw the player's face

        // ============================================
        // SCENARIO A: I AM THE CHALLENGER (I clicked)
        // ============================================
       if (this.isChallenger&&this.currentSpeaker.socketId != "NPC_SUNCAT") {
         // Show Message
         MessageBox.show(0.5, 8, 1, 9, 2, 'Challenge Sent. Awaiting response...', 'dialogue', 1, 0);
         
         // Show Cancel Button (Make sure you have a 'btnNo' or similar)
         if(typeof btnNo !== 'undefined') {
             btnNo.show(7.5, 5, 1, 2, 1.5, 'Cancel', 'jrpg_btn', 1, 'pvp_cancel');
         }
         
         // If they clicked the button (handled in btn class), we handle reset
         // You'd need a listener in your btn class for 'pvp_cancel' that emits to server.
         this.dCounter = 0; // Still lock regular clicks
         return;
    }
    else if (this.isChallenger && this.currentSpeaker.socketId === "NPC_SUNCAT")
    {
      MessageBox.show(0.5, 8, 1, 9, 2, 'Challenge Suncat?', 'dialogue', 1, 0);
      // MAKE SURE 'btnYes' and 'btnNo' are defined in your game!
      btnYes.show(0.5, 5, 1, 2, 1.5, 'Yes', 'jrpg_btn', 1, 'emperor');
      btnNo.show(7.5, 5, 1, 2, 1.5, 'No', 'jrpg_btn', 1, 'emperor');
             
    }
        
        // ============================================
        // SCENARIO B: I AM THE RECEIVER (I was clicked)
        // ============================================
        else {
             if (this.dCounter === 0) {
                 MessageBox.show(0.5, 8, 1, 9, 2, 'Player challenges you! Accept?', 'dialogue', 1, 0);
             }
             
             // Choice Menu
             if (this.dCounter === 1) {
                 MessageBox.show(2.5, 0, 1, 5, 2, 'Accept Duel?', 'dialogue', 1, 0);
                 
                 // MAKE SURE 'btnYes' and 'btnNo' are defined in your game!
                 btnYes.show(0.5, 5, 1, 2, 1.5, 'Yes', 'jrpg_btn', 1, 'pvp_accept');
                 btnNo.show(7.5, 5, 1, 2, 1.5, 'No', 'jrpg_btn', 1, 'pvp_deny');
             }
             
             // Handle Exit (For now, just resets)
             if (this.dCounter > 1) {
                 
                 this.dCounter = 1;
                 
             }
        }
        
        return; // STOP here so we don't run NPC logic
    }
    // --- BRANCH A: 3D NPC (e.g., The Fire Elemental or special quest giver) ---
    if (this.currentSpeaker.model) {
        // 1. Calculate Screen Position
        // We center it horizontally, and place it slightly higher up 
        // to leave room for the text box at the bottom.
        const centerX = tX + (tL > 0 ? tL : 400) / 2; 
        const centerY = tY + (tH > 0 ? tH : 400) * 0.4; // 0.4 places it at 40% height
        // 2. Animate the Model
        // A slow, hypnotic spin is usually better for dialogue than a fast battle spin
        this.currentSpeaker.model.rx += 0.02; 
        this.currentSpeaker.model.ry += 0.01;
        // 3. Draw the Model
        // Scale is set to 120 (slightly smaller than battle to fit the frame)
        this.currentSpeaker.model.draw(ctx, centerX, centerY, 120, 4);
    } 
    // --- BRANCH B: 2D Pixel NPC ---
    else {
        // Standard 2D portrait logic
        // --- NEW: CARD PICKUP NOTIFICATION ---
        if (this.currentSpeaker.type === -27) {
        cardID = this.currentSpeaker.deck[0];

        // --- 1. DUPLICATE LOGIC ---
        if (this.currentSpeaker.isDuplicate) {
             if (this.dCounter === 0) {
                // Show the "Already have it" message
                MessageBox.show(0.5, 8, 1, 9, 2, 'You already have this card...', 'dialogue', 1, -27);
                // Still draw the portrait so they know which card it is
                drawPortrait(this.currentSpeaker.type, 2.5, 2.25, .5, cardID);
             }
             // On next click, exit dialogue without doing anything else
             if (this.dCounter >= 1) {
                startGame = 'explore';
                preGame = 'explore';
                this.dCounter = 0;
                this.currentSpeaker.isDuplicate = false; // Reset flag
                this.npcs.forEach(npc => { if (!npc.isDead) npc.visible = true; });
             }
             return; // STOP HERE so we don't run the "You obtained" logic
        }
          //Obtained a new card message (if lost to emperor during the tut battle change message to Emperor joins party)
        if (this.dCounter === 0) {
          let msg = 'You obtained a new Card!'
          if (preGame == 'emploss') { msg = "The Emperor joins your party!"; cardID = 4; }
          MessageBox.show(0.5, 8, 1, 9, 2, msg, 'dialogue', 1, -27);
          drawPortrait(this.currentSpeaker.type, 2.5, 2.25, .5, cardID);
        }//if in emperor battle and player won and received card do additional message for emperor joining party
        if (this.dCounter === 1&&preGame =='emperor battle') {
            MessageBox.show(0.5, 8, 1, 9, 2, 'The Emperor joins your party!', 'dialogue', 1, -27);
            drawPortrait(this.currentSpeaker.type, 2.5, 2.25, .5,4);
          }
          //if emperor message go back to map
          if (this.dCounter === 2&&preGame =='emperor battle') {
              preGame = 'explore';
              startGame = 'explore';
              this.dCounter = 0;
              this.npcs.forEach(npc => {
                  if (!npc.isDead) npc.visible = true;});
                                    Dungeon.saveGame();

          }
          //if normal single card award from pickup and such go back to map
          if (this.dCounter === 1&&preGame !='emperor battle') {
              startGame = 'explore';
              preGame = 'explore'
              this.dCounter = 0;
              this.saveGame();
              /////////////////////////////////////////////////
              //////MAP CHANGES AFTER PICKING UP CARD//////////////
              //SAILBOAT AFTER ICE QUEEN PORTAL TO MAP 9
              if(cardID == 55 ){
                this.spawnPersistentNPC(8, 6, 5.5, 1.5, 99, 'stationary', '#66ccff');//portal to map 9
                this.saveGame();

                this.loadMap(9)  
                MusicEngine.stop();
                MusicEngine.playSFX('warp')
                MusicEngine.play(36)
                
              }
              //Dragon Hoard Spawn Fairy Queen for Tele
              if(cardID == 67 ){
                this.npcs.push(new NPC(13,this.x, this.y+1, 62,'chasing','#00ff00')); // fairy queen
                MusicEngine.stop();
                MusicEngine.play(24)
              }
              //////////////////////////////////////////
              ///////////////////////////////////////////
              this.npcs.forEach(npc => {
                  if (!npc.isDead) npc.visible = true;
              });
          }

        }
        //HIGH PRIESTESS
        if (this.currentSpeaker.type == 2){
          if(this.MainQuest == 0){drawPortrait(this.currentSpeaker.type, .445, .47, .909);}
          if (this.dCounter == 0&&this.MainQuest == 0){MessageBox.show(.5,8,1,9,2,'Welcome. Do you want to learn to play Runestones?','dialogue',1,0)}
          if (this.dCounter == 1&&this.MainQuest == 0){
            MessageBox.show(2.5,0,1,5,2,'Learn to play Runestones?','dialogue',1,0)
            btnYes.show(.5,5,1,2,1.5,'Yes','jrpg_btn',1,'high priestess')
            btnNo.show(7.5,5,1,2,1.5,'No','jrpg_btn',1,'high priestess')
          }
          if (this.dCounter > 1&&this.MainQuest == 0)(this.dCounter = 0)
          if(this.MainQuest == 1){
            if(this.dCounter <3 ){drawPortrait(this.currentSpeaker.type, .445, .47, .909);}

            if (this.dCounter == 0){MessageBox.show(.5,8,1,9,2,'The Magician has gone to confront our captors, but has not returned in some time.','dialogue',1,0)}
            if (this.dCounter == 1){MessageBox.show(.5,8,1,9,2,'I fear for the worst...','dialogue',1,0)}
            if (this.dCounter == 2){MessageBox.show(.5,8,1,9,2,'The portal created by the magician still works, so let us depart.','dialogue',1,0)}
            if (this.dCounter == 3){
            this.deck.push(new Card(2,0))
            MusicEngine.playSFX('heal');

            this.dCounter =4;
        }
        if (this.dCounter == 4){
          MessageBox.show(0.5, 8, 1, 9, 2, 'High Priestess joins your party!', 'dialogue', 1, -27);
            drawPortrait(-27, 2.5, 2.25, .5,2);
         }
          if (this.dCounter == 5){
            startGame = 'explore';  
            this.dCounter = 0; 
            this.killNPC(this.currentSpeaker, true)
            MusicEngine.stop()
            MusicEngine.play(18)
          }

        }
        }
        //EMPRESS
        if (this.currentSpeaker.type == 3){
          if (this.dCounter == 0){
            drawPortrait(this.currentSpeaker.type,-.01, .013, 1);
            MessageBox.show(.5,8,1,9,2,'Hello. Do you like Music? I heard a rumor that Suncat has music out on Spotify...look for the logo of the ginger cat chasing a butterfly.','dialogue',1,this.foe)
          }
          if (this.dCounter == 1){
            this.deck.push(new Card(3,0))
            this.dCounter =2;
            MusicEngine.playSFX('heal');
          }
          if (this.dCounter == 2){
            MessageBox.show(0.5, 8, 1, 9, 2, 'Empress joins your party!', 'dialogue', 1, -27);
            drawPortrait(-27, 2.5, 2.25, .5,3);
          }
          if (this.dCounter == 3){
            startGame = 'explore';  
            this.dCounter = 0; 
            this.killNPC(this.currentSpeaker, true)
          }}
        //EMPEROR
        if (this.currentSpeaker.type == 4){
          drawPortrait(this.currentSpeaker.type, -.01, .013, 1);
          if (this.tutorialFinished == 0&&this.MainQuest ==0){
            if (this.dCounter == 0){MessageBox.show(.5,8,1,9,2,'Hello, lad. Fancy a game of stones? Ah, you dont know how to play? Talk to the lady in blue over there...','dialogue',1,0)}
            if (this.dCounter == 1){startGame = 'explore'; this.y = this.y-1; this.dCounter = 0; }
          }
          if (this.tutorialFinished == 1||this.MainQuest >0){
            if (this.dCounter == 0){MessageBox.show(.5,8,1,9,2,'Well done lad. You finished that tutorial like a champ. Fancy a game of stones?','dialogue',1,0)}
            if (this.dCounter == 1){
              MessageBox.show(2.5,0,1,5,2,'Play a game of Runestones?','dialogue',1,0)
              btnYes.show(.5,5,1,2,1.5,'Yes','jrpg_btn',1,'emperor')
              btnNo.show(7.5,5,1,2,1.5,'No','jrpg_btn',1,'emperor')
            }
          }
        }
        //HEIROPHANT
        if (this.currentSpeaker.type == 5){
          if (this.dCounter == 0){
            drawPortrait(this.currentSpeaker.type, -.01, .013, 1);
            MessageBox.show(.5,8,1,9,2,'If you would like to get to know our creator Suncat...why not visit their instagram? @suncat.meow','dialogue',1,0)

          }
          if (this.dCounter == 1){
            this.deck.push(new Card(5,0))
            this.dCounter =2;
            MusicEngine.playSFX('heal');
          }
          if (this.dCounter == 2){
            MessageBox.show(0.5, 8, 1, 9, 2, 'Heirophant joins your party!', 'dialogue', 1, -27);
            drawPortrait(-27, 2.5, 2.25, .5,5);
          }
          if (this.dCounter == 3){
            startGame = 'explore';  
            this.dCounter = 0; 
            this.killNPC(this.currentSpeaker, true)
          }
        }
        //Magician
        if (this.currentSpeaker.type == 1.1||this.currentSpeaker.type == 1){
          if(this.mapID == 1){
            if(this.dCounter <8){drawPortrait(this.currentSpeaker.type,-.01, .016, 1);}

            if (this.dCounter == 0){MessageBox.show(.5,8,1,9,2,'So you came...','dialogue',1,0)}
            if (this.dCounter == 1){MessageBox.show(.5,8,1,9,2,'What happened with the four kings, you ask?','dialogue',1,0)}
            if (this.dCounter == 2){MessageBox.show(.5,8,1,9,2,'After I entered this floor, I had hoped to confront each of the kings separately...','dialogue',1,0)}
            if (this.dCounter == 3){MessageBox.show(.5,8,1,9,2,'They had no sense of honour...they mocked me and then joined forces against me.','dialogue',1,0)}
            if (this.dCounter == 4){MessageBox.show(.5,8,1,9,2,'I exhausted all my spells and items to just barely get away.','dialogue',1,0)}
            if (this.dCounter == 5){MessageBox.show(.5,8,1,9,2,'Without magical artifacts... I dare not venture forth...','dialogue',1,0)}
            if (this.dCounter == 6){MessageBox.show(.5,8,1,9,2,'The kings have left the dungeon. No doubt to advance their nefarious plot.','dialogue',1,0)}
            if (this.dCounter == 7){MessageBox.show(.5,8,1,9,2,'Come with you? Oh my dear Fool.. ever the optimist... Before we go lets collect my things. We may need them.','dialogue',1,0);}
            if (this.dCounter == 8){
              this.deck.push(new Card(1,0))
              this.dCounter =9;
              MusicEngine.playSFX('heal');
            }
            if (this.dCounter == 9){
              MessageBox.show(0.5, 8, 1, 9, 2, 'Magician joins your party!', 'dialogue', 1, -27);
              drawPortrait(-27, 2.5, 2.25, .5,1);
            }
            if (this.dCounter == 10){
              MusicEngine.stop();
              MusicEngine.play(this.mapSong[this.mapID])
              startGame = 'explore';  
              this.dCounter = 0; 
              this.killNPC(this.currentSpeaker, true)
              this.npcs.forEach(npc => {
              if (!npc.isDead) npc.visible = true;});
            }
          }
          if(this.mapID == 2){
            drawPortrait(this.currentSpeaker.type, -.01, .016, 1);
            if (this.dCounter == 0){MessageBox.show(.5,8,1,9,2,'I have brought us to the forest outside of Tintagel.','dialogue',1,0)}
            if (this.dCounter == 1){MessageBox.show(.5,8,1,9,2,'We must find my master, The Hermit. He will know what to do.','dialogue',1,0)}
            if (this.dCounter == 2){MessageBox.show(.5,8,1,9,2,'He has a magical formation protecting his hermitage...','dialogue',1,0)}
            if (this.dCounter == 3){MessageBox.show(.5,8,1,9,2,'We will have to seek him out without the use of magic','dialogue',1,0)}
            if (this.dCounter == 4){
              startGame = 'explore';  
              this.dCounter = 0; 
              this.killNPC(this.currentSpeaker, true)
              this.npcs.forEach(npc => {if (!npc.isDead) npc.visible = true;});
            }

          }
        }
        //Hermit
        if (this.currentSpeaker.type == 9.1){
          if(this.dCounter <5){drawPortrait(this.currentSpeaker.type, -.01, .013, 1);}
          if (this.dCounter == 0){MessageBox.show(.5,8,1,9,2,'If you came this means the four kings have made their move...','dialogue',1,0)}
          if (this.dCounter == 1){MessageBox.show(.5,8,1,9,2,"The goblins have left their caverns in the North West and made a camp to the South West...",'dialogue',1,0)}
          if (this.dCounter == 2){MessageBox.show(.5,8,1,9,2,"They were driven out by something even more terrible, I imagine...",'dialogue',1,0)}
          if (this.dCounter == 3){MessageBox.show(.5,8,1,9,2,"My apprentice has already gone to investigate. Let us go meet with him and see if we can provide any assistance.",'dialogue',1,0)}
          if (this.dCounter == 4){
            this.deck.push(new Card(9,0))
            this.dCounter =5;
            MusicEngine.playSFX('heal');

          }
          if (this.dCounter == 5){
            MessageBox.show(0.5, 8, 1, 9, 2, 'Hermit joins your party!', 'dialogue', 1, -27);
            drawPortrait(-27, 2.5, 2.25, .5,9);
          }
          if (this.dCounter == 6){
               this.npcs.push(new NPC(13,9.5, 6.5, 60.1,'stationary','#ff0000',[60,6,29,8,28])); // Pixie
              MusicEngine.stop();
              MusicEngine.play(this.mapSong[this.mapID])
              startGame = 'explore';  
              this.dCounter = 0; 
              this.killNPC(this.currentSpeaker, true)
              this.npcs.forEach(npc => {
              if (!npc.isDead) npc.visible = true;});
            }
        }
        //Pixie
        if (this.currentSpeaker.type == 60.1){
          if(this.dCounter <4){drawPortrait(this.currentSpeaker.type,  -.01, .013, 1);}
          if (this.dCounter == 0){MessageBox.show(.5,8,1,9,2,'Heh, letting you escape was part of the plan.','dialogue',1,0)}
          if (this.dCounter == 1){MessageBox.show(.5,8,1,9,2,"And just like that we found The Hermit as well.",'dialogue',1,0)}
          if (this.dCounter == 2){MessageBox.show(.5,8,1,9,2,"Don't worry about your apprentice old man, we'll take care of him!",'dialogue',1,0)}
          if (this.dCounter == 3){
               this.npcs.push(new NPC(14,this.x+1, this.y, 60.1,'stationary','#ff0000',[60,6,50,50,51,59,58])); // Magician

              startGame = 'explore';  
              this.dCounter = 0; 
              this.killNPC(this.currentSpeaker, true)
              this.npcs.forEach(npc => {
              if (!npc.isDead) npc.visible = true;});
            }
        }
        //Apprentice
        if (this.currentSpeaker.type == 32){
          if(this.mapID == 3){
            if(this.dCounter <6){drawPortrait(this.currentSpeaker.type,  -.01, .013, 1);}
            if (this.dCounter == 0){MessageBox.show(.5,8,1,9,2,'Master! Forgive me...I was captured...','dialogue',1,0)}
            if (this.dCounter == 1){MessageBox.show(.5,8,1,9,2,'I refused to reveal your wherabouts so they held me hostage.','dialogue',1,0)}
            if (this.dCounter == 2){MessageBox.show(.5,8,1,9,2,'However, during the interrogation I tricked them into revealing their plans.','dialogue',1,0)}
            if (this.dCounter == 3){MessageBox.show(.5,8,1,9,2,'The Dark Emperor commands the Four Kings! They seek to topple the Empire completely...','dialogue',1,0)}
            if (this.dCounter == 4){MessageBox.show(.5,8,1,9,2,'Also, the Witch Queen is in peril! The King of Wands assaults her realm as we speak!','dialogue',1,0)}
            if (this.dCounter == 5){MessageBox.show(.5,8,1,9,2,'We must go to her aid. I will open the portal...','dialogue',1,0)}
            if (this.dCounter == 6){
                this.deck.push(new Card(32,0))
                this.dCounter =7;
                MusicEngine.playSFX('heal');
              }
            if (this.dCounter == 7){
                MessageBox.show(0.5, 8, 1, 9, 2, 'Apprentice joins your party!', 'dialogue', 1, -27);
                drawPortrait(-27, 2.5, 2.25, .5,32);
              }
            if (this.dCounter == 8){
              startGame = 'explore';  
              this.dCounter = 0; 

              this.spawnPersistentNPC(3, 6, 8.5, 1.5, 99, 'stationary', '#66ccff');      
              this.killNPC(this.currentSpeaker, true)
              this.npcs.forEach(npc => {
              if (!npc.isDead) npc.visible = true;});
            }

          }
          if(this.mapID == 4){
            if(this.dCounter <3){drawPortrait(this.currentSpeaker.type,  -.01, .013, 1);}
          if (this.dCounter == 0){MessageBox.show(.5,8,1,9,2,"The Witch Queen's castle lies up ahead.",'dialogue',1,0)}
          if (this.dCounter == 1){MessageBox.show(.5,8,1,9,2,"The forces of the King of Wands will attempt to stop us. We must not let them.",'dialogue',1,0)}
          if (this.dCounter == 2){MessageBox.show(.5,8,1,9,2,"Beware of mirages. They will lead us astray...",'dialogue',1,0)}

          if (this.dCounter == 3){
              startGame = 'explore';  
              this.dCounter = 0;               
              this.killNPC(this.currentSpeaker, true)
              this.npcs.forEach(npc => {
              if (!npc.isDead) npc.visible = true;});
            }
          }
        }
        //Treasure Snake
        if (this.currentSpeaker.type == 21.1){
          // Draw portrait logic
          if(this.dCounter < 3){drawPortrait(this.currentSpeaker.type,  -.01, .013, 1);}
          if (this.mapID == 3){
          if (this.dCounter == 0){
              MessageBox.show(.5,8,1,9,2,'The goblinsss... they used to bring me offeringssss...did something happen?','dialogue',1,0)
          }
          if (this.dCounter == 1){
              MessageBox.show(.5,8,1,9,2,'Dead ones you say? Vanquish them and I will give you...ssssomething...','dialogue',1,0)
          }

          // --- CHECK 1: Initial Conversation ---
          if (this.dCounter == 2){
            let alldead = 0; // Reset count locally to be safe
            this.npcs.forEach(npc => {
              // Check for Imp(56), Shade(42), Wisp(23)
              // EXCLUDE Index 4 (The Quest Giver Imp) to prevent bugs
              if (npc.type == 56 || npc.type == 42 || npc.type == 23){
                if (!npc.isDead && npc.x!= -999){ 
                    alldead++; 
                }
              }
            });
            
            if (alldead == 0){
              MessageBox.show(.5,8,1,9,2,'You sssslayed them all? Take this....','dialogue',1,0)
            }
            else{
              MessageBox.show(.5,8,1,9,2,'Ssssstuck here you say? I will ssssend you up...','dialogue',1,0)
            }   
          }

          // --- CHECK 2: Reward or Teleport ---
          if(this.dCounter == 3){
            let alldead = 0; // Reset count locally to be safe
            console.log("--- DEBUG: CHECKING ENEMIES ---");
            
            this.npcs.forEach(npc => {
              if (npc.type == 56 || npc.type == 42 || npc.type == 23){
                // EXCLUDE Index 4 again
                if (!npc.isDead && npc.x!= -999){
                    alldead++;
                    // This will tell you exactly who is still alive in the console
                    console.log(`Alive Enemy Found! Type: ${npc.type}, Index: ${npc.index} at (${npc.x}, ${npc.y})`);
                }
              }
            });

            if (alldead == 0){
              // SUCCESS: Give Reward
              this.deck.push(new Card(38,0))
              this.dCounter = 4;
              if (typeof MusicEngine !== 'undefined') MusicEngine.playSFX('heal');
            }
            else{
              // FAILURE: Teleport
              this.dCounter = 0;
              startGame = 'explore';
              // Optional: Comment out loadMap if you want to hunt the missing enemy instead of restarting
              this.loadMap(3); 
              if (typeof MusicEngine !== 'undefined') MusicEngine.playSFX('warp');
            }  
          }

          if (this.dCounter == 4){
              MessageBox.show(0.5, 8, 1, 9, 2, 'You obtained a new Card!', 'dialogue', 1, -27);
              drawPortrait(-27, 2.5, 2.25, .5, 38);
          }
          if (this.dCounter == 5){
              startGame = 'explore';  
              this.dCounter = 0; 
              this.killNPC(this.currentSpeaker, true); // Kill Snake
              // Spawn the Portal to Map 4
              this.spawnPersistentNPC(3, 3, 3.5, 2.5, 99, 'stationary', '#66ccff');                   
              this.npcs.forEach(npc => {
                 if (!npc.isDead) npc.visible = true;
              });
          }
        }
        else if(this.mapID == 15){
          if (this.dCounter == 0){
            drawPortrait(this.currentSpeaker.type, -.01, .013, 1);
            MessageBox.show(.5,8,1,9,2,'You plan to challenge the Dark Emperor?... Take thisssss....','dialogue',1,0)

          }
          if (this.dCounter == 1){
            this.deck.push(new Card(20,0))
            this.dCounter =2;
            MusicEngine.playSFX('heal');
          }
          if (this.dCounter == 2){
            MessageBox.show(0.5, 8, 1, 9, 2, 'You obtained a new card!', 'dialogue', 1, -27);
            drawPortrait(-27, 2.5, 2.25, .5,20);
          }
          if (this.dCounter == 3){
            this.spawnPersistentNPC(15, 3, 8.5, 9.5, 99, 'stationary', '#66ccff');                   
            startGame = 'explore';  
            this.dCounter = 0; 
            this.killNPC(this.currentSpeaker, true)
          }
        }
        }
        //Imp
        if (this.currentSpeaker.type == 56){
          if(this.dCounter <4){drawPortrait(this.currentSpeaker.type,  -.01, .013, 1);}
          if (this.dCounter == 0){MessageBox.show(.5,8,1,9,2,'Kee hee! You finally arrived...','dialogue',1,0)}
          if (this.dCounter == 1){MessageBox.show(.5,8,1,9,2,"Your precious student said you'd come.",'dialogue',1,0)}
          if (this.dCounter == 2){MessageBox.show(.5,8,1,9,2,"You are like the others... doomed!",'dialogue',1,0)}
          if (this.dCounter == 3){
              this.spawnPersistentNPC(3, 5, this.x, this.y-1, 56, 'stationary', '#ff0000',[56,40,26,56,58,56,59,15,26,12,56,68,50]);    
                

              startGame = 'explore';  
              this.dCounter = 0; 
              this.killNPC(this.currentSpeaker, true)
              this.npcs.forEach(npc => {
              if (!npc.isDead) npc.visible = true;});
            }
        }
        //Djinn
        if (this.currentSpeaker.type == 35.1){
          if (this.mapID == 5){
          if(this.dCounter <3){drawPortrait(this.currentSpeaker.type,  -.01, .013, 1);}
          if (this.dCounter == 0){MessageBox.show(.5,8,1,9,2,'You Dare?','dialogue',1,0)}
          if (this.dCounter == 1){MessageBox.show(.5,8,1,9,2,"You're courting death!",'dialogue',1,0)}
          if (this.dCounter == 2){
              this.spawnPersistentNPC(5, 11, this.x, this.y-1, 35.1, 'stationary', '#ff0000',[35,35,35,16,18,26,26,26,26,15,28,44]);    


              startGame = 'explore';  
              this.dCounter = 0; 
              this.killNPC(this.currentSpeaker, true)
              this.npcs.forEach(npc => {
              if (!npc.isDead) npc.visible = true;});
            }
          }
          if (this.mapID == 17){
          if(this.dCounter <3){drawPortrait(this.currentSpeaker.type,  -.01, .013, 1);}
          if (this.dCounter == 0){MessageBox.show(.5,8,1,9,2,'...','dialogue',1,0)}
          if (this.dCounter == 1){
            let fireDeck = [];
                for (let i = 22; i <= 35; i++) {
                    fireDeck.push(i);
                }
              this.spawnPersistentNPC(17, 1, this.x, this.y-1, 35.1, 'chasing', '#ff0000',fireDeck);    


              startGame = 'explore';  
              this.dCounter = 0; 
              this.killNPC(this.currentSpeaker, true)
              this.npcs.forEach(npc => {
              if (!npc.isDead) npc.visible = true;});
            }
          }
        }
        //Witch Queen
        if (this.currentSpeaker.type == 34.1){
          if(this.dCounter <4){drawPortrait(this.currentSpeaker.type, -.01, .013, 1);}
          if (this.dCounter == 0){MessageBox.show(.5,8,1,9,2,"Thank you. Sorry to trouble you with this...",'dialogue',1,0)}
          if (this.dCounter == 1){MessageBox.show(.5,8,1,9,2,"The Ice Queen needs our help.",'dialogue',1,0)}
          if (this.dCounter == 2){MessageBox.show(.5,8,1,9,2,"The King of Cups assails her lonely fortess as we speak.",'dialogue',1,0)}
          if (this.dCounter == 3){MessageBox.show(.5,8,1,9,2,"I'll open a portal to her realm. Let us depart.",'dialogue',1,0)}
          if (this.dCounter == 4){
            this.deck.push(new Card(34,0))
            this.dCounter =5;
            MusicEngine.playSFX('heal');

          }
          if (this.dCounter == 5){
            MessageBox.show(0.5, 8, 1, 9, 2, 'Witch Queen joins your party!', 'dialogue', 1, -27);
            drawPortrait(-27, 2.5, 2.25, .5,34);
          }
          if (this.dCounter == 6){
               this.spawnPersistentNPC(5, 12, 8.5, 1.5, 99, 'stationary', '#66ccff');    

              startGame = 'explore';  
              this.dCounter = 0; 
              this.killNPC(this.currentSpeaker, true)
              this.npcs.forEach(npc => {
              if (!npc.isDead) npc.visible = true;});
              MusicEngine.stop();
              MusicEngine.play(this.mapSong[this.mapID])
            }
        }
        //Ice Queen
        if (this.currentSpeaker.type == 48){
          
          if(this.mapID == 8){
            if(this.dCounter <5){drawPortrait(this.currentSpeaker.type, -.01, .013, 1);}
              if (this.dCounter == 0){MessageBox.show(.5,8,1,9,2,'Thank you for coming...','dialogue',1,0)}
              if (this.dCounter == 1){MessageBox.show(.5,8,1,9,2,'The King of Cups cannot reach me here on the peak, but he controls the sea.','dialogue',1,0)}
              if (this.dCounter == 2){MessageBox.show(.5,8,1,9,2,'I am a prisoner in my own home...','dialogue',1,0)}
              if (this.dCounter == 3){MessageBox.show(.5,8,1,9,2,'You aim to confront him? He may very well drag you to the abyss...','dialogue',1,0)}
              if (this.dCounter == 4){MessageBox.show(.5,8,1,9,2,'...then I will go with you. We can take my ship. Let us go.','dialogue',1,0)}
              if (this.dCounter == 5){
              this.deck.push(new Card(48,0))
              this.dCounter =6;
              MusicEngine.playSFX('heal');

            }
            if (this.dCounter == 6){
              MessageBox.show(0.5, 8, 1, 9, 2, 'Ice Queen joins your party!', 'dialogue', 1, -27);
              drawPortrait(-27, 2.5, 2.25, .5,48);
            }
            if (this.dCounter == 7){
                startGame = 'explore';  
                this.dCounter = 0; 
                //MusicEngine.stop();
                //MusicEngine.play(this.mapSong[this.mapID])
                this.spawnPersistentNPC(8, 5, 5.5, 1.5, -27, 'stationary', '#ffff00',[55]);    
                this.killNPC(this.currentSpeaker, true)
                this.npcs.forEach(npc => {
                if (!npc.isDead) npc.visible = true;});
              }
          }
          if(this.mapID == 9){
              if(this.dCounter <6){drawPortrait(this.currentSpeaker.type, -.01, .013, 1);}
              if (this.dCounter == 0){MessageBox.show(.5,8,1,9,2,'And so the cup spills...','dialogue',1,0)}
              if (this.dCounter == 1){MessageBox.show(.5,8,1,9,2,'Without this ally, the Dark Emperor has lost control of the sea...','dialogue',1,0)}
              if (this.dCounter == 2){MessageBox.show(.5,8,1,9,2,'But the heavens belong to him...','dialogue',1,0)}
              if (this.dCounter == 3){MessageBox.show(.5,8,1,9,2,"The domain of the Fairy Queen lies ahead. ",'dialogue',1,0)}
              if (this.dCounter == 4){MessageBox.show(.5,8,1,9,2,"The King of Swords lays siege to her realm.",'dialogue',1,0)}
              if (this.dCounter == 5){MessageBox.show(.5,8,1,9,2,'Let us offer our assistance.','dialogue',1,0)}
              
            if (this.dCounter == 6){
                startGame = 'explore';  
                this.dCounter = 0; 
                //MusicEngine.stop();
                //MusicEngine.play(this.mapSong[this.mapID])
                this.killNPC(this.currentSpeaker, true)
                this.npcs.forEach(npc => {
                if (!npc.isDead) npc.visible = true;});
              }
          
          }
          
        }
        //Fairy Queen
        if (this.currentSpeaker.type == 62){
          
          if(this.mapID == 11&& this.currentSpeaker.index == 1){
            if(this.dCounter <10){drawPortrait(this.currentSpeaker.type, -.01, .013, 1);}

            //HOW TO CHECK FOR DEATH ON OTHER MAPS if (this.memory['12_1'] && this.memory['12_1'].permanent === true && this.dCounter == 0) {
        
              if (this.dCounter == 0){MessageBox.show(.5,8,1,9,2,'So you came...','dialogue',1,0)}
              if (this.dCounter == 1){MessageBox.show(.5,8,1,9,2,'It is for naught...','dialogue',1,0)}
              if (this.dCounter == 2){MessageBox.show(.5,8,1,9,2,'The King of Swords is too powerful.','dialogue',1,0)}
              if (this.dCounter == 3){MessageBox.show(.5,8,1,9,2,'He demands I surrender my kingdom, or he will burn it all to ash...','dialogue',1,0)}
              if (this.dCounter == 4){MessageBox.show(.5,8,1,9,2,'Strategy? These things fall apart in front of absolute power... ','dialogue',1,0)}
              if (this.dCounter == 5){MessageBox.show(.5,8,1,9,2,'Even my own knights have betrayed me to join his cause...','dialogue',1,0)}
              if (this.dCounter == 6){MessageBox.show(.5,8,1,9,2,'Fight back? I am alone. My people will only suffer.','dialogue',1,0)}
              if (this.dCounter == 7){MessageBox.show(.5,8,1,9,2,'...A ruler must fight for their people? ','dialogue',1,0)}
              if (this.dCounter == 8){MessageBox.show(.5,8,1,9,2,'You...are right. Let us go. His lair lies to the west. ','dialogue',1,0)}
              if (this.dCounter == 9){MessageBox.show(.5,8,1,9,2,'Sigh... if only the Sleeping King would awaken from his slumber... ','dialogue',1,0)}

              if (this.dCounter == 10){
              this.deck.push(new Card(62,0))
              this.dCounter =11;
              MusicEngine.playSFX('heal');

            }
            if (this.dCounter == 11){
              MessageBox.show(0.5, 8, 1, 9, 2, 'Fairy Queen joins your party!', 'dialogue', 1, -27);
              drawPortrait(-27, 2.5, 2.25, .5,62);
            }
            if (this.dCounter == 12){
                startGame = 'explore';  
                this.dCounter = 0; 
                MusicEngine.stop();
                MusicEngine.play(this.mapSong[this.mapID])
                this.killNPC(this.currentSpeaker, true)
                this.npcs.forEach(npc => {
                if (!npc.isDead) npc.visible = true;});
              }
          }
          //Spawns In dragons lair after slaying dragon
          if(this.mapID == 12){ 
            if(this.dCounter <2){drawPortrait(this.currentSpeaker.type, -.01, .013, 1);}
              if (this.dCounter == 0){MessageBox.show(.5,8,1,9,2,'Sigh...thank you...truly.','dialogue',1,0)}
              if (this.dCounter == 1){MessageBox.show(.5,8,1,9,2,"...Come. Let us return to my castle.",'dialogue',1,0)}
              
              
            if (this.dCounter == 2){
                startGame = 'explore';  
                this.dCounter = 0; 
                
                
                this.memory['11_1'] = { permanent: true };

                this.loadMap(11);
                this.spawnPersistentNPC(11, 4, 5.5, 2.5, 62, 'stationary', '#66ccff');    
                MusicEngine.stop();
                MusicEngine.play(this.mapSong[this.mapID])
                
                this.killNPC(this.currentSpeaker, true)
                this.npcs.forEach(npc => {
                if (!npc.isDead) npc.visible = true;});
              }
          }
          if(this.mapID == 11 && this.currentSpeaker.index == 4){
              if(this.dCounter <4){drawPortrait(this.currentSpeaker.type, -.01, .013, 1);}
              
              if (this.dCounter == 0){MessageBox.show(.5,8,1,9,2,"The Dark Emperor has lost his dominion over the skies.",'dialogue',1,0)}
              if (this.dCounter == 1){MessageBox.show(.5,8,1,9,2,'But the Elf Queen calls for aid.','dialogue',1,0)}
              if (this.dCounter == 2){MessageBox.show(.5,8,1,9,2,"The King of Pentacles besieges her realm.",'dialogue',1,0)}
              if (this.dCounter == 3){MessageBox.show(.5,8,1,9,2,"We must help her fend of his attack. I will open a portal. Let us make haste!",'dialogue',1,0)}

              
            if (this.dCounter == 4){
                startGame = 'explore';  
                this.dCounter = 0; 
                MusicEngine.stop();
                MusicEngine.play(this.mapSong[this.mapID])
                this.spawnPersistentNPC(11, 5, 5.5, 1.5, 99, 'stationary', '#66ccff');    

                this.killNPC(this.currentSpeaker, true)
                this.npcs.forEach(npc => {
                if (!npc.isDead) npc.visible = true;});
              }
          
          }
          
        }
        //Dragon
        if (this.currentSpeaker.type == 63.1){
          if (this.mapID == 12){
          if(this.dCounter <2){drawPortrait(this.currentSpeaker.type,  -.01, .013, 1);}
          if (this.dCounter == 0){MessageBox.show(.5,8,1,9,2,'Arrogant fools...','dialogue',1,0)}
          if (this.dCounter == 1){MessageBox.show(.5,8,1,9,2,"You don't know the difference between heaven and earth!",'dialogue',1,0)}
          if (this.dCounter == 2){
              this.spawnPersistentNPC(12, 12, this.x, this.y-1, 63.1, 'stationary', '#ff0000',[39,39,51,59,58,26,26,28,19,63,63,63]);    


              startGame = 'explore';  
              this.dCounter = 0; 
              this.killNPC(this.currentSpeaker, true)
              this.npcs.forEach(npc => {
              if (!npc.isDead) npc.visible = true;});
            }
          }
          if (this.mapID == 19){
          if(this.dCounter <2){drawPortrait(this.currentSpeaker.type,  -.01, .013, 1);}
          if (this.dCounter == 0){MessageBox.show(.5,8,1,9,2,'...','dialogue',1,0)}
          if (this.dCounter == 1){
            let airDeck = [];
                for (let i = 50; i <= 63; i++) {
                    airDeck.push(i);
                }
              this.spawnPersistentNPC(19, 2.5, this.x, this.y-1, 63.1, 'chasing', '#ff0000',airDeck);    
                

              startGame = 'explore';  
              this.dCounter = 0; 
              this.killNPC(this.currentSpeaker, true)
              this.npcs.forEach(npc => {
              if (!npc.isDead) npc.visible = true;});
            }
          }

        }
        //Arthur
        if (this.currentSpeaker.type == 4.1){
          if (this.currentSpeaker.index == 2){
          if(this.dCounter <7){drawPortrait(this.currentSpeaker.type,  -.01, .013, 1);}
          if (this.dCounter == 0){MessageBox.show(.5,8,1,9,2,"Who disturbs this King's slumber?",'dialogue',1,0)}
          if (this.dCounter == 1){MessageBox.show(.5,8,1,9,2,"The realm is in dire need?",'dialogue',1,0)}
          if (this.dCounter == 2){MessageBox.show(.5,8,1,9,2,"It is not yet my appointed time.",'dialogue',1,0)}
          if (this.dCounter == 3){MessageBox.show(.5,8,1,9,2,"...I sense your desire to save the people of this land. ",'dialogue',1,0)}
          if (this.dCounter == 4){MessageBox.show(.5,8,1,9,2,"Lend you my sword?",'dialogue',1,0)}
          if (this.dCounter == 5){MessageBox.show(.5,8,1,9,2,"A King's strength is earned, not given.",'dialogue',1,0)}
          if (this.dCounter == 6){MessageBox.show(.5,8,1,9,2,"Prove your worth to me!",'dialogue',1,0)}

          if (this.dCounter == 7){
              this.spawnPersistentNPC(13, 3, this.x, this.y-1, 4.1, 'stationary', '#00ff00',[50,64,59,51,8,28,85]);    


              startGame = 'explore';  
              this.dCounter = 0; 
              this.killNPC(this.currentSpeaker, true)
              this.npcs.forEach(npc => {
              if (!npc.isDead) npc.visible = true;});
            }
          }
          if (this.currentSpeaker.index == 4){
            if(this.dCounter <2){drawPortrait(this.currentSpeaker.type,  -.01, .013, 1);}
            if (this.dCounter == 0){MessageBox.show(.5,8,1,9,2,"Grammercy! Your heart is true.",'dialogue',1,0)}
            if (this.dCounter == 1){MessageBox.show(.5,8,1,9,2,"Take my sword...and use it to cut through the darkness...",'dialogue',1,0)}
            if (this.dCounter == 2){MessageBox.show(.5,8,1,9,2,"Arthur returns to slumber...",'dialogue',1,0)}

            if (this.dCounter == 3){
              startGame = 'explore';  
              this.dCounter = 0; 
              MusicEngine.stop();
              MusicEngine.play(37)
              this.killNPC(this.currentSpeaker, true)
              this.npcs.forEach(npc => {
              if (!npc.isDead) npc.visible = true;});
            }
          }
        }
        //Giant's Daughter
        if (this.currentSpeaker.type == 77.2){
          if (this.currentSpeaker.index == 6){
          if(this.dCounter <4){drawPortrait(this.currentSpeaker.type,  -.01, .013, 1);}
          if (this.dCounter == 0){MessageBox.show(.5,8,1,9,2,"Thank thee for thy assistance <3",'dialogue',1,0)}
          if (this.dCounter == 1){MessageBox.show(.5,8,1,9,2,"I shall inform my father of thy bravery and selflessness.",'dialogue',1,0)}
          if (this.dCounter == 2){MessageBox.show(.5,8,1,9,2,"...surely he must sorely grieve my absence... sigh, father...",'dialogue',1,0)}
          if (this.dCounter == 3){MessageBox.show(.5,8,1,9,2,"Good be with ye brave hero... <3...",'dialogue',1,0)}


          if (this.dCounter == 4){
              this.spawnPersistentNPC(13, 3, this.x, this.y-1, 4.1, 'stationary', '#00ff00',[50,64,59,51,8,28,85]);    

              this.gd = 1;
              startGame = 'explore';  
              this.dCounter = 0; 
              this.killNPC(this.currentSpeaker, true)
              this.npcs.forEach(npc => {
              if (!npc.isDead) npc.visible = true;});
            }
          }
          if (this.currentSpeaker.index == 10){
            if(this.dCounter <2){drawPortrait(this.currentSpeaker.type,  -.01, .013, 1);}
            if (this.dCounter == 0){MessageBox.show(.5,8,1,9,2,"Grammercy! Your heart is true.",'dialogue',1,0)}
            if (this.dCounter == 1){MessageBox.show(.5,8,1,9,2,"Take my sword...and use it to cut through the darkness...",'dialogue',1,0)}
            if (this.dCounter == 2){MessageBox.show(.5,8,1,9,2,"Arthur returns to slumber...",'dialogue',1,0)}

            if (this.dCounter == 3){
              startGame = 'explore';  
              this.dCounter = 0; 
              MusicEngine.stop();
              MusicEngine.play(37)
              this.killNPC(this.currentSpeaker, true)
              this.npcs.forEach(npc => {
              if (!npc.isDead) npc.visible = true;});
            }
          }
        }
        //Elf Queen
        if (this.currentSpeaker.type == 76){
          if (this.gd < 2){
            if(this.dCounter <5){drawPortrait(this.currentSpeaker.type, -.01, .013, 1);}
              if (this.dCounter == 0){MessageBox.show(.5,8,1,9,2,'So you came...','dialogue',1,0)}
              if (this.dCounter == 1){MessageBox.show(.5,8,1,9,2,'I have heard of your exploits.','dialogue',1,0)}
              if (this.dCounter == 2){MessageBox.show(.5,8,1,9,2,'Do not fear. The King of Pentacles is not here.','dialogue',1,0)}
              if (this.dCounter == 3){MessageBox.show(.5,8,1,9,2,'Did something happen? I wonder...','dialogue',1,0)}

              if (this.gd == 0){
                if (this.dCounter == 4){MessageBox.show(.5,8,1,9,2,'I thought perhaps you...No? Hmm...','dialogue',1,0)}
                if (this.dCounter == 5){this.dCounter =0;startGame = 'explore';  }
              }
              if (this.gd == 1){
                if (this.dCounter == 4){MessageBox.show(.5,8,1,9,2,'Hmm...Oh my!','dialogue',1,0)}
                if (this.dCounter == 5){
                  drawPortrait(77.1, 2, .013, 1);
                  drawPortrait(this.currentSpeaker.type, -2, .013, 1);
                  MessageBox.show(.5,8,1,9,2,'So! This little one dared to seduce my daughter??','dialogue',1,0)
                }
                if (this.dCounter == 6){
                  drawPortrait(77.2, 0, .013, 1);
                  drawPortrait(77.1, 2, .013, 1);
                  drawPortrait(this.currentSpeaker.type, -3, .013, 1);
                  MessageBox.show(.5,8,1,9,2,'Father, no!','dialogue',1,0)
                }
                if (this.dCounter == 7){
                  drawPortrait(77.2, 0, .013, 1);
                  drawPortrait(this.currentSpeaker.type, -3, .013, 1);
                  
                  drawPortrait(77.1, 2, .013, 1);
                  MessageBox.show(.5,8,1,9,2,'King of Pentacles Attacks!','dialogue',1,0)
                }
                if (this.dCounter == 8){
                  this.spawnPersistentNPC(14, 14, Dungeon.x-.5, Dungeon.y-.5, 77.1, 'chasing', '#00ff00',[50,65,59,51,8,28,77]);    
                  this.dCounter = 0;
                  startGame = 'explore'
                  this.gd = 2;
                }
              }
            }
          if (this.gd == 5){
            if(this.dCounter <5){drawPortrait(this.currentSpeaker.type, -.01, .013, 1);}
            if (this.dCounter == 0){MessageBox.show(.5,8,1,9,2,"Hmm...well then. Let us confront the Dark Emperor.",'dialogue',1,0)}
            if (this.dCounter == 1){MessageBox.show(.5,8,1,9,2,"With our combined might he cannot possibly stand against us.",'dialogue',1,0)}
            if (this.dCounter == 2){MessageBox.show(.5,8,1,9,2,"My spies tell me a dark tower has risen...",'dialogue',1,0)}
            if (this.dCounter == 3){MessageBox.show(.5,8,1,9,2,"We shall surely find him there.",'dialogue',1,0)}
            if (this.dCounter == 4){MessageBox.show(.5,8,1,9,2,"I will open a portal to his realm...shall we depart?",'dialogue',1,0)}
            

            if (this.dCounter == 5){
              this.deck.push(new Card(76,0))
              this.dCounter =6;
              MusicEngine.playSFX('heal');

            }
            if (this.dCounter == 6){
              MessageBox.show(0.5, 8, 1, 9, 2, 'Elf Queen joins your party!', 'dialogue', 1, -27);
              drawPortrait(-27, 2.5, 2.25, .5,76);
            }
            if (this.dCounter == 7){
                this.spawnPersistentNPC(14, 16, 17.5, 8.5, 99, 'stationary', '#66ccff');    
                this.gd = 6;
                startGame = 'explore';  
                this.dCounter = 0; 
                this.killNPC(this.currentSpeaker, true)
                this.npcs.forEach(npc => {
                if (!npc.isDead) npc.visible = true;});
                MusicEngine.stop();
                MusicEngine.play(this.mapSong[this.mapID])
            }
        
          }

        }
        //Giant
        if(this.currentSpeaker.type == 77.1){
          if(this.mapID == 14){
          if(this.gd == 2){
            if(this.dCounter <5){drawPortrait(this.currentSpeaker.type, -.01, .013, 1);}
            if (this.dCounter == 0){MessageBox.show(.5,8,1,9,2,'Urgh... I underestimated you...','dialogue',1,0)}
            if (this.dCounter == 1){MessageBox.show(.5,8,1,9,2,'How about it? Will you marry my daughter?','dialogue',1,0)}
            if (this.dCounter == 2){
              MessageBox.show(2.5,0,1,5,2,"Marry the giant's daughter?",'dialogue',1,0)
              btnYes.show(.5,5,1,2,1.5,'Yes','jrpg_btn',1,'giant')
              btnNo.show(7.5,5,1,2,1.5,'No','jrpg_btn',1,'giant')
            }
          }
          if(this.gd == 3){
            if(this.dCounter <4){drawPortrait(this.currentSpeaker.type, -.01, .013, 1);}

            if (this.dCounter == 0){MessageBox.show(.5,8,1,9,2,'Very well... I cannot force you two to part.','dialogue',1,0)}
            if (this.dCounter == 1){MessageBox.show(.5,8,1,9,2,'Nevertheless, my daughter has you in her heart.','dialogue',1,0)}
            if (this.dCounter == 2){MessageBox.show(.5,8,1,9,2,'I will not side with the Dark Emperor.','dialogue',1,0)}
            if (this.dCounter == 3){MessageBox.show(.5,8,1,9,2,'I shall aid you, lest my daughter become a widow before she marries.','dialogue',1,0)}
            if (this.dCounter == 4){
            this.deck.push(new Card(77,0))
            this.dCounter =5;
            MusicEngine.playSFX('heal');
          }
          if (this.dCounter == 5){
            MessageBox.show(0.5, 8, 1, 9, 2, 'Giant joins your party!', 'dialogue', 1, -27);
            drawPortrait(-27, 2.5, 2.25, .5,77);
          }

          if (this.dCounter == 6){
            this.deck.push(new Card(73,0))
            this.dCounter =7;
            MusicEngine.playSFX('heal');
          }
          if (this.dCounter == 7){
            MessageBox.show(0.5, 8, 1, 9, 2, 'You obtained a new card!', 'dialogue', 1, -27);
            drawPortrait(-27, 2.5, 2.25, .5,73);
          }
          if (this.dCounter == 8){
                          drawPortrait(77.2, -.01, .013, 1);

              MessageBox.show(.5,8,1,9,2,'Take this, my love. May it protect you in the coming battle...<3','dialogue',1,0)

            }
            if (this.dCounter == 9){
            this.deck.push(new Card(72,0))
            this.dCounter =10;
            MusicEngine.playSFX('heal');
          }
          if (this.dCounter == 10){
            MessageBox.show(0.5, 8, 1, 9, 2, 'You obtained a new card!', 'dialogue', 1, -27);
            drawPortrait(-27, 2.5, 2.25, .5,72);
          }
            
            if (this.dCounter == 11){
              startGame = 'explore';  
              this.dCounter = 0; 
              this.gd=5;
              this.killNPC(this.currentSpeaker, true)
              this.npcs.forEach(npc => {
              if (!npc.isDead) npc.visible = true;});
            }
          }
          if(this.gd == 4){
            if(this.dCounter <4){drawPortrait(this.currentSpeaker.type, -.01, .013, 1);}

            if (this.dCounter == 0){MessageBox.show(.5,8,1,9,2,'Very well... I cannot force you.','dialogue',1,0)}
            if (this.dCounter == 1){MessageBox.show(.5,8,1,9,2,'Nevertheless, my daughter has you in her heart.','dialogue',1,0)}
            if (this.dCounter == 2){MessageBox.show(.5,8,1,9,2,'I will not side with the Dark Emperor.','dialogue',1,0)}
            if (this.dCounter == 3){MessageBox.show(.5,8,1,9,2,'I leave you in peace. Come daughter.','dialogue',1,0)}
            if (this.dCounter == 4){
              drawPortrait(77.2, -.01, .013, 1);
              MessageBox.show(.5,8,1,9,2,'I will never forget thee.','dialogue',1,0)

            }
            if (this.dCounter == 5){
              startGame = 'explore';  
              this.dCounter = 0; 
              this.gd = 5;
              this.killNPC(this.currentSpeaker, true)
              this.npcs.forEach(npc => {
              if (!npc.isDead) npc.visible = true;});
            }
        }
      }
      if(this.mapID == 20){
        if(this.dCounter <2){drawPortrait(this.currentSpeaker.type,  -.01, .013, 1);}
          if (this.dCounter == 0){MessageBox.show(.5,8,1,9,2,'...','dialogue',1,0)}
          if (this.dCounter == 1){
            let earthDeck = [];
                for (let i = 64; i <= 77; i++) {
                    earthDeck.push(i);
                }
              this.spawnPersistentNPC(20, 1, this.x, this.y-1, 77.1, 'chasing', '#ff0000',earthDeck);    


              startGame = 'explore';  
              this.dCounter = 0; 
              this.killNPC(this.currentSpeaker, true)
              this.npcs.forEach(npc => {
              if (!npc.isDead) npc.visible = true;});
            }
      }
        }
       //Gnomes
        if(this.currentSpeaker.type == 75.1){
          //villlager S cultivator clue
          if(this.dCounter <1){drawPortrait(this.currentSpeaker.type,  -.01, .013, 1);}
          if (this.currentSpeaker.index == 10){
          if (this.dCounter == 0){MessageBox.show(.5,8,1,9,2,"They say an immortal has entered seculsion somewhere in this forest.",'dialogue',1,0)}
          if (this.dCounter == 1){
                startGame = 'explore';  
                this.dCounter = 0; 
            }
            

          }
          //villager N story hint noise nearby gd tried to steal armor but got caught by gargoyle guards
          if (this.currentSpeaker.index == 11){
            if (this.dCounter == 0){MessageBox.show(.5,8,1,9,2,"I heard yelling nearby. I think someone tried to rob the armory.",'dialogue',1,0)}
          if (this.dCounter == 1){
                startGame = 'explore';  
                this.dCounter = 0; 
            }
          }
          //smith clue about armor  card existence
          if (this.currentSpeaker.index == 12){
              if (this.dCounter == 0){MessageBox.show(.5,8,1,9,2, "Feel free to use my forge anytime.",'dialogue',1,0)}
          if (this.dCounter == 1){
                startGame = 'explore';  
                this.dCounter = 0; 
            }
          }
        }
        //cultivator
        if(this.currentSpeaker.type == 70.1){
          //HEIROPHANT
        
          if (this.dCounter == 0){
            drawPortrait(this.currentSpeaker.type, -.01, .013, 1);
            MessageBox.show(.5,8,1,9,2,'The glowing man smiles bashfully.','dialogue',1,0)

          }
          if (this.dCounter == 1){
            this.deck.push(new Card(70,0))
            this.dCounter =2;
            MusicEngine.playSFX('heal');
          }
          if (this.dCounter == 2){
            MessageBox.show(0.5, 8, 1, 9, 2, 'You obtained a new card!', 'dialogue', 1, -27);
            drawPortrait(-27, 2.5, 2.25, .5,70);
          }
          if (this.dCounter == 3){
            startGame = 'explore';  
            this.dCounter = 0; 
            this.killNPC(this.currentSpeaker, true)
          }
        
        }
        //The Fool/Dark Emperor
        if (this.currentSpeaker.type == 0) {

            if (this.dCounter == 0) {
                drawPortrait(this.currentSpeaker.type, -.01, .013, 1);
                MessageBox.show(.5, 8, 1, 9, 2, "Um, so actually...There is no Dark Emperor.", 'dialogue', 1, 0)
            }
            if (this.dCounter == 1) {
                drawPortrait(this.currentSpeaker.type, -.01, .013, 1);
                MessageBox.show(.5, 8, 1, 9, 2, "It was me all along!", 'dialogue', 1, 0)
            }
            if (this.dCounter == 2) {
                drawPortrait(this.currentSpeaker.type, -.01, .013, 1);
                MessageBox.show(.5, 8, 1, 9, 2, "I offered each of the Kings what they most desired.", 'dialogue', 1, 0)
            }
            if (this.dCounter == 3) {
                drawPortrait(this.currentSpeaker.type, -.01, .013, 1);
                MessageBox.show(.5, 8, 1, 9, 2, "They turned so easily.", 'dialogue', 1, 0)
            }
            if (this.dCounter == 4) {
                drawPortrait(this.currentSpeaker.type, -.01, .013, 1);
                MessageBox.show(.5, 8, 1, 9, 2, "But wow, those Kings sure had a lot of cards!", 'dialogue', 1, 0)
            }
            if (this.dCounter == 5) {
                drawPortrait(this.currentSpeaker.type, -.01, .013, 1);
                MessageBox.show(.5, 8, 1, 9, 2, "I wonder...", 'dialogue', 1, 0)
            }
            if (this.dCounter == 6) {
                drawPortrait(this.currentSpeaker.type, -.01, .013, 1);
                MessageBox.show(.5, 8, 1, 9, 2, "Who's stronger, you or me?", 'dialogue', 1, 0)
            }
            
            // --- STEP 1: REMOVE FOOL CARD ---
            if (this.dCounter == 7) {
                // Find the specific card object in the deck array where index is 0
                const foolIndex = this.deck.findIndex(c => c.index === 0);
                
                // If found, remove 1 item at that position
                if (foolIndex > -1) {
                    this.deck.splice(foolIndex, 1);
                }

                this.dCounter = 8;
                MusicEngine.playSFX('heal');
            }

            if (this.dCounter == 8) {
                MessageBox.show(0.5, 8, 1, 9, 2, 'Fool leaves your party!', 'dialogue', 1, -27);
                drawPortrait(-27, 2.5, 2.25, .5, 0);
            }

            // --- STEP 2: SPAWN BOSS WITH DECK 0-77 ---
            if (this.dCounter == 9) {
                // Create an array containing numbers 0 through 77
                let bossDeck = [];
                for (let i = 0; i <= 77; i++) {
                    bossDeck.push(i);
                }

                // Pass bossDeck as the last argument
                this.spawnPersistentNPC(21, 1, this.x, this.y - 1, 0, 'chasing', '#ff0000', bossDeck);

                startGame = 'explore';
                this.dCounter = 0;
                this.killNPC(this.currentSpeaker, true)
                this.npcs.forEach(npc => {
                    if (!npc.isDead) npc.visible = true;
                });
            }
        }
      }//end 2D dialogue

    // --- DRAW TEXT BOX (Optional Overlay) ---
    // If you haven't drawn your UI elsewhere, you can force a text box here
    // to ensure the text is readable over the 3D model.
    /*
    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
    ctx.fillRect(tX, tY + (tH * 0.7), tL, tH * 0.3);
    ctx.fillStyle = 'white';
    ctx.font = '20px monospace';
    ctx.fillText("Greetings, traveler...", tX + 20, tY + (tH * 0.8));
    */
  }
  tutorial(dt){
    let tick = 30 * dt
    const SPEED_Y = 6 * dt; 
    const SPEED_Z = 3 * dt; 
    //draw padding
	        ctx.fillStyle = "rgba(39,39,39,1)";
	        ctx.fillRect(0,0,wX,wY);
	        //draw table
	        ctx.fillStyle = "rgba(0,6,13,1)";
	        ctx.fillRect(tX,tY,tL,tH);
          this.card[0].place(3.875,0,1)
          if (this.option != 6){
          this.card[1].place(3.875,6.5,1)}
          sRune.refresh(dt);
        cRune.refresh(dt);
        iRune.refresh(dt);
        aRune.refresh(dt);
        
    switch(this.option){
      case 0://intro to runestones quick, start by learning how to attack
        if (this.dCounter == 0){MessageBox.show(.5,8,1,9,2,'Let us begin.','dialogue',1,0)}
        if (this.dCounter == 1){MessageBox.show(.5,8,1,9,2,'To play Runestones, both players must draw from their deck of cards until they get a monster card, easily identifiable by its yellow color.','dialogue',1,0)}
        if (this.dCounter == 2){MessageBox.show(.5,8,1,9,2,'Aside from monster cards, Runestone decks also contain item cards(blue) and spell cards (purple)','dialogue',1,0)}
        if (this.dCounter == 3){MessageBox.show(.5,8,1,9,2,'Then both players must decide on an action based on their available cards...','dialogue',1,0)}
        if (this.dCounter == 4){MessageBox.show(.5,8,1,9,2,'Since only us Monsters occupy the field, we will start with the most basic action - Attack','dialogue',1,0)}
        if (this.dCounter == 5){MessageBox.show(.5,8,1,9,2,'Click on your card and select the attack option','dialogue',1,0)}
        if (this.dCounter == 6){this.option = 1;this.dCounter = 0;}
        break;
      case 1://waiting for player to click monster
        MessageBox.show(4.85,6,1,9,2,'','indicator',1,0)
        break;
      case 2://Prompt for attack click
        drawPortrait(-15,mX*.99,5.68,.066);//attack icon
        drawText(mX-.15,5.39,1.13,1,'Attack','white',.75);
        if (this.dCounter <= 1){MessageBox.show(.5,8,1,9,2,'Now click the Attack button to begin the round','dialogue',1,0)}
        if (this.dCounter == 2){this.dCounter = 0;this.option = 3;}
      break;
      case 3://waiting for player to Click the attack button
          drawPortrait(-15,mX*.99,5.68,.066);//attack icon
          drawText(mX-.15,5.39,1.13,1,'Attack','white',.75);
          
          MessageBox.show(mX,4.89,1,9,2,'','indicator',1,0)
          
          break;
      case 4://AGI check
          drawPortrait(-14,9,9,.1);//draw hourglass
          drawPortrait(-14,0,9,.1);//draw hourglass
          drawPortrait(-14,0,0,.1);//draw hourglass
          drawPortrait(-14,9,0,.1);//draw hourglass
          if(this.at <31){this.at = this.at+tick;} //animation timer tick
          if (this.at > 31 && this.at < 36){this.at = 31}
          //step 1. up and closer like flipping coin ay = animation y and az = animation z. 
          if (this.ay < 3 && this.at <=30){this.ay = this.ay+SPEED_Y;this.az = this.az + SPEED_Z;}
          //step2.Dice Falls
          if (this.ay >=3 && this.az !=1 && this.at<=30){this.az = this.az -SPEED_Z;}
          //step 4.Dice Stops
          if (this.ay >=3 && this.az ==1 && this.at<=30){
            Player[0].setDice(8,8,6,1,.001,dt)
            drawText(7.7,5.6,1,1,''+rnd(1,8),'white',1);
            Player[1].flip();
            Player[1].setDice(8,8,6,1,.001,dt)
            drawText(7.7,5.6,1,1,''+rnd(1,8),'white',1);
            Player[1].flip();
          }
          //step 3.Dice Animate
          else{if (this.at < 30){
              Player[0].setDice(8,8,9-this.ay,this.az,99,dt)
              Player[1].flip();
              Player[1].setDice(8,8,9-this.ay,this.az,99,dt)
              Player[1].flip();
            }
          }
          if (this.at > 30){//show result of roll and announce turns
            //DICE STOP
            
            Player[0].setDice(8,8,6,1,.001,dt);
            if (this.reroll == 0){drawText(7.7,5.6,1,1,''+8,'white',1);}else{drawText(7.7,5.6,1,1,''+6,'white',1);} 
            Player[1].flip();
            Player[1].setDice(8,8,6,1,.001,dt)
            if (this.reroll == 0){drawText(7.7,5.6,1,1,''+8,'white',1);}else{drawText(7.7,5.6,1,1,''+3,'white',1);} 
            Player[1].flip();  
            
            if ( this.at==31){
              //drawText(2.15,4.75,6,1,"Tap Screen To Continue",`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)})`,1);
              if (this.reroll == 0){
                MessageBox.show(.5,6,1.5,2,1,'Tie - Roll Again!','jrpg',1,0)
                Player[1].flip();  
                MessageBox.show(.5,6,1.5,2,.9,'Tie - Roll Again!','jrpg',1,0)
                Player[1].flip();  
              }
              else{
                MessageBox.show(.5,6,1.5,2,1,'First!','jrpg',1,0)
                Player[1].flip();  
                MessageBox.show(.5,6,1.5,2,.9,'Second!','jrpg',1,0)
                Player[1].flip();
              }
            }
            if (this.at >= 36&& this.reroll ==1){
              MessageBox.show(.5,6,1.5,2,1,'First!','jrpg',1,0)
                Player[1].flip();  
                MessageBox.show(.5,6,1.5,2,.9,'Second!','jrpg',1,0)
                Player[1].flip();
            }
            if (this.at == 36){
              if (this.reroll == 0){this.at = 0; this.ay = 0; this.az = 0;this.reroll = 1;} 
              else{MessageBox.show(.5,8,1,9,2,'Well Done...','dialogue',1,0)}
            }
            if (this.at==37){MessageBox.show(.5,8,1,9,2,'You move quickly.','dialogue',1,0)}
            if (this.at==38){MessageBox.show(.5,8,1,9,2,'And because your AGI roll landed higher than mine, you get to make the first move.','dialogue',1,0)}
            if (this.at==39){MessageBox.show(.5,8,1,9,2,'Let us move on. You will Attack by rolling STR and I will Defend by rolling CON ...','dialogue',1,0);
              this.option = 5;
              this.at = 0;this.ay = 0;this.az = 0;
              this.reroll = 0;
            }

            }//end show result of roll and announce turns
          break;
      case 5://death by combat
          if (this.reroll == 0){
            drawPortrait(-11,9,9,.1);//draw hourglass
          drawPortrait(-11,0,9,.1);//draw hourglass
          drawPortrait(-13,0,0,.1);//draw hourglass
          drawPortrait(-13,9,0,.1);//draw hourglass
          }
          else{
            drawPortrait(-11,0,0,.1);//draw hourglass
          drawPortrait(-11,9,0,.1);//draw hourglass
          drawPortrait(-13,9,9,.1);//draw hourglass
          drawPortrait(-13,0,9,.1);//draw hourglass
          }
          if(this.at <69){this.at = this.at+tick;} //animation timer tick
          if (this.at >= 69 && this.at < 73){this.at = 69}
          //step 1. up and closer like flipping coin ay = animation y and az = animation z. 
          if (this.ay < 3 && this.at <=30){this.ay = this.ay+SPEED_Y;this.az = this.az + SPEED_Z;}
          //step2.Dice Falls
          if (this.ay >=3 && this.az !=1 && this.at<=30){this.az = this.az -SPEED_Z;}
          //step 4.Dice Stops
          if (this.ay >=3 && this.az ==1 && this.at<=30){
            Player[0].setDice(4,8,6,1,.001,dt)
            drawText(7.7,5.6,1,1,''+rnd(1,4),'white',1);
            Player[1].flip();
            Player[1].setDice(4,8,6,1,.001,dt)
            drawText(7.7,5.6,1,1,''+rnd(1,4),'white',1);
            Player[1].flip();
          }
          //step 3.Dice Animate
          else{if (this.at < 30){
            this.mc = 1;
              Player[0].setDice(4,8,9-this.ay,this.az,99,dt)
              Player[1].flip();
              Player[1].setDice(4,8,9-this.ay,this.az,99,dt)
              Player[1].flip();
              if(this.reroll == 0){
                MessageBox.show(.5,6,1.5,2,1,'Fool attacks!','jrpg',1,0)
                drawPortrait(-20,4.5-this.at*.005,7-(this.at*.04),.1+this.at*.001);
                Player[1].flip();
                drawPortrait(-16,4.5-this.at*.005,7-(this.at*.03),.1+this.at*.001);
                Player[1].flip();
              }
              else{
                MessageBox.show(.5,6,1.5,2,1,'High Priestess attacks!','jrpg',1,0)
                Player[1].flip();
                drawPortrait(-20,4.5-this.at*.005,7-(this.at*.05),.1+this.at*.001);
                Player[1].flip();
                drawPortrait(-16,4.5-this.at*.005,7-(this.at*.03),.1+this.at*.001);
              }
              
            }
          }
          if (this.at > 30){//show result of roll and announce turns
            //DICE STOP
           
            Player[0].setDice(4,8,6,1,.001,dt);
            if (this.reroll == 0){drawText(7.7,5.6,1,1,''+3,'white',1);}else{drawText(7.7,5.6,1,1,''+1,'white',1);}
            Player[1].flip();
            Player[1].setDice(4,8,6,1,.001,dt)
            if (this.reroll == 0){drawText(7.7,5.6,1,1,''+3,'white',1);}else{drawText(7.7,5.6,1,1,''+4,'white',1);}
            Player[1].flip();  
            
            if ( this.at>31){
              //drawText(2.15,4.75,6,1,"Tap Screen To Continue",`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)})`,1);
              if (this.reroll == 0){
                MessageBox.show(.5,6,1.5,2,1,'High Priestess resists the attack!','jrpg',1,0)
                if (this.at <69){
                  drawPortrait(-20,4.5-this.at*.005,7-(this.at*.05),.1+this.at*.001);
                  Player[1].flip();
                  drawPortrait(-16,4.5-this.at*.005,7-(this.at*.03),.1+this.at*.001);
                  Player[1].flip();
                }
              }  
              else{
                
                
                if(this.mc == 1){MusicEngine.playSFX('death');MusicEngine.stop();MusicEngine.play(21); this.mc = 0;}
                MessageBox.show(.5,6,1.5,2,1,'Fool is slain!','jrpg',1,0)
                drawShape('rec',0,0,1,3.875,6.45,2.25,3.55,0,0,0,0,`rgba(0,0,0,${(.3+this.at*.01)})`,1);
                
               
                
                if (this.at <69){
                  
                  drawPortrait(3.2,4.5-this.at*.001,7,.1+this.at*.001);
                    Player[1].flip();
                    drawPortrait(-20,4.5-this.at*.005,7-(this.at*.05),.1+this.at*.001);
                    Player[1].flip();
          
                }
              }
            }
              
              
            if (this.at == 69){
              if (this.reroll == 0){
              MessageBox.show(.5,8,1,9,2,'Heh, I guess I got lucky...Did I sense a hint of killing intent there?','dialogue',1,0)}
              else{
                MessageBox.show(.5,8,1,9,2,'...','dialogue',1,0)}
            }
            if (this.at==76){
               if (this.reroll == 0){
              MessageBox.show(.5,8,1,9,2,'No matter. Since I survived your attack you must now face my counterattack.','dialogue',1,0)
            }
              else{MessageBox.show(.5,8,1,9,2,'I should bring him back...','dialogue',1,0)}
            }
            if (this.at==77){
              if (this.reroll == 0){
                MessageBox.show(.5,8,1,9,2,'You will roll CON to Defend and I will roll STR to Attack. En Garde!','dialogue',1,0)
              }
              else{MessageBox.show(.5,8,1,9,2,'I guess...','dialogue',1,0)}
            }
            if (this.at==78){
              if (this.reroll == 0){
              this.at = 0;this.ay = 0;this.az = 0; this.reroll = 1;}
              else{this.at = 0;this.ay = 0;this.az = 0;this.option = 6;this.reroll = 0;MusicEngine.stop();MusicEngine.play(8)}
            }

            }//end show result of roll and announce turns
      break;
      case 6://drawing cards and taking runestones
           if(this.at <99&& this.at > -1){this.at = this.at+tick;} //animation timer tick
             if (this.dCounter > 4){drawText(4.6, .93, .4, .3, '+1', 'green', 1);}
           if (this.at < 39&& this.at > 1){this.card[2].place(10-this.at*.23,6.5,1)}
           
           if (this.at >= 39 && this.at < 69){
            this.card[2].place(.875,6.5,1)
            this.card[3].place(10-(this.at-39)*.3,6.5,1)
           }
           if (this.at >= 69&& this.at < 99){
            this.card[2].place(.875,6.5,1)
            this.card[3].place(.875,6.5,1)
            this.card[1].place(10-(this.at-69)*.2,6.5,1)
           }
           if (this.at>99){
            this.card[1].place(3.875,6.5,1)
            this.card[2].place(.875,6.5,1)
            this.card[3].place(.875,6.5,1)
            this.at = -1;
            this.dCounter = 0;
           }
           if (this.at == -1){
            this.card[1].place(3.875,6.5,1)
            this.card[2].place(.875,6.5,1)
            this.card[3].place(.875,6.5,1)
            if (this.dCounter == 0){MessageBox.show(.5,8,1,9,2,'Ahem...to continue our lesson...','dialogue',1,0)}
            if (this.dCounter == 1){MessageBox.show(.5,8,1,9,2,'If you lose a monster, you must draw from your deck until you get a new monster','dialogue',1,0)}
            if (this.dCounter == 2){MessageBox.show(.5,8,1,9,2,'This is the only way to get item cards and spell cards in your hand without using a card like Treasure Chest.','dialogue',1,0)}
            if (this.dCounter == 3){
              MessageBox.show(3.85,4.25,1,9,2,'','indicator',1,0)
              MessageBox.show(1.85,4.25,1,9,2,'','indicator',1,0)
              MessageBox.show(5.85,4.25,1,9,2,'','indicator',1,0)
              MessageBox.show(7.85,4.25,1,9,2,'','indicator',1,0)
              MessageBox.show(.5,8,1,9,2,'As the winner of this round... I have the right to take a runestone from the center of the field, or if none on the field remain, i may take it from the opponent','dialogue',1,0);}
            if(this.dCounter ==4){
              MessageBox.show(.5,8,1,9,2,'To win the game you must seize all four runestones... or make your opponent run out of monsters.','dialogue',1,0)
            }
            if (this.dCounter == 5){
               iRune.changeOwner('tutorial')
              MessageBox.show(.5,8,1,9,2,'Finally, seizing a Runestone gives a +1 bonus to its corresponding Stat. ','dialogue',1,0);
            }
            if (this.dCounter == 6){MessageBox.show(.5,8,1,9,2,'STR for Attack. CON for Defend. INT for spells. AGI gives the initiative which paired with Items and spells, can turn the tide of battle!','dialogue',1,0);}
            if (this.dCounter == 7){MessageBox.show(.5,8,1,9,2,'Lastly, the final invisible Stat which determines everything. Luck!','dialogue',1,0)}
           
            if (this.dCounter == 8){MessageBox.show(.5,8,1,9,2,'Now then, onto the final topic of Spells (purple cards) and Items (blue cards)','dialogue',1,0)}
            if (this.dCounter == 9){this.option = 7; this.at = 0; this.dCounter = 0;}
          }
           
      break;
      case 7://Using cards in hand
      
        drawText(4.6, .93, .4, .3, '+1', 'green', 1);
      
        if(this.dCounter < 2){
          MessageBox.show(halX-.15,arY-.35,1,9,2,'','indicator',1,0)
          MessageBox.show(harX+.4,arY-.35,1,9,2,'','indicator',1,0)
          drawText(1.5, 5.75, 1, 1, '1/2', 'white', 1);
          this.card[2].place(.875,6.5,1)
          this.card[3].place(.875,6.5,1)
          drawPortrait(-1,halX-.5,arY,.1);//left
          drawPortrait(-2,harX,arY,.1);//right
        }

        if (this.dCounter == 0){MessageBox.show(.5,8,1,9,2,'I see you have a Strength spell... What else do you have there?. Click the arrows to cycle through your hand.','dialogue',1,0)}

        if (this.dCounter == 2){
          drawText(1.5, 5.75, 1, 1, '2/2', 'white', 1);
          this.card[2].place(.875,6.5,1)
          drawPortrait(-1,halX-.5,arY,.1);//left
          drawPortrait(-2,harX,arY,.1);//right
          MessageBox.show(.5,8,1,9,2,'*blush* the Lovers eh? ahem... I mean, go ahead and select the card','dialogue',1,0)
        }
        if (this.dCounter == 3){
          //drawText(1.5, 5.75, 1, 1, ''+ this.dCounter, 'white', 1);
          this.card[2].place(.875,6.5,1)
          drawPortrait(-1,halX-.5,arY,.1);//left
          drawPortrait(-2,harX,arY,.1);//right
          MessageBox.show(hX+.95,cY - .4,1,9,2,'','indicator',1,0)
        }
        if (this.dCounter == 4){
          drawText(1.5, 5.75, 1, 1, '2/2', 'white', 1);
          this.card[2].place(.875,6.5,1)
          drawPortrait(-1,halX-.5,arY,.1);//left
          drawPortrait(-2,harX,arY,.1);//right
          drawPortrait(-21,hX*.96,5.68,.066);//Use/Cast icon
          drawText(hX,5.33,1,1,'Use','white',.66);//USE/CAST TEXT
          MessageBox.show(hX+.15,5.33 - .4,1,9,2,'','indicator',1,0)
          MessageBox.show(.5,8,1,9,2,'Click the Use button to ready the card for battle and to begin the next round of combat.','dialogue',1,0)
        }
        if (this.dCounter == 5){
          drawText(1.5, 5.75, 1, 1, '2/2', 'white', 1);
          this.card[2].place(.875,6.5,1)
          drawPortrait(-1,halX-.5,arY,.1);//left
          drawPortrait(-2,harX,arY,.1);//right
          drawPortrait(-21,hX*.96,5.68,.066);//Use/Cast icon
          drawText(hX,5.33,1,1,'Use','white',.66);//USE/CAST TEXT
          MessageBox.show(hX+.15,5.33 - .4,1,9,2,'','indicator',1,0)
          }
          if(this.dCounter == 6){this.at = 0; this.ax = 0; this.ay = 0; this.dCounter = 0; this.option = 8}
       
      break;
      case 8://Round 2 AGI check again
          drawPortrait(-14,9,9,.1);//draw hourglass
          drawPortrait(-14,0,9,.1);//draw hourglass
          drawPortrait(-14,0,0,.1);//draw hourglass
          drawPortrait(-14,9,0,.1);//draw hourglass
           drawText(4.6, .93, .4, .3, '+1', 'green', 1);
          if(this.at <31){this.at = this.at+tick;} //animation timer tick
          if (this.at > 31 && this.at < 36){this.at = 31}
          //step 1. up and closer like flipping coin ay = animation y and az = animation z. 
          if (this.ay < 3 && this.at <=30){this.ay = this.ay+SPEED_Y;this.az = this.az + SPEED_Z;}
          //step2.Dice Falls
          if (this.ay >=3 && this.az !=1 && this.at<=30){this.az = this.az -SPEED_Z;}
          //step 4.Dice Stops
          if (this.ay >=3 && this.az ==1 && this.at<=30){
            Player[0].setDice(8,8,6,1,.001,dt)
            drawText(7.7,5.6,1,1,''+rnd(1,8),'white',1);
            Player[1].flip();
            Player[1].setDice(8,8,6,1,.001,dt)
            drawText(7.7,5.6,1,1,''+rnd(1,8),'white',1);
            Player[1].flip();
          }
          //step 3.Dice Animate
          else{if (this.at < 30){
              Player[0].setDice(8,8,9-this.ay,this.az,99,dt)
              Player[1].flip();
              Player[1].setDice(8,8,9-this.ay,this.az,99,dt)
              Player[1].flip();
            }
          }
          if (this.at > 30){//show result of roll and announce turns
            //DICE STOP
            
            Player[0].setDice(8,8,6,1,.001,dt);
            drawText(7.7,5.6,1,1,''+8,'white',1);
            Player[1].flip();
            Player[1].setDice(8,8,6,1,.001,dt)
            drawText(7.7,5.6,1,1,''+1,'white',1);
            Player[1].flip();  
            
            if ( this.at>31){
              //drawText(2.15,4.75,6,1,"Tap Screen To Continue",`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)})`,1);
              
                MessageBox.show(.5,6,1.5,2,1,'First!','jrpg',1,0)
                Player[1].flip();  
                MessageBox.show(.5,6,1.5,2,.9,'Second!','jrpg',1,0)
                Player[1].flip();
              
            }
            if (this.at == 36){
             
              MessageBox.show(.5,8,1,9,2,'As expected of my love... *cough* er... ANYWAY ','dialogue',1,0)
            }
            if (this.at==37){MessageBox.show(.5,8,1,9,2,'Because your AGI roll landed higher than mine you must make the first move','dialogue',1,0)}
            if (this.at==38){MessageBox.show(.5,8,1,9,2,'Because you selected an Item from your hand, you will not Attack, instead you will activate the item.','dialogue',1,0)}
            if (this.at==39){MessageBox.show(.5,8,1,9,2,'Items have game changing effects and typically do not require stats to activate, unlike Spells... as you shall soon see.','dialogue',1,0);}
            if (this.at==40){MessageBox.show(.5,8,1,9,2,'Now lets move on. Your item will now take effect and then I shall make my move.','dialogue',1,0);}
            if (this.at==41){ this.option = 9;this.at = 0;this.ay = 0;this.az = 0;}
            }//end show result of roll and announce turns
          break;
      case 9://Item use  
       drawText(4.6, .93, .4, .3, '+1', 'green', 1);
        if (this.reroll == 0){
          if (this.at == 61){drawText(4.6, 7, .4, .3, '+1', 'green', 1);
            drawText(5.6, 7, .4, .3, '+1', 'green', 1);
          }

          drawPortrait(-21,9,9,.1);
          drawPortrait(-21,0,9,.1);
          drawPortrait(-13,0,0,.1);//draw hourglass
          drawPortrait(-13,9,0,.1);//draw hourglass
          if (this.at <61){this.at = this.at+tick;}
          if (this.at >= 61){this.at = 61}
          //MOVE ITEM FROM HAND TO CENTER OF FIELD
          if (this.at <= 30){this.card[2].place(1+((2.875/30)*this.at),6.5,1);}
          //GLOW EFFECT TO INDICATE USE
          if (this.at > 30 && this.at <=60){
            this.card[2].place(3.88,6.5,1);
            drawShape('rec',3.88,6.5,1,0,0,2.25,3.55,0,0,0,0,`rgba(255,255,0,${.1+this.at*.01})`,1);
            this.dCounter = 0;
          }
          if (this.dCounter == 0 && this.at ==61){MessageBox.show(.5,8,1,9,2,'Items give you an advantage, however, Items alone wont win a game...','dialogue',1,0)}
          if (this.dCounter == 1 && this.at ==61){MessageBox.show(.5,8,1,9,2,'Now Spells, unlike Items, are dependent on stat rolls to activate.','dialogue',1,0)}
          if (this.dCounter == 2 && this.at ==61){MessageBox.show(.5,8,1,9,2,'Since you have taken your turn, allow me to demonstrate Spell use...','dialogue',1,0)}
          if (this.dCounter == 3 && this.at ==61){
              MessageBox.show(.5,8,1,9,2,'Since you have taken your turn, allow me to demonstrate Spell use.','dialogue',1,0)
              this.reroll = 1; this.at = 0; this.ay = 0; this.az = 0;
          }
        }
        if (this.reroll == 1){
          if (this.at <101){drawText(4.6, 7, .4, .3, '+1', 'green', 1);
            drawText(5.6, 7, .4, .3, '+1', 'green', 1);
          }
          if(this.at <130){this.at = this.at+tick;}//ticking til 100
          else if (this.at>130&&this.at <136 ){this.at = 130;}//pause at 101
          else if (this.at >=136){this.at = this.at+tick;}//continue after 106  
          drawPortrait(-21, 0, 0, .1);
          drawPortrait(-21, 9, 0, .1);
          drawPortrait(-13,9,9,.1);//draw hourglass
          drawPortrait(-13,0,9,.1);//draw hourglass
          //MOVE ITEM FROM HAND TO CENTER OF FIELD
          if (this.at <= 30){
            this.mc = 1;
            Player[1].flip();
            this.card[4].place(1+((2.875/30)*this.at),6.5,1);
            Player[1].flip();
          }
          //GLOW EFFECT TO INDICATE USE
          if (this.at > 30 && this.at <=69){
            Player[1].flip()
            this.card[4].place(3.88,6.5,1);
            drawShape('rec',3.88,6.5,1,0,0,2.25,3.55,0,0,0,0,`rgba(255,255,0,${.1+this.at*.01})`,1);
            Player[1].flip()
          }
          if (this.at > 69){
            drawPortrait(-12, 9, 9, .1);
            drawPortrait(-12, 0, 9, .1);
            drawPortrait(-12, 9, 0, .1);
            drawPortrait(-12, 0, 0, .1);
            if (this.ay < 3 && this.at < 100) {this.ay = this.ay + SPEED_Y;this.az = this.az + SPEED_Z;}
            if (this.ay > 3 && this.az > 1 && this.at < 100) {this.az = this.az - SPEED_Z;}
            // DICE STOPPED
            if (this.ay > 3 && this.az <= 1 && this.at < 100) {
              Player[0].setDice(4, 8, 6, 1.5, .0001, dt);
              drawText(7.7, 5.6, 1, 1, '' + 3, 'white', 1);
              Player[1].flip();
              Player[1].setDice(10, 8, 6, 1.5, .0001, dt);
              drawText(7.7, 5.6, 1, 1, '' + 9, 'white', 1);
              Player[1].flip()
            } 
            // DICE ROLLING
            else {if (this.at < 100) {
              // Player Roll
              Player[0].setDice(4, 8, 9 - this.ay, this.az, 99, dt);
              // Foe Roll
              Player[1].flip();
              Player[1].setDice(10, 8, 9 - this.ay, this.az, 99, dt);
              Player[1].flip();
              MessageBox.show(.5,6,1.5,2,1,'High Priestess mutters an incantation...','jrpg',1,0)  
              drawPortrait(13, 4.5 - this.at * .005, 5 - this.at * .003, .1 + this.at * .001)
              }   //<100 
            }//end if dice rolling....
            //Roll Results
            if (this.at > 100) {
              //DICE STOP
              Player[0].setDice(4, 8, 6, 1.5, .0001, dt);
              drawText(7.7, 5.6, 1, 1, '' + 3, 'white', 1);
              //DICE STOP FOE
              Player[1].flip();
              Player[1].setDice(10, 8, 6, 1.5, .0001, dt);
              drawText(7.7, 5.6, 1, 1, '' + 9, 'white', 1);
              Player[1].flip();
              if (this.mc == 1){MusicEngine.stop();MusicEngine.playSFX('death');MusicEngine.play(21);this.mc = 0;}
              MessageBox.show(.5,6,1.5,2,1, 'Fool succumbs to the spell!','jrpg',1,0)
              drawShape('rec',0,0,1,3.875,6.45,2.25,3.55,0,0,0,0,`rgba(0,0,0,${(.3+(this.at-100)*.2)})`,1);
            }//>100
            if (this.at == 130){
              this.option = 10
              this.at = 0; this.ay = 0; this.az = 0; this.dCounter = 0;  
            }
          }//>69
        }//reroll = 1
      break;
      case 10://END and return to explore
       drawText(4.6, .93, .4, .3, '+1', 'green', 1);
        drawShape('rec',0,0,1,3.88,6.45,2.25,3.55,0,0,0,0,`rgba(0,0,0,1)`,1);
         //DICE STOP
              Player[0].setDice(4, 8, 6, 1.5, .0001, dt);
              drawText(7.7, 5.6, 1, 1, '' + 3, 'white', 1);
              //DICE STOP FOE
              Player[1].flip();
              Player[1].setDice(10, 8, 6, 1.5, .0001, dt);
              drawText(7.7, 5.6, 1, 1, '' + 9, 'white', 1);
              Player[1].flip();
              MessageBox.show(.5,6,1.5,2,1, 'Fool succumbs to the spell!','jrpg',1,0)
        if (this.dCounter <2){MessageBox.show(.5,8,1,9,2,'Oh dear...','dialogue',1,0)}
        if (this.dCounter == 2){MessageBox.show(.5,8,1,9,2,'I forget my own strength at times...','dialogue',1,0)}
        if (this.dCounter == 3){
          this.dCounter = 0; 
          iRune.changeOwner(2); 
          this.x = this.x; 
          this.y = this.y+1;
          this.tutorialFinished = 1;
          this.MainQuest = 1;
          MusicEngine.stop();
          MusicEngine.playSFX('heal');
          MusicEngine.play(4);
          this.deck.push(new Card(17, 0));
               this.currentSpeaker = {
              type: -27,          // Triggers the "You obtained a card" UI
              deck: [17],     // The card to show
              visible: true       // Required for safety checks
              };
              startGame = 'dialogue'; // Switch mode to show the box
        }
      break;
    } 
  }
  killNPC(npc, permanent = false) {
      npc.isDead = true;
      npc.visible = false;
      let uniqueID = this.mapID + "_" + npc.index;

      if (permanent) {
          this.memory[uniqueID] = { permanent: true };
          npc.respawnTime = Infinity;

          // --- SYNC WITH SERVER ---
          console.log("Attempting to sync death for:", uniqueID); 
          
          if (typeof socket !== 'undefined') {
              console.log("Socket found. Emitting npc_died...");
              socket.emit("npc_died", { 
                  mapID: this.mapID, 
                  index: npc.index 
              });
          } else {
              console.log("ERROR: Socket is not defined inside killNPC!");
          }
          // ------------------------

      } else {
          // Temporary death logic...
          let respawnTime = Date.now() + npc.respawnDelay;
          npc.respawnTime = respawnTime;
          this.memory[uniqueID] = { respawnAt: respawnTime, permanent: false };
      }
  }
  // Add this inside your Map class
  reviveNPC(index) {
    // 1. Construct the unique ID for this map and npc index
    // Note: Use the index number (e.g., 5, 56, etc.)
    let uniqueID = this.mapID + "_" + index;

    // 2. Delete the "Permanent Death" note from memory
    if (this.memory[uniqueID]) {
        delete this.memory[uniqueID];
        console.log(`[Revive] Death Memory cleared for ID: ${uniqueID}`);
    } else {
        console.log(`[Revive] No death memory found for ID: ${uniqueID}`);
    }

    // 3. Find the NPC object in the current list and reset it
    let npc = this.npcs.find(n => n.index === index);
    if (npc) {
        npc.isDead = false;
        npc.visible = true;
        // Reset position from the "Void" if they were sent to -999
        // You might need to manually set x/y if they don't snap back automatically
        console.log(`[Revive] NPC ${index} visual restored.`);
    }

    // 4. FORCE SAVE immediately so this fix persists through refresh
    this.saveGame();
    console.log(`[Revive] Game Saved. The NPC should now exist on refresh.`);
}
  spawnPersistentNPC(targetMapID, index, x, y, type, state = 'stationary', color = '#ffffff', deck = []) {
    // 1. Create the persistent data object
    const npcData = { index, x, y, type, state, color, deck };
    
    // 2. Initialize the memory array for this map if it doesn't exist
    const memoryKey = 'spawned_' + targetMapID;
    if (!this.memory[memoryKey]) {
        this.memory[memoryKey] = [];
    }

    // 3. Save to memory (prevent duplicates based on index)
    const existing = this.memory[memoryKey].find(n => n.index === index);
    if (!existing) {
        this.memory[memoryKey].push(npcData);
    }

    // 4. If we are currently on that map, spawn it immediately so we see it
    if (this.mapID === targetMapID) {
        // Create the actual instance
        const newNPC = new NPC(index, x, y, type, state, color, deck);
        this.npcs.push(newNPC);
    }
  }
  parseColor(str) {
    // 1. Handle Hex Codes (e.g. #8b4513)
    if (str.startsWith('#')) {
        return {
            r: parseInt(str.substring(1, 3), 16),
            g: parseInt(str.substring(3, 5), 16),
            b: parseInt(str.substring(5, 7), 16)
        };
    }
    
    // 2. Handle RGB / RGBA (e.g. rgba(100, 50, 0, 1))
    if (str.startsWith('rgb')) {
        // This Regex grabs all numbers (integers or decimals) from the string
        const parts = str.match(/(\d+(\.\d+)?)/g); 
        if (parts && parts.length >= 3) {
            return {
                r: parseInt(parts[0]), // Red
                g: parseInt(parts[1]), // Green
                b: parseInt(parts[2])  // Blue
                // We typically ignore Alpha [3] for wall shading logic
            };
        }
    }

    // 3. Fallback (if type is missing or invalid) -> Return Brown
    return { r: 139, g: 69, b: 19 };
}
}

class WeatherSystem {
  constructor(size) {
    this.width = size;
    this.height = size;
    this.mode = 'clear';

    this.particles = [];
    this.bolts = [];
    this.flashOpacity = 0;
    this.lightningTimer = Math.random() * 5 + 2;
    
    // NEW: Intensity of the shake
    this.shakeIntensity = 0; 
  }

  resize(w, h) {
    this.width = w;
    this.height = h;
  }

  setMode(mode) {
    if (this.mode === mode) return;
    this.mode = mode;
    this.particles = [];
    this.bolts = [];
    this.flashOpacity = 0;
    this.shakeIntensity = 0; // Reset shake

    if (mode === 'snow') this.spawnParticles(200, 'snow');
    else if (mode === 'rain' || mode === 'storm') this.spawnParticles(100, 'rain');
    else if (mode === 'leaves') this.spawnParticles(13, 'leaves');
    else if (mode === 'lightning') this.spawnParticles(25, 'cloud');
    else if (mode === 'space') this.spawnParticles(80, 'glitter');

    // --- NEW: APOCALYPSE MODE ---
    else if (mode === 'apocalypse') {
      // 1. Spawn storm clouds for background
      this.spawnParticles(20, 'cloud'); 
      // 2. Spawn rising embers
      this.spawnParticles(150, 'ember'); 
      // 3. Enable shake
      this.shakeIntensity = 5; 
    }
  }

  spawnParticles(count, type) {
    const leafColors = ['#e6a12c', '#d95d1e', '#8a3324', '#bf9b30'];
    // Fire colors: Red, Orange, Yellow, Dark Red
    const emberColors = ['#ff4d00', '#ff8400', '#ffc400', '#ff0000', '#cf1919'];

    for (let i = 0; i < count; i++) {
      let p = {
        x: Math.random() * this.width,
        y: Math.random() * this.height,
        type: type
      };

      if (type === 'snow') {
        p.size = Math.random() * 2 + 1;
        p.speed = (Math.random() * 1 + 0.5) * 60;
        p.drift = Math.random() * 2 - 1;
      } 
      else if (type === 'rain') {
        p.length = Math.random() * 20 + 10;
        p.speed = Math.random() * 10 + 20;
      } 
      else if (type === 'leaves') {
        p.size = Math.random() * 4 + 4;
        p.speed = Math.random() * 10 + 5;
        p.swayPhase = Math.random() * Math.PI * 2;
        p.swaySpeed = Math.random() * 2 + 1;
        p.swayAmp = Math.random() * 20 + 10;
        p.rotation = Math.random() * 360;
        p.rotSpeed = (Math.random() - 0.5) * 0.1;
        p.color = leafColors[Math.floor(Math.random() * leafColors.length)];
      }
      else if (type === 'cloud') {
        // Clouds spawn higher up
        p.y = (Math.random() * (this.height * 0.4)) - 50; 
        p.size = Math.random() * 120 + 100; 
        p.speed = Math.random() * 15 + 10; // Faster clouds for chaos
        p.opacity = Math.random() * 0.3 + 0.1; 
      }
      else if (type === 'glitter') {
        p.size = Math.random() * .63; 
        p.life = Math.random(); 
        p.decay = Math.random() * 0.03 + 0.01; 
        p.color = Math.random() > 0.25 ? "255, 255, 255" : "0, 0, 0";
      }
      // --- NEW EMBER LOGIC ---
      else if (type === 'ember') {
        p.size = Math.random() * 3 + 1; // Small specks
        // Speed is NEGATIVE later because heat rises
        p.speed = Math.random() * 40 + 20; 
        p.swayPhase = Math.random() * Math.PI * 2;
        p.swaySpeed = Math.random() * 3 + 1;
        p.color = emberColors[Math.floor(Math.random() * emberColors.length)];
        // Life allows them to burn out before reaching top
        p.life = Math.random() * 0.8 + 0.2; 
        p.decay = Math.random() * 0.01 + 0.005;
      }

      this.particles.push(p);
    }
  }

  update(dt) {
    if (this.mode === 'clear') return;

    const wind = (this.mode === 'snow') ? 0 : -2;

    for (let p of this.particles) {

      // LEAVES
      if (this.mode === 'leaves') {
        p.y += p.speed * dt;
        p.swayPhase += p.swaySpeed * dt;
        p.x += (Math.sin(p.swayPhase) * p.swayAmp * dt) - (5 * dt);
        p.rotation += p.rotSpeed;
        if (p.y > this.height) { p.y = -15; p.x = Math.random() * this.width; }
      } 

      // CLOUDS (Shared by 'lightning' and 'apocalypse')
      else if (p.type === 'cloud') {
        p.x -= p.speed * dt;
        if (p.x < -p.size * 2) {
          p.x = this.width + p.size;
          p.y = (Math.random() * (this.height * 0.3)) - 50;
        }
      }

      // SPACE GLITTER
      else if (this.mode === 'space') {
        p.life += p.decay;
        if (p.life >= 1) {
            p.life = 0;
            p.x = Math.random() * this.width;
            p.y = Math.random() * this.height;
            p.decay = Math.random() * 0.03 + 0.01;
        }
      }

      // --- NEW EMBER UPDATE ---
      else if (this.mode === 'apocalypse' && p.type === 'ember') {
        // Move UP (Heat rises)
        p.y -= p.speed * dt; 
        
        // Chaotic sway (embers flutter)
        p.swayPhase += p.swaySpeed * dt;
        p.x += Math.sin(p.swayPhase) * 20 * dt;

        // Life cycle (flicker out)
        p.life -= p.decay;

        // Reset if off top screen OR burnt out
        if (p.y < -10 || p.life <= 0) {
           p.y = this.height + 10;
           p.x = Math.random() * this.width;
           p.life = 1;
           // Reset speed for variety
           p.speed = Math.random() * 40 + 20; 
        }
      }

      // STANDARD RAIN/SNOW
      else if (p.type !== 'cloud' && p.type !== 'ember') {
        let speedMod = (this.mode === 'snow') ? p.size : 60;
        p.y += p.speed * speedMod * dt;
        p.x += (this.mode === 'snow' ? p.drift * 10 : wind * 60) * dt;
        if (p.y > this.height) { p.y = -15; p.x = Math.random() * this.width; }
        if (p.x > this.width) p.x = 0;
        if (p.x < -15) p.x = this.width;
      }
    }

    // Lightning Update (Shared by storm and apocalypse)
    if (this.mode === 'storm' || this.mode === 'lightning' || this.mode === 'apocalypse') {
      this.updateLightning(dt);
    }
  }

  draw(ctx, startX, startY) {
    if (this.mode === 'clear') return;

    ctx.save();

    // --- 1. APPLY EARTHQUAKE SHAKE ---
    let shakeX = 0;
    let shakeY = 0;
    if (this.mode === 'apocalypse') {
        // Generate random jitter between -shakeIntensity and +shakeIntensity
        shakeX = (Math.random() - 0.5) * this.shakeIntensity * 2;
        shakeY = (Math.random() - 0.5) * this.shakeIntensity * 2;
    }

    ctx.beginPath();
    ctx.rect(startX, startY, this.width, this.height);
    ctx.clip();
    
    // Apply translation WITH shake
    ctx.translate(startX + shakeX, startY + shakeY);

    // --- DRAW BACKGROUND CLOUDS ---
    if (this.mode === 'lightning' || this.mode === 'apocalypse') {
      for (let p of this.particles) {
        if (p.type !== 'cloud') continue;
        // Apocalypse clouds are darker/redder
        let color = (this.mode === 'apocalypse') ? `rgba(45, 20, 20, ${p.opacity})` : `rgba(40, 40, 55, ${p.opacity})`;
        
        let gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);
        gradient.addColorStop(0, color);
        gradient.addColorStop(1, `rgba(0,0,0,0)`);
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // --- DRAW SPACE/GLITTER ---
    if (this.mode === 'space') {
       // (Existing glitter draw code...)
       for (let p of this.particles) {
           let alpha = Math.sin(p.life * Math.PI);
           ctx.fillStyle = `rgba(${p.color}, ${alpha})`;
           ctx.shadowBlur = 10 * alpha; 
           ctx.shadowColor = `rgba(${p.color}, ${alpha})`;
           ctx.beginPath();
           ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
           ctx.fill();
           ctx.shadowBlur = 0;
       }
    }

    // --- FLASH EFFECT ---
    if ((this.mode === 'storm' || this.mode === 'lightning' || this.mode === 'apocalypse') && this.flashOpacity > 0) {
      // Apocalypse lightning is slightly orange/yellow
      ctx.fillStyle = (this.mode === 'apocalypse') 
          ? `rgba(255, 220, 180, ${this.flashOpacity})`
          : `rgba(255, 255, 255, ${this.flashOpacity})`;
      ctx.fillRect(0, 0, this.width, this.height);
    }

    // --- DRAW STANDARD PARTICLES (Rain/Snow/Leaves) ---
    // (Existing draw code for rain/snow/leaves...)
    if (this.mode === 'leaves') {
         for (let p of this.particles) {
            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.rotate(p.rotation);
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.moveTo(0, -p.size);
            ctx.lineTo(p.size/2, 0);
            ctx.lineTo(0, p.size);
            ctx.lineTo(-p.size/2, 0);
            ctx.fill();
            ctx.restore();
         }
    }
    else if (this.mode === 'rain' || this.mode === 'storm') {
        ctx.beginPath();
        ctx.strokeStyle = "rgba(170, 190, 230, 0.6)";
        ctx.lineWidth = 2;
        for (let p of this.particles) {
            if(p.type === 'rain') {
                ctx.moveTo(p.x, p.y);
                ctx.lineTo(p.x - 2, p.y + p.length);
            }
        }
        ctx.stroke();
    }
    else if (this.mode === 'snow') {
        ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
        ctx.beginPath();
        for(let p of this.particles) if(p.type === 'snow') ctx.rect(p.x, p.y, p.size, p.size);
        ctx.fill();
    }

    // --- NEW: DRAW EMBERS ---
    if (this.mode === 'apocalypse') {
        for (let p of this.particles) {
            if (p.type !== 'ember') continue;
            
            // Flicker effect based on life
            let alpha = p.life * (0.6 + Math.random() * 0.4); 
            
            ctx.fillStyle = p.color;
            ctx.globalAlpha = alpha;
            
            // Add a fire glow
            ctx.shadowBlur = 10;
            ctx.shadowColor = "#ff4d00"; // Orange glow
            
            ctx.beginPath();
            ctx.rect(p.x, p.y, p.size, p.size);
            ctx.fill();
            
            ctx.shadowBlur = 0; // Reset
            ctx.globalAlpha = 1.0;
        }
    }

    // --- DRAW LIGHTNING ---
    if (this.mode === 'storm' || this.mode === 'lightning' || this.mode === 'apocalypse') {
      this.drawLightning(ctx);
    }

    // --- NEW: RED FIRE VIGNETTE ---
    // This draws a "heat" overlay on the edges
    if (this.mode === 'apocalypse') {
        // Use standard blending to overlay the red tint
        ctx.globalCompositeOperation = 'source-over';
        
        // Gradient from center (transparent) to edges (red/orange)
        let grad = ctx.createRadialGradient(
            this.width/2, this.height/2, this.width * 0.3, 
            this.width/2, this.height/2, this.width * 0.8
        );
        grad.addColorStop(0, 'rgba(0,0,0,0)');
        grad.addColorStop(0.6, 'rgba(100, 20, 0, 0.1)'); // Subtle heat
        grad.addColorStop(1, 'rgba(255, 50, 0, 0.35)');  // Intense fire edges

        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, this.width, this.height);
    }

    ctx.restore();
  }

  // --- LIGHTNING HELPERS (Unchanged) ---
  updateLightning(dt) {
    if (this.flashOpacity > 0) this.flashOpacity -= dt * 2.0;
    this.lightningTimer -= dt;
    if (this.lightningTimer <= 0) {
      this.createBolt();
      // Storms/Apocalypse have chaotic lightning timing
      this.lightningTimer = Math.random() * 4 + 1; 
    }
    for (let i = this.bolts.length - 1; i >= 0; i--) {
      let bolt = this.bolts[i];
      bolt.life -= dt;
      if (bolt.life <= 0) this.bolts.splice(i, 1);
    }
  }

  createBolt() {
    const scale = Math.random() * 0.8 + 0.2;
    const startX = Math.random() * this.width;
    let segments = this.generateBoltPath(startX, -50, scale);
    let branches = [];
    if (Math.random() < 0.3) {
       let split = segments[Math.floor(segments.length / 2)];
       branches = this.generateBoltPath(split.x, split.y, scale * 0.5, 5);
    }
    this.bolts.push({
      segments, branches, life: 0.15 + Math.random() * 0.2,
      width: scale * 3, opacity: scale
    });
    if (scale > 0.6) this.flashOpacity = scale * 0.5;
  }

  generateBoltPath(x, y, scale, limit = null) {
    let segments = [{x, y}];
    let stepY = (40 * scale) + 10;
    let numSteps = limit || (this.height + 50) / stepY;
    for (let i = 0; i < numSteps; i++) {
      y += stepY;
      x += (Math.random() - 0.5) * 60 * scale;
      segments.push({x, y});
    }
    return segments;
  }

  drawLightning(ctx) {
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    for (let bolt of this.bolts) {
      let alpha = bolt.opacity * (bolt.life / 0.2);
      ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
      ctx.lineWidth = bolt.width;
      ctx.shadowBlur = 15;
      ctx.shadowColor = "white"; // Or light orange for apocalypse if desired
      ctx.beginPath();
      ctx.moveTo(bolt.segments[0].x, bolt.segments[0].y);
      for (let i = 1; i < bolt.segments.length; i++) ctx.lineTo(bolt.segments[i].x, bolt.segments[i].y);
      ctx.stroke();
      if (bolt.branches.length) {
        ctx.lineWidth = bolt.width * 0.5;
        ctx.beginPath();
        ctx.moveTo(bolt.branches[0].x, bolt.branches[0].y);
        for (let i = 1; i < bolt.branches.length; i++) ctx.lineTo(bolt.branches[i].x, bolt.branches[i].y);
        ctx.stroke();
      }
      ctx.shadowBlur = 0;
    }
  }
}
class btn{
  constructor(x,y,l,h,z,text,frameColor,textColor,index=0,visible = 0){
    this.wobbleTimer = 0;
    this.wobbleMax = 0;
    this.x = x; this.y = y; this.z = z;
    this.text = text;
    this.frameColor = frameColor;
    this.textColor = textColor;
    this.visible = visible;
    this.index = index;
    //shape,x,y,z,x1,y1,x2,y2,x3,y3,x4,y4,color,fill,x5,y5
    drawShape('rec',this.x,this.y,this.z,0,0,this.l,this.h,0,0,0,0,this.frameColor,0,0,0)
    //x, y, boxW, boxH, text, color, z
    drawText(this.x,this.y,this.l,this.h,this.text,this.textColor,this.z)
  }
  setOrigin(x,y,z){
    this.originx = x;
    this.originy = y;
    this.originz = z;
  }
  show(x,y,z,l,h,text,type='frame',visible = 1,foe,originx = this.x, originy = this.y,originz = this.originz){
    if (foe == 1&&Player[1].isCPU == 1){return}
    this.foe = foe
    this.x = x;
    this.y = y;
    this.z = z;
    this.l = l;
    this.h = h;
    let pulse = 0;
    let isPressed = 0;
    let bSize = 0;
    let baseCol = 0;
    let frameCol = 0;
    let inset = 0;
    let borderCol = 0;
    let bgCol = 0;
    this.originx = originx;
    this.originy = originy;
    this.originz = originz;
    this.type = type;
    this.visible = visible;
    this.text = text
    if (this.visible > 0){
      switch(type){
        case 'frame':
          this.frameColor = 'rgba(0,0,190,.75)';
          this.textColor = 'black'
          //shape,x,y,z,x1,y1,x2,y2,x3,y3,x4,y4,color,fill,x5,y5
          //drawShape('rec',this.x+.05*this.z,this.y+.05*this.z,this.z,0,0,this.l-.06*this.z,this.h,0,0,0,0,'gold',0,0,0)
          drawShape('rec',this.x,this.y,this.z,0,0,this.l,this.h,0,0,0,0,'gold',0,0,0)
          drawShape('rec',this.x,this.y,this.z,0,0,this.l,this.h,0,0,0,0,this.frameColor,1,0,0)
          drawShape('rec',this.x,this.y,this.z,0,0,this.l-.03*this.z,this.h-.06*this.z,0,0,0,0,'rgba(255,255,255,.5)',1,0,0)
          drawShape('rec',this.x,this.y,this.z,0,0,this.l-.03*this.z,this.h-.06*this.z,0,0,0,0,'gold',0,0,0)
          //x, y, boxW, boxH, text, color, z
          drawText(this.x,this.y+.015*this.z,this.l-.02*this.z,this.h-.02*this.z,this.text,this.textColor,this.z-.01)
          break;
        case 'button3D':
          // If pressed, we move the top layer down and change the color slightly
          let pressShift = this.isPressed ? 0.02 * this.z : 0;
          let shadowColor = '#555';
          let faceColor = this.isPressed ? '#d4af37' : 'gold'; // Darkens 'gold' when pressed

          // 1. DRAW THE SHADOW (The "Side" of the button)
          // We draw this at the original position
          drawShape('rec', this.x, this.y, this.z, 0, 0, this.l, this.h + (0.03 * this.z), 0, 0, 0, 0, shadowColor, 1, 0, 0);

          // 2. DRAW THE MAIN FACE
          // We offset 'y' by pressShift. When pressed, it moves DOWN.
          drawShape('rec', this.x, this.y + pressShift, this.z, 0, 0, this.l, this.h, 0, 0, 0, 0, faceColor, 1, 0, 0);

          // 3. DRAW THE TEXT
          // Text must also move down with the face!
          drawText(this.x, this.y + pressShift, this.l, this.h, this.text, this.textColor, this.z - 0.01);
          break;
        case 'neon':
          let glowSize = this.isPressed ? 0.06 * this.z : 0.02 * this.z;
          let glowColor = this.isPressed ? '#00ffff' : '#008888';

          // Glow Layer
          drawShape('rec', this.x - glowSize/2, this.y - glowSize/2, this.z, 0, 0, this.l + glowSize, this.h + glowSize, 0,0,0,0, glowColor, 1, 0, 0);
          
          // Main Dark Box
          drawShape('rec', this.x, this.y, this.z, 0, 0, this.l, this.h, 0,0,0,0, '#111', 1, 0, 0);
          
          drawText(this.x, this.y, this.l, this.h, this.text, '#00ffff', this.z);
          break;
        case 'seesaw':
          const WOBBLE_SPEED = 15; // Higher is faster
          let finalTilt = 0;

          if (this.isPressed) {
            let elapsed = (Date.now() - this.wobbleTimer) / 1000;
            let progress = elapsed * WOBBLE_SPEED;
            
            // Logic: 1 = Tilt & Back | 2 = Tilt, Back, Other Side, Back
            // We use Math.sin and a decay multiplier so it stops at the count
            if (progress < (this.wobbleMax * Math.PI)) {
              finalTilt = Math.sin(progress) * 0.15 * this.side;
            }
          }

          // Calculate 4 corners using the dynamic finalTilt
          let x1 = 0, y1 = 0 - finalTilt;
          let x2 = this.l, y2 = 0 + finalTilt;
          let x3 = this.l, y3 = this.h + finalTilt;
          let x4 = 0, y4 = this.h - finalTilt;

          // Draw Shadow
          drawShape('qua', this.x, this.y + 0.05, this.z, x1, y1, x2, y2, x3, y3, x4, y4, '#444', 1);
          // Draw Face
          drawShape('qua', this.x, this.y, this.z, x1, y1, x2, y2, x3, y3, x4, y4, 'gold', 1);
          // Draw Text
          drawText(this.x, this.y + (finalTilt/2), this.l, this.h, this.text, 'black', this.z - 0.01);
          break;
        case 'pulse':
          pulse = Math.sin(Date.now() / 200) * 0.03;
          let thick = 0.05 + pulse;

          // Dark Center
          drawShape('qua', this.x, this.y, this.z, 
                    -thick, -thick, 
                    this.l + thick, -thick, 
                    this.l + thick, this.h + thick, 
                    -thick, this.h + thick, 
                    '#111', 1);
          // Pulsing neon border (using 'qua' for precision)
          drawShape('qua', this.x, this.y, this.z, 
                    -thick, -thick, 
                    this.l + thick, -thick, 
                    this.l + thick, this.h + thick, 
                    -thick, this.h + thick, 
                    '#00ff00', 0);

          drawText(this.x, this.y, this.l, this.h, this.text, `rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)})`, this.z);
          break;
        case 'jrpg':
          bSize = 0.04; // Border/Bevel thickness
          isPressed = 0;
          
          // 1. OUTER SHADOW (Grounds the UI)
          drawShape('rec', this.x + 0.03, this.y + 0.03, this.z, 0, 0, this.l, this.h, 0, 0, 0, 0, 'rgba(0,0,0,0.5)', 1);

          // 2. MAIN BODY (The Gradient)
          // We use a slightly lighter color if pressed
          baseCol = isPressed ? '#1a1a99' : '#000066'; 
          drawShape('rec', this.x, this.y, this.z, 0, 0, this.l, this.h, 0, 0, 0, 0, baseCol, 1);
          // Secondary "Wash" for top half to simulate light hitting silk/glass
          drawShape('rec', this.x, this.y, this.z, 0, 0, this.l, this.h * 0.5, 0, 0, 0, 0, 'rgba(255,255,255,0.1)', 1);

          // 3. THE BEVEL (Lighting Simulation)
          // Top Highlight (Light hitting the top edge)
          drawShape('lin', this.x, this.y, this.z, 0, 0, this.l, 0, 0, 0, 0, 0, 'rgba(255,255,255,0.8)', 0);
          // Left Highlight
          drawShape('lin', this.x, this.y, this.z, 0, 0, 0, this.h, 0, 0, 0, 0, 'rgba(255,255,255,0.5)', 0);
          // Bottom Shadow (Ambient occlusion)
          drawShape('lin', this.x, this.y + (this.h * this.z), this.z, 0, 0, this.l, 0, 0, 0, 0, 0, 'rgba(0,0,0,0.8)', 0);

          // 4. THE PINSTRIPE (The "Golden" Frame)
          frameCol = isPressed ? '#ffffff' : '#d4af37'; // Glows white when clicked
          // Draw an inset rectangle
          inset = 0.05;
          drawShape('rec', this.x, this.y, this.z, inset, inset, this.l - (inset * 2), this.h - (inset * 2), 0, 0, 0, 0, frameCol, 0);

          // 5. THE TEXT (With subtle drop shadow)
          // Draw shadow text first
          //drawText(this.x + 0.01, this.y + 0.01, this.l, this.h, this.text, 'black', this.z);
          // Draw main text
          //drawText(this.x, this.y, this.l*.98, this.h*.98, this.text, 'white', this.z);
         // if (this.text == 'Second'||this.text == 'First'){
            //drawText(this.x + 0.07, this.y + 0.21, this.l*.8, this.h*.8, this.text, 'black', this.z);
            drawText(this.x+.13, this.y+.2, this.l*.8, this.h*.8, this.text, 'white', this.z);
          //}else{
            // Draw shadow text first
         //drawText(this.x + 0.01, this.y + 0.01, this.l, this.h, this.text, 'black', this.z);
          // Draw main text
       // drawText(this.x, this.y, this.l, this.h, this.text, 'white', this.z);
          //}
          break;
          
        case 'jrpg_btn':
          bSize = 0.04; // Border/Bevel thickness
          isPressed = this.isPressed;
          
          // 1. OUTER SHADOW (Grounds the UI)
          drawShape('rec', this.x + 0.03, this.y + 0.03, this.z, 0, 0, this.l, this.h, 0, 0, 0, 0, 'rgba(0,0,0,0.5)', 1);

          // 2. MAIN BODY (The Gradient)
          // We use a slightly lighter color if pressed
          baseCol = isPressed ? '#1a1a99' : '#000066'; 
          drawShape('rec', this.x, this.y, this.z, 0, 0, this.l, this.h, 0, 0, 0, 0, baseCol, 1);
          // Secondary "Wash" for top half to simulate light hitting silk/glass
          drawShape('rec', this.x, this.y, this.z, 0, 0, this.l, this.h * 0.5, 0, 0, 0, 0, 'rgba(255,255,255,0.1)', 1);

          // 3. THE BEVEL (Lighting Simulation)
          // Top Highlight (Light hitting the top edge)
          drawShape('lin', this.x, this.y, this.z, 0, 0, this.l, 0, 0, 0, 0, 0, 'rgba(255,255,255,0.8)', 0);
          // Left Highlight
          drawShape('lin', this.x, this.y, this.z, 0, 0, 0, this.h, 0, 0, 0, 0, 'rgba(255,255,255,0.5)', 0);
          // Bottom Shadow (Ambient occlusion)
          drawShape('lin', this.x, this.y + (this.h * this.z), this.z, 0, 0, this.l, 0, 0, 0, 0, 0, 'rgba(0,0,0,0.8)', 0);

          // 4. THE PINSTRIPE (The "Golden" Frame)
          frameCol = isPressed ? '#ffffff' : '#d4af37'; // Glows white when clicked
          // Draw an inset rectangle
          inset = 0.05;
          drawShape('rec', this.x, this.y, this.z, inset, inset, this.l - (inset * 2), this.h - (inset * 2), 0, 0, 0, 0, frameCol, 0);

          // 5. THE TEXT (With subtle drop shadow)
          // Draw shadow text first
          //drawText(this.x + 0.01, this.y + 0.01, this.l, this.h, this.text, 'black', this.z);
          // Draw main text
          //drawText(this.x, this.y, this.l*.98, this.h*.98, this.text, 'white', this.z);
          //if (this.text == 'Second'){
          if (this.text != 'Deck') {
            drawText(this.x + 0.07, this.y + 0.21, this.l*.93, this.h*.96, this.text, 'black', this.z);
            drawText(this.x+.13, this.y+.2, this.l*.93, this.h*.96, this.text, 'white', this.z);
          }//}else{
            // Draw shadow text first
         // drawText(this.x + 0.01, this.y + 0.01, this.l, this.h, this.text, 'black', this.z);
          // Draw main text
          //drawText(this.x, this.y, this.l, this.h, this.text, 'white', this.z);
          //}
          // --- NEW CODE START ---
  if (this.text === 'Deck') {
      // Calculate size to fit inside the button (padding of 0.1)
     

      // Draw the Deck Icon (-26)
      // Adjust the 4th parameter (size) if your drawPortrait logic uses scale vs width
      drawPortrait(-28, this.x+.34*this.z, this.y+.49*this.z, this.z*.29); // *0.15 assumes your portrait scale needs shrinking
  } 
  else {
      // Normal Text Drawing
      drawText(this.x + 0.07, this.y + 0.21, this.l * .93, this.h * .96, this.text, 'black', this.z);
      drawText(this.x + .13, this.y + .2, this.l * .93, this.h * .96, this.text, 'white', this.z);
  }
  // --- NEW CODE END ---
          break;
          // --- Active Animation: Subtle Border Pulse ---
          pulse = Math.sin(Date.now() / 300) * 0.02;
          borderCol = this.isPressed ? 'yellow' : 'white';
          bgCol = this.isPressed ? '#4a4aff' : '#00008b'; // Lighter blue when pressed

          // 1. Black Outer Shadow
          drawShape('rec', this.x + 0.02, this.y + 0.02, this.z, 0, 0, this.l, this.h, 0, 0, 0, 0, 'black', 1, 0, 0);
          
          // 2. Main Blue Body
          drawShape('rec', this.x, this.y, this.z, 0, 0, this.l, this.h, 0, 0, 0, 0, bgCol, 1, 0, 0);
          
          // 3. The White Border (with the pulse animation)
          drawShape('rec', this.x, this.y, this.z, 0.02 - pulse, 0.02 - pulse, this.l - 0.04 + (pulse*2), this.h - 0.04 + (pulse*2), 0, 0, 0, 0, borderCol, 0, 0, 0);

          drawText(this.x + 0.05, this.y, this.l - 0.1, this.h, this.text, 'white', this.z);
          break;       
        case 'dialogue':
          // 1. DIMMER OVERLAY (Optional)
          // Darkens the game world slightly behind the box for focus
          // drawShape('rec', 0, 0, 10, 0, 0, 10, 10, 0, 0, 0, 0, 'rgba(0,0,0,0.3)', 1);

          // 2. OUTER GLOW & MAIN BODY
          // Using a deep obsidian blue with 85% opacity
          let bodyCol = 'rgba(10, 15, 40, 0.55)';
          //drawShape('rec', this.x, this.y, this.z, 0, 0, this.l, this.h, 0, 0, 0, 0, 'black', 1); // Border shadow
          drawShape('rec', this.x, this.y, this.z, 0.02, 0.02, this.l - 0.04, this.h - 0.04, 0, 0, 0, 0, bodyCol, 1);

          // 3. ORNATE CORNERS (The "Industry" Polish)
          // We draw small L-shapes or brackets in the corners
          let cSize = 0.2; // Corner bracket size
          let cThick = 0.03;
          let gold = '#d4af37';
          // Top-Left Bracket
          drawShape('rec', this.x, this.y, this.z, 0, 0, cSize, cThick, 0, 0, 0, 0, gold, 1);
          drawShape('rec', this.x, this.y, this.z, 0, 0, cThick, cSize, 0, 0, 0, 0, gold, 1);
          // Bottom-Right Bracket
          drawShape('rec', this.x, this.y, this.z, this.l - cSize, this.h - cThick, cSize, cThick, 0, 0, 0, 0, gold, 1);
          drawShape('rec', this.x, this.y, this.z, this.l - cThick, this.h - cSize, cThick, cSize, 0, 0, 0, 0, gold, 1);
          
            drawText(this.x+.13, this.y+.2, this.l*.93, this.h*.96, this.text, 'white', this.z);
          
          break;
        case 'indicator':
          // 4. THE NAME TAG (Header)
          // If the text contains a ":" we can extract a name, or just use a default
          //drawShape('rec', this.x + 0.5, this.y - 0.3, this.z, 0, 0, 2.5, 0.5, 0, 0, 0, 0, 'gold', 1);
          //drawText(this.x + 0.6, this.y - 0.25, 2.3, 0.4, "SPEAKER", 'black', this.z);

          // 5. THE DIALOGUE TEXT
          // We use a slight inset so text doesn't touch the borders
          drawText(this.x + 0.3, this.y + 0.3, this.l - 0.6, this.h - 0.6, this.text, 'white', this.z);

          // 6. "NEXT" INDICATOR (Animated Arrow)
          let arrowBounce = Math.sin(Date.now() / 150) * 0.05;
          drawShape('tri', this.x , this.y + arrowBounce, this.z, 
                    0, 0, 
                    0.3, 0, 
                    0.15, 0.2, 
                    0, 0, 'gold', 1);
          break;
        case 'arrow_left':
          drawPortrait(-1,this.x,this.y,.075);//left
        break;
        case 'arrow_right':         
          drawPortrait(-2,this.x,this.y,.075);//right
        break;
        case 'add_toHand':
          //DJINN LAMP QUICKSEARCH NEED TO MAKE EXCEPTION FOR && Player[0].hand[Player[0].eLOOK.H]].index != 44 and foe side too press make sure remove exit button)
          
            if (Player[attacker].deck[Player[attacker].look[eLOOK.D]].type == 0&&Player[attacker].hand[Player[attacker].look[eLOOK.H]].index != 44){
              this.visible = false;
              return;
            }
            else if (Player[attacker].deck[Player[attacker].look[eLOOK.D]].type == 0&&Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 71){
              this.visible = false;
              return;
            }
            else if (Player[attacker].deck[Player[attacker].look[eLOOK.D]].type == 2&&Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 71){
              this.visible = false;
              return;
            }
            else{
              this.visible = true;
              drawPortrait(-23,this.x,this.y,.3);//add to hand
            }
          
          

        break;
        case 'stone':
          
          isPressed = this.isPressed;
          
          
        
      }
    }
    
  }
  // Check if a touch coordinate (tx, ty) is inside the button
  isTouched(tx, ty) {
    // 1. Calculate the 'Visual' scale if you're using one (default to 1)
    let s = this.scale || 1.0; 
    
    // 2. Calculate the actual boundaries based on the grid
    // We add a tiny 'grace' buffer (0.05) to make clicking feel more responsive
    let buffer = 0.05;
    let xMin = this.x - buffer;
    let xMax = this.x + (this.l * this.z * s) + buffer;
    let yMin = this.y - buffer;
    let yMax = this.y + (this.h * this.z * s) + buffer;

    if (tx >= xMin && tx <= xMax && ty >= yMin && ty <= yMax) {
        // Calculate which side was hit for your 'seesaw' effects
        let midPoint = this.x + (this.l * this.z / 2);
        this.side = (tx < midPoint) ? -1 : 1;
        return true;
    }
    return false;
  }
  press(count = 0) {
    this.isPressed = true;
    this.wobbleMax = count;
    this.wobbleTimer = Date.now();
    if (this.type == 'arrow_left'||this.type == 'arrow_right'){count = .1||this.type == 'add_toHand'}
    
    // Keep the "active" state alive for the duration of the wobble
    // Each back-and-forth takes roughly 200ms
    setTimeout(() => { 
      this.isPressed = false; 
    ///////////////////////////////
    //BUTTON INDEX
      switch(this.index){
        case 'deck_view':
              console.log("Opening Deck View via Button...");
              // 1. Set global state
              viewingFullDeck = false; // Flag disabled: Show only MY cards
              preGame = 'explore'
              startGame = 'grimoire';
              // 2. Load Player Deck indices
              filterGrimoire('ALL');
              // 3. Reset view
              playlistIndex = 0;
              
              break;
        case 0://MessageBox
          //Jukebox Stop
          if (startGame == 'jukebox'){
            MusicEngine.stop();
            return;
          }
          //exit scry 
          if(Player[attacker].option == 6.4){
            for(let i=0;i<Player[attacker].deck.length;i++){	//place deck on right side of field
              Player[attacker].deck[i].location = 'deck'
            }
            Player[0].option = 7;
            Player[1].option = 7;
            Player[attacker].sendAction('SCRY_EXIT');
            
          }
          

          

        break;
        case 1://btnYes
          //Dungeon.x = 1.5;Dungeon.y = 1.5;
          //Emperor YES
          if (this.foe == 'emperor'){
            Dungeon.saveGame();
            // 2. INITIALIZE BATTLE
            preGame = 'explore';
            startGame = 4; 
            Dungeon.dCounter = 0;
            // 3. LOAD THE PLAYER'S DUNGEON DECK
            // We create the field, then immediately wipe the default deck
            Player[0] = new Field(0); 
            Player[1] = new Field(1,1);
            
            Player[1].opponent = Player[0];
            Player[0].opponent = Player[1];
            sRune = new stone(1.545,4.545,1,eSTAT.S);
            cRune = new stone(7.625,4.625,1,eSTAT.C);
            iRune = new stone(3.545,4.49,1,eSTAT.I);
            aRune = new stone(5.545,4.53,1,eSTAT.A);
            if(typeof Dungeon !== 'undefined' && Dungeon.deck && Dungeon.deck.length > 0){
                Player[0].deck = []; // Wipe default/random deck
                Player[0].hand = []; 
                
                // Copy every card from Dungeon to Battle Field
                for(let i = 0; i < Dungeon.deck.length; i++){
                    let dCard = Dungeon.deck[i];
                    // Create new battle card instance based on Dungeon card ID
                    let bCard = new Card(dCard.index, 0); 
                    bCard.location = 'deck';
                    bCard.locIndex = i;
                    Player[0].deck.push(bCard);
                }
            }
            let currentIndex4 = Player[0].deck.length; 
            let randomIndex4;
            while (currentIndex4 !== 0) {
              randomIndex4 = Math.floor(Math.random() * currentIndex4);
              currentIndex4--; 

              [Player[0].deck[currentIndex4], Player[0].deck[randomIndex4]] = [
              Player[0].deck[randomIndex4], Player[0].deck[currentIndex4]
            ];        
    }
  
            // 4. SETUP THE IMPOSSIBLE EMPEROR
            
            Player[1].isCPU = 1; 
            // Optional: You could buff the Emperor here if you want him truly impossible
            // Player[1].statPoints += 5; 
             // 1. THE SENILE GIFT: Give Emperor Card (ID 4) immediately
            let hasEmperor = false;
            if(typeof Dungeon !== 'undefined' && Dungeon.deck&&Dungeon.currentSpeaker != 'NPC_SUNCAT'){
                 hasEmperor = Dungeon.deck.some(c => c.index === 4);
                 if (!hasEmperor) {
                     Dungeon.deck.push(new Card(4, 0)); 
                 }
            }
           if(Dbug == 1){
            Player[0].deck.length = 0;
            Player[0].deck.push(new Card(63,0))
            Player[0].deck[0].locIndex = 0; 
            Player[0].deck[0].locCount = 0;
            Player[0].deck[0].location = 'deck';
            Player[0].deck[0].stat[0][2] = 100;
            Player[0].deck[0].stat[1][2] = 100;
            Player[0].deck[0].stat[2][2] = 100;
            Player[0].deck[0].stat[3][2] = 100;
          }
            MusicEngine.stop();
            MusicEngine.playSFX('heal');
            MusicEngine.play(4);
          }
          else if (this.foe == 'high priestess'){//High Priestess YES
            startGame = 'tutorial';
            MusicEngine.stop();
            MusicEngine.playSFX('heal')
            MusicEngine.play(21);
            Dungeon.dCounter = 0;
          }
          else if (this.foe == 'giant'){
            Dungeon.gd = 3;
            Dungeon.dCounter = 0;
          }
          //ONLINE
          // Inside btn class (pvp_accept)
          else if (this.foe == 'pvp_accept'){
              let opponentId = Dungeon.currentSpeaker?.socketId;
              if (opponentId) {
                  // 1. Prepare My Deck
                  let myDeckIndices = Dungeon.deck ? Dungeon.deck.map(c => c.index) : [];
                  
                  // 2. Send Accept + My Deck to Host
                  socket.emit("challenge_accepted", {
                      targetId: opponentId,
                      receiverDeck: myDeckIndices 
                  });

                  // 3. NEW: Do NOT start game yet. Show waiting UI.
                  MessageBox.show(0.5, 8, 1, 9, 2, 'Waiting for Host setup...', 'dialogue', 1, 0);
                  
                  // Hide buttons so they can't click again
                  this.visible = false;
                  if (typeof btnNo !== 'undefined') btnNo.visible = false;
              }
          }
          btnYes.visible = false;
          btnNo.visible = false;
          
          break;
        case 2://btnNo
              //Emperor and High Priestess No
            if (this.foe == 'emperor' || this.foe == 'high priestess'){
              if (this.foe == 'emperor'){Dungeon.y = Dungeon.y-1;}
              else{Dungeon.y = Dungeon.y+1;Dungeon.MainQuest = 1;}
              startGame = 'explore'
              Dungeon.dCounter = 0;
              btnYes.visible = false;
              btnNo.visible = false;
              Dungeon.status = 'normal';
              MusicEngine.stop();
              MusicEngine.playSFX('cancel')
              MusicEngine.play(4);
            }
            else if (this.foe == 'giant'){
              Dungeon.gd = 4;
              Dungeon.dCounter = 0;
            }
           //ONLINE//////////////////////////////
            else if (this.foe == 'pvp_cancel') {
              // 1. Reset My View
              Dungeon.status = 'normal';
              startGame = 'explore';
              Dungeon.isChallenger = false;
              btnNo.visible = false;
              
              // 2. Tell Server to cancel for the other guy
              socket.emit("battle_action", {
                  targetId: Dungeon.currentSpeaker.socketId,
                  actionType: "CHALLENGE_CANCEL",
                  payload: {} 
              });
            }
            
          else if (this.foe == 'pvp_deny') {
            // 1. Reset Me (The Receiver)
            Dungeon.status = 'normal';
            startGame = 'explore';
            
            // Hide buttons
            this.visible = false; 
            if (typeof btnYes !== 'undefined') btnYes.visible = false;

            // 2. Get the Challenger's ID (We saved this when we got the invite)
            let challengerId = Dungeon.currentSpeaker?.socketId;
            console.log("Rejecting Challenger ID:", challengerId); // <--- Add this
            if (challengerId) {
              // 3. SEND THE REJECTION SIGNAL
              socket.emit("battle_action", {
                targetId: challengerId,
                actionType: "CHALLENGE_REJECTED",
                payload: {} 
              });
            }
          }
          ///////////////////////////////////////////////
          break;
        case 3://btnAction, btnAction2
          if (this.type == 'arrow_left'){
            if(this.text == 'deck'){
              
                if (Player[attacker].deck.length > 1) {
                  if (Player[attacker].deck[Player[attacker].look[eLOOK.D]].location == 'scry') {
                    if (Player[attacker].look[eLOOK.D] - 1 < 0) {
                      Player[attacker].look[eLOOK.D] = Player[attacker].look[eLOOK.R] - 1; // Wrap to Scry Limit
                    } else {
                      Player[attacker].look[eLOOK.D] = Player[attacker].look[eLOOK.D] - 1;
                    }
                    Player[attacker].sendAction('SELECTION', { look: Player[attacker].look });
                  } else { // Standard Deck Cycle
                    if (Player[0].look[eLOOK.D] - 1 < 0) {
                      Player[0].look[eLOOK.D] = Player[0].deck.length - 1; // Wrap to Deck End
                    } else {
                      Player[0].look[eLOOK.D] = Player[0].look[eLOOK.D] - 1;
                    }
                  }
                }
              
              
            }
          }
    
          if (this.type == 'arrow_right'){
            if(this.text == 'deck'){
              
                if (Player[attacker].deck.length > 1) {
                  // FIX: Added quotes around 'scry' and fixed the index lookup
                  if (Player[attacker].deck[Player[attacker].look[eLOOK.D]].location == 'scry') {
                    if (Player[attacker].look[eLOOK.D] + 1 > Player[attacker].look[eLOOK.R] - 1) {
                      Player[attacker].look[eLOOK.D] = 0; // Wrap to Scry Start
                    } else {
                      Player[attacker].look[eLOOK.D] = Player[attacker].look[eLOOK.D] + 1;
                    }
                    Player[0].sendAction('SELECTION', { look: Player[0].look });
                  } else { // Standard Deck Cycle
                    if (Player[attacker].look[eLOOK.D] + 1 > Player[attacker].deck.length - 1) {
                      Player[attacker].look[eLOOK.D] = 0; // Wrap to Deck Start
                    } else {
                      Player[attacker].look[eLOOK.D] = Player[attacker].look[eLOOK.D] + 1;
                    }
                  }
                }
              
            }
          }
          
        break;
        case 4://btnAdd
          if (this.type == 'add_toHand'){
            if(this.text == 'deck'){
              let card = Player[attacker].deck.splice(Player[attacker].look[eLOOK.D], 1)[0];
              // 2. Set location and push the OBJECT (not the array) to hand
              if (card.type == 0){
                Player[attacker].unequip();
                Player[attacker].aMonster.length = 0;
                card.location = 'field';
                Player[attacker].aMonster.push(card);
              }
              else{
                card.location = 'hand';
                Player[attacker].hand.push(card);
              }
              Player[0].option = 7;
              Player[1].option = 7;
              for(let i=0;i<Player[attacker].deck.length;i++){	//reassign deck location 
                Player[attacker].deck[i].location = 'deck'
              }
              Player[attacker].sendAction('SCRY_ADD');
            }
          }
        break;
      }
    }, count * 200);
  }
  do(index){//execute button click
    switch(index){
      case 'mc'://menu close
        this.option = 0;
        break;
      case 'hm'://hand menu
        if (this.hand.length > 0){
          this.option = 1
        }
        break;
      case 'hra'://hand right arrow
        if(this.hand.length > 1){
          if (this.look[eLOOK.H] + 1 > this.hand.length-1){
            this.look[eLOOK.H] = 0;
          }
          else{
            this.look[eLOOK.H] = this.look[eLOOK.H] + 1;
          }
          if (this.option != 2){
            this.option = 1;
          }
        }
        break;
      case 'hla'://hand left arrow
        if (this.hand.length>1){
          if (this.look[eLOOK.H] - 1 < 0){
            this.look[eLOOK.H] = this.hand.length-1;
          }
          else{
            this.look[eLOOK.H] = this.look[eLOOK.H]-1;
          }
          if (this.option != 2){
            this.option = 1;
          }
        }
        break;
      case 'use'://hand use
        if (this.hand.length > 0){
          this.look[eLOOK.A] = this.hand[this.look[eLOOK.H]].type;
          this.option = 5;
        }
        break;
      case 'hex'://hand examine
        if (this.hand.length > 0){
          this.option = 2;
        }
      break;
      case 'hec'://hand examine close
        this.option = 1;
      break;
      case 'mmo'://monster menu
        if (this.aMonster.length>0){
          this.option =3;
        }
        break;
      case 'mra'://monster right arrow
        if (this.aMonster.length > 1){
          if (this.look[eLOOK.M] + 1 > this.aMonster.length-1){
            this.look[eLOOK.M] = 0;
          }
          else{
            this.look[eLOOK.M] = this.look[eLOOK.M]+1;
          }
          if (this.option != 4){
            this.option = 3;
          }
        }
        break;
      case 'mla'://monster left arrow
        
        break;
      case 'me'://monster examine
        if (this.aMonster.length > 0){
          this.option = 4;
        }
        break;
      case 'mec'://monster examine close
        this.option = 3;
      break;
      case 'atk':
        if (this.aMonster.length >0){
            this.option = 5;
            this.look[eLOOK.A] = 0;
        }
        break;
      case 'rex'://ready close
          this.look[eLOOK.A] = -1
          this.option = 0;
      break;
      }
  }
}

class Field{
  //ONLINE PARAMETER          //////HERE/////////////////////////
   constructor(foe,isCPU = 0,socketId = null,importedDeck = null){
    this.battleOpponentId = socketId; // <--- NEW: Store Opponent ID
    //////////
    
    this.foe = foe;  // player(0), foe(1) , examine(613)
   
    
    this.isCPU =isCPU;
      this.deck = [];
			this.hand = [];
      this.aMonster = [];
      this.draw = 0;					//value of 1 starts drawing animation
      this.equip = 0;
      this.option = 9;				//value of 1 displays option menu
      this.view;
      this.look = [0,0,0,0,-1,0,-1,0,0];//F:0(field),D:1(deck),M:2(monster),H:3(hand),A:4(action),R:5(dice roll),P:6(stone)
      this.d2 = new Dice('d2');
      this.d4 = new Dice('d4');
      this.d6 = new Dice('d6');
      this.d8 = new Dice('d8');
      this.d10 = new Dice('d10');
      this.d12 = new Dice('d12');
      this.d20 = new Dice('d20');
      this.timer = 0;
      this.ax = 0;
      this.ay = 0;
      this.az = 1;
      this.at = 0;
      this.mOpt = 0;
      this.preOpt = 0;
      this.respawn = 0;
      this.defStat = 1;
      this.hasWingedBoots = 0;
      this.hasStarPendant = 0;
      this.hasScalesOfJustice = 0;
      this.hasTreasureChest = 0;
      this.hasLovers = 0;
      this.hasBind = 0;
      this.hasLunacy = 0;
      this.hasProtectOrb = 0;
      this.hasAmulet = 0;
      this.hasLuckyCharm = 0;
      this.hasIntimidate = 0;
      this.diceType = 0;
      this.turnOrder = 0;
      this.turnCurrent = 0;
      this.runeStat = [0,0,0,0];
      this.statPoints = 0;
      this.cleanupsent = 0;
      this.hasReroll = 0;
      //ONLINE
   if (importedDeck && importedDeck.length > 0) {
      for (let i = 0; i < importedDeck.length; i++) {
        // Handle both simple IDs (integers) or Card objects
        let cardID = (typeof importedDeck[i] === 'object') ? importedDeck[i].index : importedDeck[i];
        
        let newCard = new Card(cardID, foe);
        newCard.locIndex = i;
        newCard.locCount = i;
        newCard.location = 'deck';
        this.deck.push(newCard);
      }
    } 
    //////////////////////////////////////
    // Offline
    else {
      //get cards
        for (let cardIndex = 0; cardIndex < 78; cardIndex++) {
            const newCard = new Card(cardIndex, foe);
            newCard.locIndex = cardIndex;
            newCard.locCount = cardIndex;
            newCard.location = 'deck';
            this.deck.push(newCard);
        }
        // Shuffle
        let currentIndex = this.deck.length;
        let randomIndex;
        while (currentIndex !== 0) {
            randomIndex = Math.floor(Math.random() * currentIndex);
            currentIndex--;
            [this.deck[currentIndex], this.deck[randomIndex]] = [
                this.deck[randomIndex], this.deck[currentIndex]
            ];
            this.deck[currentIndex].locIndex = currentIndex;
        }
    }
  }//end constructor
   
  //ONLINE
 sendAction(actionType, payload = {}) {
      // 1. Only Human Players send data (isCPU === 0)
      // 2. Only send if we have a valid opponent ID
      if (this.isCPU === 0 && this.battleOpponentId) {
          if (typeof socket !== 'undefined') {
              console.log(`[Send] ${actionType} to ${this.battleOpponentId}`, payload);
              socket.emit("battle_action", {
                  targetId: this.battleOpponentId,
                  actionType: actionType,
                  payload: payload
              });
          }
      }
  }
  sync(data) {
         this.draw = data.draw;					//value of 1 starts drawing animation
      this.equip = data.equip;
      this.option = data.option;				//value of 1 displays option menu
      this.view=data.view;
      this.look = data.look;//F:0(field),D:1(deck),M:2(monster),H:3(hand),A:4(action),R:5(dice roll),P:6(stone)
      this.d2 = data.d2;
      this.d4 = data.d4;
      this.d6 = data.d6;
      this.d8 = data.d8;
      this.d10 = data.d10;
      this.d12 = data.d12;
      this.d20 = data.d20;
      this.timer = data.timer;
      this.ax = data.ax;
      this.ay = data.ay;
      this.az = data.az;
      this.at = data.at;
      this.mOpt = data.mOpt;
      this.preOpt = data.preOpt;
      this.respawn = data.respawn;
      this.defStat = data.defStat;
      this.hasWingedBoots = data.hasWingedBoots;
      this.hasStarPendant = data.hasStarPendant;
      this.hasScalesOfJustice = data.hasScalesOfJustice;
      this.hasTreasureChest = data.hasTreasureChest;
      this.hasLovers = data.hasLovers;
      this.hasBind = data.hasBind;
      this.hasLunacy = data.hasLunacy;
      this.hasProtectOrb = data.hasProtectOrb;
      this.hasAmulet = data.hasAmulet;
      this.hasLuckyCharm = data.hasLuckyCharm;
      this.hasIntimidate = data.hasIntimidate;
      this.diceType = data.diceType;
      this.turnOrder = data.turnOrder;
      this.turnCurrent = data.turnCurrent;
      this.runeStat = data.runeStat;
      this.statPoints = data.statPoints;
      this.cleanupsent = data.cleanupsent;
      this.hasReroll = data.hasReroll;
    }
  getSyncData() {
        return {
            // Core Stats
            option: this.option,       // Current State (Case 6, 7, etc)
            turnOrder: this.turnOrder,
            turnCurrent: this.turnCurrent,
            
            // Visuals
            look: this.look,           // Your dice results/stat choices
            diceType: this.diceType,
            
            // Animation Timers (To sync movements)
            at: this.at,
            ay: this.ay,
            az: this.az,
            
            // Flags
            hasRolled: this.hasRolled,
            hasScalesOfJustice: this.hasScalesOfJustice,
            
          draw:this.draw ,					//value of 1 starts drawing animation
          equip:this.equip ,
          view:this.view,
          d2:this.d2 ,
          d4:this.d4 ,
          d6:this.d6 ,
          d8:this.d8 ,
          d10:this.d10 ,
          d12:this.d12,
          d20:this.d20 ,
          timer:this.timer ,
          ax:this.ax ,
          
          mOpt:this.mOpt,
          preOpt:this.preOpt,
          respawn:this.respawn,
          defStat:this.defStat,
          hasWingedBoots:this.hasWingedBoots,
          hasStarPendant:this.hasStarPendant,
          hasScalesOfJustice:this.hasScalesOfJustice,
          hasTreasureChest:this.hasTreasureChest,
          hasLovers:this.hasLovers,
          hasBind:this.hasBind ,
          hasLunacy:this.hasLunacy ,
          hasProtectOrb:this.hasProtectOrb ,
          hasAmulet:this.hasAmulet,
          hasLuckyCharm:this.hasLuckyCharm ,
          hasIntimidate:this.hasIntimidate,
          diceType:this.diceType,
          runeStat:this.runeStat,
          statPoints:this.statPoints ,
          cleanupsent:this.cleanupsent,
          hasReroll:this.hasReroll,
        };
    }
  //CPU
  getWinChance(myStat, oppStat, myMonObj = null, oppMonObj = null) {
    // 1. Determine who we are calculating for (Real vs Virtual)
    let attacker = myMonObj || Player[1].aMonster[0];
    let defender = oppMonObj || Player[1].opponent.aMonster[0];

    // Safety check
    if (!attacker || !defender) return 0; 

    let wins = 0;
    let iterations = 50; // Keep low for performance during simulation loops

    for (let i = 0; i < iterations; i++) {
        // Simulate Attacker Roll (using the passed object's stats)
        let myMin = attacker.stat[myStat][eDICE.MIN]; 
        let myMax = attacker.stat[myStat][eDICE.MAX]; 
        let myMod = attacker.stat[myStat][eDICE.MOD];
        let myRoll = Math.floor(Math.random() * (myMax - myMin + 1) + myMin) + myMod;

        // Simulate Defender Roll
        let opMin = defender.stat[oppStat][eDICE.MIN]; 
        let opMax = defender.stat[oppStat][eDICE.MAX];
        let opMod = defender.stat[oppStat][eDICE.MOD]; 
        let opRoll = Math.floor(Math.random() * (opMax - opMin + 1) + opMin) + opMod;

        if (myRoll > opRoll) wins++;
    }
    return wins / iterations;
}
  getVirtualMonster(realMonster) {
      return JSON.parse(JSON.stringify(realMonster)); 
  }
  getDeckCount(targetIndex = null, type = null) {
      let count = 0;
      for (let card of Player[1].deck) {
          if (targetIndex !== null && card.index === targetIndex) count++;
          if (type !== null && card.type === type) count++;
      }
      return count;
  }
  getCardPower(index) {
    switch (index) {
        // --- S TIER (Game Changers) ---
        case 21: return 100; // Crown (Autowin equip)
        case 13: return 95;  // Death (Unblockable kill)
        case 44: return 95;  // Djinn Lamp (Search ANY card)
        case 20: return 90;  // Horn of Judgement (Board wipe - high potential if losing)
        case 73: return 85;  // Inheritance (Buffed monster swap)

        // --- A TIER (High Impact Kills & Equips) ---
        case 66: return 80;  // Armor (+3 CON)
        case 7:  return 80;  // Winged Boots (+3 AGI)
        case 72: return 80;  // Magic Ring (+1 All)
        case 26: return 75;  // Fire (Kill)
        case 51: return 75;  // Overpower (Kill)
        case 52: return 75;  // Backstab (Kill)
        case 59: return 75;  // Critical Strike (Kill)
        case 39: return 75;  // Dragon Wing (Disrupt opponent monster)

        // --- B TIER (Strong Control & Utility) ---
        case 12: return 65;  // Bind (Turn skip)
        case 58: return 65;  // Intimidate (Turn skip)
        case 18: return 60;  // Lunacy (Silence)
        case 10: return 60;  // Treasure Chest (Draw engine)
        case 30: return 60;  // Protect Orb (Defensive swap)
        case 17: return 55;  // Star Pendant (Reroll)

        // --- C TIER (Average Stuff) ---
        // Basic Equips (Sword, Wand, Shield, Hourglass)
        case 50: case 22: case 64: case 36: return 40; 
        
        // Search Cards themselves (Scry, Forge)
        // Their value is dynamic, but they have a base baseline utility
        case 24: case 71: return 45; 

        // --- D TIER (Situationally Weak) ---
        case 0:  return 20;  // Fool (Weak stats)
        case 53: return 30;  // Camp (Basic draw)
        
        // DEFAULT
        default: return 35; // Most monsters/items fall here
    }
}
  getDeckPotential() {
    if (Player[1].deck.length === 0) return 0;

    let totalPower = 0;
    
    for (let i = 0; i < Player[1].deck.length; i++) {
        // Use the helper we just made
        totalPower += Player[1].getCardPower(Player[1].deck[i].index);
    }

    // Return the Average (e.g., 65 means a deck full of B+ cards)
    return totalPower / Player[1].deck.length;
}
  getDangerLevel() {
      let me = Player[1].aMonster[0];
      let opp = Player[1].opponent.aMonster[0];
      if (!me || !opp) return false;

      // Compare Opponent's MAX Attack vs My CURRENT Constitution
      // This assumes standard STR vs CON combat
      let oppMaxAtk = opp.stat[0][1] + opp.stat[0][2]; // Max STR + Mod
      let myMaxDef = me.stat[1][1] + me.stat[1][2];   // Max CON + Mod

      // If their max hit is significantly higher than our average defense, we are in danger.
      return oppMaxAtk > (myMaxDef * 0.8); 
  }
  getOpponentDeckPotential() {
      // Access the opponent's deck via the opponent object
      let oppDeck = Player[1].opponent.deck; 
      
      if (!oppDeck || oppDeck.length === 0) return 0;

      let totalPower = 0;
      
      for (let i = 0; i < oppDeck.length; i++) {
          // Reuse the power grader we made earlier
          totalPower += Player[1].getCardPower(oppDeck[i].index);
      }

      return totalPower / oppDeck.length; // Returns 0-100 (High = Danger Coming)
  }
  simulateCardImpact(cardIndex) {
        let card = Player[1].hand[cardIndex];
        
        // 1. Snapshot Current Reality (STR vs CON is the default battle state)
        let currentChance = Player[1].getWinChance(0, 1); 
        
        // 2. Create Virtual Universe
        let vMyMonster = Player[1].getVirtualMonster(Player[1].aMonster[0]);
        let vOppMonster = Player[1].getVirtualMonster(Player[0].opponent.aMonster[0]);

        // 3. Apply Card Effects to Virtual Monsters
        if (card.type === 1 && card.subType === 3) {
          if (card.passiveStats) {
            for(let s = 0; s < 4; s++) {
              vMyMonster.stat[s][2] += card.passiveStats[s];
            }
          }
        }
        
        // --- SPELLS / DEBUFFS (Type 2) ---
        else if (card.type === 2) {
            // Curse (15): Lowers all stats by difference in INT [cite: 119]
            if (card.index === 15) {
                // Estimate roll outcome using Averages (Max+Min)/2
                let myIntAvg = (vMyMonster.stat[2][0] + vMyMonster.stat[2][1]) / 2 + vMyMonster.stat[2][2];
                let oppIntAvg = (vOppMonster.stat[2][0] + vOppMonster.stat[2][1]) / 2 + vOppMonster.stat[2][2];
                
                if (myIntAvg > oppIntAvg) {
                    let penalty = Math.floor(myIntAvg - oppIntAvg);
                    // Apply penalty to opponent's virtual stats
                    for(let s=0; s<4; s++) vOppMonster.stat[s][2] -= penalty;
                }
            }
        }

        // 4. Calculate Future Win Chance using the Virtual Monsters
        // We pass vMyMonster and vOppMonster to the refactored getWinChance
        let futureChance = this.getWinChance(0, 1, vMyMonster, vOppMonster);

        // 5. Calculate Score
        // If we are currently losing (chance < 0.4) and this makes us win, value it highly
        let improvement = futureChance - currentChance;
        let score = improvement * 100;

        // "Vanquish" Check: If this card guarantees a win (95%+), prioritize it heavily
        if (futureChance >= 0.95 && currentChance < 0.8) {
            score += 200; 
        }
        
        // Base value: Even if improvement is low, playing a card usually has some utility value
        // This prevents the AI from doing nothing if improvement is 0.01%
        if (score > 0) score += 20;

        return score;
    }
  cpuTurn() {
      if (Player[1].aMonster.length === 0) return;

      
   
      // --- 1. PERMISSION CHECKS ---
      // Determine exactly what the CPU is allowed to do based on status
      let hasIntimidate = (Player[1].hasIntimidate > 0);
      let hasLunacy = (Player[1].hasLunacy > 0);
      let hasBind = (Player[1].hasBind > 0);

      // Intimidate: No Attack, No Spells
      // Lunacy: No Spells, No Items
      // Bind: No Items, No Attack
      let canAttack = !hasIntimidate && !hasBind;
      let canCast = !hasIntimidate && !hasLunacy;
      let canUseItem = !hasLunacy && !hasBind;

      // --- 2. ANALYZE STATE ---
      let myMonster = Player[1].aMonster[0];
      let danger = Player[1].getDangerLevel(); 
      let myDeckPotential = Player[1].getDeckPotential(); 
      let oppThreat = Player[1].getOpponentDeckPotential(); 

      // --- 3. ESTABLISH BASELINE (The Attack Score) ---
      let bestAction = { type: 0, index: -1, score: -100 }; // Default to very low

      if (canAttack) {
          let attackWinChance = Player[1].getWinChance(0, 1);
          
          // Default: Value attack at 70% of raw win chance
          let attackScore = (attackWinChance * 70); 

          // Logic: If attack is a guaranteed kill (>90%), prioritize it
          if (attackWinChance > 0.9) attackScore = 200; 

          // Logic: Aggression Bonus if opponent is casting
          if (Player[1].opponent.look[4] > 0) attackScore += 30;

          // Set this as the beat-able baseline
          bestAction.score = attackScore;
      } else {
          // If we can't attack, the "Attack Action" effectively has a score of -100.
          // Any valid card play will beat this. 
          // If no cards are valid, we stick with this, effectively passing the turn.
          bestAction.score = -100;
      }

      // --- 4. EVALUATE HAND ---
      for (let i = 0; i < Player[1].hand.length; i++) {
          let card = Player[1].hand[i];
          let score = 0;

          // --- CRITICAL: SKIP ILLEGAL MOVES ---
          // If we are silenced/bound/intimidated, skip cards we can't use
          if (card.type === 2 && !canCast) continue; // Spell check
          if (card.type === 1 && !canUseItem) continue; // Item check

          // --- HAND PRESSURE BONUS ---
          score += (Player[1].hand.length * 5);
          score += 10; // Utility bias

          // --- LOGIC A: Disruption ---
          if (card.index === 40 || card.index === 39 || card.index === 16) {
              if (oppThreat > 60) score += 50;
              if (card.index === 39) {
                  let currentOppPower = Player[1].getCardPower(Player[1].opponent.aMonster[0].index);
                  if (currentOppPower > oppThreat) score += 40; else score -= 30;
              }
          }

          // --- LOGIC B: Searching ---
          else if (card.index === 10 || card.index === 24 || card.index === 71) {
              score += myDeckPotential; 
              if (myMonster.index === 3 || myMonster.index === 77) score += 20; 
              if (danger) score -= 100; 
              if (card.index === 10) {
                  let monstersInHand = Player[1].hand.filter(c => c.type === 0).length;
                  if (monstersInHand === 0) score += 50; 
              }
          }

          // --- LOGIC C: Standard Tactics ---
          // NOTE: Ensure your subTypes match! (Integers vs Strings)
          else if (card.subType === 3 || card.subType === 'debuff' || card.subType === 5) {
              let simScore = Player[1].simulateCardImpact(i);
              score += simScore;
              score += (Player[1].getCardPower(card.index) * 0.3); 
          }
          
          // --- LOGIC D: Specific Cards ---
          else if (card.index === 70) { 
              if (myMonster.stat[1][1] >= 8 && !danger) score += 50;
          }
          else if (card.index === 44) {
              let maxPowerInDeck = 0;
              for(let c of Player[1].deck) maxPowerInDeck = Math.max(maxPowerInDeck, Player[1].getCardPower(c.index));
              score += maxPowerInDeck;
          }

          // --- LOGIC E: Stalemate Breaker ---
          // Only relevant if we CAN attack but it's risky
          if (canAttack) {
             let currentWinChance = Player[1].getWinChance(0, 1);
             if (currentWinChance > 0.4 && currentWinChance < 0.6) {
                 if (card.type === 1 || card.type === 2) score += 15;
             }
          }

          // --- SELECTION ---
          if (score > bestAction.score) {
              bestAction.score = score;
              bestAction.type = card.type;
              bestAction.index = i;
          }
      }

      // --- 5. EXECUTE (Always runs) ---
      // If we are fully locked (bestAction is still -100), we send 0/-1.
      // The game engine will process this as a turn attempt, see the Bind/Intimidate,
      // and proceed to the next turn correctly.
      if (bestAction.type === 0 && bestAction.index === -1) {
          Player[1].look[eLOOK.A] = 0; 
          Player[1].look[eLOOK.H] = -1;
      } else {
          Player[1].look[eLOOK.H] = bestAction.index;
          Player[1].look[eLOOK.A] = Player[1].hand[bestAction.index].type;
      }
      
      // Triggers the game state update to prevent freezing
      Player[1].option = 5; 
  }
  cpuRuneSelect() {
      // 1. VICTORY CHECK: Do I already have 3 runes? If so, grab the 4th to win immediately.
      let myRunes = 0;
      let missingRune = -1;
      
      // Check which runes I own
      if (sRune.owner === Player[1].foe) myRunes++; else missingRune = eSTAT.S;
      if (cRune.owner === Player[1].foe) myRunes++; else missingRune = eSTAT.C;
      if (iRune.owner === Player[1].foe) myRunes++; else missingRune = eSTAT.I;
      if (aRune.owner === Player[1].foe) myRunes++; else missingRune = eSTAT.A;

      // If I have 3, targeting the missing one is Priority #1
      if (myRunes === 3 && missingRune !== -1) {
          Player[1].look[eLOOK.S] = missingRune;
          return;
      }

      // 2. AVAILABILITY: Identify which runes are actually takable.
      // Rule: Take from Table (2) first. If Table empty, steal from Opponent.
      let available = [];
      
      // Check Table
      if (sRune.owner === 2) available.push(eSTAT.S);
      if (cRune.owner === 2) available.push(eSTAT.C);
      if (iRune.owner === 2) available.push(eSTAT.I);
      if (aRune.owner === 2) available.push(eSTAT.A);

      // If Table is empty, check Opponent (The "Steal" phase)
      if (available.length === 0) {
          if (sRune.owner === Player[1].opponent.foe) available.push(eSTAT.S);
          if (cRune.owner === Player[1].opponent.foe) available.push(eSTAT.C);
          if (iRune.owner === Player[1].opponent.foe) available.push(eSTAT.I);
          if (aRune.owner === Player[1].opponent.foe) available.push(eSTAT.A);
      }

      // Safety fallback (shouldn't happen unless logic error)
      if (available.length === 0) { 
          Player[1].look[eLOOK.S] = eSTAT.S; 
          return; 
      }

      // 3. STRATEGY: Buff my weakest stat
      // If I have multiple options, pick the one where my current monster is weakest.
      // e.g. If my monster has 1d4 CON, I desperately want the CON rune.
      let bestRune = available[0];
      let lowestStatVal = 999;

      if (Player[1].aMonster.length > 0) {
          for (let i = 0; i < available.length; i++) {
              let statType = available[i];
              // Check my monster's MAX potential for this stat
              let myVal = Player[1].aMonster[0].stat[statType][eDICE.MAX];
              
              if (myVal < lowestStatVal) {
                  lowestStatVal = myVal;
                  bestRune = statType;
              }
          }
      }

      // Lock in the selection
      this.look[eLOOK.S] = bestRune;
    }
  cpuHandleReroll() {
    let myRoll = Player[1].look[eLOOK.R];
    let oppRoll = Player[1].opponent.look[eLOOK.R];
    let shouldReroll = false;

    // 1. CONTEXT CHECK
    // Are we in a contested roll? (Initiative, Attack, Defend, Debuff)
    // Most rolls in this game are contested.
    // Exception: Self-Buffs (Strength Spell) or non-combat items.
    
    let isContested = true;
    if (Player[1].option === 7 && Player[1].hand.length > 0 && Player[1].look[eLOOK.H] < Player[1].hand.length) {
        // If using a card, check if it's a buff
        if (Player[1].hand[Player[1].look[eLOOK.H]].subType === 'buff') isContested = false;
    }

    // 2. DECISION LOGIC
   
        // If I am strictly losing or tied, REROLL.
        // (This makes the CPU very annoying/challenging to fight)
        //defense
        if (Player[1].option === 7){
          if (myRoll < oppRoll) {
            shouldReroll = true;
          }
        }
        //attack or agi
        if (Player[1].option === 7||(Player[1].option === 6&&myRoll<(Player[1].diceType * .75))){
          if (myRoll <= oppRoll) {
            shouldReroll = true;
          }
          if(Player[1].hasLuckyCharm == 1&&myRoll==oppRoll){shouldReroll = false}
        }
     

    // 3. EXECUTE
    // Find the Star Pendant to mark it as triggered
    let pendantIndex = -1;
    for (let i = 0; i < this.aMonster.length; i++) {
        if (Player[1].aMonster[i].index == 17 && Player[1].aMonster[i].effectTriggered == 0) {
            pendantIndex = i;
            break;
        }
    }

    if (pendantIndex !== -1) {
        Player[1].aMonster[pendantIndex].effectTriggered = 1; // Mark used
        
        if (shouldReroll) {
            // YES: Reset timers to 0 to trigger the re-animation and re-roll
            this.ax = 0; this.ay = 0; this.az = 0; this.at = 0;
            Player[1].option = Player[1].preOpt; // Go back to action
        } else {
            // NO: Just go back without resetting timers (keeps the current roll)
            Player[1].option = Player[1].preOpt; 
        }
    }
  }
  //UI HELPERS
  setDice(type,x,y,z,r,dt){
    if(type==4){this.d4.animate(x,y,z*1.5,r,dt);}
    if(type==6){this.d6.animate(x,y,z*1.5,r,dt);}
    if(type==8){this.d8.animate(x,y,z,r,dt);}
    if(type==10){this.d10.animate(x,y,z,r,dt);}
    if(type==12){this.d12.animate(x,y,z,r,dt);}
    if(type==20){this.d20.animate(x,y,z,r,dt);}
  }
  flip(){
    ctx.translate(wX/2,wY/2);
    ctx.rotate(Math.PI);
    ctx.translate(-wX/2,-wY/2);
  } 
  //GAMEPLAY FUNCTIONS
  react(dt){
    
    if (Player[1].isCPU === 1 && Player[1].opponent.option === 5 && Player[1].option !== 5) {
        Player[1].cpuTurn();
    }
    if (this.foe == 1){this.flip()}
    let tick = 30 * dt
    const SPEED_Y = 6 * dt; 
    const SPEED_Z = 3 * dt; 
    ctx.textAlign= 'left';
    let elem = 0;
    let debug = 0;
    if( debug == 1){
      drawText(0,1,1,.25,'P[A]:' + Player[0].look[eLOOK.A],'white',1);//Players intended action
      drawText(0,1.25,1,.25,'P[H]:' + Player[0].look[eLOOK.H],'white',1);//Current focus in hand
      drawText(0,1.5,1,.25,'P[M]:' + Player[0].look[eLOOK.M],'white',1);//current focus in monster field
      drawText(0,1.75,1,.25,'P[R]:' + Player[0].look[eLOOK.R],'white',1);//focused on rune
      drawText(0,2,1,.25,'F[A]:' + Player[1].look[eLOOK.A],'white',1);
      drawText(0,2.25,1,.25,'F[H]:' + Player[1].look[eLOOK.H],'white',1);
      drawText(0,2.5,1,.25,'F[M]:' + Player[1].look[eLOOK.M],'white',1);
      drawText(0,2.75,1,.25,'F[R]:' + Player[1].look[eLOOK.R],'white',1);
      drawText(0,3.25,1,.25,'FO:' + Player[1].option,'white',1);//foe's current phase
      drawText(0,3,1,.25,'PO:' + Player[0].option,'white',1);
      drawText(0,3.5,1,.25,'Pat:' + Player[0].at,'white',1);//ani timer state
      drawText(0,3.75,1,.25,'Fat:' + Player[1].at,'white',1);
      drawText(0,4,1,.25,'SG:' + startGame,'white',1);
      drawText(0,4.25,1,.25,'FDeck:' + Player[1].deck.length,'white',1);
      drawText(0,4.5,1,.25,'ppO:' + Player[0].preOpt,'white',1);
      drawText(0,4.75,1,.25,'fpO:' + Player[1].preOpt,'white',1);
      drawText(0,5,1,.25,'atk:' + attacker,'white',1);
      drawText(0,5.25,1,.25,'def:' + defender,'white',1);
      drawText(0,5.5,1,.25,'psoj:' + Player[0].hasScalesOfJustice,'white',1);
      drawText(0,5.75,1,.25,'fsoj:' + Player[1].hasScalesOfJustice,'white',1);
    }
      switch(this.option){
        case 0:
          let runeQTY = 4;//total number of runes
          let rcount = 0; //count runes
          let winning = 0;
          for (let i = 0;i<Player.length;i++){
            if (sRune.owner == Player[i].foe) {sRune.changeOwner(Player[i].foe)}
            if (cRune.owner == Player[i].foe) {cRune.changeOwner(Player[i].foe)}
            if (iRune.owner == Player[i].foe) {iRune.changeOwner(Player[i].foe)}
            if (aRune.owner == Player[i].foe) {aRune.changeOwner(Player[i].foe)}
            if (sRune.owner == Player[i].foe) {rcount = rcount+1;}
            if (cRune.owner == Player[i].foe) {rcount = rcount+1;}
            if (iRune.owner == Player[i].foe) {rcount = rcount+1;}
            if (aRune.owner == Player[i].foe) {rcount = rcount+1;}
            winning = rcount;
            //player won
             if ((rcount == runeQTY&&i==0)||(Player[1].deck.length==0&&Player[1].aMonster.length==0)){Player[1].option = 10.1;Player[0].option = 10;}
             //foe won
             else if ((rcount == runeQTY&&i==1)||(Player[0].deck.length==0&&Player[0].aMonster.length==0)){Player[i].option = 10.2;Player[0].option = 10;}
             rcount = 0;
          }
         
           
          
          if (startGame == 4||startGame == 6){
            //cpu winning
             if (this.foe == 0&&this.option != 10){
            
                song = rnd(0,3);
                if (song == 0){
                  MusicEngine.stop();
                  MusicEngine.play(0);
                }
                if (song == 1){
                  MusicEngine.stop();
                  MusicEngine.play(4);
                }
                if (song == 2){
                  MusicEngine.stop();
                  MusicEngine.play(21);
                }    
                if (song == 3){
                  MusicEngine.stop();
                  MusicEngine.play(28);
                }    
              
              startGame = 5;
             }
          }
          break;
        case 1://hand menu visible
          drawPortrait(-22,this.hand[0].x + this.hand[0].l/1.39,5.68,.066);//eye Icon
          drawText(this.hand[this.look[eLOOK.H]].x +this.hand[0].l/1.63,5.33,1.5,1,'Examine','white',.8);//EXAMINE TEXT

          drawPortrait(-21,this.hand[0].x *.96,5.68,.066);//Use/Cast icon
          drawText(this.hand[this.look[eLOOK.H]].x-.05 ,5.33,1,1,'Use','white',.66);//USE/CAST TEXT
         break;
        case 2://hand examine
          drawShape('rec',0,0,1,0,0,10,10,0,0,0,0,'rgba(0,0,0,.75)',1);
          this.cardID(this.hand[0+this.look[eLOOK.H]].index)
         break;
        case 3://monster menu visible
         drawPortrait(-22,this.aMonster[0].x + this.aMonster[0].l/1.39,5.68,.066);//eye icon
         drawText(this.aMonster[0].x +this.aMonster[0].l/1.63,5.39,1.5,1,'Examine','white',.75);
         if (this.aMonster[this.look[eLOOK.M]].type == 0&&this.isCPU == 0){
         drawPortrait(-15,this.aMonster[0].x*.99,5.68,.066);//attack icon
         drawText(this.aMonster[this.look[eLOOK.M]].x -.15,5.39,1.13,1,'Attack','white',.75);}
         break;
        case 4://monster examine
          if (this.isCPU==1){this.flip();}///half the size of examine because player ready half screen taken
          drawShape('rec',0,0,1,0,0,10,10,0,0,0,0,'rgba(0,0,0,.75)',1);
          this.cardID(this.aMonster[0+this.look[eLOOK.M]].index)
          if (this.isCPU==1){this.flip();}
          break;
        case 5://ready
          //Draw Graphics
          if (Player[1].isCPU == 1){} 
          else{
            if(Player[0].preOpt != 6&&Player[0].preOpt != 7){
              drawShape('rec',0,5,1,0,0,10,5,0,0,0,0,'rgba(0,0,0,.9)',1);
              if (this.look[eLOOK.A] >0) {this.hand[this.look[eLOOK.H]].place(1,6,1);}
              else{if (this.look[eLOOK.A] == 0){this.aMonster[0].place(1,6,1);}}
            }
            else{
              drawShape('rec',0,5,1,0,0,10,5,0,0,0,0,'rgba(0,0,0,.9)',1);
              this.aMonster[0].place(1,6,1);
            }
            drawText(4,5.5,4,1,'Player Ready','green',1.5);
            drawPortrait (-3,4.5,6,.4);
            drawText(1.755,5,1,1,'X','white',1.25);
          }
         //Check if both ready to start AGI roll
         if (!Player[1].battleOpponentId){
          if(this.foe == 0 && this.option == 5&&this.opponent.option == 5&&Player[0].preOpt != 6&&Player[0].preOpt != 7){
            this.option = 6;this.opponent.option = 6;
            
          }
          else if(this.foe == 0 && this.option == 5&&this.opponent.option == 5&&Player[0].preOpt == 6){
            this.option = 6;this.opponent.option = 6;
           
                 
          }
          else if(this.foe == 0 && this.option == 5&&this.opponent.option == 5&& Player[0].preOpt==7){
            this.option = 7;this.opponent.option = 7;
            if ((Player[0].at >= 31&&Player[0].at <69)){Player[0].at = 69;}
                  
          }
        }
        else{
          if (Dungeon.isChallenger) {
            //FROM INITIAL READY STATE
            if (Player[0].option === 5 && Player[1].option === 5&&Player[0].preOpt != 6&&Player[0].preOpt != 7) {
              console.log("Both players ready! Triggering AGI CHECK...");
              
             Player[0].option = 6;Player[1].option = 6;Player[0].at = 0;
              Player[0].sendAction('PHASE_CHANGE', { option: 6 });
              Player[0].sendAction('FORCE_OPPONENT_OPTION', { option: 6 });
              Player[0].sendAction('SYNC_AT', { at: 0 });
            
            }
            //FROM AGI CHECK
           else  if (Player[0].option === 5 && Player[1].option === 5&&Player[0].preOpt == 6) {
              console.log("Both players ready! CONTINUING FROM AGI CHECK...");
              Player[0].option = 6;Player[1].option = 6;Player[0].at = 69
              Player[0].sendAction('PHASE_CHANGE', { option: 6 });
              Player[0].sendAction('FORCE_OPPONENT_OPTION', { option: 6 });
              Player[0].sendAction('SYNC_AT', { at: 69 });
             
            
            }
            //FROM COMBAT
            else if (Player[0].option === 5 && Player[1].option === 5 && Player[0].preOpt==7) {
              console.log("Both players ready! CONTINUING COMBAT...");
                Player[0].option = 7;Player[1].option = 7;
                  Player[0].at = Player[0].at+38;
                  
                
                Player[0].sendAction('PHASE_CHANGE', { option: 7 });
                Player[0].sendAction('FORCE_OPPONENT_OPTION', { option: 7 });
                Player[0].sendAction('SYNC_AT', { at: Player[0].at+38 });
                
              
              
            }
          }
        }
         break;
        case 6://AGI Check
          if (startGame == 5||startGame == 7){
            song = rnd(1,5);
            if (song == 0){
              MusicEngine.stop();
              MusicEngine.play(5);
            }
            if (song == 1){
              MusicEngine.stop();
              MusicEngine.play(15);
            }
            if (song == 2){
              MusicEngine.stop();
              MusicEngine.play(16);
            }
            if (song == 3){
              MusicEngine.stop();
              MusicEngine.play(25);
            }    
            if (song == 4){
              MusicEngine.stop();
              MusicEngine.play(26);
            }    
            if (song == 5){
              MusicEngine.stop();
              MusicEngine.play(27);
            }   
            startGame = 6;
          }
          Player[0].aMonster[0].place(3.88,5.5,1);//draw card in center
          drawPortrait(-14,9,9,.1);//draw hourglass
          drawPortrait(-14,0,9,.1);//draw hourglass
          this.flip()
          Player[1].aMonster[0].place(3.88,5.5,1);//draw card in center
          drawPortrait(-14,9,9,.1);//draw hourglass
          drawPortrait(-14,0,9,.1);//draw hourglass
          this.flip()

          if(this.at <30){this.at = this.at+tick;} //animation timer tick
          if (this.at >= 30 && this.at < 69){this.at = 31}
                    

          for (let i = 0;i<Player.length;i++){
            Player[i].diceType = Player[i].aMonster[0].stat[eSTAT.A][eDICE.MAX];
          }

          //step 1. up and closer like flipping coin ay = animation y and az = animation z. 
          if (this.ay < 3 && this.at <=30){this.ay = this.ay+SPEED_Y;this.az = this.az + SPEED_Z;}
          //step2.Dice Falls
          if (this.ay >=3 && this.az !=1 && this.at<=30){this.az = this.az -SPEED_Z;}
          //step 4.Dice Stops
          if (this.ay >=3 && this.az ==1 && this.at<=30){
            for (let i = 0;i<Player.length;i++){
              Player[i].setDice(Player[i].diceType,8,6,1,.001,dt)
              drawText(7.7,5.6,1,1,''+Player[i].look[eLOOK.R],'white',1);
            }
            
          }
          //step 3.Dice Animate
          else{if (this.at < 30){
            Player[0].setDice(Player[0].diceType,8,9-this.ay,this.az,99,dt)
            this.flip()
            Player[1].setDice(Player[1].diceType,8,9-this.ay,this.az,99,dt)
            this.flip()
          if (Dungeon.isChallenger == true||!Player[1].battleOpponentId) {           
             for (let i = 0;i<Player.length;i++){
              Player[i].look[eLOOK.R] = 0;
              Player[i].look[eLOOK.R]=Player[i].aMonster[0].rollStat(3);
            }
          }
          }
          }
          //show result of roll and announce turns
          if (this.at > 30){
           if (!this.rollSent&&Dungeon.isChallenger) {
                Player[0].sendAction('DICE_RESULT', {
                    p0_roll: Player[0].look[eLOOK.R], // My result
                    p1_roll: Player[1].look[eLOOK.R], // Opponent result
                    diceType: Player[0].diceType      // Sync dice type
                });
                this.rollSent = 1;
            }
            //DICE STOP
            Player[0].setDice(Player[0].diceType,8,6,1,.001,dt);
            drawText(7.7,5.6,1,1,''+Player[0].look[eLOOK.R],'white',1);
            this.flip()
            Player[1].setDice(Player[1].diceType,8,6,1,.001,dt);
            drawText(7.7,5.6,1,1,''+Player[1].look[eLOOK.R],'white',1);
            this.flip()
           
            
            if ((this.at>=31&& this.at < 69) && this.opponent.option != 6.1){
              if(this.opponent.isCPU == 0){
                drawText(0,9.5,10,.5,"Tap Screen To Continue",`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)})`,1,'center');
                this.flip()
                drawText(0,9.5,10,.5,"Tap Screen To Continue",`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)})`,1,'center');
                this.flip()
              }
              else{
                drawText(2.15,4.75,6,1,"Tap Screen To Continue",`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)})`,1);
              }
            }
              
              if (this.look[eLOOK.R]>this.opponent.look[eLOOK.R]){
                MessageBox.show(.5,6,1.5,2,1,'First','jrpg',1,this.foe)
                this.flip()
                MessageBox.show(.5,6,1.5,2,.9,'Second','jrpg',1,this.foe)
                this.flip()
              }
              else if (this.look[eLOOK.R]<this.opponent.look[eLOOK.R]){
                MessageBox.show(.5,6,1.5,2,1,'Second','jrpg',1,this.foe)
                this.flip()
                MessageBox.show(.5,6,1.5,2,.9,'First','jrpg',1,this.foe)
                this.flip()
              }
              else if (this.look[eLOOK.R]==this.opponent.look[eLOOK.R]){
                MessageBox.show(.5,6,1.5,2,1,'Tie - Roll Again!','jrpg',1,this.foe)
                this.flip()
                MessageBox.show(.5,6,1.5,2,.9,'Tie - Roll Again!','jrpg',1,this.foe)
                this.flip()
              }
              
          
            if (this.at >=69){
              for (let i = 0;i<Player.length;i++){

              // 1. CALCULATE TIE BREAKER
              winTie = 0;
              // If I have charm and opponent doesn't, I win ties
              if (Player[i].hasLuckyCharm == 1 && Player[i].opponent.hasLuckyCharm == 0) { winTie = 1; }
              //FIRST
              if (Player[i].look[eLOOK.R]>Player[i].opponent.look[eLOOK.R]|| (Player[i].look[eLOOK.R] == Player[i].opponent.look[eLOOK.R] && winTie == 1)){
                Player[i].option = 7;
                Player[i].turnCurrent = 1;
                Player[i].turnOrder = 1;
              }
              //SECOND
              else if (Player[i].look[eLOOK.R]<Player[i].opponent.look[eLOOK.R]){//second, player moves to opt 7 first defend   
                Player[i].option = 7;
                Player[i].defStat = 1; //0 str, 1 con, 2, int, 3, agi
                Player[i].turnCurrent = 1;
                Player[i].turnOrder = 2;
              }
              
            }//end show result of roll and announce turns
                this.ay = 0;
                this.az = 0;
                this.at = 0
                this.rollSent = 0;
          }//>69
          }//>30
          break;
        case 7://Combat
          if(Player[0].turnCurrent == 1){
            if(Player[0].turnOrder == 1){
              defender = 1;
              attacker = 0;
            }
            else{
              defender = 0;
              attacker = 1;
            }
          }
          if(Player[0].turnCurrent == 2){
            if(Player[0].turnOrder == 1){
              defender = 0;
              attacker = 1;
            }
            else{
              defender = 1;
              attacker = 0;
            }
          }
          switch(Player[attacker].look[eLOOK.A]){
            case 0://reacting to monster attack from Foe
            //STEP 1: SETUP DEFENDER
              //DISPLAY MONSTER CARDS
              if (Player[defender].foe == 1){this.flip()}
              Player[defender].aMonster[0].place(3.88,5.5,1);      
              if (Player[defender].foe == 1){this.flip()}
              if (Player[attacker].foe == 1){this.flip()}
              Player[attacker].aMonster[0].place(3.88,5.5,1);      
              if (Player[attacker].foe == 1){this.flip()}

              //Winged Boots 6.2 EFFECT ACTIVATE
              if (Player[defender].hasWingedBoots==1&&Player[defender].opponent.hasScalesOfJustice <1&&Player[defender].opponent.hasBind <1){
                for (let i = 0; i < Player[defender].aMonster.length; i++){
                  if (Player[defender].aMonster[i].index == 7 && Player[defender].aMonster[i].effectTriggered == 0){
                    Player[0].option = 6.2;
                    Player[1].option = 6.2;
                    return
                  }
                }
              }
              //Protect Orb 6.5 EFFECT ACTIVATE
              if (Player[defender].hasProtectOrb==1&&Player[defender].opponent.hasScalesOfJustice <1&&Player[defender].opponent.hasBind <1){
                for (let i = 0; i < Player[defender].aMonster.length; i++){
                  if (Player[defender].aMonster[i].index == 30 && Player[defender].aMonster[i].effectTriggered == 0){
                    Player[0].option = 6.5;
                    Player[1].option = 6.5;
                    return
                  }
                }
              }
              
              //DEFENDER BORDER GRAPHICS AND DICETYPE SETUP
              //SCALES OF JUSTICE
              if (Player[defender].opponent.hasScalesOfJustice == 1){
                if (Player[defender].foe == 1){this.flip()}
                drawPortrait(11,9,9,.1);
                drawPortrait(11,0,9,.1);
                if (Player[defender].foe == 1){this.flip()}
                Player[defender].diceType = 12
              }
              //ALCHEMY DURING STAT SELECTION
              else if(Player[defender].opponent.hasScalesOfJustice ==2 ||Player[defender].opponent.hasScalesOfJustice == 3 ){
                if (Player[defender].foe == 1){this.flip()}
                drawPortrait(14,9,9,.1);
                drawPortrait(14,0,9,.1);
                if (Player[defender].foe == 1){this.flip()}
              }
              //ALCHEMY POST STAT SELECTION
              else if ( Player[defender].opponent.hasScalesOfJustice == 4){
                if (Player[defender].look[eLOOK.STAT]== eSTAT.S){
                  if (Player[defender].foe == 1){this.flip()}
                  drawPortrait(-11,9,9,.1);
                  drawPortrait(-11,0,9,.1);
                  if (Player[defender].foe == 1){this.flip()}
                  Player[defender].diceType = Player[defender].aMonster[0].stat[eSTAT.S][eDICE.MAX]
                }
                if (Player[defender].look[eLOOK.STAT]== eSTAT.C){
                  if (Player[defender].foe == 1){this.flip()}
                  drawPortrait(-13,9,9,.1);
                  drawPortrait(-13,0,9,.1);
                  if (Player[defender].foe == 1){this.flip()}
                  Player[defender].diceType = Player[defender].aMonster[0].stat[eSTAT.C][eDICE.MAX]
                }
                if (Player[defender].look[eLOOK.STAT]== eSTAT.I){
                  if (Player[defender].foe == 1){this.flip()}
                  drawPortrait(-12,9,9,.1);
                  drawPortrait(-12,0,9,.1);
                  if (Player[defender].foe == 1){this.flip()}
                  Player[defender].diceType = Player[defender].aMonster[0].stat[eSTAT.I][eDICE.MAX]
                }
                if (Player[defender].look[eLOOK.STAT]== eSTAT.A){
                  if (Player[defender].foe == 1){this.flip()}
                  drawPortrait(-14,9,9,.1);
                  drawPortrait(-14,0,9,.1);
                  if (Player[defender].foe == 1){this.flip()}
                  Player[defender].diceType = Player[defender].aMonster[0].stat[eSTAT.A][eDICE.MAX]
                }
              }
              //DEF graphics/////
              else if (Player[defender].defStat == 1){//CON
                if (Player[defender].foe == 1){this.flip()}
                drawPortrait(-13,9,9,.1);
                drawPortrait(-13,0,9,.1);
                if (Player[defender].foe == 1){this.flip()}
                Player[defender].diceType = Player[defender].aMonster[0].stat[eSTAT.C][eDICE.MAX]
              }
              else if (Player[defender].defStat == 3){//AGI
                if (Player[defender].foe == 1){this.flip()}
                drawPortrait(-14,9,9,.1);
                drawPortrait(-14,0,9,.1);
                if (Player[defender].foe == 1){this.flip()}
                Player[defender].diceType = Player[defender].aMonster[0].stat[eSTAT.A][eDICE.MAX]
              } 
              else if (Player[defender].defStat == 2){//INT
                if (Player[defender].foe == 1){this.flip()}
                drawPortrait(-12,9,9,.1);
                drawPortrait(-12,0,9,.1);
                if (Player[defender].foe == 1){this.flip()}
                Player[defender].diceType = Player[defender].aMonster[0].stat[eSTAT.A][eDICE.MAX]
              } 
              ///////////////
            //STEP 2: SETUP ATTACKER

              //CHECK IF ATTACKER BOUND
              if (Player[attacker].hasBind > 0){
                this.at= this.at+tick;
                drawPortrait(12,9,9,.1);
                drawPortrait(12,0,9,.1);
                drawPortrait(12,9,5,.1);
                drawPortrait(12,0,5,.1);
                if(Player[attacker].isCPU == 1&&Player[attacker].foe == 1){
                  this.flip();
                  MessageBox.show(.5,6,1.5,2,1,Player[attacker].aMonster[0].name + ' cannot act!','jrpg',1,0)
                  this.flip()
                }
                else{MessageBox.show(.5,6,1.5,2,1,Player[attacker].aMonster[0].name + ' cannot act!','jrpg',1,this.foe)}
                if (this.at>39){
                  Player[attacker].hasBind = Player[attacker].hasBind - 1;
                  if (Player[attacker].hasBind == 0) {
                    for (let i = 0; i < Player[attacker].aMonster.length; i++) {
                      if (Player[attacker].aMonster[i].index == 12) { // 12 is the Bind card ID
                        Player[attacker].aMonster.splice(i, 1); // Remove it from the field
                        break; // Stop looking
                      }
                    }
                  }
                  if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 2){Player[0].option = 9;Player[1].option = 9;}
                  if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 1){Player[0].turnCurrent = 2}
                  this.at = 0;
                  this.ay = 0;
                  this.az = 0;
                }
                return; 
              }
              //CHECK IF ATTACKER INTIMIDATED
              if (Player[attacker].hasIntimidate> 0){
                this.at= this.at+tick;
                drawPortrait(58,9,9,.1);
                drawPortrait(58,0,9,.1);
                drawPortrait(58,9,5,.1);
                drawPortrait(58,0,5,.1);
                if(Player[attacker].isCPU == 1&&Player[attacker].foe == 1){
                  this.flip();
                  MessageBox.show(.5,6,1.5,2,1,Player[attacker].aMonster[attacker].name + ' cowers in fear!','jrpg',1,0)
                  this.flip();
                }
                else{ MessageBox.show(.5,6,1.5,2,1,Player[attacker].aMonster[0].name + ' cowers in fear!','jrpg',1,this.foe)}
                if (this.at>69){
                  Player[attacker].hasIntimidate = Player[attacker].hasIntimidate - 1;
                  if (Player[attacker].hasIntimidate == 0) {
                    for (let i = 0; i < Player[attacker].aMonster.length; i++) {
                      if (Player[attacker].aMonster[i].index == 58) { // 12 is the Bind card ID
                        Player[attacker].aMonster.splice(i, 1); // Remove it from the field
                        break; // Stop looking
                      }
                    }
                  }
                  if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 2){Player[0].option = 9;Player[1].option = 9;}
                  if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 1){Player[0].turnCurrent = 2}
                  this.at = 0;
                  this.ay = 0;
                  this.az = 0;
                }
                if (this.foe == 1){this.flip()}
                return;
              }
              /////////

              //ATTACKER BORDER GRAPHICS AND DICE TYPE SETUP
              //SCALES OF JUSTICE
              if (Player[attacker].hasScalesOfJustice == 1){
                if (Player[attacker].foe == 1){this.flip()}
                drawPortrait(11,9,9,.1);
                drawPortrait(11,0,9,.1);
                if (Player[attacker].foe == 1){this.flip()}
                Player[attacker].diceType = 12
              }
              //ALCHEMY DURING STAT SELECTION
              else if(Player[attacker].hasScalesOfJustice ==2 ||Player[attacker].hasScalesOfJustice == 3 ){
                if (Player[attacker].foe == 1){this.flip()}
                drawPortrait(14,9,9,.1);
                drawPortrait(14,0,9,.1);
                if (Player[attacker].foe == 1){this.flip()}
                this.at = 0;
                this.ay = 0;
                this.az = 0;
                return;
              }
              //Alchemy POST STAT SELECTION
              else if ( Player[attacker].hasScalesOfJustice == 4){
                if (Player[attacker].look[eLOOK.STAT]== eSTAT.S){
                  if (Player[attacker].foe == 1){this.flip()}
                  drawPortrait(-11,9,9,.1);
                  drawPortrait(-11,0,9,.1);
                  if (Player[attacker].foe == 1){this.flip()}
                  Player[attacker].diceType = Player[attacker].aMonster[0].stat[eSTAT.S][eDICE.MAX]
                }
                if (Player[attacker].look[eLOOK.STAT]== eSTAT.C){
                  if (Player[attacker].foe == 1){this.flip()}
                  drawPortrait(-13,9,9,.1);
                  drawPortrait(-13,0,9,.1);
                  if (Player[attacker].foe == 1){this.flip()}
                  Player[attacker].diceType = Player[attacker].aMonster[0].stat[eSTAT.C][eDICE.MAX]
                }
                if (Player[attacker].look[eLOOK.STAT]== eSTAT.I){
                  if (Player[attacker].foe == 1){this.flip()}
                  drawPortrait(-12,9,9,.1);
                  drawPortrait(-12,0,9,.1);
                  if (Player[attacker].foe == 1){this.flip()}
                  Player[attacker].diceType = Player[attacker].aMonster[0].stat[eSTAT.I][eDICE.MAX]
                }
                if (Player[attacker].look[eLOOK.STAT]== eSTAT.A){
                  if (Player[attacker].foe == 1){this.flip()}
                  drawPortrait(-14,9,9,.1);
                  drawPortrait(-14,0,9,.1);
                  if (Player[attacker].foe == 1){this.flip()}
                  Player[attacker].diceType = Player[attacker].aMonster[0].stat[eSTAT.A][eDICE.MAX]
                }
              }
              //STR attack graphics
              else{
                if (Player[attacker].foe == 1){this.flip()}
                drawPortrait(-11,9,9,.1);
                drawPortrait(-11,0,9,.1);
                if (Player[attacker].foe == 1){this.flip()}
                Player[attacker].diceType = Player[attacker].aMonster[0].stat[eSTAT.S][eDICE.MAX]
              }
              /////////////////
              
              //TIMERS//////////////////
              //MAIN TIMER
              if(this.at <30){this.at = this.at+tick;}
              else if(this.at>=69){this.at = this.at+tick;} 
              //CLAMP for CLICK TO CONTINUE         
              else if(this.at>=30&&this.at < 69){this.at = 31;}
              //DICE TIMERS
              if (this.ay < 3 && this.at <=30){
                this.ay = this.ay + SPEED_Y;
                this.az = this.az + SPEED_Z;
              }             
              if (this.ay >=3 && this.az >1 && this.at<=30){
                  this.az = this.az - SPEED_Z;
              }
              //////////////////
            //STEP 3: ROLL DICE
              //DICE ROLL STOP         
              if (this.ay >=3 && this.az <1 && this.at<=30){
                //defender DICE ROLL STOP
                if (Player[defender].foe == 1){this.flip()}
                Player[defender].setDice(Player[defender].diceType,8,6,1,.001,dt)
                drawText(7.7,5.6,1,1,''+Player[defender].look[eLOOK.R],'white',1);
                if (Player[defender].foe == 1){this.flip()}
                //attacker DICE ROLL STOP
                if (Player[attacker].foe == 1){this.flip()}
                  Player[attacker].setDice(Player[attacker].diceType,8,6,1,.001,dt)
                  drawText(7.7,5.6,1,1,''+Player[attacker].look[eLOOK.R],'white',1);
                if (Player[attacker].foe == 1){this.flip()}
              }
              //DICE ROLL ANIMATION
              else{
                if (this.at <= 30){
                  //DICE ROLL defender
                  if (Player[defender].foe == 1) {this.flip()}
                  if (Player[attacker].hasReroll == 1) {
                    Player[defender].setDice(Player[defender].diceType, 8, 6, 1, .001, dt)
                    drawText(7.7, 5.6, 1, 1, '' + Player[defender].look[eLOOK.R], 'white', 1);
                  } 
                  else {
                    // Normal Roll (Happens during initial roll OR if only Defender is rerolling)
                    Player[defender].setDice(Player[defender].diceType, 8, 9 - this.ay, this.az, 99, dt)
                if (Dungeon.isChallenger == true||!Player[1].battleOpponentId) {
                    Player[defender].look[eLOOK.R] = 0;
                    if (Player[defender].defStat == 1) { Player[defender].look[eLOOK.R] = Player[defender].aMonster[0].rollStat(eSTAT.C); }
                    if (Player[defender].defStat == 3) { Player[defender].look[eLOOK.R] = Player[defender].aMonster[0].rollStat(eSTAT.A); }
                    if (Player[defender].defStat == 2) { Player[defender].look[eLOOK.R] = Player[defender].aMonster[0].rollStat(eSTAT.I); }
                  }
                  }
                  if (Player[defender].foe == 1) {this.flip()}
                  ////////////////////////

                  //DICE ROLL attacker
                  if (Player[attacker].foe == 1) {this.flip()}
                  if (Player[defender].hasReroll == 1 && Player[attacker].hasReroll == 0) {
                    Player[attacker].setDice(Player[attacker].diceType, 8, 6, 1, .001, dt)
                    drawText(7.7, 5.6, 1, 1, '' + Player[attacker].look[eLOOK.R], 'white', 1);
                  } 
                  else {
                  
                    Player[attacker].setDice(Player[attacker].diceType, 8, 9 - this.ay, this.az, 99, dt)
                    if (Dungeon.isChallenger == true||!Player[1].battleOpponentId) {
                    Player[attacker].look[eLOOK.R] = 0;
                    Player[attacker].look[eLOOK.R] = Player[attacker].aMonster[0].rollStat(eSTAT.S);
                    
                    //Scales of justice activate 
                    if (Player[attacker].hasScalesOfJustice == 1) {
                      Player[attacker].look[eLOOK.R] = rnd(1, 12);
                      Player[defender].look[eLOOK.R] = rnd(1, 12);
                    }
                    //////////
                    //Alchemy activate
                    if (Player[attacker].hasScalesOfJustice == 4) {
                      if (Player[attacker].look[eLOOK.STAT]== eSTAT.S){Player[attacker].look[eLOOK.R] = Player[attacker].aMonster[0].rollStat(eSTAT.S);}
                      if (Player[attacker].look[eLOOK.STAT]== eSTAT.C){Player[attacker].look[eLOOK.R] = Player[attacker].aMonster[0].rollStat(eSTAT.C);}
                      if (Player[attacker].look[eLOOK.STAT]== eSTAT.I){Player[attacker].look[eLOOK.R] = Player[attacker].aMonster[0].rollStat(eSTAT.I);}
                      if (Player[attacker].look[eLOOK.STAT]== eSTAT.A){Player[attacker].look[eLOOK.R] = Player[attacker].aMonster[0].rollStat(eSTAT.A);}
                      if (Player[defender].look[eLOOK.STAT]== eSTAT.S){Player[defender].look[eLOOK.R] = Player[defender].aMonster[0].rollStat(eSTAT.S);}
                      if (Player[defender].look[eLOOK.STAT]== eSTAT.C){Player[defender].look[eLOOK.R] = Player[defender].aMonster[0].rollStat(eSTAT.C);}
                      if (Player[defender].look[eLOOK.STAT]== eSTAT.I){Player[defender].look[eLOOK.R] = Player[defender].aMonster[0].rollStat(eSTAT.I);}
                      if (Player[defender].look[eLOOK.STAT]== eSTAT.A){Player[defender].look[eLOOK.R] = Player[defender].aMonster[0].rollStat(eSTAT.A);}
                    }
                    }
                  }
                  if (Player[attacker].foe == 1) { this.flip() }
                  //Battle Graphics
                  if (defender== 0){
                    //player defends
                    MessageBox.show(.5,6,1.5,2,1,Player[defender].aMonster[0].name + ' defends!','jrpg',1,this.foe)
                    ani = getAniValues(this.at, 30, 4, 4, 7, 3, .2, .2);
                    drawPortrait(-16,ani.x,ani.y,ani.z);
                    //foe attacks
                    this.flip()
                    MessageBox.show(.5,6,1.5,2,1,Player[attacker].aMonster[0].name + ' attacks!','jrpg',1,this.foe)
                    ani = getAniValues(this.at, 30, 4, 4, 7, 3, .2, .2);
                    drawPortrait(-15.1,ani.x,ani.y,ani.z);
                    this.flip()
                  }
                  else if (attacker == 0){
                    //player attacks
                    MessageBox.show(.5,6,1.5,2,1,Player[attacker].aMonster[0].name + ' attacks!','jrpg',1,this.foe)
                    ani = getAniValues(this.at, 30, 4, 4, 7, 3, .2, .2);
                    drawPortrait(-15.1,ani.x,ani.y,ani.z);
                    //foe defends
                    this.flip()
                    MessageBox.show(.5,6,1.5,2,1,Player[defender].aMonster[0].name + ' defends!','jrpg',1,this.foe)
                    ani = getAniValues(this.at, 30, 4, 4, 7, 3, .2, .2);
                    drawPortrait(-16,ani.x,ani.y,ani.z);
                    this.flip()
                  }
                  ////////////////////
                }//end at <=30
              }//end dice rolling
            //STEP 4: CHECK REROLLS (STEP 5 INSIDE this.at>30)
              //DICE ROLL END and RESULTS (also check for star pendant rerolls )
              if (this.at > 30){
                //defender DICE ROLL STOP
                
                if (!this.rollSent&&Dungeon.isChallenger == true) {
                Player[0].sendAction('DICE_RESULT', {
                    p0_roll: Player[0].look[eLOOK.R], // My result
                    p1_roll: Player[1].look[eLOOK.R], // Opponent result
                    diceType: Player[0].diceType      // Sync dice type
                });
                this.rollSent = 1;
            }
                if (Player[defender].foe == 1){this.flip()}
                Player[defender].setDice(Player[defender].diceType,8,6,1,.001,dt)
                drawText(7.7,5.6,1,1,''+Player[defender].look[eLOOK.R],'white',1);
                if (Player[defender].foe == 1){this.flip()}
                //attacker DICE ROLL STOP
                if (Player[attacker].foe == 1){this.flip()}
                Player[attacker].setDice(Player[attacker].diceType,8,6,1,.001,dt)
                drawText(7.7,5.6,1,1,''+Player[attacker].look[eLOOK.R],'white',1);
                if (Player[attacker].foe == 1){this.flip()}

                //defender STAR PENDANT ACTIVATE////
                if (Player[defender].hasStarPendant==1){
                  for (let i = 0; i < Player[defender].aMonster.length; i++){
                    if (Player[defender].aMonster[i].index == 17 && Player[defender].aMonster[i].effectTriggered == 0){
                      if (defender == 0){
                        Player[0].option = 6.1;
                        Player[1].option = 6.11;
                      }
                      else{
                      Player[0].option = 6.1;
                      Player[1].option = 6.12;
                      }
                      return
                    }
                  }
                }
                /////////////////////////////
                //attacker STAR PENDANT ACTIVATE//////////////// 
                if (Player[attacker].hasStarPendant==1){
                  for (let i = 0; i < Player[attacker].aMonster.length; i++){
                    if (Player[attacker].aMonster[i].index == 17 && Player[attacker].aMonster[i].effectTriggered == 0){
                      if (attacker == 0){
                        Player[0].option = 6.1;
                        Player[1].option = 6.11;
                      }
                      else{
                      Player[0].option = 6.1;
                      Player[1].option = 6.12;
                      }
                      return
                    }
                  }
                }
                ///////////////
              //STEP 5 WAIT FOR TAP TO CONTINUE
                //TAP SCREEN TO CONTINUE MESSAGE
                if ((this.at>=31&& this.at < 69) &&this.opponent.option != 6.1 && this.opponent.option != 6.2){
                  if(this.opponent.isCPU == 0){
                    drawText(0,9.5,10,.5,"Tap Screen To Continue",`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)})`,1,'center');
                    this.flip()
                    drawText(0,9.5,10,.5,"Tap Screen To Continue",`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)})`,1,'center');
                    this.flip()
                  }
                  else{
                    drawText(2.15,4.75,6,1,"Tap Screen To Continue",`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)})`,1);
                  }                    
                  if (defender== 0){
                    MessageBox.show(.5,6,1.5,2,1,Player[defender].aMonster[0].name + ' defends!','jrpg',1,this.foe)
                    this.flip()
                    MessageBox.show(.5,6,1.5,2,1,Player[attacker].aMonster[0].name + ' attacks!','jrpg',1,this.foe)
                    this.flip()
                  }
                  else if (attacker == 0){
                    MessageBox.show(.5,6,1.5,2,1,Player[attacker].aMonster[0].name + ' attacks!','jrpg',1,this.foe)
                    this.flip()
                    MessageBox.show(.5,6,1.5,2,1,Player[defender].aMonster[0].name + ' defends!','jrpg',1,this.foe)
                    this.flip()
                  }
                }
                ///////Wait for player click to set at to 69///////
              //STEP 6: CALCULATE RESULTS at this.at >= 69 and STEP 7: CLEANUP at this.at>99
                //BATTLE RESULTS
                if (this.at >= 69){

                  //LUCKY CHARM CHECK
                  foeWinsTie = 0;
                  if (Player[attacker].hasLuckyCharm == 1 && Player[defender].hasLuckyCharm == 0) { foeWinsTie = 1; }
                  //////////////////////

                  //ATTACKER SLAYS DEFENDER
                  if ((Player[attacker].look[eLOOK.R]>Player[defender].look[eLOOK.R])|| (Player[defender].look[eLOOK.R] == Player[attacker].look[eLOOK.R] && foeWinsTie == 1)){            
                    MessageBox.show(.5,6,1.5,2,1,Player[defender].opponent.aMonster[0].name+' slays '+ Player[defender].aMonster[0].name + '!','jrpg',1,this.foe)
                    if(attacker == 0){
                      //foe dies
                      this.flip();
                      drawShape('rec',0,0,1,3.875,5.45,2.25,3.55,0,0,0,0,`rgba(0,0,0,${(.3+this.at*.01)})`,1);
                      ani = getAniValues(this.at, 99, 4.2, 4.2, 6.5, 6.5, .2, .2);
                      drawPortrait(3.2,ani.x,ani.y,ani.z);
                      drawShape('rec',0,0,1,3.875,5.45,2.25,3.55,0,0,0,0,`rgba(0,0,0,${(1-this.at*.00599)})`,1);
                      this.flip();
                      //player attacks
                      ani = getAniValues(this.at, 99, 4, 4, 7, 3, .2, .2);
                      drawPortrait(-15.1,ani.x,ani.y,ani.z);
                    }
                    else{
                      //player dies
                      drawShape('rec',0,0,1,3.875,5.45,2.25,3.55,0,0,0,0,`rgba(0,0,0,${(.3+this.at*.01)})`,1);
                      ani = getAniValues(this.at, 99, 4.2, 4.2, 6.5, 6.5, .2, .2);
                      drawPortrait(3.2,ani.x,ani.y,ani.z);
                      drawShape('rec',0,0,1,3.875,5.45,2.25,3.55,0,0,0,0,`rgba(0,0,0,${(1-this.at*.00599)})`,1);
                      //foe attacks
                      this.flip();
                      ani = getAniValues(this.at, 99, 4, 4, 7, 3, .2, .2);
                      drawPortrait(-15.1,ani.x,ani.y,ani.z);
                      this.flip();
                    }
                    //Cleanup and go to opt 8
                    if (this.at > 99){
                      MusicEngine.playSFX('death');
                      if(attacker == 0){
                        Player[0].option = 8;
                        Player[1].option = 8.1
                      }
                      if(attacker == 1){
                        Player[0].option = 8;
                        Player[1].option = 8.2
                      }
                      this.ay = 0;
                      this.az = 0;
                      this.at = 0
                      this.rollSent = 0;
                      //LOVERS + 1 STR and CON for defeating defender///////////
                      if (Player[attacker].hasLovers > 0 && Player[attacker].hasLovers <3 ){
                        Player[attacker].aMonster[0].stat[eSTAT.S][eDICE.MOD]=Player[attacker].aMonster[0].stat[eSTAT.S][eDICE.MOD] + 1;
                        Player[attacker].aMonster[0].stat[eSTAT.C][eDICE.MOD]=Player[attacker].aMonster[0].stat[eSTAT.C][eDICE.MOD] + 1;
                        Player[attacker].hasLovers = Player[attacker].hasLovers + 1;
                      }
                      //////////////////////////////////
                      //AMULET +1 INT for defeating defender///////////
                      if (Player[attacker].hasAmulet > 0 && Player[attacker].hasAmulet <3 ){
                        Player[attacker].aMonster[0].stat[eSTAT.I][eDICE.MOD]=Player[attacker].aMonster[0].stat[eSTAT.I][eDICE.MOD] + 1;
                        Player[attacker].hasAmulet = Player[attacker].hasAmulet + 1;
                      }
                      //////////////////////////////////
                      //attacker STAR PENDANT RESET//////////////////////
                      if (Player[attacker].hasStarPendant == 1){
                        for (let i = 0; i < Player[attacker].aMonster.length; i++){
                          if (Player[attacker].aMonster[attacker].index == 17 && Player[attacker].aMonster[attacker].effectTriggered == 1){
                            Player[attacker].aMonster[attacker].effectTriggered = 0;
                            Player[attacker].hasReroll = 0;
                          }
                        }
                      } 
                      /////////////////////////////
                      //SCALES OF JUSTICE RESET/////////////////////////
                      if (Player[attacker].hasScalesOfJustice == 1){Player[attacker].hasScalesOfJustice = 0;}
                      ///////////////////////////////
                      //ALCHEMY RESET
                      if (Player[attacker].hasScalesOfJustice == 4){
                        Player[attacker].look[eLOOK.STAT] = 0;
                        Player[attacker].opponent.look[eLOOK.STAT] = 0;
                        Player[attacker].hand.splice(Player[attacker].look[eLOOK.H],1);
                        Player[attacker].look[eLOOK.H] = 0;
                        Player[attacker].hasScalesOfJustice = 0;
                      } 
                    }   
                  }//end attacker slay defender
                  //DEFENDER RESISTS ATTACK
                  else if (Player[attacker].look[eLOOK.R]<=Player[defender].look[eLOOK.R]){//if PSTR <= FCON, lives goes on to second attack
                    if (Player[defender].foe == 1){this.flip()}
                    MessageBox.show(.5,6,1.5,2,1,Player[defender].aMonster[0].name + ' resists ' + Player[attacker].aMonster[0].name+ '!','jrpg',1,this.foe)
                    if (Player[defender].foe == 1){this.flip()}
                    if (Player[attacker].foe == 1){this.flip()}
                    MessageBox.show(.5,6,1.5,2,1,Player[defender].aMonster[0].name + ' resists ' + Player[attacker].aMonster[0].name+ '!','jrpg',1,this.foe)
                    if (Player[attacker].foe == 1){this.flip()}
                    if(attacker == 0){
                      //Foe defending
                      this.flip();
                      ani = getAniValues(this.at, 99, 4, 4, 7, 3, .2, .2);
                      drawPortrait(-16,ani.x,ani.y,ani.z);
                      //Player attacking
                      this.flip();
                      ani = getAniValues(this.at, 99, 4, 4, 3, 6, .2, .2);
                      drawPortrait(-20,ani.x,ani.y,ani.z);                   
                    }
                    else{
                      //player defending
                      ani = getAniValues(this.at, 99, 4, 4, 7, 3, .2, .2);
                      drawPortrait(-16,ani.x,ani.y,ani.z);
                      //foe attacking
                      this.flip();
                      ani = getAniValues(this.at, 99, 4, 4, 3, 6, .2, .2);
                      drawPortrait(-20,ani.x,ani.y,ani.z);                   
                      this.flip();
                    }
                    //CLEANUP and if turncurrent 1 then turncurrent 2 or if turncurrent = 2 go to opt.9
                    if (this.at > 99){
                      if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 2){Player[0].option = 9;Player[1].option = 9;}
                      else if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 1){Player[0].turnCurrent = 2}
                      this.ay = 0;
                      this.az = 0;
                      this.at = 0
                      this.rollSent = 0;
                      //defender STAR PENDANT RESET
                      if (Player[defender].hasStarPendant == 1){
                        for (let i = 0; i < Player[defender].aMonster.length; i++){
                          if (Player[defender].aMonster[i].index == 17 && Player[defender].aMonster[i].effectTriggered == 1){
                            Player[defender].aMonster[i].effectTriggered = 0;
                            Player[defender].hasReroll = 0;
                          }
                        }
                      }          
                      ////////////////////////////   
                      //WINGED BOOTS RESET
                      if (Player[defender].hasWingedBoots == 1){
                        for (let i = 0; i < Player[defender].aMonster.length; i++){
                          if (Player[defender].aMonster[i].index == 7 && Player[defender].aMonster[i].effectTriggered == 1){
                            Player[defender].aMonster[i].effectTriggered = 0;
                          }
                        }
                      }
                      //PROTECT ORB RESET
                      if (Player[defender].hasProtectOrb == 1){
                        for (let i = 0; i < Player[defender].aMonster.length; i++){
                          if (Player[defender].aMonster[i].index == 30 && Player[defender].aMonster[i].effectTriggered == 1){
                            Player[defender].aMonster[i].effectTriggered = 0;
                          }
                        }
                      }
                      ////////////////////////
                      //attacker STAR PENDANT RESET//////////////////////
                      if (Player[attacker].hasStarPendant == 1){
                        for (let i = 0; i < Player[attacker].aMonster.length; i++){
                          if (Player[attacker].aMonster[i].index == 17 && Player[attacker].aMonster[i].effectTriggered == 1){
                            Player[attacker].aMonster[i].effectTriggered = 0;
                            Player[attacker].hasReroll = 0;
                          }
                        }
                      } 
                      /////////////////////////////
                      //SCALES OF JUSTICE RESET////////////////////////
                      if (Player[attacker].hasScalesOfJustice == 1){Player[attacker].hasScalesOfJustice = 0;}
                      ////////////////////// 
                      //ALCHEMY RESET
                      if (Player[attacker].hasScalesOfJustice == 4){
                        Player[attacker].look[eLOOK.STAT] = 0;
                        Player[attacker].opponent.look[eLOOK.STAT] = 0;
                        Player[attacker].hand.splice(Player[attacker].look[eLOOK.H],1);
                        Player[attacker].look[eLOOK.H] = 0;
                        Player[attacker].hasScalesOfJustice = 0;
                      }
                    }//end >99
                  }//end Player Defends
                }//>=69
              }//>30
            
              break;  
            case 1://ITEM either to player or foe
              //Activate Bind
              if (Player[attacker].hasBind > 0){
                Player[attacker].aMonster[0].place(3.88,5.5,1);
                this.at= this.at+tick;
                drawPortrait(12,9,9,.1);
                drawPortrait(12,0,9,.1);
                drawPortrait(12,9,5,.1);
                drawPortrait(12,0,5,.1);
                if(Player[attacker].isCPU == 1&&Player[attacker].foe == 1){
                  this.flip();
                  MessageBox.show(.5,6,1.5,2,1,Player[attacker].aMonster[0].name + ' cannot act!','jrpg',1,0)
                  this.flip()
                }else{MessageBox.show(.5,6,1.5,2,1,Player[attacker].aMonster[0].name + ' cannot act!','jrpg',1,this.foe)}
                if (this.at>39){
                  Player[attacker].hasBind = Player[attacker].hasBind - 1;
                  if (Player[attacker].hasBind == 0) {
                    for (let i = 0; i < Player[attacker].aMonster.length; i++) {
                      if (Player[attacker].aMonster[i].index == 12) { // 12 is the Bind card ID
                        Player[attacker].aMonster.splice(i, 1); // Remove it from the field
                        break; // Stop looking
                      }
                    }
                  }
                  if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 2){Player[0].option = 9;Player[1].option = 9;}
                  if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 1){Player[0].turnCurrent = 2}
                  this.at = 0;
                  this.ay = 0;
                  this.az = 0;
                }
                if (this.foe == 1){this.flip()}
                return;
              }
              //Activate Lunacy
              if (Player[attacker].hasLunacy > 0&& Player[attacker].hand[Player[attacker].look[eLOOK.H]].index != 19&&Player[attacker].hand[Player[attacker].look[eLOOK.H]].index != 20){
                Player[attacker].aMonster[0].place(3.88,5.5,1);
                this.at= this.at+1   
                drawPortrait(18,9,9,.1);
                drawPortrait(18,0,9,.1);
                drawPortrait(18,9,5,.1);
                drawPortrait(18,0,5,.1);
                if(Player[attacker].isCPU == 1){
                  this.flip();
                  MessageBox.show(.5,6,1.5,2,1,Player[attacker].aMonster[0].name + ' cannot act!','jrpg',1,0)
                  this.flip();
                }else{MessageBox.show(.5,6,1.5,2,1,Player[attacker].aMonster[0].name + ' cannot act!','jrpg',1,this.foe)}
                if (this.at>69){
                  Player[attacker].hasLunacy = Player[attacker].hasLunacy - 1;
                  if (Player[attacker].hasLunacy == 0) {
                    for (let i = 0; i < Player[attacker].aMonster.length; i++) {
                      if (Player[attacker].aMonster[i].index == 18) { // 12 is the Bind card ID
                        Player[attacker].aMonster.splice(i, 1); // Remove it from the field
                        break; // Stop looking
                      }
                    }
                  }
                  if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 2){Player[0].option = 9;Player[1].option = 9;}
                  if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 1){Player[0].turnCurrent = 2}
                  this.at = 0;
                  this.ay = 0;
                  this.az = 0;
                }
                return;
              }
              /////////
              //Draw Defender Portrait and Graphics//////////
              Player[defender].defStat = 1; //0 str, 1 con, 2, int, 3, agi 
              if (defender == 1){this.flip()}
              drawPortrait(-13,9,9,.1);
              drawPortrait(-13,0,9,.1);
              Player[defender].aMonster[0].place(3.88,5.5,1);
              if (defender == 1){this.flip()}
              //Draw Attacker Portrait and Graphics//////////
              if (attacker == 1){this.flip()}
              drawPortrait(-21,9,9,.1);
              drawPortrait(-21,0,9,.1);
              Player[attacker].aMonster[0].place(3.88,5.5,1);
              if (attacker == 1){this.flip()}
              //////////////////////////////
              //Timer
              this.at = this.at+tick;
              //////////////////
              //Battle Message
              if (this.at <= 69){
                if (Player[attacker].foe == 1){this.flip()}
                MessageBox.show(.5,6,1.5,2,1,Player[attacker].aMonster[0].name + ' uses an item!','jrpg',1,0)     
                if (Player[attacker].foe == 1){this.flip()}
                if (Player[defender].foe == 1){this.flip()}
                MessageBox.show(.5,6,1.5,2,1,Player[attacker].aMonster[0].name + ' uses an item!','jrpg',1,0)     
                if (Player[defender].foe == 1){this.flip()}
              }
              //MOVE ITEM FROM HAND TO CENTER OF FIELD
              if (this.at <= 30){
                if (Player[attacker].foe == 1){this.flip()}
                Player[attacker].hand[Player[attacker].look[eLOOK.H]].place(1+((2.875/30)*this.at),7.5-((2/30)*this.at),1);
                if (Player[attacker].foe == 1){this.flip()}
              }
              //GLOW EFFECT TO INDICATE USE
              if (this.at > 30 && this.at <=69){
                if (Player[attacker].foe == 1){this.flip()}
                Player[attacker].hand[Player[attacker].look[eLOOK.H]].place(3.88,5.5,1);
                drawShape('rec',3.88,5.5,1,0,0,2.25,3.55,0,0,0,0,`rgba(255,255,0,${.1+this.at*.01})`,1);
                if (Player[attacker].foe == 1){this.flip()}
                //Quest Reward prep
                if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 38 && Player[attacker].deck.length > 0 && this.at == 0) {
                  if (attacker == 0) {
                    Player[attacker].hand[Player[attacker].look[eLOOK.H]].questReward = rnd(0, Player[attacker].deck.length - 1);
                    if (Dungeon.isChallenger) {
                      Player[0].sendAction('Q_REWARD', {
                        reward: Player[attacker].hand[Player[attacker].look[eLOOK.H]].questReward
                      });
                    } 
                  }
                  else if (!Player[0].battleOpponentId&&attacker == 1){
                    Player[attacker].hand[Player[attacker].look[eLOOK.H]].questReward = rnd(0, Player[attacker].deck.length - 1);
                  }
                }
                //Sail Boat prep
                if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 55){
                  let cardToKeep = Player[attacker].hand[Player[attacker].look[eLOOK.H]];
                  Player[attacker].hand = [cardToKeep];
                  Player[attacker].look[eLOOK.H] = 0;
                }
                //Dragon Hoard prep
                if(Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 67){
                  dragonHoard = 0;
                }   
              }
              //ACTIVATE CARD EFFECT
              if (this.at > 69){
                //check for subtype - 2:use, 3:equip
                switch (Player[attacker].hand[Player[attacker].look[eLOOK.H]].subType){
                  case 2://use
                    //horn of judgement
                    if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 20){
                        Player[attacker].hand.splice(Player[attacker].look[eLOOK.H],1);
                        Player[attacker].look[eLOOK.H] = 0;
                        
                        //kill both then go to opt 9
                        Player[0].option = 8;
                        Player[1].option = 8.3;
                        this.at = 0;
                        
                        if (this.foe == 1){this.flip()}
                      return
                    }
                    //scales of justice
                    if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 11){
                      Player[attacker].hand.splice(Player[attacker].look[eLOOK.H],1);
                      Player[attacker].look[eLOOK.H] = 0;
                      Player[attacker].hasScalesOfJustice = 1;
                      Player[attacker].look[eLOOK.A] = 0;
                      this.at = 0;
                      if (this.foe == 1){this.flip()}
                      return
                    }
                    //treasure chest//Sailboat/Teleportation Crystal
                    if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 10||Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 55||Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 43){
                      if (Player[attacker].deck.length > 0){
                        //Card draw animation
                        if (Player[attacker].foe == 1){this.flip()}
                        if (this.at <= 99){//move from deck to middle
                          if (Player[attacker].isCPU != 1){Player[attacker].deck[0].location = 'hand'}
                          Player[attacker].deck[0].place(7-((2.875/30)*(this.at-69)),7.5-((2/30)*(this.at-69)),1);
                          if (Player[attacker].isCPU == 1){ drawPortrait(-26, ((7-(tL/10)*1*.000069)+.40)-((2.875/30)*(this.at-69)), 8.5-((2/30)*(this.at-69)), .1369);}
                        }
                        if (this.at > 99 && this.at <=129){  //display center   
                          Player[attacker].deck[0].place(3.88,5.5,1) 
                          if (Player[attacker].isCPU == 1){ drawPortrait(-26, ((3.88-(tL/10)*1*.000069)+.40), 6.5, .1369);}
                        }
                        if (this.at > 129 && this.at <= 159){//move from center to hand
                          Player[attacker].deck[0].place(3.88-((2.875/30)*(this.at-129)),5.5+((2/30)*(this.at-129)),1);
                          if (Player[attacker].isCPU == 1){ drawPortrait(-26, ((3.88-(tL/10)*1*.000069)+.40)-((2.875/30)*(this.at-129)), 6.5+((2/30)*(this.at-129)), .1369);} 
                        }
                        if (Player[attacker].foe == 1){this.flip()}
                        /////////////////
                        if (this.at > 159){//put in hand/swap monster/dont swap
                          if (Player[attacker].deck[0].type == 0){//if monster
                            if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index != 43){ //check for Teleportation Crystal
                              if(Player[attacker].isCPU==1){Player[attacker].deck[0].location = 'hand'}
                              //draw graphics
                              if (Player[attacker].foe == 1){this.flip()}
                              drawShape('rec',0,0,1,3.875,5.45,2.25,3.55,0,0,0,0,`rgba(0,0,0,1)`,1);
                              Player[attacker].deck[0].place(1.5,6.5,1)
                              Player[attacker].aMonster[0].place(6.25,6.5,1);

                              drawText(2.15,5,6,1,'Swap out active monster?','white',1)
                              drawText(1.9,5.75,6,1,'Yes                   No','white',1)
                              if (Player[attacker].foe == 1){this.flip()}
                              ////////
                              if (Player[attacker].hasTreasureChest == 0) {Player[attacker].hasTreasureChest = 1}
                              if (Player[attacker].isCPU === 1 && this.at > 189){
                                // --- CPU TREASURE CHEST LOGIC START ---
                                if (Player[attacker].isCPU === 1 && Player[attacker].hasTreasureChest === 1) {
                                  // 1. Calculate Score for Current Monster (Sum of Max Stats + Mods)
                                  // Note: Current monster stats ALREADY include equipped item buffs, 
                                  // which is correct because swapping loses those items.
                                  let currentScore = 0;
                                  for(let s=0; s<4; s++) {
                                      currentScore += Player[attacker].aMonster[0].stat[s][eDICE.MAX] + Player[attacker].aMonster[0].stat[s][eDICE.MOD];
                                  }

                                  // 2. Calculate Score for New Monster (Raw Stats)
                                  let newScore = 0;
                                  for(let s=0; s<4; s++) {
                                      newScore += Player[attacker].deck[0].stat[s][eDICE.MAX] + Player[attacker].deck[0].stat[s][eDICE.MOD];
                                  }

                                  // 3. Smart Decision
                                  // If the new monster is stronger, take it.
                                  if (newScore > currentScore) {
                                      Player[attacker].hasTreasureChest = 2; // Yes (Swap)
                                  } else {
                                      Player[attacker].hasTreasureChest = 3; // No (Discard)
                                  }
                                  if (this.foe == 1){this.flip()}
                                  return; // Exit frame to let the swap logic execute next tick
                            }}
                              // --- CPU TREASURE CHEST LOGIC END ---
                              //yes
                              if (Player[attacker].hasTreasureChest == 2){
                                Player[attacker].unequip();
                                Player[attacker].aMonster.length = 0;
                                Player[attacker].aMonster.push(Player[attacker].deck.shift());
                                Player[attacker].aMonster[0].location = 'field';
                                Player[attacker].look[eLOOK.M] = 0;

                                if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 2){Player[0].option = 9;Player[1].option = 9;}
                                if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 1){Player[0].turnCurrent = 2}
                                if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 55){
                                  Player[0].option = 9;Player[1].option = 9;
                                }

                                this.at = 0;
                                Player[attacker].hand.splice(Player[attacker].look[eLOOK.H],1);
                                Player[attacker].look[eLOOK.H] = 0;
                                if (this.foe == 1){this.flip()}
                                return
                              }
                              //no
                              if (Player[attacker].hasTreasureChest == 3){

                                if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 2){Player[0].option = 9;Player[1].option = 9;}
                                if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 1){Player[0].turnCurrent = 2}
                                if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 55){
                                  Player[0].option = 9;Player[1].option = 9;
                                }
                                
                                Player[attacker].hand.splice(Player[attacker].look[eLOOK.H],1);
                                Player[attacker].deck.splice(0,1);
                                Player[attacker].look[eLOOK.H] = 0;
                                Player[attacker].hasTreasureChest = 0;
                                
                                this.at = 0;
                                
                                if (this.foe == 1){this.flip()}
                                return
                              }
                            }
                            //IF TELEPORTATION CRYSTAL AUTO YES MONSTER
                            else{
                              Player[attacker].unequip();
                              Player[attacker].aMonster.length = 0;
                              Player[attacker].aMonster.push(Player[attacker].deck.shift());
                              Player[attacker].aMonster[0].location = 'field';
                              Player[attacker].look[eLOOK.M] = 0;

                              Player[0].option = 9;Player[1].option = 9;
                              
                              this.at = 0;
                              Player[attacker].hand.splice(Player[attacker].look[eLOOK.H],1);
                              Player[attacker].look[eLOOK.H] = 0;
                              if (this.foe == 1){this.flip()}
                              return
                            }
                          }
                          //item
                          else{
                            if (Player[attacker].isCPU == 1){Player[attacker].deck[0].location = 'hand'}
                            Player[attacker].hand.push(Player[attacker].deck.shift());
                            this.at = 69;
                            if (this.foe == 1){this.flip()}
                            return
                          }  
                        }
                      }//end if deck.legth > 0 
                      //if no cards in deck for teleportation crystal
                      else{
                        if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 43){
                          if(attacker == 0){
                            Player[0].option = 10; Player[1].option = 10.1;
                          }
                          else{
                            Player[0].option = 10;Player[1].option = 10.2;
                          }
                        }
                        else{
                          Player[attacker].hand.splice(Player[attacker].look[eLOOK.H],1);
                          Player[attacker].look[eLOOK.H] = 0;

                          if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 2){Player[0].option = 9;Player[1].option = 9;}
                          if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 1){Player[0].turnCurrent = 2}

                          this.at = 0;
                          if (this.foe == 1){this.flip()}
                          return;
                        }
                      }
                    
                    }
                    //Solar Rite
                    if (Player[attacker].hand[ Player[attacker].look[eLOOK.H]].index == 19){
                      
                      let tempindex = Player[attacker].aMonster[0].index
                      Player[attacker].aMonster.length = 0;
                      Player[attacker].aMonster[0] = new Card(tempindex,0)
                      Player[attacker].aMonster[0].location = 'field';
                      Player[attacker].aMonster[0].foe = Player[attacker].foe;
                      Player[attacker].look[eLOOK.M] = 0;
                      Player[attacker].aMonster[0].locIndex = 0;
                      Player[attacker].aMonster[0].locCount = 1;

                      tempindex = Player[attacker].opponent.aMonster[0].index
                      Player[attacker].opponent.aMonster.length = 0;
                      Player[attacker].opponent.aMonster[0] = new Card(tempindex,1)
                      Player[attacker].opponent.aMonster[0].location = 'field';
                      Player[attacker].opponent.look[eLOOK.M] = 0;
                      Player[attacker].opponent.aMonster[0].foe = Player[attacker].opponent.foe;
                      Player[attacker].opponent.aMonster[0].locIndex = 0;
                      Player[attacker].opponent.aMonster[0].locCount = 1;
                      
                      
                      if (sRune.owner == Player[attacker].foe) {sRune.changeOwner(Player[attacker].foe)}
                      if (cRune.owner == Player[attacker].foe) {cRune.changeOwner(Player[attacker].foe)}
                      if (iRune.owner == Player[attacker].foe) {iRune.changeOwner(Player[attacker].foe)}
                      if (aRune.owner == Player[attacker].foe) {aRune.changeOwner(Player[attacker].foe)}
                      if (sRune.owner == Player[attacker].opponent.foe) {sRune.changeOwner(Player[attacker].opponent.foe)}
                      if (cRune.owner == Player[attacker].opponent.foe) {cRune.changeOwner(Player[attacker].opponent.foe)}
                      if (iRune.owner == Player[attacker].opponent.foe) {iRune.changeOwner(Player[attacker].opponent.foe)}
                      if (aRune.owner == Player[attacker].opponent.foe) {aRune.changeOwner(Player[attacker].opponent.foe)}
                      if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 2){Player[0].option = 9;Player[1].option = 9;}
                      if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 1){Player[0].turnCurrent = 2}
                      this.at = 0;
                      Player[attacker].hand.splice(this.look[eLOOK.H],1);
                      Player[attacker].look[eLOOK.H] = 0;
                      if (this.foe == 1){this.flip()}
                      return;
                    }
                    //Elixir
                    if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 25){
                      let tempindex = Player[attacker].aMonster[0].index
                      Player[attacker].unequip();
                      Player[attacker].aMonster.length = 0;
                      Player[attacker].aMonster[0] = new Card(tempindex,0)
                      Player[attacker].aMonster[0].location = 'field';
                      Player[attacker].aMonster[0].foe = Player[attacker].foe;
                      Player[attacker].look[eLOOK.M] = 0;
                      Player[attacker].aMonster[0].locIndex = 0;
                      Player[attacker].aMonster[0].locCount = 1;
                      if (sRune.owner == Player[attacker].foe) {sRune.changeOwner(Player[attacker].foe)}
                      if (cRune.owner == Player[attacker].foe) {cRune.changeOwner(Player[attacker].foe)}
                      if (iRune.owner == Player[attacker].foe) {iRune.changeOwner(Player[attacker].foe)}
                      if (aRune.owner == Player[attacker].foe) {aRune.changeOwner(Player[attacker].foe)}
                      
                      if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 2){Player[0].option = 9;Player[1].option = 9;}
                      if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 1){Player[0].turnCurrent = 2}
                      this.at = 0;
                      Player[attacker].hand.splice(Player[attacker].look[eLOOK.H],1);
                      Player[attacker].look[eLOOK.H] = 0;
                      if (this.foe == 1){this.flip()}
                      return;
                    }
                    //Quest Reward
                    if (Player[attacker].hand[ Player[attacker].look[eLOOK.H]].index == 38){
                      if (Player[attacker].deck.length > 0){
                        
                        let questReward = Player[attacker].hand[Player[attacker].look[eLOOK.H]].questReward;
                        //draw animation
                        if (attacker == 1){this.flip()}
                        if (this.at <= 99){//move from deck to middle
                          if (Player[attacker].isCPU != 1){Player[attacker].deck[questReward].location = 'hand'}
                          Player[attacker].deck[questReward].place(7-((2.875/30)*(this.at-69)),7.5-((2/30)*(this.at-69)),1);
                          if (Player[attacker].isCPU == 1){ drawPortrait(-26, ((7-(tL/10)*1*.000069)+.40)-((2.875/30)*(this.at-69)), 8.5-((2/30)*(this.at-69)), .1369);}
                        }
                        if (this.at > 99 && this.at <=129){  //display center   
                          Player[attacker].deck[questReward].place(3.88,5.5,1) 
                          if (Player[attacker].isCPU == 1){ drawPortrait(-26, ((3.88-(tL/10)*1*.000069)+.40), 6.5, .1369);}
                        }
                        if (this.at > 129 && this.at <= 159){//move from center to hand
                          Player[attacker].deck[questReward].place(3.88-((2.875/30)*(this.at-129)),5.5+((2/30)*(this.at-129)),1);
                          if (Player[attacker].isCPU == 1){ drawPortrait(-26, ((3.88-(tL/10)*1*.000069)+.40)-((2.875/30)*(this.at-129)), 6.5+((2/30)*(this.at-129)), .1369);} 
                        }
                        if (attacker == 1){this.flip()}
                        ///////////////////////
                        if (this.at > 159){//put in hand/swap monster/dont swap
                          if (Player[attacker].deck[questReward].type == 0){//if monster
                            if (Player[attacker].isCPU != 1){Player[attacker].deck[questReward].location = 'hand'}
                            if (attacker == 1){this.flip()}
                            drawShape('rec',0,0,1,3.875,5.45,2.25,3.55,0,0,0,0,`rgba(0,0,0,1)`,1);
                            Player[attacker].deck[questReward].place(1.5,6.5,1)
                            Player[attacker].aMonster[0].place(6.25,6.5,1);

                            drawText(2.15,5,6,1,'Swap out active monster?','white',1)
                            drawText(1.9,5.75,6,1,'Yes                   No','white',1)
                            if (attacker == 1){this.flip()}
                            if (Player[attacker].hasTreasureChest == 0) {Player[attacker].hasTreasureChest = 1}
                            // --- CPU TREASURE CHEST LOGIC START ---
                            if (Player[attacker].isCPU === 1 && Player[attacker].hasTreasureChest === 1) {
                                // 1. Calculate Score for Current Monster (Sum of Max Stats + Mods)
                                // Note: Current monster stats ALREADY include equipped item buffs, 
                                // which is correct because swapping loses those items.
                                let currentScore = 0;
                                for(let s=0; s<4; s++) {
                                    currentScore += Player[attacker].aMonster[0].stat[s][eDICE.MAX] + Player[attacker].aMonster[0].stat[s][eDICE.MOD];
                                }

                                // 2. Calculate Score for New Monster (Raw Stats)
                                let newScore = 0;
                                for(let s=0; s<4; s++) {
                                    newScore += Player[attacker].deck[questReward].stat[s][eDICE.MAX] + Player[attacker].deck[questReward].stat[s][eDICE.MOD];
                                }

                                // 3. Smart Decision
                                // If the new monster is stronger, take it.
                                if (newScore > currentScore) {
                                    Player[attacker].hasTreasureChest = 2; // Yes (Swap)
                                } else {
                                    Player[attacker].hasTreasureChest = 3; // No (Discard)
                                }
                                if (this.foe == 1){this.flip()}
                                return; // Exit frame to let the swap logic execute next tick
                            }
                            // --- CPU TREASURE CHEST LOGIC END ---
                            //yes
                            if (Player[attacker].hasTreasureChest == 2){
                              Player[attacker].aMonster.length = 0;
                              Player[attacker].aMonster.push(Player[attacker].deck.splice(questReward,1)[0]);
                              Player[attacker].aMonster[0].location = 'field';
                              Player[attacker].look[eLOOK.M] = 0;
                              if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 2){Player[0].option = 9;Player[1].option = 9;}
                              if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 1){Player[0].turnCurrent = 2}
                              this.at = 0;
                              Player[attacker].hand.splice(Player[attacker].look[eLOOK.H],1);
                              Player[attacker].look[eLOOK.H] = 0;
                              Player[attacker].unequip();
                              if (this.foe == 1){this.flip()}
                              return
                            }
                            //no
                            if (Player[attacker].hasTreasureChest == 3){
                              Player[attacker].hand.splice(Player[attacker].look[eLOOK.H],1);
                              Player[attacker].deck.splice(questReward,1);
                              Player[attacker].look[eLOOK.H] = 0;
                              
                              Player[attacker].hasTreasureChest = 0;
                              if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 2){Player[0].option = 9;Player[1].option = 9;}
                              if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 1){Player[0].turnCurrent = 2}
                              this.at = 0;
                              if (this.foe == 1){this.flip()}
                              return;

                            }
                          }
                          //item
                          else{
                            if (Player[attacker].isCPU == 1){Player[attacker].deck[questReward].location = 'hand'}
                            Player[attacker].hand.push(Player[attacker].deck.splice(questReward,1)[0]);
                            if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 2){Player[0].option = 9;Player[1].option = 9;}
                            if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 1){Player[0].turnCurrent = 2}
                            this.at = 0;
                            Player[attacker].hand.splice(Player[attacker].look[eLOOK.H],1);
                            Player[attacker].look[eLOOK.H] = 0;
                            if (this.foe == 1){this.flip()}
                            return;
                          }
                          
                        }
                      } 
                      //no cards in deck
                      else{
                        Player[attacker].hand.splice(Player[attacker].look[eLOOK.H],1);
                        Player[attacker].look[eLOOK.H] = 0;
                        if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 2){Player[0].option = 9;Player[1].option = 9;}
                        if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 1){Player[0].turnCurrent = 2}
                        this.at = 0;
                        if (this.foe == 1){this.flip()}
                        return;
                      }
                    
                    }
                     //Dragon Wing
                    if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 39){
                      if (Player[attacker].opponent.deck.length > 0){
                        if (attacker == 1){this.flip()}
                        if (this.at <= 99){//move from deck to middle
                          if (Player[attacker].opponent.isCPU != 1){Player[attacker].opponent.deck[0].location = 'hand'}
                          this.flip();
                          drawShape('rec',0,0,1,3.875,5.45,2.25,3.55,0,0,0,0,`rgba(0,0,0,1)`,1);
                          Player[attacker].opponent.deck[0].place(7-((2.875/30)*(this.at-69)),7.5-((2/30)*(this.at-69)),1);
                          if (Player[attacker].opponent.isCPU == 1){ drawPortrait(-26, ((7-(tL/10)*1*.000069)+.40)-((2.875/30)*(this.at-69)), 8.5-((2/30)*(this.at-69)), .1369);}
                          this.flip();
                        }
                        if (this.at > 99 && this.at <=129){  //display center   
                          this.flip();
                          drawShape('rec',0,0,1,3.875,5.45,2.25,3.55,0,0,0,0,`rgba(0,0,0,1)`,1);
                          Player[attacker].opponent.deck[0].place(3.88,5.5,1) 
                          if (Player[attacker].opponent.isCPU == 1){ drawPortrait(-26, ((3.88-(tL/10)*1*.000069)+.40), 6.5, .1369);}
                          this.flip();
                        }
                        if (this.at > 129 && this.at <= 159){//move from center to hand
                          this.flip();
                          drawShape('rec',0,0,1,3.875,5.45,2.25,3.55,0,0,0,0,`rgba(0,0,0,1)`,1);
                          Player[attacker].opponent.deck[0].place(3.88-((2.875/30)*(this.at-129)),5.5+((2/30)*(this.at-129)),1);
                          if (Player[attacker].opponent.isCPU == 1){ drawPortrait(-26, ((3.88+(tL/10)*1*.000069)+.40)-((2.875/30)*(this.at-129)), 6.5+((2/30)*(this.at-129)), .1369);}
                          this.flip();
                        }
                        if (attacker == 1){this.flip()}
                        if (this.at > 159){//put in hand/swap monster/dont swap
                          if (Player[attacker].opponent.deck[0].type == 0){//if monster
                            Player[attacker].opponent.unequip();
                            Player[attacker].opponent.aMonster.length = 0;
                            Player[attacker].opponent.aMonster.push(Player[attacker].opponent.deck.shift());
                            Player[attacker].opponent.aMonster[0].location = 'field';
                            Player[attacker].opponent.look[eLOOK.M] = 0;
                            Player[0].option = 9;Player[0].opponent.option = 9;
                            this.at = 0;
                            Player[attacker].hand.splice(Player[attacker].look[eLOOK.H],1);
                            Player[attacker].look[eLOOK.H] = 0;
                            if (this.foe == 1){this.flip()}
                            return
                          }
                          //item
                          else{
                            Player[attacker].opponent.deck.shift();
                            this.at = 69;
                            if (this.foe == 1){this.flip()}
                            return
                          }  
                        }
                      }//end if deck.legth > 0 
                      //if no cards in deck
                      else{
                        if(attacker == 0){
                          Player[0].option = 10; Player[1].option = 10.1;
                        }
                        else{
                          Player[0].option = 10;Player[1].option = 10.2;
                        }
                      }
                    }
                    //Loot
                    if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 41){
                      if (Player[attacker].deck.length > 0){
                        if (attacker == 1){this.flip()}
                        if (this.at <= 99){//move from deck to middle
                          if (Player[attacker].isCPU != 1){Player[attacker].deck[Player[attacker].deck.length-1].location = 'hand'}
                          Player[attacker].deck[Player[attacker].deck.length-1].place(7-((2.875/30)*(this.at-69)),7.5-((2/30)*(this.at-69)),1);
                          if (Player[attacker].isCPU == 1){ drawPortrait(-26, ((7-(tL/10)*1*.000069)+.40)-((2.875/30)*(this.at-69)), 8.5-((2/30)*(this.at-69)), .1369);}
                        }
                        if (this.at > 99 && this.at <=129){  //display center   
                          Player[attacker].deck[Player[attacker].deck.length-1].place(3.88,5.5,1) 
                          if (Player[attacker].isCPU == 1){drawPortrait(-26, ((3.88-(tL/10)*1*.000069)+.40), 6.5, .1369);}
                        }
                        if (this.at > 129 && this.at <= 159){//move from center to hand
                          Player[attacker].deck[Player[attacker].deck.length-1].place(3.88-((2.875/30)*(this.at-129)),5.5+((2/30)*(this.at-129)),1);
                          if (Player[attacker].isCPU == 1){ drawPortrait(-26, ((3.88-(tL/10)*1*.000069)+.40)-((2.875/30)*(this.at-129)), 6.5+((2/30)*(this.at-129)), .1369);} 
                        }
                        if (attacker == 1){this.flip()}
                        if (this.at > 159){
                          //monster
                          if (Player[attacker].deck[Player[attacker].deck.length-1].type == 0){
                            Player[attacker].deck.pop();
                            Player[attacker].hand.splice(Player[attacker].look[eLOOK.H],1);
                            Player[attacker].look[eLOOK.H] = 0;
                            if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 2){Player[0].option = 9;Player[1].option = 9;}
                            if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 1){Player[0].turnCurrent = 2}
                            this.at = 0;
                            if (this.foe == 1){this.flip()}
                            return;
                          }
                          //item
                          else{
                            if (this.isCPU == 1){Player[attacker].deck[Player[attacker].deck.length-1].location = 'hand'}
                            Player[attacker].hand.push(Player[attacker].deck.pop());
                            Player[attacker].hand.splice(Player[attacker].look[eLOOK.H],1);
                            Player[attacker].look[eLOOK.H] = 0;
                            if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 2){Player[0].option = 9;Player[1].option = 9;}
                            if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 1){Player[0].turnCurrent = 2}
                            this.at = 0;
                            if (this.foe == 1){this.flip()}
                            return;
                          }   
                        }
                      }//end if deck length > 0 
                      //no cards in deck
                      else{
                        Player[attacker].hand.splice(Player[attacker].look[eLOOK.H],1);
                        Player[attacker].look[eLOOK.H] = 0;
                        if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 2){Player[0].option = 9;Player[1].option = 9;}
                        if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 1){Player[0].turnCurrent = 2}
                        this.at = 0;
                        if (this.foe == 1){this.flip()}
                        return;
                      }
                    
                    }
                    //Djinn Lamp
                    if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 44){
                      if (spellcheck ==0){
                        if (attacker == 0){
                          Player[0].preOpt = 'attacker';
                        }
                        else{
                          Player[0].preOpt = 'defender';
                        }
                      Player[0].option =6.4;
                      Player[1].option = 6.4
                      spellcheck = 1;
                      Player[attacker].look[eLOOK.D]= 0;
                      if (this.foe == 1){this.flip();}
                      return
                      }
                      else{
                        Player[attacker].hand.splice(Player[attacker].look[eLOOK.H],1);
                        Player[attacker].look[eLOOK.H] = 0;
                        if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 2){Player[0].option = 9;Player[1].option = 9;}
                        if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 1){Player[0].turnCurrent = 2}
                        this.at = 0;
                        spellcheck = 0;
                        if (this.foe == 1){this.flip()}
                        return;
                      }
                    }
                    //Camp
                    if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 53){
                      if (Player[attacker].deck.length > 0){
                        if (attacker == 1){this.flip()}
                        if (this.at <= 99){//move from deck to middle
                          if (Player[attacker].isCPU != 1){Player[attacker].deck[0].location = 'hand'}
                          Player[attacker].deck[0].place(7-((2.875/30)*(this.at-69)),7.5-((2/30)*(this.at-69)),1);
                          if (Player[attacker].isCPU == 1){ drawPortrait(-26, ((7-(tL/10)*1*.000069)+.40)-((2.875/30)*(this.at-69)), 8.5-((2/30)*(this.at-69)), .1369);}
                        }
                        if (this.at > 99 && this.at <=129){  //display center   
                          Player[attacker].deck[0].place(3.88,5.5,1) 
                          if (Player[attacker].isCPU == 1){ drawPortrait(-26, ((3.88-(tL/10)*1*.000069)+.40), 6.5, .1369);}
                        }
                        if (this.at > 129 && this.at <= 159){//move from center to hand
                          Player[attacker].deck[0].place(3.88-((2.875/30)*(this.at-129)),5.5+((2/30)*(this.at-129)),1);
                          if (Player[attacker].isCPU == 1){ drawPortrait(-26, ((3.88-(tL/10)*1*.000069)+.40)-((2.875/30)*(this.at-129)), 6.5+((2/30)*(this.at-129)), .1369);} 
                        }
                        if (attacker == 1){this.flip()}
                        if (this.at > 159){
                          //monster
                          if (Player[attacker].deck[0].type == 0){
                            Player[attacker].deck.shift();
                            Player[attacker].hand.splice(Player[attacker].look[eLOOK.H],1);
                            Player[attacker].look[eLOOK.H] = 0;
                            if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 2){Player[0].option = 9;Player[1].option = 9;}
                            if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 1){Player[0].turnCurrent = 2}
                            this.at = 0;
                            if (this.foe == 1){this.flip()}
                            return;
                          }
                          //item
                          else{
                            if (Player[attacker].isCPU == 1){Player[attacker].deck[0].location = 'hand'}
                            Player[attacker].hand.push(Player[attacker].deck.shift());
                            Player[attacker].hand.splice(Player[attacker].look[eLOOK.H],1);
                            Player[attacker].look[eLOOK.H] = 0;
                            if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 2){Player[0].option = 9;Player[1].option = 9;}
                            if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 1){Player[0].turnCurrent = 2}
                            this.at = 0;
                            if (this.foe == 1){this.flip()}
                            return;
                          }

                          
                        }
                      }//end if deck length > 0 
                      //no cards in deck
                      else{
                        Player[attacker].hand.splice(Player[attacker].look[eLOOK.H],1);
                        Player[attacker].look[eLOOK.H] = 0;
                        if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 2){Player[0].option = 9;Player[1].option = 9;}
                        if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 1){Player[0].turnCurrent = 2}
                        this.at = 0;
                        if (this.foe == 1){this.flip()}
                        return;
                      }
                    
                    }
                    //Dragon Hoard
                    if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 67){
                      if (Player[attacker].deck.length > 0){
                        if (attacker == 1){this.flip()}
                        if (this.at <= 99){//move from deck to middle
                          if (Player[attacker].isCPU != 1){Player[attacker].deck[0].location = 'hand'}
                          Player[attacker].deck[0].place(7-((2.875/30)*(this.at-69)),7.5-((2/30)*(this.at-69)),1);
                          if (Player[attacker].isCPU == 1){ drawPortrait(-26, ((7-(tL/10)*1*.000069)+.40)-((2.875/30)*(this.at-69)), 8.5-((2/30)*(this.at-69)), .1369);}
                        }
                        if (this.at > 99 && this.at <=129){  //display center   
                          Player[attacker].deck[0].place(3.88,5.5,1) 
                          if (Player[attacker].isCPU == 1){ drawPortrait(-26, ((3.88-(tL/10)*1*.000069)+.40), 6.5, .1369);}
                        }
                        if (this.at > 129 && this.at <= 159){//move from center to hand
                          Player[attacker].deck[0].place(3.88-((2.875/30)*(this.at-129)),5.5+((2/30)*(this.at-129)),1);
                          if (Player[attacker].isCPU == 1){ drawPortrait(-26, ((3.88-(tL/10)*1*.000069)+.40)-((2.875/30)*(this.at-129)), 6.5+((2/30)*(this.at-129)), .1369);} 
                        }
                        if (attacker == 1){this.flip()}
                        if (this.at > 159){//put in hand/swap monster/dont swap
                          if (Player[attacker].deck[0].type == 0){//if monster
                              dragonHoard = dragonHoard + 1
                              Player[attacker].unequip()
                              Player[attacker].aMonster.length = 0;
                              Player[attacker].aMonster.push(Player[attacker].deck.shift());
                              Player[attacker].aMonster[0].location = 'field';
                              Player[attacker].look[eLOOK.M] = 0;
                              Player[attacker].opponent.deck.splice(0,dragonHoard);
                              dragonHoard = 0;
                              if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 2){Player[0].option = 9;Player[1].option = 9;}
                              if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 1){Player[0].turnCurrent = 2}
                              
                              this.at = 0;
                              Player[attacker].hand.splice(Player[attacker].look[eLOOK.H],1);
                              Player[attacker].look[eLOOK.H] = 0;
                              if (this.foe == 1){this.flip()}
                              return
                            
                          }
                          //item
                          else{
                            if (Player[attacker].isCPU == 1){Player[attacker].deck[0].location = 'hand'}

                            dragonHoard = dragonHoard + 1
                            Player[attacker].hand.push(Player[attacker].deck.shift());
                            this.at = 69;
                            if (this.foe == 1){this.flip()}
                            return
                          }  
                        }
                      }//end if deck.legth > 0 
                      //if no cards in deck
                      else{
                        Player[attacker].hand.splice(Player[attacker].look[eLOOK.H],1);
                        Player[attacker].look[eLOOK.H] = 0;
                        if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 2){Player[0].option = 9;Player[1].option = 9;}
                        if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 1){Player[0].turnCurrent = 2}
                        this.at = 0;
                        if (this.foe == 1){this.flip()}
                        return;
                      }
                    
                    }
                    //Bad Luck Charm
                    if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 68){
                      Player[attacker].opponent.unequip();
                      let tempindex2 = Player[attacker].opponent.aMonster[0].index
                      Player[attacker].opponent.aMonster.length = 0;
                      Player[attacker].opponent.aMonster[0] = new Card(tempindex2,1)
                      Player[attacker].opponent.aMonster[0].location = 'field';
                      Player[attacker].opponent.look[eLOOK.M] = 0;
                      Player[attacker].opponent.aMonster[0].foe = Player[attacker].opponent.foe;
                      Player[attacker].opponent.aMonster[0].locIndex = 0;
                      Player[attacker].opponent.aMonster[0].locCount = 1;
                      Player[attacker].opponent.aMonster[0].stat[eSTAT.S][eDICE.MOD]=Player[attacker].opponent.aMonster[0].stat[eSTAT.S][eDICE.MOD] - 1;
                      Player[attacker].opponent.aMonster[0].stat[eSTAT.C][eDICE.MOD]=Player[attacker].opponent.aMonster[0].stat[eSTAT.C][eDICE.MOD] - 1;
                      Player[attacker].opponent.aMonster[0].stat[eSTAT.I][eDICE.MOD]=Player[attacker].opponent.aMonster[0].stat[eSTAT.I][eDICE.MOD] - 1;
                      Player[attacker].opponent.aMonster[0].stat[eSTAT.A][eDICE.MOD]=Player[attacker].opponent.aMonster[0].stat[eSTAT.A][eDICE.MOD] - 1;
                      
                      

                      if (sRune.owner == Player[attacker].opponent.foe) {sRune.changeOwner(Player[attacker].opponent.foe)}
                      if (cRune.owner == Player[attacker].opponent.foe) {cRune.changeOwner(Player[attacker].opponent.foe)}
                      if (iRune.owner == Player[attacker].opponent.foe) {iRune.changeOwner(Player[attacker].opponent.foe)}
                      if (aRune.owner == Player[attacker].opponent.foe) {aRune.changeOwner(Player[attacker].opponent.foe)}
                      if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 2){Player[0].option = 9;Player[1].option = 9;}
                      if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 1){Player[0].turnCurrent = 2}
                      this.at = 0;
                      Player[attacker].hand.splice(Player[attacker].look[eLOOK.H],1);
                      Player[attacker].look[eLOOK.H] = 0;
                      if (this.foe == 1){this.flip()}
                      return;
                    }
                    //Charity
                    if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 69){
                      if (Player[attacker].opponent.deck.length > 0){
                        if (attacker == 1){this.flip()}
                        if (this.at <= 99){//move from deck to middle
                          if (Player[attacker].opponent.isCPU != 1){Player[attacker].opponent.deck[0].location = 'hand'}
                          this.flip();
                          Player[attacker].opponent.deck[0].place(7-((2.875/30)*(this.at-69)),7.5-((2/30)*(this.at-69)),1);
                          if (Player[attacker].opponent.isCPU == 1){drawPortrait(-26, ((7-(tL/10)*1*.000069)+.40)-((2.875/30)*(this.at-69)), 8.5-((2/30)*(this.at-69)), .1369);}
                          this.flip();
                        }
                        if (this.at > 99 && this.at <=129){  //display center   
                            this.flip();
                            Player[attacker].opponent.deck[0].place(3.88,5.5,1) 
                            if (Player[attacker].opponent.isCPU == 1){ drawPortrait(-26, ((3.88-(tL/10)*1*.000069)+.40), 6.5, .1369);}
                            this.flip();
                        }
                        if (this.at > 129 && this.at <= 159){//move from center to hand
                          this.flip();
                          Player[attacker].opponent.deck[0].place(3.88-((2.875/30)*(this.at-129)),5.5+((2/30)*(this.at-129)),1);
                          if (Player[attacker].opponent.isCPU == 1){drawPortrait(-26, ((3.88-(tL/10)*1*.000069)+.40)-((2.875/30)*(this.at-129)), 6.5+((2/30)*(this.at-129)), .1369);}
                          this.flip();
                        }
                        if (attacker == 1){this.flip()}
                        if (this.at > 159){
                          //monster
                          if (Player[attacker].deck[0].type == 0){
                            Player[attacker].opponent.deck.shift();
                            Player[attacker].hand.splice(Player[attacker].look[eLOOK.H],1);
                            Player[attacker].look[eLOOK.H] = 0;
                            if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 2){Player[0].option = 9;Player[1].option = 9;}
                            if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 1){Player[0].turnCurrent = 2}
                            this.at = 0;
                            if (this.foe == 1){this.flip()}
                            return;
                          }
                          //item
                          else{
                            if (Player[attacker].opponent.isCPU == 1){
                            Player[attacker].opponent.deck[0].location = 'hand'
                            }
                            Player[attacker].opponent.hand.push(Player[attacker].opponent.deck.shift());
                            Player[attacker].hand.splice(Player[attacker].look[eLOOK.H],1);
                            Player[attacker].look[eLOOK.H] = 0;
                            if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 2){Player[0].option = 9;Player[1].option = 9;}
                            if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 1){Player[0].turnCurrent = 2}
                            this.at = 0;
                            if (this.foe == 1){this.flip()}
                            return;
                          }

                          
                        }
                      }//end if deck length > 0 
                      //no cards in deck
                      else{
                        Player[attacker].hand.splice(Player[attacker].look[eLOOK.H],1);
                        Player[attacker].look[eLOOK.H] = 0;
                        if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 2){Player[0].option = 9;Player[1].option = 9;}
                        if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 1){Player[0].turnCurrent = 2}
                        this.at = 0;
                        if (this.foe == 1){this.flip()}
                        return;
                      }
                    
                    }
                    //Ineritance
                    if (Player[attacker].hand[ Player[attacker].look[eLOOK.H]].index == 73){
                      if (Player[attacker].deck.length > 0){
                        if (attacker == 1){this.flip()}
                        if (this.at <= 99){//move from deck to middle
                          if (Player[attacker].isCPU != 1){Player[attacker].deck[0].location = 'hand'}
                          Player[attacker].deck[0].place(7-((2.875/30)*(this.at-69)),7.5-((2/30)*(this.at-69)),1);
                          if (Player[attacker].isCPU == 1){ drawPortrait(-26, ((7-(tL/10)*1*.000069)+.40)-((2.875/30)*(this.at-69)), 8.5-((2/30)*(this.at-69)), .1369);}
                        }
                        if (this.at > 99 && this.at <=129){  //display center   
                          Player[attacker].deck[0].place(3.88,5.5,1) 
                          if (Player[attacker].isCPU == 1){ drawPortrait(-26, ((3.88-(tL/10)*1*.000069)+.40), 6.5, .1369);}
                        }
                        if (this.at > 129 && this.at <= 159){//move from center to hand
                          Player[attacker].deck[0].place(3.88-((2.875/30)*(this.at-129)),5.5+((2/30)*(this.at-129)),1);
                          if (Player[attacker].isCPU == 1){ drawPortrait(-26, ((3.88-(tL/10)*1*.000069)+.40)-((2.875/30)*(this.at-129)), 6.5+((2/30)*(this.at-129)), .1369);} 
                        }
                        if (attacker == 1){this.flip()}
                        if (this.at > 159){//put in hand/swap monster/dont swap
                          if (Player[attacker].deck[0].type == 0){//if monster
                              Player[attacker].unequip();
                              Player[attacker].aMonster.length = 0;
                              Player[attacker].aMonster.push(Player[attacker].deck.shift());
                              Player[attacker].aMonster[0].location = 'field';
                              Player[attacker].look[eLOOK.M] = 0;
                              if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 2){Player[0].option = 9;Player[1].option = 9;}
                              if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 1){Player[0].turnCurrent = 2}
                                          
                              this.at = 0;
                              Player[attacker].hand.splice(Player[attacker].look[eLOOK.H],1);
                              Player[attacker].look[eLOOK.H] = 0;
                              Player[attacker].aMonster[0].stat[eSTAT.S][eDICE.MOD]=this.aMonster[0].stat[eSTAT.S][eDICE.MOD] + 2;
                              Player[attacker].aMonster[0].stat[eSTAT.C][eDICE.MOD]=this.aMonster[0].stat[eSTAT.C][eDICE.MOD] + 2;
                              Player[attacker].aMonster[0].stat[eSTAT.I][eDICE.MOD]=this.aMonster[0].stat[eSTAT.I][eDICE.MOD] + 2;
                              Player[attacker].aMonster[0].stat[eSTAT.A][eDICE.MOD]=this.aMonster[0].stat[eSTAT.A][eDICE.MOD] + 2;
                              if (this.foe == 1){this.flip()}
                              return
                            
                          }
                          //item
                          else{
                            if (Player[attacker].isCPU == 1){Player[attacker].deck[0].location = 'hand'}
                            Player[attacker].hand.push(Player[attacker].deck.shift());
                            this.at = 69;
                            if (this.foe == 1){this.flip()}
                            return
                          }  
                        }
                      }//end if deck.legth > 0 
                      //if no cards in deck
                      else{
                        if(attacker == 0){
                            Player[0].option = 10; Player[1].option = 10.1;
                          }
                        else{
                          Player[0].option = 10;Player[1].option = 10.2;
                        }
                        
                      }
                    
                    }
                    
                    break;
                  case 3://equip
                    Player[attacker].draw = 0;
                    Player[attacker].aMonster.push(Player[attacker].hand.splice(Player[attacker].look[eLOOK.H],1)[0]) 
                    Player[attacker].look[eLOOK.H] = 0;
                    Player[attacker].aMonster[Player[attacker].aMonster.length - 1].location = "field";
                    Player[attacker].aMonster[Player[attacker].aMonster.length - 1].locCount = Player[attacker].aMonster.length - 1;
                    Player[attacker].aMonster[Player[attacker].aMonster.length-1].locIndex = Player[attacker].aMonster.length-1;
                    Player[attacker].at = 0;
                    //Winged Boots
                    if (Player[attacker].aMonster[Player[attacker].aMonster.length - 1].index == 7&&spellcheck == 0){
                      Player[attacker].aMonster[0].stat[3][2]= Player[attacker].aMonster[0].stat[3][2]+3;
                      Player[attacker].hasWingedBoots = 1;
                      spellcheck = 1;
                    }
                    //Star Pendant
                    if (Player[attacker].aMonster[Player[attacker].aMonster.length - 1].index == 17&&spellcheck == 0){
                      Player[attacker].hasStarPendant = 1;
                      spellcheck = 1;
                    }
                    //Lovers
                    if (Player[attacker].aMonster[Player[attacker].aMonster.length - 1].index == 6&&spellcheck == 0){
                      Player[attacker].hasLovers = 1;
                      Player[attacker].aMonster[0].stat[eSTAT.S][eDICE.MOD]=Player[attacker].aMonster[0].stat[eSTAT.S][eDICE.MOD] + 1;
                      Player[attacker].aMonster[0].stat[eSTAT.C][eDICE.MOD]=Player[attacker].aMonster[0].stat[eSTAT.C][eDICE.MOD] + 1;
                      spellcheck = 1;
                    }
                    //Wand
                    if (Player[attacker].aMonster[Player[attacker].aMonster.length - 1].index == 22&&spellcheck == 0){
                      Player[attacker].aMonster[0].stat[eSTAT.I][eDICE.MOD]=Player[attacker].aMonster[0].stat[eSTAT.I][eDICE.MOD] + 1;
                      spellcheck = 1;
                    }
                    //Amulet
                    if (Player[attacker].aMonster[Player[attacker].aMonster.length - 1].index == 27&&spellcheck == 0){
                      Player[attacker].hasAmulet = 1;
                      Player[attacker].aMonster[0].stat[eSTAT.I][eDICE.MOD]=Player[attacker].aMonster[0].stat[eSTAT.I][eDICE.MOD] + 1;                      
                      spellcheck = 1;
                    }
                    //Protect Orb
                    if (Player[attacker].aMonster[Player[attacker].aMonster.length - 1].index == 30&&spellcheck == 0){
                      
                      Player[attacker].hasProtectOrb = 1;
                      spellcheck = 1;
                    }
                    //Tome
                    if (Player[attacker].aMonster[Player[attacker].aMonster.length - 1].index == 31&&spellcheck == 0){
                      Player[attacker].aMonster[0].stat[eSTAT.I][eDICE.MOD]=Player[attacker].aMonster[0].stat[eSTAT.I][eDICE.MOD] + 6;
                      Player[attacker].aMonster[0].stat[eSTAT.A][eDICE.MOD]=Player[attacker].aMonster[0].stat[eSTAT.A][eDICE.MOD] - 3;
                      Player[attacker].aMonster[0].stat[eSTAT.S][eDICE.MOD]=Player[attacker].aMonster[0].stat[eSTAT.S][eDICE.MOD] - 1;
                      spellcheck = 1;
                     ;
                    }
                    //Hourglass
                    if (Player[attacker].aMonster[Player[attacker].aMonster.length - 1].index == 36&&spellcheck == 0){
                      Player[attacker].aMonster[0].stat[eSTAT.A][eDICE.MOD]=Player[attacker].aMonster[0].stat[eSTAT.A][eDICE.MOD] + 1;
                      spellcheck = 1;
                     
                    }
                    //Lucky Charm
                    if (Player[attacker].aMonster[Player[attacker].aMonster.length - 1].index == 45&&spellcheck == 0){
                      Player[attacker].hasLuckyCharm = 1; 
                      spellcheck = 1;
                     
                    }
                    //Sword
                    if (Player[attacker].aMonster[Player[attacker].aMonster.length - 1].index == 50&&spellcheck == 0){
                      Player[attacker].aMonster[0].stat[eSTAT.S][eDICE.MOD]=Player[attacker].aMonster[0].stat[eSTAT.S][eDICE.MOD] + 1;
                      spellcheck = 1;
                     
                    }
                    //Shield
                    if (Player[attacker].aMonster[Player[attacker].aMonster.length - 1].index == 64&&spellcheck == 0){
                      Player[attacker].aMonster[0].stat[eSTAT.C][eDICE.MOD]=Player[attacker].aMonster[0].stat[eSTAT.C][eDICE.MOD] + 1;
                      spellcheck = 1;
                     
                    }
                    //Armor
                    if (Player[attacker].aMonster[Player[attacker].aMonster.length - 1].index == 66&&spellcheck == 0){
                      Player[attacker].aMonster[0].stat[eSTAT.C][eDICE.MOD]=Player[attacker].aMonster[0].stat[eSTAT.C][eDICE.MOD] + 3;
                      spellcheck = 1;
                     
                    }
                    //Magic Ring
                    if (Player[attacker].aMonster[Player[attacker].aMonster.length - 1].index == 72&&spellcheck == 0){
                      Player[attacker].aMonster[0].stat[eSTAT.S][eDICE.MOD]=Player[attacker].aMonster[0].stat[eSTAT.S][eDICE.MOD] + 1;
                      Player[attacker].aMonster[0].stat[eSTAT.C][eDICE.MOD]=Player[attacker].aMonster[0].stat[eSTAT.C][eDICE.MOD] + 1;
                      Player[attacker].aMonster[0].stat[eSTAT.I][eDICE.MOD]=Player[attacker].aMonster[0].stat[eSTAT.I][eDICE.MOD] + 1;
                      Player[attacker].aMonster[0].stat[eSTAT.A][eDICE.MOD]=Player[attacker].aMonster[0].stat[eSTAT.A][eDICE.MOD] + 1;
                      spellcheck = 1;
                     
                    }
                    //Crown
                    if (Player[attacker].aMonster[Player[attacker].aMonster.length - 1].index == 21&&spellcheck == 0){
                      Player[attacker].aMonster[0].stat[eSTAT.S][eDICE.MOD]=Player[attacker].aMonster[0].stat[eSTAT.S][eDICE.MOD] + 3;
                      Player[attacker].aMonster[0].stat[eSTAT.C][eDICE.MOD]=Player[attacker].aMonster[0].stat[eSTAT.C][eDICE.MOD] + 3;
                      Player[attacker].aMonster[0].stat[eSTAT.I][eDICE.MOD]=Player[attacker].aMonster[0].stat[eSTAT.I][eDICE.MOD] + 3;
                      Player[attacker].aMonster[0].stat[eSTAT.A][eDICE.MOD]=Player[attacker].aMonster[0].stat[eSTAT.A][eDICE.MOD] + 3;
                      spellcheck = 1;
                     
                    }
                    //Excalibur
                    if (Player[attacker].aMonster[Player[attacker].aMonster.length - 1].index == 84&&spellcheck == 0){
                      Player[attacker].aMonster[0].stat[eSTAT.S][eDICE.MOD]=Player[attacker].aMonster[0].stat[eSTAT.S][eDICE.MOD] + 3;
                      spellcheck = 1;
                     
                    }
                    
                    spellcheck = 0;
                    if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 2){Player[0].option = 9;Player[1].option = 9;}
                    if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 1){Player[0].turnCurrent = 2}
                    this.at = 0;
                    this.ay = 0; 
                    this.az = 0;
                    break;
                }      
                
              }//end if >69
            break;           
            case 2: //SPELL either on player or foe
              //SET DICE TYPE
              if(this.at == 0){
                if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 40){
                  Player[attacker].diceType = Player[attacker].aMonster[0].stat[eSTAT.A][eDICE.MAX];
                  Player[attacker].opponent.diceType = Player[attacker].opponent.aMonster[0].stat[eSTAT.A][eDICE.MAX];
                  Player[attacker].look[eLOOK.STAT]= eSTAT.A;
                  Player[attacker].opponent.look[eLOOK.STAT]= eSTAT.A;
                }
                else if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 51){
                  Player[attacker].diceType = Player[attacker].aMonster[0].stat[eSTAT.S][eDICE.MAX];
                  Player[attacker].opponent.diceType = Player[attacker].opponent.aMonster[0].stat[eSTAT.S][eDICE.MAX];
                  Player[attacker].look[eLOOK.STAT]= eSTAT.S;
                  Player[attacker].opponent.look[eLOOK.STAT]= eSTAT.S;
                }
                else if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 52){
                  Player[attacker].diceType = Player[attacker].aMonster[0].stat[eSTAT.A][eDICE.MAX];
                  Player[attacker].opponent.diceType = Player[attacker].opponent.aMonster[0].stat[eSTAT.A][eDICE.MAX];
                  Player[attacker].look[eLOOK.STAT]= eSTAT.A;
                  Player[attacker].opponent.look[eLOOK.STAT]= eSTAT.A;
                }
                else if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 58){
                  Player[attacker].diceType = Player[attacker].aMonster[0].stat[eSTAT.S][eDICE.MAX];
                  Player[attacker].opponent.diceType = Player[attacker].opponent.aMonster[0].stat[eSTAT.I][eDICE.MAX];
                  Player[attacker].look[eLOOK.STAT]= eSTAT.S;
                  Player[attacker].opponent.look[eLOOK.STAT]= eSTAT.I;
                }
                else if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 59){
                  Player[attacker].diceType = Player[attacker].aMonster[0].stat[eSTAT.S][eDICE.MAX];
                  Player[attacker].opponent.diceType = Player[attacker].opponent.aMonster[0].stat[eSTAT.A][eDICE.MAX];
                  Player[attacker].look[eLOOK.STAT]= eSTAT.S;
                  Player[attacker].opponent.look[eLOOK.STAT]= eSTAT.A;
                }
                else if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 65){
                  Player[attacker].diceType = Player[attacker].aMonster[0].stat[eSTAT.C][eDICE.MAX];
                  Player[attacker].opponent.diceType = Player[attacker].opponent.aMonster[0].stat[eSTAT.S][eDICE.MAX];
                  Player[attacker].look[eLOOK.STAT]= eSTAT.C;
                  Player[attacker].opponent.look[eLOOK.STAT]= eSTAT.S;
                }
                else if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 70){
                  Player[attacker].diceType = Player[attacker].aMonster[0].stat[eSTAT.C][eDICE.MAX];
                  Player[attacker].look[eLOOK.STAT]= eSTAT.C;
                }
                else if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 71){
                  Player[attacker].diceType = Player[attacker].aMonster[0].stat[eSTAT.C][eDICE.MAX];
                  Player[attacker].look[eLOOK.STAT]= eSTAT.C;
                }
                else{
                  Player[attacker].diceType = Player[attacker].aMonster[0].stat[eSTAT.I][eDICE.MAX];
                  Player[attacker].opponent.diceType = Player[attacker].opponent.aMonster[0].stat[eSTAT.I][eDICE.MAX];
                  Player[attacker].look[eLOOK.STAT]= eSTAT.I;
                  Player[attacker].opponent.look[eLOOK.STAT]= eSTAT.I;
                }
              }
              
              //Draw Defender Portrait and Graphics//////////
              if (defender == 1){this.flip()}
              Player[defender].aMonster[0].place(3.88,5.5,1);
              if (this.at < 69) {//Draw USE/CAST on Border
                drawPortrait(-21, 9, 9, .1);
                drawPortrait(-21, 0, 9, .1);
              }
              else{
                if (Player[defender].look[eLOOK.STAT]== eSTAT.S){drawPortrait(-11,9,9,.1);drawPortrait(-11,0,9,.1)}
                if (Player[defender].look[eLOOK.STAT]== eSTAT.C){ drawPortrait(-13,9,9,.1);drawPortrait(-13,0,9,.1)}
                if (Player[defender].look[eLOOK.STAT]==eSTAT.I){drawPortrait(-12,9,9,.1);drawPortrait(-12,0,9,.1)}
                if (Player[defender].look[eLOOK.STAT]== eSTAT.A){drawPortrait(-14,9,9,.1);drawPortrait(-14,0,9,.1)}
              }
              if (defender == 1){this.flip()}

              //Draw Attacker Portrait and Graphics//////////
              if (attacker == 1){this.flip()}
              Player[attacker].aMonster[0].place(3.88,5.5,1);
              if (this.at < 69) {//Draw USE/CAST on Border
                drawPortrait(-21, 9, 9, .1);
                drawPortrait(-21, 0, 9, .1);
              }
              else{
                if (Player[attacker].look[eLOOK.STAT]== eSTAT.S){drawPortrait(-11,9,9,.1);drawPortrait(-11,0,9,.1)}
                if (Player[attacker].look[eLOOK.STAT]== eSTAT.C){ drawPortrait(-13,9,9,.1);drawPortrait(-13,0,9,.1)}
                if (Player[attacker].look[eLOOK.STAT]==eSTAT.I){drawPortrait(-12,9,9,.1);drawPortrait(-12,0,9,.1)}
                if (Player[attacker].look[eLOOK.STAT]== eSTAT.A){drawPortrait(-14,9,9,.1);drawPortrait(-14,0,9,.1)}
              }
              if (attacker == 1){this.flip()}      

              //CHECK IF ATTACKER SUFFERS FROM LUNACY
              if (Player[attacker].hasLunacy > 0&& Player[attacker].hand[Player[attacker].look[eLOOK.H]].index != 19&&Player[attacker].hand[Player[attacker].look[eLOOK.H]].index != 20){
                Player[attacker].aMonster[0].place(3.88,5.5,1);
                this.at= this.at+1   
                drawPortrait(18,9,9,.1);
                drawPortrait(18,0,9,.1);
                drawPortrait(18,9,5,.1);
                drawPortrait(18,0,5,.1);
                if(Player[attacker].isCPU == 1){
                  this.flip();
                  MessageBox.show(.5,6,1.5,2,1,Player[attacker].aMonster[0].name + ' cannot act!','jrpg',1,0)
                  this.flip();
                }else{MessageBox.show(.5,6,1.5,2,1,Player[attacker].aMonster[0].name + ' cannot act!','jrpg',1,this.foe)}
                if (this.at>69){
                  Player[attacker].hasLunacy = Player[attacker].hasLunacy - 1;
                  if (Player[attacker].hasLunacy == 0) {
                    for (let i = 0; i < Player[attacker].aMonster.length; i++) {
                      if (Player[attacker].aMonster[i].index == 18) { // 12 is the Bind card ID
                        Player[attacker].aMonster.splice(i, 1); // Remove it from the field
                        break; // Stop looking
                      }
                    }
                  }
                  if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 2){Player[0].option = 9;Player[1].option = 9;}
                  if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 1){Player[0].turnCurrent = 2}
                  this.at = 0;
                  this.ay = 0;
                  this.az = 0;
                }
                return;
              }
              /////////
              //CHECK IF ATTACKER INTIMIDATED
              if (Player[attacker].hasIntimidate> 0){
                this.at= this.at+tick;
                drawPortrait(58,9,9,.1);
                drawPortrait(58,0,9,.1);
                drawPortrait(58,9,5,.1);
                drawPortrait(58,0,5,.1);
                if(Player[attacker].isCPU == 1&&Player[attacker].foe == 1){
                  this.flip();
                  MessageBox.show(.5,6,1.5,2,1,Player[attacker].aMonster[attacker].name + ' cowers in fear!','jrpg',1,0)
                  this.flip();
                }
                else{ MessageBox.show(.5,6,1.5,2,1,Player[attacker].aMonster[0].name + ' cowers in fear!','jrpg',1,this.foe)}
                if (this.at>69){
                  Player[attacker].hasIntimidate = Player[attacker].hasIntimidate - 1;
                  if (Player[attacker].hasIntimidate == 0) {
                    for (let i = 0; i < Player[attacker].aMonster.length; i++) {
                      if (Player[attacker].aMonster[i].index == 58) { // 12 is the Bind card ID
                        Player[attacker].aMonster.splice(i, 1); // Remove it from the field
                        break; // Stop looking
                      }
                    }
                  }
                  if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 2){Player[0].option = 9;Player[1].option = 9;}
                  if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 1){Player[0].turnCurrent = 2}
                  this.at = 0;
                  this.ay = 0;
                  this.az = 0;
                }
                if (this.foe == 1){this.flip()}
                return;
              }
              /////////  

              //TIMERS            
              if(this.at <100){this.at = this.at+tick;}
              else if (this.at >=139){this.at = this.at+tick;}
              else if (this.at <139 &&this.at>100){this.at = 101;}
              /////////////////////////////
              //STEP 1. HAND TO CENTER
              if (this.at <= 30) {
                if (attacker == 1){this.flip()} 
                Player[attacker].hand[Player[attacker].look[eLOOK.H]].place(1 + ((2.875 / 30) * this.at), 7.5 - ((2 / 30) * this.at), 1);
                if (attacker == 1){this.flip()} 
              }
              //STEP 2. GLOW ANIMATION
              if (this.at > 30 && this.at <= 60) {
                if (attacker == 1){this.flip()} 
                Player[attacker].hand[Player[attacker].look[eLOOK.H]].place(3.88, 5.5, 1);
                drawShape('rec', 3.88, 5.5, 1, 0, 0, 2.25, 3.55, 0, 0, 0, 0, `rgba(255,255,0,${.1+this.at*.01})`, 1);
                if (attacker == 1){this.flip()} 
              }
              //STEP 3. ACTIVATE SPELL CARD
              if (this.at > 69) {
                // check for subtype - debuff, buff, cast
                switch (Player[attacker].hand[Player[attacker].look[eLOOK.H]].subType) {
                  case 'buff':
                    // Dice Move UP Closer to Player
                    if (this.ay < 3 && this.at < 100) {this.ay = this.ay + SPEED_Y;this.az = this.az + SPEED_Z;}
                    //Dice Moves down toward table
                    if (this.ay >= 3 && this.az > 1 && this.at < 100) {this.az = this.az - SPEED_Z;}
                    //Dice stops rolling after it finishes its up and down motion
                    if (this.ay >= 3 && this.az <= 1 && this.at < 100) {
                      // DICE STOP
                      if (attacker == 1){this.flip()}
                      Player[attacker].setDice(Player[attacker].diceType, 8, 6, 1.5, .0001, dt); 
                      drawText(7.7, 5.6, 1, 1, '' + Player[attacker].look[eLOOK.R], 'white', 1);
                      if (attacker == 1){this.flip()}
                    } 
                    //animate dice roll while it moves up and down
                    else {
                      if (this.at < 100) {
                        // DICE Animate
                        if (defender == 1){this.flip();}
                        MessageBox.show(.5,6,1.5,2,1,Player[attacker].aMonster[0].name + ' mutters an incantation...','jrpg',1,0)     
                        if (defender == 1){this.flip();}

                        if (attacker == 1){this.flip();}
                        Player[attacker].setDice( Player[attacker].diceType, 8, 9 - this.ay, this.az, 99, dt);
                        if (Dungeon.isChallenger == true||!Player[1].battleOpponentId) {
                        Player[attacker].look[eLOOK.R] = 0;
                        if (Player[attacker].look[eLOOK.STAT]== eSTAT.S){Player[attacker].look[eLOOK.R] = Player[attacker].aMonster[0].rollStat(eSTAT.S);}
                        if (Player[attacker].look[eLOOK.STAT]== eSTAT.C){Player[attacker].look[eLOOK.R] = Player[attacker].aMonster[0].rollStat(eSTAT.C);}
                        if (Player[attacker].look[eLOOK.STAT]== eSTAT.I){Player[attacker].look[eLOOK.R] = Player[attacker].aMonster[0].rollStat(eSTAT.I);}
                        if (Player[attacker].look[eLOOK.STAT]== eSTAT.A){Player[attacker].look[eLOOK.R] = Player[attacker].aMonster[0].rollStat(eSTAT.A);}
                        }
                        //Battle message and graphic    
                        MessageBox.show(.5,6,1.5,2,1,Player[attacker].aMonster[0].name + ' mutters an incantation...','jrpg',1,0)     
                        //////////////////
                        //Spell Battle Graphics
                        ////////////////////
                        //Strength
                        if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 8) {drawPortrait(8, 4.5 - this.at * .005, 7 - this.at * .003, .1 + this.at * .001);}
                        //Scry 
                        if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 24) {drawPortrait(24, 4.5 - this.at * .005, 7 - this.at * .003, .1 + this.at * .001);}
                        //Defense
                        if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 28) {drawPortrait(28, 4.5 - this.at * .005, 7 - this.at * .003, .1 + this.at * .001);}
                        //Haste
                        if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 29) {drawPortrait(29, 4.5 - this.at * .005, 7 - this.at * .003, .1 + this.at * .001);}
                        //Cultivate
                        if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 70) {drawPortrait(70, 4.5 - this.at * .005, 7 - this.at * .003, .1 + this.at * .001);}
                        //Forge 
                        if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 71) {drawPortrait(71, 4.5 - this.at * .005, 7 - this.at * .003, .1 + this.at * .001);}
                        ////////////////////////
                        if (attacker == 1){this.flip();}
                      }
                    }
                    //Roll Results
                    if (this.at > 100) {
                      if (!this.rollSent&&Dungeon.isChallenger == true) {
                Player[0].sendAction('DICE_RESULT', {
                    p0_roll: Player[0].look[eLOOK.R], // My result
                    p1_roll: Player[1].look[eLOOK.R], // Opponent result
                    diceType: Player[0].diceType      // Sync dice type
                });
                this.rollSent = 1;
            }
                      //Dice Stop
                      if (attacker == 1){this.flip();}
                      Player[attacker].setDice(Player[attacker].diceType, 8, 6, 1.5, .0001, dt);
                      drawText(7.7, 5.6, 1, 1, '' + Player[attacker].look[eLOOK.R], 'white', 1); 
                      if (attacker == 1){this.flip();}
                      //BATTLE RESULT MESSAGE (monster gained +... etc)           
                      if (this.at >= 101 && this.at <139) {
                        if(this.opponent.isCPU == 0){
                          drawText(0,9.5,10,.5,"Tap Screen To Continue",`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)})`,1,'center');
                          this.flip()
                          drawText(0,9.5,10,.5,"Tap Screen To Continue",`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)})`,1,'center');
                          this.flip()
                        }
                        else{
                          drawText(0,9.5,10,.5,"Tap Screen To Continue",`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)})`,1,'center');
                        }
                        //Spell Battle Message
                        if (attacker == 1){this.flip();}
                        //Strength 
                        if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 8) {MessageBox.show(.5,6,1.5,2,1,Player[attacker].aMonster[0].name + ' gains + ' + Player[attacker].look[eLOOK.R] + ' to STR rolls !','jrpg',1,0)  }
                        //Scry
                        if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 24) {MessageBox.show(.5,6,1.5,2,1,Player[attacker].aMonster[0].name + ' reveals top ' + Player[attacker].look[eLOOK.R] + ' cards of their deck!','jrpg',1,0)  }
                        //Defense 
                        if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 28) {MessageBox.show(.5,6,1.5,2,1,Player[attacker].aMonster[0].name + ' gains + ' + Player[attacker].look[eLOOK.R] + ' to CON rolls !','jrpg',1,0)  }
                        //Haste 
                        if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 29) {MessageBox.show(.5,6,1.5,2,1,Player[attacker].aMonster[0].name + ' gains + ' + Player[attacker].look[eLOOK.R] + ' to AGI rolls !','jrpg',1,0)  }
                        //Cultivate
                        if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 70) {MessageBox.show(.5,6,1.5,2,1,Player[attacker].aMonster[0].name + ' breaks through!','jrpg',1,0)  }
                        //Forge
                        if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 71) {MessageBox.show(.5,6,1.5,2,1,Player[attacker].aMonster[0].name + ' fires up the forge!','jrpg',1,0)  }
                        /////////////
                        if (attacker == 1){this.flip();}
                        if (defender == 1){this.flip();}
                        //Strength 
                        if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 8) {MessageBox.show(.5,6,1.5,2,1,Player[attacker].aMonster[0].name + ' gains + ' + Player[attacker].look[eLOOK.R] + ' to STR rolls !','jrpg',1,0)  }
                        //Scry
                        if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 24) {MessageBox.show(.5,6,1.5,2,1,Player[attacker].aMonster[0].name + ' reveals top ' + Player[attacker].look[eLOOK.R] + ' cards of their deck!','jrpg',1,0)  }
                        //Defense 
                        if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 28) {MessageBox.show(.5,6,1.5,2,1,Player[attacker].aMonster[0].name + ' gains + ' + Player[attacker].look[eLOOK.R] + ' to CON rolls !','jrpg',1,0)  }
                        //Haste 
                        if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 29) {MessageBox.show(.5,6,1.5,2,1,Player[attacker].aMonster[0].name + ' gains + ' + Player[attacker].look[eLOOK.R] + ' to AGI rolls !','jrpg',1,0)  }
                        //Cultivate
                        if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 70) {MessageBox.show(.5,6,1.5,2,1,Player[attacker].aMonster[0].name + ' breaks through!','jrpg',1,0)  }
                        //Forge
                        if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 71) {MessageBox.show(.5,6,1.5,2,1,Player[attacker].aMonster[0].name + ' fires up the forge!','jrpg',1,0)  }
                        /////////////
                        if (defender == 1){this.flip();}
                      }
                      //////////////////////
                      //APPLY SPELL EFFECT
                      if (this.at >= 139) {
                        // Strength
                        if ( Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 8&&spellcheck == 0) {Player[attacker].aMonster[0].stat[eSTAT.S][eDICE.MOD] = Player[attacker].aMonster[0].stat[eSTAT.S][eDICE.MOD] + Player[attacker].look[eLOOK.R];}
                        //Scry
                        if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 24&&spellcheck == 0) {
                          Player[0].option = 6.4;
                          
                          Player[1].option = 6.4;
                          spellcheck = 1;
                          Player[attacker].look[eLOOK.D]= 0;
                          return
                        }
                        //Defense
                        if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 28&&spellcheck == 0) {Player[attacker].aMonster[0].stat[eSTAT.C][eDICE.MOD] = Player[attacker].aMonster[0].stat[eSTAT.C][eDICE.MOD] + Player[attacker].look[eLOOK.R];}
                        //Haste
                        if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 29&&spellcheck == 0) {Player[attacker].aMonster[0].stat[eSTAT.A][eDICE.MOD] = Player[attacker].aMonster[0].stat[eSTAT.A][eDICE.MOD] + Player[attacker].look[eLOOK.R];}
                        //Cultivate
                        if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 70&&spellcheck == 0) {
                          Player[attacker].statPoints =  Player[attacker].look[eLOOK.R];
                          Player[0].option = 6.6;
                          Player[1].option = 6.6;
                          spellcheck = 1;
                          return
                        }    
                        //Forge
                        if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 71&&spellcheck == 0) {
                          Player[0].option = 6.4;
                          Player[1].option = 6.4;
                          spellcheck = 1;
                          Player[attacker].look[eLOOK.D]= 0;
                          return
                        }
                        
                        //////////////////////////////  
                        //Cleanup
                        //////////////////////
                        if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 2){Player[0].option = 9;Player[1].option = 9;}
                        else if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 1){Player[0].turnCurrent = 2}
                        spellcheck = 0;
                        this.rollSent = 0;
                        Player[attacker].hand.splice( Player[attacker].look[eLOOK.H], 1);
                        Player[attacker].look[eLOOK.H] = 0;
                        this.ay = 0; this.az = 0; this.at = 0;
                        return;
                      }
                    }
                break; // End Buff
                  case 'debuff':
                    //DICE TIMERS
                    if (this.ay < 3 && this.at < 100) {this.ay = this.ay + SPEED_Y;this.az = this.az + SPEED_Z;}
                    if (this.ay > 3 && this.az > 1 && this.at < 100) {this.az = this.az - SPEED_Z;}
                    // DICE STOPPED
                    if (this.ay > 3 && this.az <= 1 && this.at < 100) {
                      if (attacker==1){this.flip()}
                      Player[attacker].setDice(Player[attacker].diceType, 8, 6, 1.5, .0001, dt);
                      drawText(7.7, 5.6, 1, 1, '' + Player[attacker].look[eLOOK.R], 'white', 1);

                      this.flip();
                      Player[attacker].opponent.setDice(Player[attacker].opponent.diceType, 8, 6, 1.5, .0001, dt);
                      drawText(7.7, 5.6, 1, 1, '' + Player[attacker].opponent.look[eLOOK.R], 'white', 1);
                      this.flip()
                      if (attacker==1){this.flip()}
                    } 
                    // DICE ROLLING
                    else {
                      if (this.at < 100) {
                        // Player Roll
                        if (attacker==1){this.flip()}
                        Player[attacker].setDice(Player[attacker].diceType, 8, 9 - this.ay, this.az, 99, dt);
                        if (Dungeon.isChallenger == true||!Player[1].battleOpponentId) {
                        Player[attacker].look[eLOOK.R] = 0;
                        if (Player[attacker].look[eLOOK.STAT]== eSTAT.S){Player[attacker].look[eLOOK.R] = Player[attacker].aMonster[0].rollStat(eSTAT.S);}
                        if (Player[attacker].look[eLOOK.STAT]== eSTAT.C){Player[attacker].look[eLOOK.R] = Player[attacker].aMonster[0].rollStat(eSTAT.C);}
                        if (Player[attacker].look[eLOOK.STAT]== eSTAT.I){Player[attacker].look[eLOOK.R] = Player[attacker].aMonster[0].rollStat(eSTAT.I);}
                        if (Player[attacker].look[eLOOK.STAT]== eSTAT.A){Player[attacker].look[eLOOK.R] = Player[attacker].aMonster[0].rollStat(eSTAT.A);}
                        }
                        // Foe Roll
                        this.flip();
                        Player[attacker].opponent.setDice(Player[attacker].opponent.diceType, 8, 9 - this.ay, this.az, 99, dt);
                        this.flip();
                        if (Dungeon.isChallenger == true||!Player[1].battleOpponentId) {
                        Player[attacker].opponent.look[eLOOK.R] = 0;
                        if (Player[attacker].opponent.look[eLOOK.STAT]== eSTAT.S){Player[attacker].opponent.look[eLOOK.R] = Player[attacker].opponent.aMonster[0].rollStat(eSTAT.S);}
                        if (Player[attacker].opponent.look[eLOOK.STAT]== eSTAT.C){Player[attacker].opponent.look[eLOOK.R] = Player[attacker].opponent.aMonster[0].rollStat(eSTAT.C);}
                        if (Player[attacker].opponent.look[eLOOK.STAT]== eSTAT.I){Player[attacker].opponent.look[eLOOK.R] = Player[attacker].opponent.aMonster[0].rollStat(eSTAT.I);}
                        if (Player[attacker].opponent.look[eLOOK.STAT]== eSTAT.A){Player[attacker].opponent.look[eLOOK.R] = Player[attacker].opponent.aMonster[0].rollStat(eSTAT.A);}
                        }
                        //Battle Message && Spell Graphic (on foe)
                        if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 40){ 
                          MessageBox.show(.5,6,1.5,2,1,Player[attacker].aMonster[0].name + ' slips into the shadows...','jrpg',1,0);
                          this.flip();
                          MessageBox.show(.5,6,1.5,2,1,Player[attacker].aMonster[0].name + ' slips into the shadows...','jrpg',1,0) ;
                          this.flip();
                        }
                        else{
                          MessageBox.show(.5,6,1.5,2,1,Player[attacker].aMonster[0].name + ' mutters an incantation...','jrpg',1,0) 
                        }
                        this.flip();
                        if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 15) drawPortrait(15, 4.5 - this.at * .005, 5 - this.at * .003, .1 + this.at * .001); //Curse
                        if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 12) drawPortrait(12, 4.5 - this.at * .005, 5 - this.at * .003, .1 + this.at * .001); //Bind
                        if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 13) drawPortrait(13, 4.5 - this.at * .005, 5 - this.at * .003, .1 + this.at * .001); //Death
                        if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 16) drawPortrait(16, 4.5 - this.at * .005, 5 - this.at * .003, .1 + this.at * .001); //Ruin
                        if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 18) drawPortrait(18, 4.5 - this.at * .005, 5 - this.at * .003, .1 + this.at * .001); //Lunacy
                        if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 26) drawPortrait(26, 4.5 - this.at * .005, 5 - this.at * .003, .1 + this.at * .001); //Fire
                        if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 40) drawPortrait(40, 4.5 - this.at * .005, 5 - this.at * .003, .1 + this.at * .001); //Steal
                        if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 51) drawPortrait(51, 4.5 - this.at * .005, 5 - this.at * .003, .1 + this.at * .001); //Overpower
                        if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 52) drawPortrait(52, 4.5 - this.at * .005, 5 - this.at * .003, .1 + this.at * .001); //Backstab
                        if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 58) drawPortrait(58, 4.5 - this.at * .005, 5 - this.at * .003, .1 + this.at * .001); //Intimidate
                        if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 59) drawPortrait(59, 4.5 - this.at * .005, 5 - this.at * .003, .1 + this.at * .001); //Critical Strike
                        if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 65) drawPortrait(65, 4.5 - this.at * .005, 5 - this.at * .003, .1 + this.at * .001); //Shield Bash
                        this.flip();
                        if (attacker==1){this.flip()}
                      }
                    }
                    //Roll Results
                    if (this.at > 100) {
                      if (!this.rollSent&&Dungeon.isChallenger == true) {
                Player[0].sendAction('DICE_RESULT', {
                    p0_roll: Player[0].look[eLOOK.R], // My result
                    p1_roll: Player[1].look[eLOOK.R], // Opponent result
                    diceType: Player[0].diceType      // Sync dice type
                });
                this.rollSent = 1;
            }
                      //DICE STOP attacker
                      if (attacker==1){this.flip()}
                      Player[attacker].setDice(Player[attacker].diceType, 8, 6, 1.5, .0001, dt);
                      drawText(7.7, 5.6, 1, 1, '' + Player[attacker].look[eLOOK.R], 'white', 1);
                      //DICE STOP defender
                      this.flip();
                      Player[attacker].opponent.setDice(Player[attacker].opponent.diceType, 8, 6, 1.5, .0001, dt);
                      drawText(7.7, 5.6, 1, 1, '' + Player[attacker].opponent.look[eLOOK.R], 'white', 1);
                      this.flip();
                      if (attacker==1){this.flip()}
                      //CALCULATE RESULTS and TAP TO CONTINUE
                      if (this.at >= 101 && this.at < 139){
                        winSpellTie = 0;
                        if (Player[attacker].hasLuckyCharm == 1 && Player[attacker].opponent.hasLuckyCharm == 0) { winSpellTie = 1; }
                        if (attacker==1){this.flip()}
                        drawText(2.15, 4.75, 6, 1, "Tap Screen To Continue", `rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)})`, 1);
                        if (Player[attacker].look[eLOOK.R] > Player[attacker].opponent.look[eLOOK.R]|| (Player[attacker].look[eLOOK.R] == Player[attacker].opponent.look[eLOOK.R] && winSpellTie == 1)) {
                          // Success Messages
                          if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 15) MessageBox.show(.5,6,1.5,2,1,Player[attacker].opponent.aMonster[0].name + ' suffers - ' + (Player[attacker].look[eLOOK.R] - Player[attacker].opponent.look[eLOOK.R])+ ' to all rolls!','jrpg',1,0);
                          if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 12) MessageBox.show(.5,6,1.5,2,1,Player[attacker].opponent.aMonster[0].name + ' cannot act!','jrpg',1,0);
                          if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 13) MessageBox.show(.5,6,1.5,2,1,Player[attacker].opponent.aMonster[0].name + ' succumbs to the spell!','jrpg',1,0);
                          if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 16) MessageBox.show(.5,6,1.5,2,1,Player[attacker].opponent.aMonster[0].name + ' succumbs to the spell!','jrpg',1,0);
                          if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 18) MessageBox.show(.5,6,1.5,2,1,Player[attacker].opponent.aMonster[0].name + ' falls under a spell!','jrpg',1,0);
                          if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 26) MessageBox.show(.5,6,1.5,2,1,Player[attacker].opponent.aMonster[0].name + ' burns to ash!','jrpg',1,0);
                          if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 40) MessageBox.show(.5,6,1.5,2,1,Player[attacker].opponent.aMonster[0].name + ' loses ' + (Player[attacker].look[eLOOK.R] - Player[attacker].opponent.look[eLOOK.R])+ ' cards from their deck!','jrpg',1,0);
                          if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 51) MessageBox.show(.5,6,1.5,2,1,Player[attacker].opponent.aMonster[0].name + ' could not withstand the attack!','jrpg',1,0);
                          if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 52) MessageBox.show(.5,6,1.5,2,1,Player[attacker].opponent.aMonster[0].name + ' could not withstand the attack!','jrpg',1,0);
                          if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 58) MessageBox.show(.5,6,1.5,2,1,Player[attacker].opponent.aMonster[0].name + ' cowers in fear!','jrpg',1,0);
                          if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 59) MessageBox.show(.5,6,1.5,2,1,Player[attacker].opponent.aMonster[0].name + ' could not withstand the attack!','jrpg',1,0);
                          if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 65) MessageBox.show(.5,6,1.5,2,1,Player[attacker].opponent.aMonster[0].name + ' could not withstand the attack!','jrpg',1,0);
                          this.flip();
                          if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 15) MessageBox.show(.5,6,1.5,2,1,Player[attacker].opponent.aMonster[0].name + ' suffers - ' + (Player[attacker].look[eLOOK.R] - Player[attacker].opponent.look[eLOOK.R])+ ' to all rolls!','jrpg',1,0);
                          if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 12) MessageBox.show(.5,6,1.5,2,1,Player[attacker].opponent.aMonster[0].name + ' cannot act!','jrpg',1,0);
                          if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 13) MessageBox.show(.5,6,1.5,2,1,Player[attacker].opponent.aMonster[0].name + ' succumbs to the spell!','jrpg',1,0);
                          if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 16) MessageBox.show(.5,6,1.5,2,1,Player[attacker].opponent.aMonster[0].name + ' succumbs to the spell!','jrpg',1,0);
                          if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 18) MessageBox.show(.5,6,1.5,2,1,Player[attacker].opponent.aMonster[0].name + ' falls under a spell!','jrpg',1,0);
                          if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 26) MessageBox.show(.5,6,1.5,2,1,Player[attacker].opponent.aMonster[0].name + ' burns to ash!','jrpg',1,0);
                          if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 40) MessageBox.show(.5,6,1.5,2,1,Player[attacker].opponent.aMonster[0].name + ' loses ' + (Player[attacker].look[eLOOK.R] - Player[attacker].opponent.look[eLOOK.R])+ ' cards from their deck!','jrpg',1,0);
                          if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 51) MessageBox.show(.5,6,1.5,2,1,Player[attacker].opponent.aMonster[0].name + ' could not withstand the attack!','jrpg',1,0);
                          if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 52) MessageBox.show(.5,6,1.5,2,1,Player[attacker].opponent.aMonster[0].name + ' could not withstand the attack!','jrpg',1,0);
                          if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 58) MessageBox.show(.5,6,1.5,2,1,Player[attacker].opponent.aMonster[0].name + ' cowers in fear!','jrpg',1,0);
                          if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 59) MessageBox.show(.5,6,1.5,2,1,Player[attacker].opponent.aMonster[0].name + ' could not withstand the attack!','jrpg',1,0);
                          if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 65) MessageBox.show(.5,6,1.5,2,1,Player[attacker].opponent.aMonster[0].name + ' could not withstand the attack!','jrpg',1,0);
                          this.flip();
                        } 
                        else {MessageBox.show(.5,6,1.5,2,1,Player[attacker].opponent.aMonster[0].name + ' resists the spell!','jrpg',1,0)}
                        if (attacker==1){this.flip()}
                      }
                      ////////////              
                      //Apply Effect
                      if (this.at >= 139) {
                        if (Player[attacker].look[eLOOK.R] > Player[attacker].opponent.look[eLOOK.R]|| (Player[attacker].look[eLOOK.R] == Player[attacker].opponent.look[eLOOK.R] && winSpellTie == 1)) {
                          // Curse (15)
                          if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 15&&spellcheck == 0) {
                              Player[attacker].opponent.aMonster[0].stat[eSTAT.S][eDICE.MOD] = Player[attacker].aMonster[0].stat[eSTAT.S][eDICE.MOD] - (Player[attacker].look[eLOOK.R] - Player[attacker].opponent.look[eLOOK.R]);
                              Player[attacker].opponent.aMonster[0].stat[eSTAT.C][eDICE.MOD] = Player[attacker].aMonster[0].stat[eSTAT.C][eDICE.MOD] - (Player[attacker].look[eLOOK.R] - Player[attacker].opponent.look[eLOOK.R]);
                              Player[attacker].opponent.aMonster[0].stat[eSTAT.I][eDICE.MOD] = Player[attacker].aMonster[0].stat[eSTAT.I][eDICE.MOD] - (Player[attacker].look[eLOOK.R] - Player[attacker].opponent.look[eLOOK.R]);
                              Player[attacker].opponent.aMonster[0].stat[eSTAT.A][eDICE.MOD] = Player[attacker].aMonster[0].stat[eSTAT.A][eDICE.MOD] - (Player[attacker].look[eLOOK.R] - Player[attacker].opponent.look[eLOOK.R]);
                              spellcheck = 1;
                            }
                          // Bind (12)
                          if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 12&&spellcheck == 0) {
                            Player[attacker].look[eLOOK.INDEX] = 12;
                            Player[attacker].opponent.hasBind = Player[attacker].look[eLOOK.R] - Player[attacker].opponent.look[eLOOK.R];
                            spellcheck = 1;
                          }
                          // Death (13) - Special return case
                          if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 13&&spellcheck == 0) {
                            Player[attacker].hand.splice(Player[attacker].look[eLOOK.H], 1);
                            Player[attacker].look[eLOOK.H] = 0;
                            if(attacker == 0){Player[0].option = 8;Player[1].option = 8.1;}
                            else{Player[0].option = 8;Player[1].option = 8.2;}
                            this.ay = 0; this.az = 0; this.at = 0;
                            this.rollSent = 0;
                            return; // Death exits early
                          }
                          // Ruin (16)
                          if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 16&&spellcheck == 0) {
                            let tempindex = Player[attacker].opponent.aMonster[0].index
                            Player[attacker].opponent.unequip();
                            Player[attacker].opponent.aMonster.length = 0;
                            Player[attacker].opponent.aMonster[0] = new Card(tempindex, 1)
                            Player[attacker].opponent.aMonster[0].location = 'field';
                            Player[attacker].opponent.aMonster[0].foe = Player[attacker].opponent.foe;
                            Player[attacker].opponent.look[eLOOK.M] = 0;
                            Player[attacker].opponent.aMonster[0].locIndex = 0;
                            Player[attacker].opponent.aMonster[0].locCount = 1;
                            Player[attacker].opponent.hand.length = 0;
                            Player[attacker].opponent.look[eLOOK.A] = 0;
                            
                            if (sRune.owner == Player[attacker].opponent.foe) {sRune.changeOwner(Player[attacker].opponent.foe)}
                            if (cRune.owner == Player[attacker].opponent.foe) {cRune.changeOwner(Player[attacker].opponent.foe)}
                            if (iRune.owner == Player[attacker].opponent.foe) {iRune.changeOwner(Player[attacker].opponent.foe)}
                            if (aRune.owner == Player[attacker].opponent.foe) {aRune.changeOwner(Player[attacker].opponent.foe)}
                            spellcheck = 1;
                          }
                          // Lunacy (18)
                          if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 18&&spellcheck == 0) {
                            Player[attacker].look[eLOOK.INDEX] = 18
                            Player[attacker].opponent.hasLunacy = Player[attacker].look[eLOOK.R] - Player[attacker].opponent.look[eLOOK.R];
                            spellcheck = 1;
                          }
                          // Fire (26) - Special return case
                          if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 26&&spellcheck == 0) {
                            Player[attacker].hand.splice(Player[attacker].look[eLOOK.H], 1);
                            Player[attacker].look[eLOOK.H] = 0;
                            if(attacker == 0){Player[0].option = 8;Player[1].option = 8.1;}
                            else{Player[0].option = 8;Player[1].option = 8.2;}
                            this.ay = 0; this.az = 0; this.at = 0;
                            this.rollSent = 0;
                            return; // Fire exits early
                          }
                          //Steal(40)
                          if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 40&&spellcheck == 0) {
                            Player[attacker].opponent.deck.splice(0, Player[attacker].look[eLOOK.R] - Player[attacker].opponent.look[eLOOK.R]);
                            spellcheck = 1;
                          }
                           //Overpower(51) - Special return case
                          if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 51&&spellcheck == 0) {
                            Player[attacker].hand.splice(Player[attacker].look[eLOOK.H], 1);
                            Player[attacker].look[eLOOK.H] = 0;
                            if(attacker == 0){Player[0].option = 8;Player[1].option = 8.1;}
                            else{Player[0].option = 8;Player[1].option = 8.2;}
                            this.ay = 0; this.az = 0; this.at = 0;
                            this.rollSent = 0;
                            return; // Overpower exits early
                          }
                          //Backstab(52) - Special return case
                          if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 52&&spellcheck == 0) {
                            Player[attacker].hand.splice(Player[attacker].look[eLOOK.H], 1);
                            Player[attacker].look[eLOOK.H] = 0;
                            if(attacker == 0){Player[0].option = 8;Player[1].option = 8.1;}
                            else{Player[0].option = 8;Player[1].option = 8.2;}
                            this.ay = 0; this.az = 0; this.at = 0;
                            this.rollSent = 0;
                            return; // Backstab exits early
                          }
                          // Intimidate (58)
                          if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 58&&spellcheck == 0) {
                            Player[attacker].look[eLOOK.INDEX] = 58
                            Player[attacker].opponent.hasIntimidate = Player[attacker].look[eLOOK.R] - Player[attacker].opponent.look[eLOOK.R];
                            spellcheck = 1;
                          }
                          //Critical Strike(59) - Special return case
                          if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 59&&spellcheck == 0) {
                            Player[attacker].hand.splice(Player[attacker].look[eLOOK.H], 1);
                            Player[attacker].look[eLOOK.H] = 0;
                            if(attacker == 0){Player[0].option = 8;Player[1].option = 8.1;}
                            else{Player[0].option = 8;Player[1].option = 8.2;}
                            this.ay = 0; this.az = 0; this.at = 0;
                            this.rollSent = 0;
                            return; // Critical Strike exits early
                          }
                          //Shield Bash (60) - Special return case
                          if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 65&&spellcheck == 0) {
                            Player[attacker].hand.splice(Player[attacker].look[eLOOK.H], 1);
                            Player[attacker].look[eLOOK.H] = 0;
                            if(attacker == 0){Player[0].option = 8;Player[1].option = 8.1;}
                            else{Player[0].option = 8;Player[1].option = 8.2;}
                            this.ay = 0; this.az = 0; this.at = 0;
                            this.rollSent = 0;
                            return; // Shield Bash exits early
                          }
                          
                        }
                        //Cleanup
                        spellcheck = 0;
                        this.rollSent = 0;
                        if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 2){Player[0].option = 9;Player[1].option = 9;}
                        else if ((Player[0].turnOrder == 1||Player[0].turnOrder == 2)&&Player[0].turnCurrent == 1){Player[0].turnCurrent = 2}
                        //Exclude Lunacy and Bind and Intimidate because these 'equip' to monster 
                        if (Player[attacker].look[eLOOK.INDEX] != 12 && Player[attacker].look[eLOOK.INDEX]!= 18&&Player[attacker].look[eLOOK.INDEX]!= 58) {
                          Player[attacker].hand.splice(Player[attacker].look[eLOOK.H], 1);
                          Player[attacker].look[eLOOK.H] = 0;
                        }
                        else{
                          Player[attacker].look[eLOOK.INDEX] = 0
                          Player[attacker].opponent.aMonster.push(Player[attacker].hand.splice(Player[attacker].look[eLOOK.H], 1)[0])
                          Player[attacker].look[eLOOK.H] = 0;
                          Player[attacker].opponent.aMonster[Player[attacker].opponent.aMonster.length - 1].location = "field";
                          Player[attacker].opponent.aMonster[Player[attacker].opponent.aMonster.length - 1].locCount = Player[attacker].opponent.aMonster.length - 1;
                          Player[attacker].opponent.aMonster[Player[attacker].opponent.aMonster.length - 1].locIndex = Player[attacker].opponent.aMonster.length - 1;
                          Player[attacker].opponent.aMonster[Player[attacker].opponent.aMonster.length - 1].foe = Player[attacker].foe;
                        }
                        this.ay = 0; this.az = 0; this.at = 0;
                        return;
                      }//end at>102
                    }//at>100
                    break; // End Debuff
                  case 'cast':
                    //Alchemy
                    if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 14) {
                      Player[attacker].hasScalesOfJustice = 2;
                      Player[attacker].look[eLOOK.A] = 0;
                      Player[0].option = 6.3;
                      Player[1].option = 6.3;
                      this.at = 0;
                      Player[0].sendAction('ALCHEMY',{ s: 0, soj:2 });
                      return;
                    }
                    //Trick
                    if (this.hand[this.look[eLOOK.H]].index == 28888) {
                      this.hasScalesOfJustice = 2;
                      this.look[eLOOK.A] = 0;
                      this.at = 0;
                      if (this.foe == 1){this.flip()}
                      return;
                    }
                    break; // End Cast
                } //switch subtype
              } //>69
            break; //spell           
          }//switch action
          break;//opt 7       
        case 8://Monster defeated
          //triumph music
          if (startGame == 6&& this.foe == 0){
            MusicEngine.stop();
            MusicEngine.play(8); 
            startGame = 4         
          }
          //defeat music
          if (startGame == 6&& this.foe == 0){
            MusicEngine.stop();
            MusicEngine.play(18); 
            startGame = 7         
          }
          
          if (this.at <= 0){
            if (this.at < -613){this.at = 0}
            this.at = this.at - 1;
            if (this.at % 5 == 0||this.at % 3 == 0||this.at % 2 == 0||this.at % 7 == 0||this.at % 9 == 0){
              if (Player[1].option == 8.1){
                drawText(2.1,6,6,.75,"Please Select Runestone",`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)})`,1);
              }
              else if (Player[1].option == 8.2){
                this.flip();
                drawText(2.1,6,6,.75,"Please Select Runestone",`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)})`,1);
                this.flip();
              }
            }
          }
          if (this.at>0){this.at = this.at+tick;}
          //Player won
          if (Player[1].option == 8.1){
            this.flip();
            drawShape('rec',0,0,1,3.875,6.45,2.25,3.55,0,0,0,0,`rgba(0,0,0,1)`,1);
            this.flip();

          }
          //foe won
          else if (Player[1].option == 8.2){
            drawShape('rec',0,0,1,3.875,6.45,2.25,3.55,0,0,0,0,`rgba(0,0,0,1)`,1);
            
            // --- CPU RUNE LOGIC START ---
          // If I am CPU and haven't selected yet (at <= 0 is the "waiting" state)
          if (Player[1].isCPU === 1 && this.at <= 0) {
              Player[1].cpuRuneSelect(); // Pick the best rune
              this.at = 1;          // Start the "Grab" animation immediately
          }
          // --- CPU RUNE LOGIC END ---
          }
          //Player[0].aMonster defeated Player[1].aMonster
          if (Player[1].option == 8.1){
            switch(Player[0].look[eLOOK.S]){
              case eSTAT.S:
                if (this.at > 31) sRune.changeOwner(0); // Trigger movement
                
                break;
              case eSTAT.C:
                if (this.at > 31) cRune.changeOwner(0);
                break;
              case eSTAT.I:
                if (this.at > 31) iRune.changeOwner(0);
                break;
              case eSTAT.A:
                if (this.at > 31) aRune.changeOwner(0);
                break;
            }
            // Wait for animation to finish
            if (this.at > 31){
              Player[0].at = 0;
              Player[0].option = 9;
              if (Player[1].draw == 0){
                Player[1].unequip();
                Player[1].aMonster.length = 0;
                Player[1].option = 9;
              }
            }
          }
          ////////////////
          //Player[1].aMonster defeated Player[0].aMonster
          if (Player[1].option == 8.2){
            switch(Player[1].look[eLOOK.S]){
              case eSTAT.S:
                if (this.at > 31) sRune.changeOwner(1); // Trigger movement
                
                break;
              case eSTAT.C:
                if (this.at > 31) cRune.changeOwner(1);
                break;
              case eSTAT.I:
                if (this.at > 31) iRune.changeOwner(1);
                break;
              case eSTAT.A:
                if (this.at > 31) aRune.changeOwner(1);
                break;
            }
            // Wait for animation to finish
            if (this.at > 31){
              Player[0].at = 0;
              Player[1].option = 9;
              if (Player[0].draw == 0){
                Player[0].unequip();
                Player[0].aMonster.length = 0;
                Player[0].option = 9;
              }
            }
          }
          ////////////////
          //Both defeated (Horn of judgement...)
          if (Player[1].option == 8.3){
            Player[1].unequip();
            Player[1].aMonster.length = 0;
            Player[1].option = 9;
            Player[0].unequip();
            Player[0].aMonster.length = 0;
            Player[0].option = 9;
          }
          break;//end case 8 TRIUMPH
        case 9://Waiting room
          if (this.draw != 1 &&this.opponent.draw != 1){
            this.option = 0;
            this.opponent.option = 0;
            this.preOpt = 9;
            this.opponent.preOpt = 9;
          }

          break;
        case 10://Battle End Screen
          //player won
          if(Player[1].option == 10.1){
            //vscpu
            if (this.opponent.isCPU == 1){
              ctx.fillStyle = "rgba(39,39,39,1)";
              ctx.fillRect(0,0,wX,wY);
              drawShape('rec',0,0,1,0,0,10,10,0,0,0,0,'black',1)
              drawText(2.5,4,5,3,'TRIUMPH','gold',1);
              if(preGame == 'explore'){drawText(0, 8, 10, 0.8, "Tap to Continue", `rgba(255,215,0,${0.6 + 0.4 * Math.sin(Date.now() / 400)})`, 1,'center');}
              else{ drawText(2.65, 8, 8, 0.8, "Tap to Restart", `rgba(255,215,0,${0.6 + 0.4 * Math.sin(Date.now() / 400)})`, 1);}
            }
            //vs human
            if (this.opponent.isCPU == 0){
              ctx.fillStyle = "rgba(39,39,39,1)";
              ctx.fillRect(0,0,wX,wY);
              drawShape('rec',0,0,1,0,0,10,10,0,0,0,0,'black',1)
              drawText(2.5,7.5,5,3,'TRIUMPH','gold',1);
              this.flip();
              drawText(2.5,7.5,5,3,'DEFEAT','silver',1);
              this.flip()
              drawText(2.5, 5, 8, 0.8, "Tap to Restart", `rgba(255,215,0,${0.6 + 0.4 * Math.sin(Date.now() / 400)})`, 1);
            }
          
            if (this.foe == 0&&startGame == 4){
              MusicEngine.stop();
              MusicEngine.play(20); 
              startGame = 8;         
            }
          }
          //foe won
          else if(Player[1].option == 10.2){
             //vscpu
            if (this.opponent.isCPU == 1){
              ctx.fillStyle = "rgba(39,39,39,1)";
              ctx.fillRect(0,0,wX,wY);
              drawShape('rec',0,0,1,0,0,10,10,0,0,0,0,'black',1)
              drawText(2.5,4,5,3,'DEFEAT','white',1);
              if(preGame == 'explore'){drawText(0, 8, 10, 0.8, "Tap to Continue", `rgba(255,255,255,${0.6 + 0.4 * Math.sin(Date.now() / 400)})`, 1,'center');}
              else{drawText(2.65, 8, 8, 0.8, "Tap to Restart", `rgba(255,255,255,${0.6 + 0.4 * Math.sin(Date.now() / 400)})`, 1);}
            }
            //vs human
            if (this.opponent.isCPU == 0){
              ctx.fillStyle = "rgba(39,39,39,1)";
              ctx.fillRect(0,0,wX,wY);
              drawShape('rec',0,0,1,0,0,10,10,0,0,0,0,'black',1)
              drawText(2.5,7.5,5,3,'DEFEAT','white',1);
              this.flip();
              drawText(2.5,7.5,5,3,'TRIUMPH','gold',1);
              this.flip()
              drawText(2.5, 5, 8, 0.8, "Tap to Restart", `rgba(255,215,0,${0.6 + 0.4 * Math.sin(Date.now() / 400)})`, 1);
            }
            if (startGame == 7){
              MusicEngine.stop();
              MusicEngine.play(18); 
              startGame = 8         
            }
          }
          break;
        case 6.1://reroll
          //player reroll
          if (Player[1].option == 6.11){
            this.flip();
            if(attacker == 1){drawPortrait(-11,9,9,.1);drawPortrait(-11,0,9,.1);}
            if(defender == 1){drawPortrait(-13,9,9,.1);drawPortrait(-13,0,9,.1);}
            Player[1].aMonster[0].place(3.88,6.5,1);
            Player[1].setDice(Player[1].diceType,8,6,1,.001,dt)
            drawText(7.7,5.6,1,1,''+Player[1].look[eLOOK.R],'white',1);
            this.flip();

            drawPortrait(17,9,9,.1);
            drawPortrait(17,0,9,.1);
            drawPortrait(17,9,5,.1);
            drawPortrait(17,0,5,.1);
            Player[0].aMonster[0].place(3.88,6.5,1);
            Player[0].setDice(Player[0].diceType,8,6,1,.001,dt)
            drawText(7.7,5.6,1,1,''+Player[0].look[eLOOK.R],'white',1);
            drawText(3.75,5,5,.75,'Re-roll?','white',1)
            drawText(2.6,5.75,5,1,'Yes        No','white',1)
          }
          //foe reroll
          if (Player[1].option == 6.12){
            // --- CPU REROLL LOGIC START ---
            if (Player[1].isCPU === 1) {
              Player[1].cpuHandleReroll();
              return; // Exit this frame so we don't draw the menu
            }
            // --- CPU REROLL LOGIC END ---
            if(attacker == 0){drawPortrait(-11,9,9,.1);drawPortrait(-11,0,9,.1);}
            if(defender == 0){drawPortrait(-13,9,9,.1);drawPortrait(-13,0,9,.1);}
            Player[0].aMonster[0].place(3.88,6.5,1);
            Player[0].setDice(Player[0].diceType,8,6,1,.001,dt)
            drawText(7.7,5.6,1,1,''+Player[0].look[eLOOK.R],'white',1);

            this.flip()
            drawPortrait(17,9,9,.1);
            drawPortrait(17,0,9,.1);
            drawPortrait(17,9,5,.1);
            drawPortrait(17,0,5,.1);
            Player[1].aMonster[0].place(3.88,6.5,1);
            Player[1].setDice(Player[1].diceType,8,6,1,.001,dt)
            drawText(7.7,5.6,1,1,''+Player[1].look[eLOOK.R],'white',1);
            drawText(3.75,5,5,.75,'Re-roll?','white',1)
            drawText(2.6,5.75,5,1,'Yes        No','white',1)
            this.flip();
          }
          break;
        case 6.2://winged boots/prompt between turns
          // --- CPU WINGED BOOTS LOGIC ---
          if (Player[defender].isCPU === 1 && this.at == 0) {
            let myAGI = Player[defender].aMonster[0].stat[3][1] + Player[defender].aMonster[0].stat[3][2]; // Max + Mod
            let myCON = Player[defender].aMonster[0].stat[1][1] + Player[defender].aMonster[0].stat[1][2];
            if (myAGI > myCON) {Player[defender].defStat = 3;}  // Switch to AGI
            else {Player[defender].defStat = 1;} // Stay CON
             // Mark used
            for (let i = 0; i < Player[defender].aMonster.length; i++){
              if (Player[defender].aMonster[i].index == 7) Player[defender].aMonster[i].effectTriggered = 1;
            }
            Player[0].option = 7;
            Player[1].option = 7;
            return;
          }
          // -----------------------------
          if(attacker == 1){this.flip()}
          Player[attacker].aMonster[0].place(3.88,6.5,1);
          if(attacker == 1){this.flip()}
          if(defender == 1){this.flip()}
          Player[defender].aMonster[0].place(3.88,6.5,1);
          for (let i = 0; i < Player[defender].aMonster.length; i++){
            if (Player[defender].aMonster[i].index == 7 && Player[defender].aMonster[i].effectTriggered == 0&& this.at == 0){
              drawText(3.4,5,4,1,'Defend with AGI ?','white',1)
              drawText(2.6,5.75,5,1,'Yes        No','white',1)
              drawPortrait(7,9,9,.1);
              drawPortrait(7,0,9,.1);
              //drawPortrait(7,9,5,.1);
              //drawPortrait(7,0,5,.1);
            }    
          }
          if(defender == 1){this.flip()}
          break;
        case 6.3://Alchemy stat pick
          
          
          // --- CPU ALCHEMY LOGIC ---
          if (Player[attacker].isCPU === 1) {
              // 1. Pick MY Best Stat (Attack)
              let bestStat = eSTAT.S;
              let maxVal = -999;
              for(let s=0; s<4; s++) {
                  let val = Player[attacker].aMonster[0].stat[s][eDICE.MAX] + Player[attacker].aMonster[0].stat[s][eDICE.MOD];
                  if(val > maxVal) { maxVal = val; bestStat = s; }
              }
              
              Player[attacker].look[eLOOK.STAT] = bestStat;
              Player[attacker].hasScalesOfJustice = 3; // Advance phase

              // 2. Pick OPPONENT'S Worst Stat (Defend)
              let worstStat = eSTAT.S;
              let minVal = 999;
              for(let s=0; s<4; s++) {
                  let val = Player[attacker].opponent.aMonster[0].stat[s][eDICE.MAX] + Player[attacker].opponent.aMonster[0].stat[s][eDICE.MOD];
                  if(val < minVal) { minVal = val; worstStat = s; }
              }
              Player[attacker].opponent.look[eLOOK.STAT] = worstStat;
              
              // Finalize
              Player[attacker].hasScalesOfJustice = 4;
              Player[0].option = 7;
              Player[1].option = 7;
              return;
          
          }
          // -------------------------
          if(attacker == 1){this.flip()}
          Player[attacker].aMonster[0].place(3.88,5.5,1);
          this.flip();
          Player[defender].aMonster[0].place(3.88,5.5,1);
          this.flip();
          if (Player[attacker].hasScalesOfJustice == 2||Player[attacker].hasScalesOfJustice == 3){
            if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].effectTriggered == 0&& this.at == 0){
              if (Player[attacker].hasScalesOfJustice == 2){drawText(2.25,5,6,1,'Choose Caster Attack Stat:','white',1)}
              if (Player[attacker].hasScalesOfJustice == 3){
                drawText(2.25,5,6,1,'Choose Target Defend Stat:','white',1);
                if (Player[attacker].look[eLOOK.STAT] == eSTAT.A){
                  //agi
                  drawShape('arc',1.25,6.5,2, .45,.47, .4,0, 2,0, .0,0,'rgba(0,0,255,.5)',1);
                  drawShape('arc',1.25,6.5,2, .45,.47, .4,0, 2,0, .0,0,'rgba(0,0,255,.5)',1);
                  drawShape('arc',1.25,6.5,2, .5,.47, .36,0, 2,0, .0,0,'rgba(255,255,255,.075)',1);
                  drawShape('arc',1.25,6.5,2, .55,.47, .3,0, 2,0, .0,0,'rgba(255,255,255,.075)',1);
                  drawShape('arc',1.25,6.5,2, .65,.47, .2,0, 2,0, .0,0,'rgba(255,255,255,.075)',1);
                  drawShape('arc',1.25,6.5,2, .75,.47, .1,0, 2,0, .0,0,'rgba(255,255,255,.075)',1);
                  drawShape('arc',1.25,6.5,2, .45,.47, .4,0, 2,0, .0,0,'rgba(0,0,0,.15)',1);
                  drawShape('arc',1.25,6.5,2, .45,.47, .4,0, 2,0, .0,0,'rgba(255,255,255,.075)',1);
                  //drawShape('qua',this.x,this.y,this.z*.9, .5,0, 0,.5, .5,1, 1,.5,'rgba(255,255,255,.25)',1);
                  drawPortrait(-7,1.25+.5,6.5+.5,.084)
                }
                else if(Player[attacker].look[eLOOK.STAT] == eSTAT.S){
                  //STR
                  drawShape('qua',1.25,6.5,1.8, .5,0, 0,.5, .5,1, 1,.5,'yellow',1);
                  drawShape('qua',1.25,6.5,1.8, .5,0, 0,.5, .5,1, 1,.5,'rgba(255,255,255,.25)',1);
                  drawShape('tri',1.25,6.5,1.8, 0,.5, .5,1, 1,.5, 0,0,'rgba(0,0,0,.15)',1);
                  drawShape('tri',1.25,6.5,1.8, .5,0, 1,.5, .5,1, 0,0,'rgba(255,255,255,.25)',1);
                  drawPortrait(-4,1.25+.5,6.5+.5,.0840)
                }
                else if(Player[attacker].look[eLOOK.STAT] == eSTAT.C){
                  //con
                  drawShape('qua',1.25,6.5,1.5, 0,0.1, .5,0, 1,.1, .5,.2,'green',1);
                  drawShape('qua',1.25,6.5,1.5, 0,0.1, .5,0, 1,.1, .5,.2,'rgba(0,0,0,.25)',1);
                  drawShape('qua',1.25,6.5,1.5, 0,0.1, 0,.9, .5,1, .5,.2,'green',1);
                  drawShape('qua',1.25,6.5,1.5, 1,0.1, 1,.9, .5,1, .5,.2,'green',1);
                  drawShape('qua',1.25,6.5,1.5, 1,0.1, 1,.9, .5,1, .5,.2,'rgba(255,255,255,.25)',1);
                  drawPortrait(-6,1.25+.33,6.5+.33,.0840)
                }
                else if(Player[attacker].look[eLOOK.STAT] == eSTAT.I){
                //int
                drawShape('qua',1.25,6.5,1.8, 0,.9, 0.5,0.1, 1,.9, .5,1,'red',1);
                drawShape('tri',1.25,6.5,1.8, .5,0.1, 1,.9, .5,1, 1,.5,'rgba(255,255,255,.45)',1);
                drawPortrait(-5,1.25+.44,6.5+.76,.0720)
              }
                this.flip();
              }
              drawPortrait(14,9,9,.1);
              drawPortrait(14,0,9,.1);
              drawPortrait(14,9,5,.1);
              drawPortrait(14,0,5,.1);
              
                //STR
              drawShape('qua',2,6,.9, .5,0, 0,.5, .5,1, 1,.5,'yellow',1);
              drawShape('qua',2,6,.9, .5,0, 0,.5, .5,1, 1,.5,'rgba(255,255,255,.25)',1);
              drawShape('tri',2,6,.9, 0,.5, .5,1, 1,.5, 0,0,'rgba(0,0,0,.15)',1);
              drawShape('tri',2,6,.9, .5,0, 1,.5, .5,1, 0,0,'rgba(255,255,255,.25)',1);
              drawPortrait(-4,2+.25,6+.25,.0420)
              //con
              drawShape('qua',7,6,.75, 0,0.1, .5,0, 1,.1, .5,.2,'green',1);
              drawShape('qua',7,6,.75, 0,0.1, .5,0, 1,.1, .5,.2,'rgba(0,0,0,.25)',1);
              drawShape('qua',7,6,.75, 0,0.1, 0,.9, .5,1, .5,.2,'green',1);
              drawShape('qua',7,6,.75, 1,0.1, 1,.9, .5,1, .5,.2,'green',1);
              drawShape('qua',7,6,.75, 1,0.1, 1,.9, .5,1, .5,.2,'rgba(255,255,255,.25)',1);
              drawPortrait(-6,7+.165,6+.165,.0420)
              //int
              drawShape('qua',2,8.5,.9, 0,.9, 0.5,0.1, 1,.9, .5,1,'red',1);
              drawShape('tri',2,8.5,.9, .5,0.1, 1,.9, .5,1, 1,.5,'rgba(255,255,255,.45)',1);
              drawPortrait(-5,2+.22,8.5+.38,.0360)
              //agi
              drawShape('arc',7,8.5,1, .45,.47, .4,0, 2,0, .0,0,'rgba(0,0,255,.5)',1);
              drawShape('arc',7,8.5,1, .45,.47, .4,0, 2,0, .0,0,'rgba(0,0,255,.5)',1);
              drawShape('arc',7,8.5,1, .5,.47, .36,0, 2,0, .0,0,'rgba(255,255,255,.075)',1);
              drawShape('arc',7,8.5,1, .55,.47, .3,0, 2,0, .0,0,'rgba(255,255,255,.075)',1);
              drawShape('arc',7,8.5,1, .65,.47, .2,0, 2,0, .0,0,'rgba(255,255,255,.075)',1);
              drawShape('arc',7,8.5,1, .75,.47, .1,0, 2,0, .0,0,'rgba(255,255,255,.075)',1);
              drawShape('arc',7,8.5,1, .45,.47, .4,0, 2,0, .0,0,'rgba(0,0,0,.15)',1);
              drawShape('arc',7,8.5,1, .45,.47, .4,0, 2,0, .0,0,'rgba(255,255,255,.075)',1);
              //drawShape('qua',this.x,this.y,this.z*.9, .5,0, 0,.5, .5,1, 1,.5,'rgba(255,255,255,.25)',1);
              drawPortrait(-7,7+.25,8.5+.25,.0420)
              if (Player[attacker].hasScalesOfJustice == 3){
               this.flip();
              }
              ///
            }
            }else{
              Player[0].option =7;
              Player[1].option = 7;
              Player[0].sendAction('PHASE_CHANGE', { option: 7 });
              Player[0].sendAction('FORCE_OPPONENT_OPTION', { option: 7 });
            }      
            if(attacker == 1){this.flip()}  
          break;
        case 6.4://Scry
          if (Player[attacker].look[eLOOK.R]>=Player[attacker].deck.length){Player[attacker].look[eLOOK.R]=Player[attacker].deck.length}
          if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 44){Player[attacker].look[eLOOK.R] = Player[attacker].deck.length;}
          if (attacker == 1){this.flip()}
          //DJINN LAMP QUICKSEARCH add check for &&Player[0].hand[Player[0].eLOOK.H]].index != 44 do not display exit also make this.look[eLOOK.R] = deck.length 
          // --- CPU LOGIC START ---
          if (Player[attacker].isCPU == 1) {
            Player[attacker].aMonster[0].place(3.88,5.5,1);
            MessageBox.show(.5,6,1.5,2,1,'Please select a card from your deck to add to your hand.','jrpg',1,0)
            MessageBox.show(7.9,5.5,1,9,2,'','indicator',1,0)
            Player[attacker].deck[Player[attacker].look[eLOOK.D]].place(7,6.45,1);   
            this.ax= this.ax +tick; // Timer tick
            // Wait ~30 frames (approx 0.5s) for visuals
            if (this.ax >= 30) {
              let bestCardIndex = -1;
              let range = Player[attacker].look[eLOOK.R]; 
              // 1. Scan revealed cards
              for (let i = 0; i < range; i++) {
                if (Player[attacker].deck[i].type != 0||(Player[attacker].deck[i].type == 0 && Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 44||(Player[attacker].deck[i].type == 0 && Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 71))) { // Not a monster
                  bestCardIndex = i;
                  // Prioritize taking a Spell (Type 2) immediately
                  if (Player[attacker].deck[i].type == 1&&Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 71) {
                    break; 
                  }
                  if (Player[attacker].deck[i].type == 2&&Player[attacker].hand[Player[attacker].look[eLOOK.H]].index != 71) {
                    break; 
                  }
                }
              }
              // 2. Execute Logic DIRECTLY (Do not click buttons)
              if (bestCardIndex != -1) {
                // --- Add to Hand Logic ---
                let card = Player[attacker].deck.splice(bestCardIndex, 1)[0];
                card.location = 'hand';
                Player[attacker].hand.push(card);
                // Reset remaining deck locations
                for(let j=0; j<Player[attacker].deck.length; j++){
                  Player[attacker].deck[j].location = 'deck';
                }
                // Return to previous option (usually Option 8: Spell Cast)
                Player[0].option = 7;
                Player[1].option = 7;
              } 
              // --- Exit Scry Logic ---
              else {
                Player[0].option = 7;
                Player[1].option = 7;
                if (attacker == 1){this.flip()}          
                return;
              }
            }//end >30
          }
          // --- CPU LOGIC END ---
          if (Player[attacker].isCPU == 0){
            Player[attacker].aMonster[0].place(3.88,5.5,1);
            this.flip()
            Player[defender].aMonster[0].place(3.88,5.5,1);
            this.flip()
            MessageBox.show(7.9,5.5,1,9,2,'','indicator',1,0)
            if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 44){
              MessageBox.show(.5,6,1.5,2,1,'Please select a card from your deck.','jrpg',1,0)
               this.flip()
              MessageBox.show(.5,6,1.5,2,1,'Please wait for opponent to finish selection.','jrpg',1,0)
               this.flip()
            }
            else if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 71) {
              MessageBox.show(.5,6,1.5,2,1,'Please select an Item card (blue) from your deck.','jrpg',1,0)
              this.flip()
              MessageBox.show(.5,6,1.5,2,1,'Please wait for opponent to finish selection.','jrpg',1,0)
              this.flip()
            }
            else {
              MessageBox.show(.5,6,1.5,2,1,'Please select a card from your deck to add to your hand.','jrpg',1,0)
              this.flip()
              MessageBox.show(.5,6,1.5,2,1,'Please wait for opponent to finish selection.','jrpg',1,0)
              this.flip()
            }
            
            MessageBox.show(.5,7.8,1.5,2,1.25,'If no cards available to add to your hand, Click here to continue.','jrpg_btn',1,this.foe)
            
            if(Player[attacker].deck.length >0){
              for(let i=0;i<Player[attacker].look[eLOOK.R];i++){	//place deck on right side of field
                
                Player[attacker].deck[i].location = 'scry'
              }
              Player[attacker].deck[Player[attacker].look[eLOOK.D]].place(7,6.45,1);
              drawText(7+.625,6,1,.5,(Player[attacker].look[eLOOK.D]+1)+'/'+(Player[attacker].look[eLOOK.R]),'white',1)
              btnAction.show(6.5,7.75,1,1,1,'deck','arrow_left',1,0)
              btnAction2.show(9,7.75,1,1,1,'deck','arrow_right',1,0)
              btnAdd.show(6.9,5.8,.9,1,1,'deck','add_toHand',1,0)
              if(btnAdd.visible == true){//Add To Hand/Field TEXT}
                if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 44){
                  if(Player[attacker].deck[Player[attacker].look[eLOOK.D]].type == 0){
                    drawText(6.36 ,5.15,3,1,'Swap Monster','white',.5);
                  }
                  else{drawText(6.36 ,5.15,3,1,'Add to Hand','white',.5); }
                }
                else if (Player[attacker].hand[Player[attacker].look[eLOOK.H]].index == 71&&Player[attacker].deck[Player[attacker].look[eLOOK.D]].type == 0||Player[attacker].deck[Player[attacker].look[eLOOK.D]].type == 2){
              //do nothing   
                }
                else{drawText(6.36 ,5.15,3,1,'Add to Hand','white',.5);}
              }
            }
          }
          if (attacker == 1){this.flip()}
        break;
        case 6.5://Protect Orb/prompt between turns
          // --- CPU WINGED BOOTS LOGIC ---
          if (Player[defender].isCPU === 1 && this.at == 0) {
            let myINT = Player[defender].aMonster[0].stat[2][1] + Player[defender].aMonster[0].stat[3][2]; // Max + Mod
            let myCON = Player[defender].aMonster[0].stat[1][1] + Player[defender].aMonster[0].stat[1][2];
            if (myINT > myCON) {Player[defender].defStat = 2;}  // Switch to AGI
            else {Player[defender].defStat = 1;} // Stay CON
             // Mark used
            for (let i = 0; i < Player[defender].aMonster.length; i++){
              if (Player[defender].aMonster[i].index == 30) Player[defender].aMonster[i].effectTriggered = 1;
            }
            Player[0].option = 7;
            Player[1].option = 7;
            return;
          }
          // -----------------------------
          if(attacker == 1){this.flip()}
          Player[attacker].aMonster[0].place(3.88,6.5,1);
          if(attacker == 1){this.flip()}
          if(defender == 1){this.flip()}
          Player[defender].aMonster[0].place(3.88,6.5,1);
          for (let i = 0; i < Player[defender].aMonster.length; i++){
            if (Player[defender].aMonster[i].index == 30 && Player[defender].aMonster[i].effectTriggered == 0&& this.at == 0){
              drawText(3.4,5,4,1,'Defend with INT  ?','white',1)
              drawText(2.6,5.75,5,1,'Yes        No','white',1)
              drawPortrait(30,9,9,.1);
              drawPortrait(30,0,9,.1);
            }    
          }
          if(defender == 1){this.flip()}
          
          break;
        case 6.6://Cultivate stat pick
          
          // --- CPU CULTIVATE LOGIC START ---
          if (Player[attacker].isCPU === 1) {
            this.at = this.at + tick;
            
            // If we have points to spend (slow down logic with 'at' > 30)
            if (this.at > 30){
              if (Player[attacker].statPoints > 0) {
                
                // 1. DEFINE WEIGHTED RANDOM POOL
                // 0=STR, 1=CON, 2=INT, 3=AGI
                // To increase weight, simply add more of that number to the array.
                let statPool = [
                    0, 0, 0, 0, // STR (High Weight)
                    1, 1, 1,    // CON (Medium-High Weight)
                    2,          // INT (Low Weight)
                    3           // AGI (Low Weight)
                ];

                // 2. PICK A RANDOM WINNER FROM THE POOL
                let randomIndex = Math.floor(Math.random() * statPool.length);
                let bestStat = statPool[randomIndex];

                // 3. EXECUTE
                Player[attacker].look[eLOOK.STAT] = bestStat; // Update visual pointer
                
                // DIRECTLY MODIFY THE MONSTER'S STAT MODIFIER
                // Structure: aMonster[0].stat[StatType][ModIndex]
                // We use index [2] because [0]=Min, [1]=Max, [2]=Mod
                Player[attacker].aMonster[0].stat[bestStat][2]++; 

                // Decrease available points
                Player[attacker].statPoints--;
                this.at = 0; // Reset timer for next point spend
                
                // CHECK: Do we have more points to spend?
                if (Player[attacker].statPoints <= 0) {
                    // All points spent, return to previous menu/game state
                    this.at = 104;
                    Player[0].option = 7;
                    Player[1].option = 7;
                }

                return; // Exit frame
              }
            }
          }
          // --- CPU CULTIVATE LOGIC END ---
          if(attacker == 1){this.flip()}
          Player[attacker].aMonster[0].place(3.88,5.5,1);
          this.flip();
          Player[defender].aMonster[0].place(3.88,5.5,1);
          this.flip()
          if (Player[attacker].statPoints > 0){
            drawText(2.25,5,6,1,'Stat Points Remaining: ' + Player[attacker].statPoints,'white',1)
            //STR
            drawShape('qua',2,6,.9, .5,0, 0,.5, .5,1, 1,.5,'yellow',1);
            drawShape('qua',2,6,.9, .5,0, 0,.5, .5,1, 1,.5,'rgba(255,255,255,.25)',1);
            drawShape('tri',2,6,.9, 0,.5, .5,1, 1,.5, 0,0,'rgba(0,0,0,.15)',1);
            drawShape('tri',2,6,.9, .5,0, 1,.5, .5,1, 0,0,'rgba(255,255,255,.25)',1);
            drawPortrait(-4,2+.25,6+.25,.0420)
            //con
            drawShape('qua',7,6,.75, 0,0.1, .5,0, 1,.1, .5,.2,'green',1);
            drawShape('qua',7,6,.75, 0,0.1, .5,0, 1,.1, .5,.2,'rgba(0,0,0,.25)',1);
            drawShape('qua',7,6,.75, 0,0.1, 0,.9, .5,1, .5,.2,'green',1);
            drawShape('qua',7,6,.75, 1,0.1, 1,.9, .5,1, .5,.2,'green',1);
            drawShape('qua',7,6,.75, 1,0.1, 1,.9, .5,1, .5,.2,'rgba(255,255,255,.25)',1);
            drawPortrait(-6,7+.165,6+.165,.0420)
            //int
            drawShape('qua',2,8.5,.9, 0,.9, 0.5,0.1, 1,.9, .5,1,'red',1);
            drawShape('tri',2,8.5,.9, .5,0.1, 1,.9, .5,1, 1,.5,'rgba(255,255,255,.45)',1);
            drawPortrait(-5,2+.22,8.5+.38,.0360)
            //agi
            drawShape('arc',7,8.5,1, .45,.47, .4,0, 2,0, .0,0,'rgba(0,0,255,.5)',1);
            drawShape('arc',7,8.5,1, .45,.47, .4,0, 2,0, .0,0,'rgba(0,0,255,.5)',1);
            drawShape('arc',7,8.5,1, .5,.47, .36,0, 2,0, .0,0,'rgba(255,255,255,.075)',1);
            drawShape('arc',7,8.5,1, .55,.47, .3,0, 2,0, .0,0,'rgba(255,255,255,.075)',1);
            drawShape('arc',7,8.5,1, .65,.47, .2,0, 2,0, .0,0,'rgba(255,255,255,.075)',1);
            drawShape('arc',7,8.5,1, .75,.47, .1,0, 2,0, .0,0,'rgba(255,255,255,.075)',1);
            drawShape('arc',7,8.5,1, .45,.47, .4,0, 2,0, .0,0,'rgba(0,0,0,.15)',1);
            drawShape('arc',7,8.5,1, .45,.47, .4,0, 2,0, .0,0,'rgba(255,255,255,.075)',1);
            //drawShape('qua',this.x,this.y,this.z*.9, .5,0, 0,.5, .5,1, 1,.5,'rgba(255,255,255,.25)',1);
            drawPortrait(-7,7+.25,8.5+.25,.0420)
            ///
            drawPortrait(70,9,9,.1);
            drawPortrait(70,0,9,.1);
            drawPortrait(70,9,5,.1);
            drawPortrait(70,0,5,.1);
          }else{
            Player[0].option =7;
            Player[1].option = 7;
            Player[0].sendAction('PHASE_CHANGE', { option: 7 });
            Player[0].sendAction('FORCE_OPPONENT_OPTION', { option: 7 });
          }    
          if(attacker == 1){this.flip()}
        break;    
      }//end switch.option
    if (this.foe == 1){this.flip()}
  }//end react
	cardID(index){//card zoom
    //Player[0].cardID(Player[0].deck[0].index);//example of using card zoom
    if (startGame == 'grimoire' && activePlaylist.length === 0) {
        filterGrimoire('ALL'); // Force populate the list if it's empty
    }
		 
     if(startGame == 'grimoire'){
      var realID = activePlaylist[playlistIndex];
      if (realID === undefined) realID = 0;
      this.view = new Card(realID, 613);
      if (realID !== lastViewedCardID) {
            // Generate the random text ONCE and save it
            currentOracleText = getOracleText(this.view);
            
            // Update our tracker
            lastViewedCardID = realID; 
        }
      this.view.place(2.83, 3.19, 1.9);
      drawPortrait(-1,.5,8.25,.15)
      drawPortrait(-2,8,8.25,.15)
      drawText(0,.15,10,.5,'Card Grimoire','gray',1,'center');
      drawText(7.25,6,3,1,'Click X to Exit','gray',.9,'center');
      drawText(7.25,6.5,2.5,1,'X','gray',1,'center');

      drawText((tX+tL)-(ctx.measureText("King of Pentacles").width/wX),2.5,4,.25,'King of Pentacles','white',1.63);
      // Generate the lore text
      var loreText = getOracleText(this.view);

      // Draw the Lore (Top paragraph)
      drawText(.1, 0.75, 9.6, 1.6, currentOracleText, 'silver', 1, 'center');      drawText(.69,3.39,1.991,.25,'Filter by Suit:','white',1);
      drawText(7.69,3.39,1.991,.25,'Filter by Rank:','white',1);

      drawText(.25,4.20,1,.75,'All','white',1,'center');
      if(this.view.index <22){
      drawText(3,2.5,4,.4,this.view.rank,'white',1,'center');

      }else{
      drawText(3,2.5,4,.4,this.view.rank + ' of ' + this.view.suit,'white',1,'center');
      }
      //suit filter buttons
      //major arcana 
      drawPortrait(-26,1.5,3.9,.1)
      //swords
      drawPortrait(-11,1.5,6.9,.1)
      //wands
      drawPortrait(-12,.25,5.3,.1)
      //pentacles
      drawPortrait(-13,.25,6.9,.1)
      //Cups
      drawPortrait(-14,1.5,5.3,.1)
      //drawShape('rec',0,0,1, 1,4.9, 1,1,0,0,0,0,'rgba(0,0,0,.75)',1);//right
      // Place this somewhere in your UI, maybe below the Suit icons?
      // This draws "Rank: King" or "Rank: All"
      var currentRankName = rankList[rankFilterIndex];
      drawText(7.39, 3.69, 2.25, .5,  currentRankName, "rgba(255,255,0,.75)", 1, "center");

      // Optional: Draw a little arrow next to it so they know it's clickable
      drawPortrait(-2, 8, 4.20, .1); // Right arrow icon

    }
		 else{
      if(this.option == 0){return}
      cardIDO = 1;
      cardIDI= index;
     }
   }
	refresh(dt) {
    // Refresh the screen graphics
    if (this.foe == 1) { this.flip() }

    // ---------------------------------------------------------
    // 1. DRAW DECK (Right Side)
    // ---------------------------------------------------------
    if (this.deck.length > 0) {
        // A. Draw the stack of cards
        for (let i = this.deck.length - 1; i >= this.draw; i--) {
            // This places the cards. Higher index = further left.
            this.deck[i].place(7 - (tL / 10) * (i * .000069), 6.45, 1);
            this.deck[i].locCount = this.deck.length - 1;
        }

        // B. Draw Portrait (-26) on the TOP card
        // We find the card currently at the top of the pile (usually index 0)
        let topDeckCard = this.deck[this.draw] || this.deck[0]; 
        
        // We use THAT card's X position. We do NOT calculate based on deck.length.
        // This ensures the portrait stays on the right, even if the deck is huge.
        let deckPortraitX = topDeckCard.x + (topDeckCard.l / 5); // Center = x + half width
        
        drawPortrait(-26, deckPortraitX, 7.5, .1369);
    }

    // ---------------------------------------------------------
    // 2. DRAW HAND (Left Side)
    // ---------------------------------------------------------
    if (this.hand.length > 0) {
        
        // A. Draw CPU Hand Borders (Stack Logic)
        if (this.isCPU != 0) {
            for (let i = 0; i < this.hand.length; i++) {
                this.hand[i].locCount = this.hand.length - 1;
                this.hand[i].locIndex = i;

                // We must calculate X here manually because CPU cards don't always run .place()
                let cpuCardX = 1 - (i * .0536); 

                // Draw the gray borders
                if (this.hand.length - 1 > 0) {
                    drawShape('rec', cpuCardX, 6.45, 1, 0, 0, 2.25, 3.55, 0, 0, 0, 0, 'rgba(0, 0, 0,1)', 1);
                    drawShape('rec', cpuCardX, 6.45, 1, 0, 0, 2.25, 3.55, 0, 0, 0, 0, 'rgba(255, 255, 255,.43)', 0);
                }
            }
        }

        // B. Draw the Cards or the CPU Portrait
        if (this.isCPU === 1) {
            // CPU: Draw Portrait -26
            // The CPU draws cards from 0 to Length. 
            // The card visually "On Top" is the last one in the array (length-1).
            let topHandIndex = this.hand.length - 1;
            
            // Re-calculate the X position of that specific top card
            let topHandCardX = 1 - (topHandIndex * .0536);
            
            // Center the portrait on that top card
            let handPortraitX = topHandCardX + (this.hand[topHandIndex].l / 5);

            drawPortrait(-26, handPortraitX, 7.5, .1369);

        } else {
            // PLAYER: Draw the actual card graphic
            this.hand[this.look[eLOOK.H]].place(.875, 6.5, 1);
        }
    }

    // ---------------------------------------------------------
    // 3. DRAW MONSTERS (Center)
    // ---------------------------------------------------------
    for (let i = 0; i < this.aMonster.length; i++) {
        this.aMonster[this.look[eLOOK.M]].place(3.875, 6.5, 1);
        this.aMonster[i].locCount = this.aMonster.length - 1;
        this.aMonster[i].locIndex = i;
    }

    // ---------------------------------------------------------
    // 4. UI ARROWS & MENUS
    // ---------------------------------------------------------
    let arrowWidth = 0;
    let arrowOffsetX = 0;
    let arrowOffsetY = 0;

    if (this.option == 1) {
        arrowWidth = .1; arrowOffsetX = .75; arrowOffsetY = 1;
    } else {
        arrowWidth = .057; arrowOffsetX = .35; arrowOffsetY = 1.3;
    }

    // Hand Menu Arrows
    if (this.hand.length > 0 && this.option < 5 && this.hand.length > 1 && this.isCPU == 0) {
        let activeCard = this.hand[0]; 
        drawPortrait(-1, activeCard.x - arrowOffsetX, activeCard.y + arrowOffsetY, arrowWidth); 
        drawPortrait(-2, activeCard.x + 2.04, activeCard.y + arrowOffsetY, arrowWidth); 
        drawText(activeCard.x + (activeCard.l / 3.6), 5.8, 1, .8, (this.look[eLOOK.H] + 1) + "/" + this.hand.length, 'white', 1);
    }

    if (this.option == 3) {
        arrowWidth = .1; arrowOffsetX = .75; arrowOffsetY = 1;
    } else {
        arrowWidth = .057; arrowOffsetX = .37; arrowOffsetY = 1.3;
    }

    // Monster Menu Arrows
    if (this.aMonster.length > 0 && this.option < 5 && this.aMonster.length > 1) {
        let activeMon = this.aMonster[0];
        drawPortrait(-1, activeMon.x - arrowOffsetX, activeMon.y + arrowOffsetY, arrowWidth); 
        drawPortrait(-2, activeMon.x + 2.04, activeMon.y + arrowOffsetY, arrowWidth); 
        drawText(activeMon.x + (activeMon.l / 3.6), 5.8, 1, .8, (this.look[eLOOK.M] + 1) + "/" + this.aMonster.length, 'white', 1);
    }

    // ---------------------------------------------------------
    // 5. DRAW ANIMATION
    // ---------------------------------------------------------
    if (this.draw == 1) {
        const DRAW_SPEED = 30;
        if (this.deck.length > 0) {
            let moveAmount = DRAW_SPEED * dt;
            this.deck[0].place(this.deck[0].x - moveAmount, this.deck[0].y);

            if (this.isCPU == 1) {
                drawShape('rec', this.deck[0].x - moveAmount, this.deck[0].y, 1, 0, 0, 2.25, 3.55, 0, 0, 0, 0, 'rgba(0, 0, 0,1)', 1);
                drawShape('rec', this.deck[0].x - moveAmount, this.deck[0].y, 1, 0, 0, 2.25, 3.55, 0, 0, 0, 0, 'darkgray', 0);
            }

            // Logic to move card to Monster Array
            if (this.deck[0].type == 0 && (tL / 10) * this.deck[0].x < (tL / 10) * 4) {
                this.draw = 0;
                
                this.aMonster.push(this.deck[0]);
                this.deck.shift();
                
                let newMon = this.aMonster[this.aMonster.length - 1];
                newMon.location = 'field';
                newMon.locIndex = this.aMonster.length - 1;
                newMon.locCount = this.aMonster.length - 1;
                
                if (sRune.owner == this.foe) sRune.changeOwner(this.foe);
                if (cRune.owner == this.foe) cRune.changeOwner(this.foe);
                if (iRune.owner == this.foe) iRune.changeOwner(this.foe);
                if (aRune.owner == this.foe) aRune.changeOwner(this.foe);

            } 
            // Logic to move card to Hand Array
            else if ((tL / 10) * this.deck[0].x < (tL / 10) * .1) {
                this.draw = 1;
                
                this.hand.push(this.deck[0]);
                this.deck.shift();
                
                let newHand = this.hand[this.hand.length - 1];
                newHand.location = 'hand';
                newHand.locIndex = this.hand.length - 1;
                newHand.locCount = this.hand.length - 1;
                this.look[eLOOK.H] = this.hand.length - 1;
            }
        }
        else{
          this.draw = 0;
          
        }
    }

    if (this.aMonster.length == 0 && this.draw == 0 && this.deck.length > 0 && this.option == 9) {
        this.draw = 1;
       
    }

    if (this.foe == 1) { this.flip() }
}
  btnDo(index){//with handleInput
  switch(index){
      case 'mc'://menu close
        this.option = 0;
        
        break;
      case 'hm'://hand menu
        if (this.hand.length > 0){
          this.option = 1

        }
        break;
      case 'hra'://hand right arrow
        if(this.hand.length > 1){
          if (this.look[eLOOK.H] + 1 > this.hand.length-1){
            this.look[eLOOK.H] = 0;
          }
          else{
            this.look[eLOOK.H] = this.look[eLOOK.H] + 1;
          }
          

          if (this.option != 2){
            this.option = 1;
          }
        }
        break;
      case 'hla'://hand left arrow
        if (this.hand.length>1){
          if (this.look[eLOOK.H] - 1 < 0){
            this.look[eLOOK.H] = this.hand.length-1;
          }
          else{
            this.look[eLOOK.H] = this.look[eLOOK.H]-1;
          }

          if (this.option != 2){
            this.option = 1;
          }
        }
        break;
      case 'use'://hand use
        if (this.hand.length > 0){
          this.look[eLOOK.A] = this.hand[this.look[eLOOK.H]].type;
          this.option = 5;
          
        }
        break;
      case 'hex'://hand examine
        if (this.hand.length > 0){
          this.option = 2;
          cardIDO = 1;
        }
      break;
      case 'hec'://hand examine close
        this.option = 1;
      break;
      case 'mmo'://monster menu
        if (this.aMonster.length>0){
          this.option = 3;
        }
        break;
      case 'mra'://monster right arrow
        if (this.aMonster.length > 1){
          if (this.look[eLOOK.M] + 1 > this.aMonster.length-1){
            this.look[eLOOK.M] = 0;
          }
          else{
            this.look[eLOOK.M] = this.look[eLOOK.M]+1;
          }
          if (this.option != 4){
            this.option = 3;
          }
        }
        break;
      case 'mla'://monster left arrow
        if (this.aMonster.length > 1){
          if (this.look[eLOOK.M] - 1 < 0){
            this.look[eLOOK.M] = this.aMonster.length-1;
          }
          else{
            this.look[eLOOK.M] = this.look[eLOOK.M]-1;
          }

          if (this.option != 4){
            this.option = 3;

          }
        }
        break;
      case 'me'://monster examine
        if (this.aMonster.length > 0){
          this.option = 4;
          cardIDO = 1;
        }
        break;
      case 'mec'://monster examine close
        this.option = 3;
      break;
      case 'atk':
        if (this.aMonster.length >0){
            this.option = 5;
            this.look[eLOOK.A] = 0;
            
        }
        break;
      case 'rex'://ready close
          this.look[eLOOK.A] = -1
          this.option = 0;


      break;
      }
  }
  unequip(){
    this.hasWingedBoots = 0;
    this.hasStarPendant = 0;
    this.hasScalesOfJustice = 0;
    this.hasTreasureChest = 0;
    this.hasLovers = 0;
    this.hasBind = 0;
    this.hasLunacy = 0;
    this.hasProtectOrb = 0;
    this.hasAmulet = 0;
    this.hasLuckyCharm = 0;
    this.hasIntimidate = 0;
    this.hasReroll = 0;
  }
}//end class field
class Card{
	constructor(index,foe){
	  this.index = index;
		this.foe = foe; //passed from field class (set in constructor)
		this.location = '';
		this.locIndex = 0;
		this.locCount = 0;
    //0-STR,1-CON,2-INT,3-AGI; 0-MIN,1-MAX,2-MOD,3-TEXT(min +'d' +max + '+' + mod)
    this.stat = [[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]];
		this.subType = 0;
    this.hasEffect = 0;
    this.buffApplied = 0;
    this.suit = 0;
        this.rank = 0;
    //ITEM: 7 - USE: 4, EQUIP: 3
    //MONSTER: 6
    //SPELL:8 - DEBUFF: 5, BUFF: 1, CAST: 3
    switch (this.index){//CARD ENCYCLOPEDIA - set card info using index set in Field class constructor
      case 0://Fool//                             MONSTER
        this.name = 'Fool';
        this.portrait = 0;
        this.type = 0;//0-monster, 1-item, 2-spell
        this.desc = 'An impulsive wanderer with raw potential.';
        this.suit = 'Major Arcana';
        this.rank = 'The Fool';
        this.stat[0][0]=1;//minSTR
        this.stat[0][1] = 4;//maxSTR
        this.stat[0][2]= 0;//modSTR
        this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];//STRlabel
        this.stat[1][0]=1;//minCON
        this.stat[1][1] = 4;//maxCON
        this.stat[1][2]= 0;//modCON
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
        this.stat[2][0]=1;//minINT
        this.stat[2][1] = 4;//maxINT
        this.stat[2][2]= 0;//modINT
        this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
        this.stat[3][0]=1;//minAGI
        this.stat[3][1] = 20;//maxAGI
        this.stat[3][2]= 0;//modAGI
        this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];
        break;
      case 1://Magician//                         MONSTER
			  this.name = 'Magician';
			  this.portrait = 1;
			  this.type = 0;//0-monster, 1-item, 2-spell
        this.subtype = 0;//normal monster 1-effect monster
        this.desc = 'A master of the elements.';  
        this.suit = 'Major Arcana';
        this.rank = 'The Magician';      
        this.stat[0][0]=1;//minSTR
        this.stat[0][1] = 8;//maxSTR
        this.stat[0][2]= 0;//modSTR
 		    this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
        this.stat[1][0]=1;//minCON
        this.stat[1][1] = 8;//maxCON
        this.stat[1][2]= 0;//modCON
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
        this.stat[2][0]=1;//minINT
        this.stat[2][1] = 8;//maxINT
        this.stat[2][2]= 0;//modINT
        this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
        this.stat[3][0]=1;//minAGI
        this.stat[3][1] = 8;//maxAGI
        this.stat[3][2]= 0;//modAGI
        this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];
		    break;
		  case 2://High Priestess//                   MONSTER
				this.name = 'High Priestess';
				this.type = 0; //0-monster, 1-item, 2-spell
        this.subtype = 0;//normal monster 1-effect monster
				this.portrait = 2;
				this.desc = 'A silent oracle shrouded in mystery.';
        this.suit = 'Major Arcana';
        this.rank = 'The High Priestess';
        this.stat[0][0]=1;//minSTR
        this.stat[0][1] = 4;//maxSTR
        this.stat[0][2]= 0;//modSTR
        this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
        this.stat[1][0]=1;//minCON
        this.stat[1][1] = 4;//maxCON
        this.stat[1][2]= 0;//modCON
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
        this.stat[2][0]=1;//minINT
        this.stat[2][1] = 10;//maxINT
        this.stat[2][2]= 0;//modINT
        this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
        this.stat[3][0]=1;//minAGI
        this.stat[3][1] = 10;//maxAGI
        this.stat[3][2]= 0;//modAGI
        this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];
				break;
			case 3://Empress//                          MONSTER
				this.name = 'Empress';
				this.portrait = 3;
				this.type = 0;//0-monster, 1-item, 2-spell
        this.subType = 0;//INT spell?
				this.desc = 'The mother of life nurturing growth.';
        this.suit = 'Major Arcana';
        this.rank = 'The Empress';
        this.stat[0][0]=1;//minSTR
        this.stat[0][1] = 4;//maxSTR
        this.stat[0][2]= 0;//modSTR
        this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
        this.stat[1][0]=1;//minCON
        this.stat[1][1] = 20;//maxCON
        this.stat[1][2]= 0;//modCON
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
        this.stat[2][0]=1;//minINT
        this.stat[2][1] = 4;//maxINT
        this.stat[2][2]= 0;//modINT
        this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
        this.stat[3][0]=1;//minAGI
        this.stat[3][1] = 4;//maxAGI
        this.stat[3][2]= 0;//modAGI
        this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];
				break;
      case 4://Emperor//                          MONSTER
        this.name = 'Emperor';
        this.portrait = 4;
        this.type = 0;//0-monster, 1-item, 2-spell
        this.subType = 0;//INT spell?
        this.desc = 'A ruler dominating with unyielding strength.';
        this.suit = 'Major Arcana';
        this.rank = 'The Emperor';
        this.stat[0][0]=1;//minSTR
        this.stat[0][1] = 20;//maxSTR
        this.stat[0][2]= 0;//modSTR
        this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
        this.stat[1][0]=1;//minCON
        this.stat[1][1] = 4;//maxCON
        this.stat[1][2]= 0;//modCON
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
        this.stat[2][0]=1;//minINT
        this.stat[2][1] = 4;//maxINT
        this.stat[2][2]= 0;//modINT
        this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
        this.stat[3][0]=1;//minAGI
        this.stat[3][1] = 4;//maxAGI
        this.stat[3][2]= 0;//modAGI
        this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];
        break;
      case 5://Heirophant//                       MONSTER
        this.name = 'Heirophant';
        this.portrait = 5;
        this.type = 0;//0-monster, 1-item, 2-spell
        this.subType = 0;//INT spell?
        this.desc = 'A keeper of ancient rites and tradition.';
        this.suit = 'Major Arcana';
        this.rank = 'The Heirophant';
        this.stat[0][0]=1;//minSTR
        this.stat[0][1] = 4;//maxSTR
        this.stat[0][2]= 0;//modSTR
        this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
        this.stat[1][0]=1;//minCON
        this.stat[1][1] = 10;//maxCON
        this.stat[1][2]= 0;//modCON
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
        this.stat[2][0]=1;//minINT
        this.stat[2][1] = 10;//maxINT
        this.stat[2][2]= 0;//modINT
        this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
        this.stat[3][0]=1;//minAGI
        this.stat[3][1] = 4;//maxAGI
        this.stat[3][2]= 0;//modAGI
        this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];           
        break;
      case 6://The Lovers//                         ITEM - EQUIP
        this.name = 'The Lovers';
        this.portrait = 6;
        this.type = 1;//null 0-monster, 1-item, 2-spell
        this.subType = 3; //0-none,1-monster effect, 2-use, 3-equip
        this.desc = 'While equipped, +1 to STR and CON rolls. Defeating a foe grants an additional +1 to STR and CON rolls (+3 max). ';
        this.suit = 'Major Arcana';
        this.rank = 'The Lovers';
        this.hasEffect = 1;
        this.buffApplied = 0;
        this.stat[0][0]=1;//STR
        this.stat[0][1] = 0;
        this.stat[0][2]= 1;
        this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
        this.stat[1][0]=1;//CON
        this.stat[1][1] = 0;
        this.stat[1][2]= 1;
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
			  break;
      case 7://The Chariot/Winged Boots//           ITEM - EQUIP
        this.name = 'Winged Boots';
        this.suit = 'Major Arcana';
        this.rank = 'The Chariot';
        this.portrait = 7;
        this.type = 1;//null 0-monster, 1-item, 2-spell
        this.subType = 3; //0-none,1-monster effect, 2-use, 3-equip
        this.desc = 'While equipped, +3 to AGI rolls. You may roll AGI instead of CON when defending.';
        this.effectTriggered = 0;
        this.buffApplied = 0;
        this.stat[3][2]= 3;//AGI mod + 3
        
			  break;
      case 8://Strength//                             SPELL - BUFF
        this.name = 'Strength';
        this.suit = 'Major Arcana';
        this.rank = 'Strength';
        this.portrait = 8;
        this.type = 2;//null 0-monster, 1-item, 2-spell
        this.subType = 'buff'
        this.desc = 'Caster gains STR equal to INT roll. Lasts until caster is defeated.';
        
			  break;
      case 9://Hermit//                           MONSTER
          this.name = 'Hermit';
          this.portrait = 9;
          this.type = 0;//0-monster, 1-item, 2-spell
          this.subType = 0;//INT spell?
          this.desc = 'A solitary sage finding power in silence.';
          this.suit = 'Major Arcana';
          this.rank = 'The Hermit';
          this.stat[0][0]=1;//minSTR
          this.stat[0][1] = 4;//maxSTR
          this.stat[0][2]= 0;//modSTR
          this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
          this.stat[1][0]=1;//minCON
          this.stat[1][1] = 4;//maxCON
          this.stat[1][2]= 0;//modCON
          this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
          this.stat[2][0]=1;//minINT
          this.stat[2][1] = 20;//maxINT
          this.stat[2][2]= 0;//modINT
          this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
          this.stat[3][0]=1;//minAGI
          this.stat[3][1] = 4;//maxAGI
          this.stat[3][2]= 0;//modAGI
          this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];
        break;
      case 10://Wheel of Fortune/Treasure Chest//   ITEM - USE
        this.name = 'Treasure Chest';
        this.suit = 'Major Arcana';
        this.rank = 'The Wheel of Fortune';
        this.portrait = 10;
        this.type = 1;//null 0-monster, 1-item, 2-spell
        this.subType = 2; //0-none,1-monster effect, 2-use, 3-equip
        this.desc = 'Reveal cards from the top of your deck until you reveal a monster card. Put all revealed spells and items into your hand. You may switch your active monster with the revealed monster, or discard it.';
			  break;
      case 11://Justice/Scales of Justice//         ITEM - USE
        this.name = 'Scales of Justice';
        this.suit = 'Major Arcana';
        this.rank = 'Justice';
        this.portrait = 11;
        this.type = 1;//null 0-monster, 1-item, 2-spell
        this.subType = 2; //0-none,1-monster effect, 2-use, 3-equip
        this.desc = 'Instead of normal battle rolls, both players roll 1d12. If player roll > foe roll, foes monster is destroyed. Ignore all buffs, debuffs, items, and special effects. If this monster is destroyed before its next turn, the foes monster is destroyed as well.';
        
			  break;
      case 12://Hanged Man//bind                      SPELL - DEBUFF
        this.name = 'Bind';
        this.suit = 'Major Arcana';
        this.rank = 'The Hanged Man';
        this.portrait = 12;
        this.type = 2;//0-monster, 1-item, 2-spell
        this.subType = 0;//INT spell?
        this.desc = 'If caster INT roll > foe INT roll, foe cannot attack or use items for (caster INT roll - foe INT roll) turns. Foe may still cast spells and defend. ';
        this.subType = 'debuff';
        break; 
      case 13://Death//                               SPELL - CAST
        this.name = 'Death';
        this.suit = 'Major Arcana';
        this.rank = 'Death';
        this.portrait = 13;
        this.type = 2;//null 0-monster, 1-item, 2-spell
        this.desc = 'If caster INT roll > target INT roll, target is defeated. This effect cannot be blocked or prevented by special effects.';
        this.subType = 'debuff'
			  break;
      case 14://Temperance/Alchemy//                  SPELL - CAST
        this.name = 'Alchemy';
        this.suit = 'Major Arcana';
        this.rank = 'Temperance';
        this.portrait = 14;
        this.type = 2;//null 0-monster, 1-item, 2-spell
        this.desc = 'Caster may choose which stat they roll to attack, and which stat the foe must roll to defend.'
			  this.subType = 'cast';
        this.effectTriggered = 0;
        break;
      case 15://Curse//                               SPELL - DEBUFF
        this.name = 'Curse';
        this.suit = 'Major Arcana';
        this.rank = 'Temptation';
        this.portrait = 15;
        this.type = 2;//null 0-monster, 1-item, 2-spell
        this.desc = 'If caster INT roll > foe INT roll, foe suffers a penalty to all stat rolls equal to the difference (caster INT roll - foe INT roll).';
        this.subType = 'debuff';
			  break;
      case 16://The Tower/Ruin//                      SPELL - DEBUFF
        this.name = 'Ruin';
        this.suit = 'Major Arcana';
        this.rank = 'The Tower';
        this.portrait = 16;
        this.type = 2;//null 0-monster, 1-item, 2-spell
        this.desc = 'If caster INT roll > target INT roll, the foe must discard all cards in their hand and field. Target monster remains unaffected.';
        this.subType = 'debuff';
			  break;
      case 17://The Star/Star Pendant//             ITEM - EQUIP
        this.name = 'Star Pendant';
        this.suit = 'Major Arcana';
        this.rank = 'The Star';
        this.portrait = 17;
        this.type = 1;//null 0-monster, 1-item, 2-spell
        this.subType = 3; //0-none,1-monster effect, 2-use, 3-equip
        this.hasEffect = 1;
        this.effectTriggered = 0;
        this.desc = 'While equipped, once per roll, you may re-roll your non-Spell Attack and Defense rolls. You must use the results of the re-roll.';
			  break;
      case 18://The Moon/Lunacy//                     SPELL - DEBUFF
        this.name = 'Lunacy';
        this.suit = 'Major Arcana';
        this.rank = 'The Moon';
        this.portrait = 18;
        this.type = 2;//null 0-monster, 1-item, 2-spell
        this.desc = 'If caster INT roll > foe INT roll, foe cannot cast spells or use items for caster INT roll - foe INT roll turns. Foe may still attack and defend. ';
			  this.subType = 'debuff';
        break;
      case 19://The Sun/Solar Rite//                ITEM - USE
        this.name = 'Solar Rite';
        this.suit = 'Major Arcana';
        this.rank = 'The Sun';
        this.portrait = 19;
        this.type = 1;//null 0-monster, 1-item, 2-spell
        this.subType = 2; //0-none,1-monster effect, 2-use, 3-equip
        this.desc = 'Discard all spell and item cards on the field. Remove all stat buffs, debuffs, and lingering effects from all monsters. (May be activated even if unable to act. Cannot be prevented by effects that block item effects.)';
        break;
      case 20://Judgement//Horn of Judgement//      ITEM - USE
        this.name = 'Horn of Judgement';
        this.suit = 'Major Arcana';
        this.rank = 'Judgement';
        this.portrait = 20;
        this.type = 1;//null 0-monster, 1-item, 2-spell
        this.subType = 2; //0-none,1-monster effect, 2-use, 3-equip
        this.desc = 'Destroy all monsters, items, and spells on the field. (Cannot be prevented by effects that block item effects. No runes awarded for destroyed monsters.)';
			  break;
      case 21://The World/The World Serpent//     MONSTER
        this.name = 'Crown';
        this.suit = 'Major Arcana';
        this.rank = 'The World';
        this.portrait = -26;
        this.type = 1;//null 0-monster, 1-item, 2-spell
        this.subType = 3; //0-none,1-monster effect, 2-use, 3-equip
        this.desc = 'While equipped, +3 to all stat rolls.';
        this.hasEffect = 1;
        this.buffApplied = 0; 
        break;
      
      case 22://Ace of Wands                        ITEM - EQUIP
        this.name = 'Wand';
        this.suit = 'Wands';
        this.rank = 'Ace';
        this.portrait = -5;
        this.type = 1;//null 0-monster, 1-item, 2-spell
        this.subType = 3; //0-none,1-monster effect, 2-use, 3-equip
        this.desc = 'While equipped, gain +1 to INT  rolls.';
        this.hasEffect = 1;
        this.buffApplied = 0;
        this.stat[0][2]= 1;//int
        break;
      case 23://Wisp,2                            MONSTER
        this.name = 'Wisp';
        this.suit = 'Wands';
        this.rank = 'Two';
        this.portrait = 23;
        this.type = 0;//null 0-monster, 1-item, 2-spell
        this.desc = 'A mischievous spirit that sometimes guides traveleres.';
        this.stat[0][0]=1;//STR
        this.stat[0][1] = 4;
        this.stat[0][2]= 0;
        this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
        this.stat[1][0]=1;//CON
        this.stat[1][1] = 6;
        this.stat[1][2]= 0;
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
        this.stat[2][0]=1;//INT
        this.stat[2][1] = 6;
        this.stat[2][2]= 0;
        this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
        this.stat[3][0]=1;//AGI
        this.stat[3][1] = 4;
        this.stat[3][2]= 0;
        this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];
        break;
      case 24://Scry,3                                SPELL - DEBUFF
        this.name = 'Scry';
        this.suit = 'Wands';
        this.rank = 'Three';
        this.portrait = -17;
        this.type = 2;//null 0-monster, 1-item, 2-spell
        this.subType = 'buff'
        this.desc = 'Reveal cards from your deck equal to caster INT  roll. You may select a Spell or Item card and add it to your hand. Shuffle the deck afterward.';
        
      break;
      case 25://Elixir 4                            ITEM - USE
        this.name = 'Elixir';
        this.portrait = 25;
        this.type = 1;//null 0-monster, 1-item, 2-spell
        this.subType = 2; //0-none,1-monster effect, 2-use, 3-equip
        this.desc = 'Discard all cards attached to the user. Dispel any item effects and spell effects on the user.';
        this.suit = 'Wands';
        this.rank = 'Four';
      break;
      case 26://Fire,5                                SPELL - DEBUFF
        this.name = 'Fire';
        this.portrait = 26;
        this.type = 2;//null 0-monster, 1-item, 2-spell
        this.subType = 'debuff'
        this.desc = 'If caster INT  roll > target CON  roll, target is slain.';
        this.suit = 'Wands';
        this.rank = 'Five';
      break;
      case 27://Amulet, 6                           ITEM - EQUIP
        this.name = 'Amulet';
        this.portrait = 27;
        this.type = 1;//null 0-monster, 1-item, 2-spell
        this.subType = 3; //0-none,1-monster effect, 2-use, 3-equip
        this.desc = 'While equipped, +1 to INT rolls. Defeating a foe grants an additional +1 to INT rolls (+3 max).';
        this.buffApplied = 0;
        this.stat[0][2]= 1;//INT mod + 1
        this.suit = 'Wands';
        this.rank = 'Six';
			  break;
      case 28://Defense,7                             SPELL - BUFF
        this.name = 'Defense';
        this.portrait = 28;
        this.type = 2;//null 0-monster, 1-item, 2-spell
        this.subType = 'buff'
        this.desc = 'Gain CON equal to INT  roll. Lasts until caster is defeated.';
        this.suit = 'Wands';
        this.rank = 'Seven';
      break;
      case 29://Haste, 8                              SPELL - BUFF
        this.name = 'Haste';
        this.portrait = 29;
        this.type = 2;//null 0-monster, 1-item, 2-spell
        this.subType = 'buff'
        this.desc = 'Gain AGI equal to INT  roll. Lasts until caster is defeated.';
        this.suit = 'Wands';
        this.rank = 'Eight';
      break;
      case 30://Protect Orb, 9                      ITEM - EQUIP
        this.name = 'Protect Orb';
        this.portrait = 30;
        this.type = 1;//null 0-monster, 1-item, 2-spell
        this.subType = 3; //0-none,1-monster effect, 2-use, 3-equip
        this.desc = 'While equipped, you may roll INT  instead of CON  when defending.';
        this.effectTriggered = 0;
        this.buffApplied = 0;
        this.stat[0][2]= 3;//STR mod + 3
        this.suit = 'Wands';
        this.rank = 'Nine';
			  break;
      case 31://Tome 10                             ITEM - EQUIP
        this.name = 'Tome';
        this.portrait = 31;
        this.type = 1;//null 0-monster, 1-item, 2-spell
        this.subType = 3; //0-none,1-monster effect, 2-use, 3-equip
        this.desc = 'While equipped, gain +6 to INT  rolls. Additionaly, suffer -3 to AGI  rolls, and -1 to STR rolls.';
        this.buffApplied = 0;
        this.stat[2][2]= 6;//int
        this.stat[0][2]= -1;//str
        this.stat[3][2]= -3;//agi
        this.suit = 'Wands';
        this.rank = 'Ten';
      break;
      case 32://Apprentice P                      MONSTER
        this.name = 'Apprentice';
        this.suit = 'Wands';
        this.rank = 'Page';
        this.portrait = 32;
        this.type = 0;//null 0-monster, 1-item, 2-spell
        this.desc = 'A curious and eager student of magic.';
        this.stat[0][0]=1;//STR
        this.stat[0][1] = 4;
        this.stat[0][2]= 0;
        this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
        this.stat[1][0]=1;//CON
        this.stat[1][1] = 4;
        this.stat[1][2]= 0;
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
        this.stat[2][0]=1;//INT
        this.stat[2][1] = 8;
        this.stat[2][2]= 0;
        this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
        this.stat[3][0]=1;//AGI
        this.stat[3][1] = 4;
        this.stat[3][2]= 0;
        this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];
        break;    
      case 33://Salamander KN                     MONSTER
        this.name = 'Salamander';
        this.suit = 'Wands';
        this.rank = 'Knight';
        this.portrait = 33;
        this.type = 0;//null 0-monster, 1-item, 2-spell
        this.desc = this.desc = 'A fiery lizard that charges into battle.';
        this.stat[0][0]=1;//STR
        this.stat[0][1] = 6;
        this.stat[0][2]= 0;
        this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
        this.stat[1][0]=1;//CON
        this.stat[1][1] = 4;
        this.stat[1][2]= 0;
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
        this.stat[2][0]=1;//INT
        this.stat[2][1] = 8;
        this.stat[2][2]= 0;
        this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
        this.stat[3][0]=1;//AGI
        this.stat[3][1] = 6;
        this.stat[3][2]= 0;
        this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];
        break;
      case 34://Witch Q                           MONSTER
        this.name = 'Witch Queen';
        this.suit = 'Wands';
        this.rank = 'Queen';
        this.portrait = 34;
        this.type = 0;//null 0-monster, 1-item, 2-spell
        this.desc = 'A charismatic sovereign of flame and shadow.';
        this.stat[0][0]=1;//STR
        this.stat[0][1] = 4;
        this.stat[0][2]= 0;
        this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
        this.stat[1][0]=1;//CON
        this.stat[1][1] = 6;
        this.stat[1][2]= 0;
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
        this.stat[2][0]=1;//INT
        this.stat[2][1] = 10;
        this.stat[2][2]= 0;
        this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
        this.stat[3][0]=1;//AGI
        this.stat[3][1] = 8;
        this.stat[3][2]= 0;
        this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];
        break;
      case 35://Djinn K                           MONSTER
        this.name = 'Djinn';
        this.suit = 'Wands';
        this.rank = 'King';
        this.portrait = 35;
        this.type = 0;//null 0-monster, 1-item, 2-spell
        this.desc = 'A visionary spirit of smokeless fire.';
        this.stat[0][0]=1;//STR
        this.stat[0][1] = 6;
        this.stat[0][2]= 0;
        this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
        this.stat[1][0]=1;//CON
        this.stat[1][1] = 8;
        this.stat[1][2]= 0;
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
        this.stat[2][0]=1;//INT
        this.stat[2][1] = 12;
        this.stat[2][2]= 0;
        this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
        this.stat[3][0]=1;//AGI
        this.stat[3][1] = 10;
        this.stat[3][2]= 0;
        this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];
        break;
      
      case 36://Ace of Cups                         ITEM - EQUIP
        this.name = 'Hourglass';
        this.suit = 'Cups';
        this.rank = 'Ace';
        this.portrait = 36;
        this.type = 1;//null 0-monster, 1-item, 2-spell
        this.subType = 3; //0-none,1-monster effect, 2-use, 3-equip
        this.desc = 'While equipped, +1 AGI rolls.';
        this.hasEffect = 1;
        this.buffApplied = 0;
        this.stat[0][3]= 1;//agi
      break;
      case 37://Siren 2                           MONSTER
        this.name = 'Siren';
        this.suit = 'Cups';
        this.rank = 'Two';
        this.portrait = 37;
        this.type = 0;//null 0-monster, 1-item, 2-spell
        this.desc = 'Her song draws victims to their doom.';
        this.stat[0][0]=1;//STR
        this.stat[0][1] = 4;
        this.stat[0][2]= 0;
        this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
        this.stat[1][0]=1;//CON
        this.stat[1][1] = 4;
        this.stat[1][2]= 0;
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
        this.stat[2][0]=1;//INT
        this.stat[2][1] = 6;
        this.stat[2][2]= 0;
        this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
        this.stat[3][0]=1;//AGI
        this.stat[3][1] = 6;
        this.stat[3][2]= 0;
        this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];
      break;
      case 38://Reward 3                            ITEM - USE
        this.name = 'Quest Reward';
        this.suit = 'Cups';
        this.rank = 'Three';
        this.portrait = 38;
        this.type = 1;//null 0-monster, 1-item, 2-spell
        this.subType = 2; //0-none,1-monster effect, 2-use, 3-equip
        this.desc = 'Draw a random card from your deck. If spell or item, add to hand. If monster, you may discard current monster and put this card into play.';
        this.hasEffect = 1;
        this.questReward = 0;
      break;
      case 39://Dragon Wing 6                              ITEM - USE
        this.name = 'Dragon Wing';
        this.suit = 'Cups';
        this.rank = 'Four';
        this.portrait = 39;
        this.desc = 'Your opponent discards their monster and draws until they get a new one. The opponent must discard any spells or items they draw.';
        this.type = 1;//null 0-monster, 1-item, 2-spell
        this.subType = 2; //0-none,1-monster effect, 2-use, 3-equip
        this.hasEffect = 1;
        this.buffApplied = 0;
        break;
      case 40://Steal 5                               SPELL - DEBUFF
        this.name = 'Steal';
        this.suit = 'Cups';
        this.rank = 'Five';
        this.portrait = 40;
        this.type = 2;//null 0-monster, 1-item, 2-spell
        this.subType = 'debuff'; //0-none,1-monster effect, 2-use, 3-equip
        this.desc = 'If caster AGI roll > Target AGI roll, target discards cards from the top of their deck equal to caster AGI roll - target AGI roll. ';
        this.hasEffect = 1;
        this.buffApplied = 0;
      break;
      case 41://Loot 6                              ITEM - USE
        this.name = 'Loot';
        this.suit = 'Cups';
        this.rank = 'Six';
        this.portrait = 41;
        this.type = 1;//null 0-monster, 1-item, 2-spell
        this.subType = 2; //0-none,1-monster effect, 2-use, 3-equip
        this.desc = 'Draw a card from the bottom of your deck. If spell or item, add to hand. If monster, discard it.';
        this.hasEffect = 1;
        this.buffApplied = 0;
        this.questReward = 0;
      break;
      case 42://Shade 7                           MONSTER
        this.name = 'Shade';
        this.suit = 'Cups';
        this.rank = 'Seven';
        this.portrait = 42;
        this.type = 0;//null 0-monster, 1-item, 2-spell
        this.desc = 'A phantom lost in the fog of dreams.';
        this.stat[0][0]=1;//STR
        this.stat[0][1] = 4;
        this.stat[0][2]= 0;
        this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
        this.stat[1][0]=1;//CON
        this.stat[1][1] = 6;
        this.stat[1][2]= 0;
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
        this.stat[2][0]=1;//INT
        this.stat[2][1] = 6;
        this.stat[2][2]= 0;
        this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
        this.stat[3][0]=1;//AGI
        this.stat[3][1] = 6;
        this.stat[3][2]= 0;
        this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];
        break;
      case 43://Teleportation Crystal 8             ITEM - USE
        this.name = 'Teleportation Crystal';
        this.suit = 'Cups';
        this.rank = 'Eight';
        this.portrait = 43;
        this.desc = 'Discard the current monster and draw until you get a new one.';
        this.type = 1;//null 0-monster, 1-item, 2-spell
        this.subType = 2; //0-none,1-monster effect, 2-use, 3-equip
        this.hasEffect = 1;
        this.buffApplied = 0;
        break;
      case 44://9 Djinn Lamp                        ITEM - USE
        this.name = 'Djinn Lamp';
        this.suit = 'Cups';
        this.rank = 'Nine';
        this.portrait = 44;
        this.desc = 'Look through your Deck and select any card. If spell or item, add it to your hand. If monster, you may discard your current monster and put this one in play.';
        this.type = 1;//null 0-monster, 1-item, 2-spell
        this.subType = 2; //0-none,1-monster effect, 2-use, 3-equip
        this.hasEffect = 1;
        this.buffApplied = 0;
        break;
      case 45://10 Lucky Charm                      ITEM - EQUIP
        this.name = 'Lucky Charm';
        this.portrait = 45;
        this.desc = 'While equipped, all ties sway in your favor. (If the opponent has a Lucky Charm equipped then this effect is negated.)';
        this.type = 1;//null 0-monster, 1-item, 2-spell
        this.subType = 3; //0-none,1-monster effect, 2-use, 3-equip
        this.hasEffect = 1;
       this.suit = 'Cups';
        this.rank = 'Ten';
        break;
      case 46://Sea Serpent P                      MONSTER
        this.name = 'Sea Serpent';
        this.suit = 'Cups';
        this.rank = 'Page';
        this.portrait = 46;
        this.type = 0;//null 0-monster, 1-item, 2-spell
        this.desc = 'A curious beast rising from the depths.';       
         this.stat[0][0]=1;//STR
        this.stat[0][1] = 4;
        this.stat[0][2]= 0;
        this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
        this.stat[1][0]=1;//CON
        this.stat[1][1] = 4;
        this.stat[1][2]= 0;
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
        this.stat[2][0]=1;//INT
        this.stat[2][1] = 4;
        this.stat[2][2]= 0;
        this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
        this.stat[3][0]=1;//AGI
        this.stat[3][1] = 8;
        this.stat[3][2]= 0;
        this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];
        break;
      case 47://Undine Knight KN                   MONSTER
        this.name = 'Undine';
        this.suit = 'Cups';
        this.rank = 'Knight';
        this.portrait = 47;
        this.type = 0;//null 0-monster, 1-item, 2-spell
        this.desc = 'A gallant spirit of the waves.';        
        this.stat[0][0]=1;//STR
        this.stat[0][1] = 6;
        this.stat[0][2]= 0;
        this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
        this.stat[1][0]=1;//CON
        this.stat[1][1] = 6;
        this.stat[1][2]= 0;
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
        this.stat[2][0]=1;//INT
        this.stat[2][1] = 4;
        this.stat[2][2]= 0;
        this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
        this.stat[3][0]=1;//AGI
        this.stat[3][1] = 8;
        this.stat[3][2]= 0;
        this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];
        break;
      case 48://Ice Queen Q                        MONSTER
        this.name = 'Ice Queen';
        this.suit = 'Cups';
        this.rank = 'Queen';
        this.portrait = 48;
        this.type = 0;//null 0-monster, 1-item, 2-spell
        this.desc = 'She rules a kingdom of frozen tears.';
        this.stat[0][0]=1;//STR
        this.stat[0][1] = 4;
        this.stat[0][2]= 0;
        this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
        this.stat[1][0]=1;//CON
        this.stat[1][1] = 6;
        this.stat[1][2]= 0;
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
        this.stat[2][0]=1;//INT
        this.stat[2][1] = 8;
        this.stat[2][2]= 0;
        this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
        this.stat[3][0]=1;//AGI
        this.stat[3][1] = 10;
        this.stat[3][2]= 0;
        this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];
        break;
      case 49://Kraken K                           MONSTER
        this.name = 'Kraken';
        this.suit = 'Cups';
        this.rank = 'King';
        this.portrait = 49;
        this.type = 0;//null 0-monster, 1-item, 2-spell
        this.desc = 'The ancient ruler of the deep.';        
        this.stat[0][0]=1;//STR
        this.stat[0][1] = 10;
        this.stat[0][2]= 0;
        this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
        this.stat[1][0]=1;//CON
        this.stat[1][1] = 8;
        this.stat[1][2]= 0;
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
        this.stat[2][0]=1;//INT
        this.stat[2][1] = 6;
        this.stat[2][2]= 0;
        this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
        this.stat[3][0]=1;//AGI
        this.stat[3][1] = 12;
        this.stat[3][2]= 0;
        this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];
        break;
      
      case 50: //Ace of Swords                      ITEM - EQUIP
        this.name = 'Sword';
        this.suit = 'Swords';
        this.rank = 'Ace';
        this.portrait = 50;
        this.type = 1;//null 0-monster, 1-item, 2-spell
        this.subType = 3; //0-none,1-monster effect, 2-use, 3-equip
        this.desc = 'While equipped, +1 STR rolls.';
        this.hasEffect = 1;
        this.buffApplied = 0;
        this.stat[0][0]= 1;//str
      break;
      case 51://Overpower 2                            SPELL - DEBUFF
        this.name = 'Overpower';
        this.suit = 'Swords';
        this.rank = 'Two';
        this.portrait = 51;
        this.type = 2;//null 0-monster, 1-item, 2-spell
        this.subType = 'debuff'; //0-none,1-monster effect, 2-use, 3-equip
        this.desc = 'If caster STR roll > target STR roll, foe is vanquished.';
        this.hasEffect = 1;
        this.buffApplied = 0;
      break;
      case 52://Backstab 3                             SPELL - DEBUFF
        this.name = 'Backstab';
        this.portrait = 52;
        this.type = 2;//null 0-monster, 1-item, 2-spell
        this.subType = 'debuff'; //0-none,1-monster effect, 2-use, 3-equip
        this.desc = 'If caster AGI roll > Target AGI roll, target is vanquished. ';
        this.hasEffect = 1;
        this.buffApplied = 0;
        this.suit = 'Swords';
        this.rank = 'Three';
      break;
      case 53://Camp 4                              ITEM - USE
        this.name = 'Camp';
        this.portrait = 53;
        this.desc = 'Draw a card from the top of your deck. If you draw an item or spell put it into your hand. If you draw a monster, discard it.';
        this.type = 1;//null 0-monster, 1-item, 2-spell
        this.subType = 2; //0-none,1-monster effect, 2-use, 3-equip
        this.hasEffect = 1;
        this.buffApplied = 0;
        this.suit = 'Swords';
        this.rank = 'Four';
        break;
      case 54://Goblin 5                           MONSTER
        this.name = 'Goblin';
        this.suit = 'Swords';
        this.rank = 'Five';
        this.portrait = 54;
        this.type = 0;//null 0-monster, 1-item, 2-spell
        this.desc = 'A cruel foe filled with spite.';
        this.stat[0][0]=1;//STR
        this.stat[0][1] = 6;
        this.stat[0][2]= 0;
        this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
        this.stat[1][0]=1;//CON
        this.stat[1][1] = 6;
        this.stat[1][2]= 0;
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
        this.stat[2][0]=1;//INT
        this.stat[2][1] = 4;
        this.stat[2][2]= 0;
        this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
        this.stat[3][0]=1;//AGI
        this.stat[3][1] = 4;
        this.stat[3][2]= 0;
        this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];
        break;
      case 55://Sailboat 6                           ITEM - USE
        this.name = 'Sailboat'
        this.suit = 'Swords';
        this.rank = 'Six';
        this.portrait = 55;
        this.type = 1;//null 0-monster, 1-item, 2-spell
        this.subType = 2; //0-none,1-monster effect, 2-use, 3-equip
        this.desc = 'Discard your hand and draw until you get a monster. You may replace your current monster with the new monster.';
        this.hasEffect = 1;
        this.buffApplied = 0;
        this.questReward = 0;
      break;
      case 56://Imp 7                              MONSTER
        this.name = 'Imp';
        this.suit = 'Swords';
        this.rank = 'Seven';
        this.portrait = 56;
        this.type = 0;//null 0-monster, 1-item, 2-spell
        this.desc = 'A sneaky foe who wins by trickery.';
        this.stat[0][0]=1;//STR
        this.stat[0][1] = 6;
        this.stat[0][2]= 0;
        this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
        this.stat[1][0]=1;//CON
        this.stat[1][1] = 4;
        this.stat[1][2]= 0;
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
        this.stat[2][0]=1;//INT
        this.stat[2][1] = 6;
        this.stat[2][2]= 0;
        this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
        this.stat[3][0]=1;//AGI
        this.stat[3][1] = 4;
        this.stat[3][2]= 0;
        this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];
        break;
      case 57://Spider  8                          MONSTER
        this.name = 'Spider';
        this.suit = 'Swords';
        this.rank = 'Eight';
        this.portrait = 57;
        this.type = 0;//null 0-monster, 1-item, 2-spell
        this.desc = 'It binds its prey in sticky webs.';
        this.stat[0][0]=1;//STR
        this.stat[0][1] = 6;
        this.stat[0][2]= 0;
        this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
        this.stat[1][0]=1;//CON
        this.stat[1][1] = 4;
        this.stat[1][2]= 0;
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
        this.stat[2][0]=1;//INT
        this.stat[2][1] = 4;
        this.stat[2][2]= 0;
        this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
        this.stat[3][0]=1;//AGI
        this.stat[3][1] = 6;
        this.stat[3][2]= 0;
        this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];
        break;
      case 58://Intimidate 9                           SPELL - DEBUFF
        this.name = 'Intimidate';
        this.suit = 'Swords';
        this.rank = 'Nine';
        this.portrait = 58;
        this.type = 2;//null 0-monster, 1-item, 2-spell
        this.subType = 'debuff'; //0-none,1-monster effect, 2-use, 3-equip
        this.desc = 'If caster STR roll > target INT roll, foe cannot attack or cast spells for turns equal to caster STR roll - target INT roll.';
        this.hasEffect = 1;
        this.buffApplied = 0;
      break;
      case 59://Critical Strike 10                      SPELL - DEBUFF
        this.name = 'Critical Strike';
        this.suit = 'Swords';
        this.rank = 'Ten';
        this.portrait = 59;
        this.type = 2;//null 0-monster, 1-item, 2-spell
        this.subType = 'debuff'; //0-none,1-monster effect, 2-use, 3-equip
        this.desc = 'If caster STR roll > target AGI roll, foe is vanquished.';
        this.hasEffect = 1;
        this.buffApplied = 0;
      break;
      case 60://Pixie P                           MONSTER
        this.name = 'Pixie';
        this.suit = 'Swords';
        this.rank = 'Page';
        this.portrait = 60;
        this.type = 0;//null 0-monster, 1-item, 2-spell
        this.desc = 'Flighty, sharp witted, and restless.';
        this.stat[0][0]=1;//STR
        this.stat[0][1] = 8;
        this.stat[0][2]= 0;
        this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
        this.stat[1][0]=1;//CON
        this.stat[1][1] = 4;
        this.stat[1][2]= 0;
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
        this.stat[2][0]=1;//INT
        this.stat[2][1] = 4;
        this.stat[2][2]= 0;
        this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
        this.stat[3][0]=1;//AGI
        this.stat[3][1] = 4;
        this.stat[3][2]= 0;
        this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];
        break;
      case 61://Sylph KN                           MONSTER
        this.name = 'Sylph';
        this.suit = 'Swords';
        this.rank = 'Knight';
        this.portrait = 61;
        this.type = 0;//null 0-monster, 1-item, 2-spell
        this.desc = 'A wind spirit that strikes like lightning.';
        this.stat[0][0]=1;//STR
        this.stat[0][1] = 8;
        this.stat[0][2]= 0;
        this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
        this.stat[1][0]=1;//CON
        this.stat[1][1] = 6;
        this.stat[1][2]= 0;
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
        this.stat[2][0]=1;//INT
        this.stat[2][1] = 4;
        this.stat[2][2]= 0;
        this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
        this.stat[3][0]=1;//AGI
        this.stat[3][1] = 6;
        this.stat[3][2]= 0;
        this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];
        break;
      case 62://Fairy Queen Q                           MONSTER
        this.name = 'Fairy Queen';
        this.suit = 'Swords';
        this.rank = 'Queen';
        this.portrait = 62;
        this.type = 0;//null 0-monster, 1-item, 2-spell
        this.desc = 'A regal fey with a sharp mind.';
        this.stat[0][0]=1;//STR
        this.stat[0][1] = 10;
        this.stat[0][2]= 0;
        this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
        this.stat[1][0]=1;//CON
        this.stat[1][1] = 6;
        this.stat[1][2]= 0;
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
        this.stat[2][0]=1;//INT
        this.stat[2][1] = 4;
        this.stat[2][2]= 0;
        this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
        this.stat[3][0]=1;//AGI
        this.stat[3][1] = 8;
        this.stat[3][2]= 0;
        this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];
        break;
      case 63://Dragon K                          MONSTER
        this.name = 'Dragon';
        this.suit = 'Swords';
        this.rank = 'King';
        this.portrait = 63;
        this.type = 0;//null 0-monster, 1-item, 2-spell
        this.desc = 'Claw, fang and fire guards its treasure.';
        this.stat[0][0]=1;//STR
        this.stat[0][1] = 12;
        this.stat[0][2]= 0;
        this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
        this.stat[1][0]=1;//CON
        this.stat[1][1] = 10;
        this.stat[1][2]= 0;
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
        this.stat[2][0]=1;//INT
        this.stat[2][1] = 6;
        this.stat[2][2]= 0;
        this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
        this.stat[3][0]=1;//AGI
        this.stat[3][1] = 8;
        this.stat[3][2]= 0;
        this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];
        break;
      
      case 64: //Ace of Pentacles                   ITEM - EQUIP
        this.name = 'Shield';
        this.suit = 'Pentacles';
        this.rank = 'Ace';
        this.portrait = 64;
        this.type = 1;//null 0-monster, 1-item, 2-spell
        this.subType = 3; //0-none,1-monster effect, 2-use, 3-equip
        this.desc = 'While equipped, +1 CON rolls.';
        this.hasEffect = 1;
        this.buffApplied = 0;
        this.stat[0][1]= 1;//con
        break;
			case 65://Shield Bash 2                             SPELL - DEBUFF
        this.name = 'Shield Bash';
        this.suit = 'Pentacles';
        this.rank = 'Two';
        this.portrait = 65;
        this.type = 2;//null 0-monster, 1-item, 2-spell
        this.subType = 'debuff'; //0-none,1-monster effect, 2-use, 3-equip
        this.desc = 'If caster CON roll > target STR roll, foe is vanquished.';
        this.hasEffect = 1;
        this.buffApplied = 0;
      break;
      case 66: //Armor 3                         ITEM - EQUIP
        this.name = 'Armor';
        this.suit = 'Pentacles';
        this.rank = 'Three';
        this.portrait = 66;
        this.type = 1;//null 0-monster, 1-item, 2-spell
        this.subType = 3; //0-none,1-monster effect, 2-use, 3-equip
        this.desc = 'While equipped, +3 CON rolls.';
        this.hasEffect = 1;
        this.buffApplied = 0;
        this.stat[0][1]= 3;//con
			break;
      case 67://Dragon Hoard 4                       ITEM - USE
        this.name = 'Dragon Hoard';
        this.suit = 'Pentacles';
        this.rank = 'Four';
        this.portrait = 67;
        this.desc = 'Player draws from their deck until they get a monster. Add items and spells to your hand and discard the monster. Opponent must discard the same amount from their deck that player drew.';
        this.type = 1;//null 0-monster, 1-item, 2-spell
        this.subType = 2; //0-none,1-monster effect, 2-use, 3-equip
        this.hasEffect = 1;
        this.buffApplied = 0;
        break;
      case 68://Bad Luck Charm 5                        ITEM - USE
        this.name = 'Bad Luck Charm';
        this.suit = 'Pentacles';
        this.rank = 'Five';
        this.portrait = 68;
        this.desc = 'Remove all equipped cards and item and spell effects from the opposing monster. The foe suffers -1 to all stat rolls';
        this.type = 1;//null 0-monster, 1-item, 2-spell
        this.subType = 2; //0-none,1-monster effect, 2-use, 3-equip
        this.hasEffect = 1;
        this.buffApplied = 0;
        break;
      case 69://Charity 6                        ITEM - USE
        this.name = 'Charity';
        this.suit = 'Pentacles';
        this.rank = 'Six';
        this.portrait = 69;
        this.desc = 'The opponent draws a card from the top of their deck. If they draw an item or spell, they may add it to their hand, if they draw a monster, discard it.';
        this.type = 1;//null 0-monster, 1-item, 2-spell
        this.subType = 2; //0-none,1-monster effect, 2-use, 3-equip
        this.hasEffect = 1;
        this.buffApplied = 0;
        break;
      case 70://Cultivate 7                           SPELL - BUFF
        this.name = 'Cultivate';
        this.suit = 'Pentacles';
        this.rank = 'Seven';
        this.portrait = 70;
        this.type = 2;//null 0-monster, 1-item, 2-spell
        this.subType = 'buff'
        this.desc = 'Gain stat points equal to CON roll and distribute them.';
        
      break;
      case 71://Forge 8                               SPELL - DEBUFF
        this.name = 'Forge';
        this.suit = 'Pentacles';
        this.rank = 'Eight';
        this.portrait = 71;
        this.type = 2;//null 0-monster, 1-item, 2-spell
        this.subType = 'buff'
        this.desc = 'Reveal cards from your deck equal to caster CON  roll. You may select a Spell or Item card and add it to your hand. Shuffle the deck afterward.';
        
      break;
      case 72://Magic Ring 9                       ITEM - EQUIP
        this.name = 'Magic Ring';
        this.suit = 'Pentacles';
        this.rank = 'Nine';
        this.portrait = 72;
        this.type = 1;//null 0-monster, 1-item, 2-spell
        this.subType = 3; //0-none,1-monster effect, 2-use, 3-equip
        this.desc = 'While equipped, +1 to all stat rolls.';
        this.hasEffect = 1;
        this.buffApplied = 0;
        
			break;
      case 73://Inheritance 10                      ITEM - USE
        this.name = 'Inheritance';
        this.suit = 'Pentacles';
        this.rank = 'Ten';
        this.portrait = 73;
        this.desc = 'Discard your active monster. Draw from your deck until you get a monster and put it in play. The active monster gains + 2 to all stat rolls. Add any drawn items and spells to your hand. ';
        this.type = 1;//null 0-monster, 1-item, 2-spell
        this.subType = 2; //0-none,1-monster effect, 2-use, 3-equip
        this.hasEffect = 1;
        this.buffApplied = 0;
        break;
      case 74://Gargoyle P                           MONSTER
        this.name = 'Gargoyle';
        this.suit = 'Pentacles';
        this.rank = 'Page';
        this.portrait = 74;
        this.type = 0;//null 0-monster, 1-item, 2-spell
        this.desc = 'A stone sentinel guarding treasure.';
        this.stat[0][0]=1;//STR
        this.stat[0][1] = 4;
        this.stat[0][2]= 0;
        this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
        this.stat[1][0]=1;//CON
        this.stat[1][1] = 8;
        this.stat[1][2]= 0;
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
        this.stat[2][0]=1;//INT
        this.stat[2][1] = 4;
        this.stat[2][2]= 0;
        this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
        this.stat[3][0]=1;//AGI
        this.stat[3][1] = 4;
        this.stat[3][2]= 0;
        this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];
        break;
      case 75://Gnome KN                           MONSTER
        this.name = 'Gnome';
        this.suit = 'Pentacles';
        this.rank = 'Knight';
        this.portrait = 75;
        this.type = 0;//null 0-monster, 1-item, 2-spell
        this.desc = 'A diligent spirit of the soil.';
        this.stat[0][0]=1;//STR
        this.stat[0][1] = 6;
        this.stat[0][2]= 0;
        this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
        this.stat[1][0]=1;//CON
        this.stat[1][1] = 8;
        this.stat[1][2]= 0;
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
        this.stat[2][0]=1;//INT
        this.stat[2][1] = 6;
        this.stat[2][2]= 0;
        this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
        this.stat[3][0]=1;//AGI
        this.stat[3][1] = 4;
        this.stat[3][2]= 0;
        this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];
        break;
      case 76://Elf Queen                           MONSTER
        this.name = 'Elf Queen';
        this.suit = 'Pentacles';
        this.rank = 'Queen';
        this.portrait = 76;
        this.type = 0;//null 0-monster, 1-item, 2-spell
        this.desc = 'The matron of the woods ensuring prosperity.';       
         this.stat[0][0]=1;//STR
        this.stat[0][1] = 6;
        this.stat[0][2]= 0;
        this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
        this.stat[1][0]=1;//CON
        this.stat[1][1] = 10;
        this.stat[1][2]= 0;
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
        this.stat[2][0]=1;//INT
        this.stat[2][1] = 8;
        this.stat[2][2]= 0;
        this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
        this.stat[3][0]=1;//AGI
        this.stat[3][1] = 4;
        this.stat[3][2]= 0;
        this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];
        break;
      case 77://Giant                          MONSTER
        this.name = 'Giant';
        this.suit = 'Pentacles';
        this.rank = 'King';
        this.portrait = 77;
        this.type = 0;//null 0-monster, 1-item, 2-spell
        this.desc = 'A titan that towers over mountains.';
        this.stat[0][0]=1;//STR
        this.stat[0][1] = 10;
        this.stat[0][2]= 0;
        this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
        this.stat[1][0]=1;//CON
        this.stat[1][1] = 12;
        this.stat[1][2]= 0;
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
        this.stat[2][0]=1;//INT
        this.stat[2][1] = 6;
        this.stat[2][2]= 0;
        this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
        this.stat[3][0]=1;//AGI
        this.stat[3][1] = 8;
        this.stat[3][2]= 0;
        this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];
        break;
      //////////////////////////////////
      case 78://Apprentice Red                      MONSTER
        this.name = 'Neophyte';
        this.suit = 'Wands';
        this.rank = 'Page';
        this.portrait = 32.1;
        this.type = 0;//null 0-monster, 1-item, 2-spell
        this.desc = 'A student of the smokeless flame.';
        this.stat[0][0]=1;//STR
        this.stat[0][1] = 4;
        this.stat[0][2]= 0;
        this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
        this.stat[1][0]=1;//CON
        this.stat[1][1] = 4;
        this.stat[1][2]= 0;
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
        this.stat[2][0]=1;//INT
        this.stat[2][1] = 8;
        this.stat[2][2]= 0;
        this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
        this.stat[3][0]=1;//AGI
        this.stat[3][1] = 4;
        this.stat[3][2]= 0;
        this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];
        break;    
      case 79://Fire Imp 7                              MONSTER
        this.name = 'Fire Imp';
        this.suit = 'Swords';
        this.rank = 'Seven';
        this.portrait = 56.1;
        this.type = 0;//null 0-monster, 1-item, 2-spell
        this.desc = 'A sneaky foe who delights in arson.';
        this.stat[0][0]=1;//STR
        this.stat[0][1] = 4;
        this.stat[0][2]= 0;
        this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
        this.stat[1][0]=1;//CON
        this.stat[1][1] = 4;
        this.stat[1][2]= 0;
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
        this.stat[2][0]=1;//INT
        this.stat[2][1] = 8;
        this.stat[2][2]= 0;
        this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
        this.stat[3][0]=1;//AGI
        this.stat[3][1] = 6;
        this.stat[3][2]= 0;
        this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];
        break;
      case 80://Frost Wyrm                            MONSTER
        this.name = 'Wyvern';
        this.suit = 'Cups';
        this.rank = 'Page';
        this.portrait = 56.1;
        this.type = 0;//null 0-monster, 1-item, 2-spell
        this.desc = 'A winged serpent that thinks itself a dragon.';
        this.stat[0][0]=1;//STR
        this.stat[0][1] = 4;
        this.stat[0][2]= 0;
        this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
        this.stat[1][0]=1;//CON
        this.stat[1][1] = 4;
        this.stat[1][2]= 0;
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
        this.stat[2][0]=1;//INT
        this.stat[2][1] = 4;
        this.stat[2][2]= 0;
        this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
        this.stat[3][0]=1;//AGI
        this.stat[3][1] = 8;
        this.stat[3][2]= 0;
        this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];
        break;
      case 81://Ice Golem                           MONSTER
        this.name = 'Ice Golem';
        this.suit = 'Cups';
        this.rank = 'Knight';
        this.portrait = 81;
        this.type = 0;//null 0-monster, 1-item, 2-spell
        this.desc = 'A fragile ice construct void of emotion.';
        this.stat[0][0]=1;//STR
        this.stat[0][1] = 6;
        this.stat[0][2]= 0;
        this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
        this.stat[1][0]=1;//CON
        this.stat[1][1] = 4;
        this.stat[1][2]= 0;
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
        this.stat[2][0]=1;//INT
        this.stat[2][1] = 4;
        this.stat[2][2]= 0;
        this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
        this.stat[3][0]=1;//AGI
        this.stat[3][1] = 8;
        this.stat[3][2]= 0;
        this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];
        break;
      case 82://Skeleton                        MONSTER
        this.name = 'Skeleton';
        this.suit = 'Cups';
        this.rank = 'Six';
        this.portrait = 3.1;
        this.type = 0;//null 0-monster, 1-item, 2-spell
        this.desc = 'Old bones clinging to the past.';
        this.stat[0][0]=1;//STR
        this.stat[0][1] = 4;
        this.stat[0][2]= 0;
        this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
        this.stat[1][0]=1;//CON
        this.stat[1][1] = 4;
        this.stat[1][2]= 0;
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
        this.stat[2][0]=1;//INT
        this.stat[2][1] = 4;
        this.stat[2][2]= 0;
        this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
        this.stat[3][0]=1;//AGI
        this.stat[3][1] = 4;
        this.stat[3][2]= 0;
        this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];
        break;
      case 83://Tentacle                        MONSTER
        this.name = 'Tentacle';
        this.suit = 'Cups';
        this.rank = 'Four';
        this.portrait = 83;
        this.type = 0;//null 0-monster, 1-item, 2-spell
        this.desc = 'A perilous arm that pulls ships into the abyss.';
        this.stat[0][0]=1;//STR
        this.stat[0][1] = 6;
        this.stat[0][2]= 0;
        this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
        this.stat[1][0]=1;//CON
        this.stat[1][1] = 4;
        this.stat[1][2]= 0;
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
        this.stat[2][0]=1;//INT
        this.stat[2][1] = 4;
        this.stat[2][2]= 0;
        this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
        this.stat[3][0]=1;//AGI
        this.stat[3][1] = 6;
        this.stat[3][2]= 0;
        this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];
        break;
      case 84://Ace of Swords                      ITEM - EQUIP
        this.name = 'Excalibur';
        this.suit = 'Swords';
        this.rank = 'Ace';
        this.portrait = -15.2;
        this.type = 1;//null 0-monster, 1-item, 2-spell
        this.subType = 3; //0-none,1-monster effect, 2-use, 3-equip
        this.desc = 'While equipped, +3 to STR  rolls.';
        this.hasEffect = 1;
        this.buffApplied = 0;
        this.stat[0][0]= 1;//str
      break;
      case 85://King Arthur                      ITEM - EQUIP
        this.name = 'Arthur';
        this.suit = 'Major Arcana';
        this.rank = 'The Emperor';
        this.portrait = 4.1;
        this.type = 0;//null 0-monster, 1-item, 2-spell
        this.desc = 'The once and future king.';
        this.stat[0][0]=1;//minSTR
        this.stat[0][1] = 20;//maxSTR
        this.stat[0][2]= 0;//modSTR
        this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
        this.stat[1][0]=1;//minCON
        this.stat[1][1] = 12;//maxCON
        this.stat[1][2]= 0;//modCON
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
        this.stat[2][0]=1;//minINT
        this.stat[2][1] = 8;//maxINT
        this.stat[2][2]= 0;//modINT
        this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
        this.stat[3][0]=1;//minAGI
        this.stat[3][1] = 10;//maxAGI
        this.stat[3][2]= 0;//modAGI
        this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];
       
      break;
      case 86://Corrupt Sylph                      ITEM - EQUIP
        this.name = 'Corrupt Sylph';
        this.suit = 'Swords';
        this.rank = 'Knight';
        this.portrait = 61.2;
        this.type = 0;//null 0-monster, 1-item, 2-spell
        this.desc = 'A reckless gale cutting with haste.';
        this.stat[0][0]=1;//minSTR
        this.stat[0][1] = 8;//maxSTR
        this.stat[0][2]= 0;//modSTR
        this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
        this.stat[1][0]=1;//minCON
        this.stat[1][1] = 6;//maxCON
        this.stat[1][2]= 0;//modCON
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
        this.stat[2][0]=1;//minINT
        this.stat[2][1] = 4;//maxINT
        this.stat[2][2]= 0;//modINT
        this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
        this.stat[3][0]=1;//minAGI
        this.stat[3][1] = 6;//maxAGI
        this.stat[3][2]= 0;//modAGI
        this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];
       
      break;
      
      

      
      default:
        this.name = '';
        this.portrait = 0;
        this.type = 3;//null 0-monster, 1-item, 2-spell
        this.desc = '';
        this.stat[0][0]=1;//STR
        this.stat[0][1] = 0;
        this.stat[0][2]= 0;
        this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
        this.stat[1][0]=1;//CON
        this.stat[1][1] = 0;
        this.stat[1][2]= 0;
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
        this.stat[2][0]=0;//INT
        this.stat[2][1] = 0;
        this.stat[2][2]= 0;
        this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
        this.stat[3][0]=0;//INT
        this.stat[3][1] = 0;
        this.stat[3][2]= 0;
        this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];
			  break;
		
    //////////////////////////////////////
    case 28888://Trick, 7                              SPELL - CAST
        this.name = 'Trick';
        this.portrait = 28888;
        this.type = 2;//null 0-monster, 1-item, 2-spell
        this.desc = 'Caster rolls INT  to attack. Choose which stat the foe must roll to defend.';
        this.subType = 'cast'; 
        this.effectTriggered = 0;
			  break;
       
       
      }//end switch
	}//end constructor
  rollStat (stat){//call x: Player[0].aMonster[0].rollStat(0), stat ex:0-STR, 1 - CON, 2 - INT, 3 - AGI
    let temprunestat = 0;
    if(stat == 0){
      if (sRune.owner == this.foe) {temprunestat = 1;}
    }
    
    if(stat == 1){
      if (cRune.owner == this.foe) {temprunestat = 1;}
    }
    if(stat == 2){
      if (iRune.owner == this.foe) {temprunestat = 1;}
    }
    if(stat == 0){
      if (aRune.owner == this.foe) {temprunestat = 1;}
    }
    let tempstatroll = rnd(this.stat[stat][0]+temprunestat,this.stat[stat][1])+this.stat[stat][2]+temprunestat;
    if (tempstatroll <0) {return 0;}
    else{
      return tempstatroll;
    }
  }
	place(x,y,z,faceDown = false){
        var color = 0;
        this.x = x;
        this.y = y;
        this.l = 2.25;
        this.h = 3.5;
        
        if (this.foe == 0){y = y-.03;}else{y = y -.055;}
        
        // LOGIC CHANGE: Check for deck location OR faceDown flag
        if (this.location == 'deck'|| faceDown){ 
            drawShape('rec',0,0,1,x-.0139,y-.0139,2.26,3.6,0,0,0,0,'rgba(0,0,0,1)',1);
            drawShape('rec',0,0,1,x-.0139,y-.0139,2.26,3.6,0,0,0,0,'rgba(255,255,255,.0369)',0);
        } else {
            // -- RENDER FACE UP CARD --
            ctx.textAlign= 'left';
            switch(this.type){
                case 0: //monster
                    color = 'rgb(255, 214, 0)';
                    drawShape('rec',x,y,z,0-.05,0-.05,this.l+.1,this.h+.1,0,0,0,0,'rgb(48, 48, 48)',1);//border
                    drawShape('rec',x,y,z,0,0,this.l,this.h,0,0,0,0,color,1);//card
                    //STATS
                    if (startGame != 'tarot'){
                      drawShape('rec',x,y,z, .225, .275,      1.8,   .89, 0,0,0,0,'rgba(255,255,255,.5)',1);//stat frame fill
                      //stat portraits
                      drawPortrait(-11,x+(.24*z),                 y+(.29*z),      .042*z);//str
                      drawPortrait(-12,x+(.24*z),                 y+(.285+.45)*z,.042*z);//int
                      drawPortrait(-13,x+(.24*z) + ((1.8/4)*2)*z,y+(.29*z),       .042*z);//con
                      drawPortrait(-14,x+(.24*z) + ((1.8/4)*2)*z,y+(.285+.45)*z,.042*z);//agi
                      let temprunestat = 0;

                      //stat text
                      if (sRune.owner == this.foe) {temprunestat = 1;}
                      if (this.stat[0][2]+temprunestat > 0){drawText((x+.25*z) + ((1.8/4)*1)*z, y+.59*z,1.8/4.3,1.8/4, '+'+   `${this.stat[0][2]+temprunestat}`,'green',z);}//str
                      if (this.stat[0][2]+temprunestat < 0){drawText((x+.25*z) + ((1.8/4)*1)*z, y+.59*z,1.8/4.3,1.8/4, `${this.stat[0][2]+temprunestat}`,'red',z);}//str
                      drawText((x+.24*z) + ((1.8/4)*1)*z, y+.4*z,1.8/4.3,1.8/4,        this.stat[0][3],'black',z);//str
                      temprunestat = 0;
                      if (iRune.owner == this.foe) {temprunestat = 1;}
                      if (this.stat[2][2]+temprunestat > 0){drawText((x+.35*z) + ((1.8/4)*1)*z, y+(.375+.63)*z,1.8/4.3,1.8/4, '+'+   `${this.stat[2][2]+temprunestat}`,'green',z);}//int
                      if (this.stat[2][2]+temprunestat < 0){drawText((x+.35*z) + ((1.8/4)*1)*z, y+(.375+.63)*z,1.8/4.3,1.8/4,  `${this.stat[2][2]+temprunestat}`,'red',z);}//int
                      drawText((x+.24*z) + ((1.8/4)*1)*z,y+(.4+.45)*z,1.8/4.3,1.8/4, this.stat[2][3],'black',z);//int
                      temprunestat = 0;
                      if (cRune.owner == this.foe) {temprunestat = 1;}
                      if (this.stat[1][2]+temprunestat > 0){drawText((x+.35*z) + ((1.8/4)*3)*z, y+.62*z,1.8/4.3,1.8/4, '+'+   `${this.stat[1][2]+temprunestat}`,'green',z);}//con
                      if (this.stat[1][2]+temprunestat < 0){drawText((x+.35*z) + ((1.8/4)*3)*z, y+.62*z,1.8/4.3,1.8/4,  `${this.stat[1][2]+temprunestat}`,'red',z);}//con
                      drawText((x+.24*z) + ((1.8/4)*3)*z,y+.4*z,1.8/4.3,1.8/4,       this.stat[1][3],'black',z);//con
                      temprunestat = 0;
                      if (aRune.owner == this.foe) {temprunestat = 1;}
                      if (this.stat[3][2]+temprunestat > 0){drawText((x+.35*z) + ((1.8/4)*3)*z, y+(.4+.62)*z,1.8/4.3,1.8/4, '+' + `${this.stat[3][2]+temprunestat}`,'green',z);}//agi
                      if (this.stat[3][2]+temprunestat < 0){drawText((x+.35*z) + ((1.8/4)*3)*z, y+(.4+.62)*z,1.8/4.3,1.8/4,  `${this.stat[3][2]+temprunestat}`,'red',z);}//agi
                      drawText((x+.24*z) + ((1.8/4)*3)*z,y+(.4+.45)*z,1.8/4.3,1.8/4,this.stat[3][3],'black',z);//agi
                      //divider lines
                      drawShape('lin',x,y,z, .23, .7235, 2.02, .7235 ,0,0,0,0,'rgba(48,48,48,.5)',0);//half across
                      for (let i =0 ;i<4;i++){
                          drawShape('lin',x,y,z, .225+(1.8/4)*i, .275, .225+(1.8/4)*i, 1.16 ,0,0,0,0,'rgba(48,48,48,.5)',0);
                      }
                    
                      drawShape('rec',x,y,z, .225, .275,      1.8,   .89, 0,0,0,0,'rgba(48,48,48,.5)',0);//stat frame border
                      //DESCRIPTION
                      drawShape('rec',x,y,1*z,.225, 1.2, 1.8, .425, 0,0,0,0,'rgba(255,255,255,.5)',1);//desc box
                      drawShape('rec',x,y,1*z,.225, 1.2, 1.8, .425, 0,0,0,0,'rgba(48,48,48,.5)',0);//desc box border
                      drawText(x+.24*z,y+1.1975*z,1.8,.425,this.desc,'black',z);//desc text
                    }
                    else{
                      drawShape('rec',x,y,z,.225, .3, 1.8, 1.3, 0,0,0,0,'rgba(255,255,255,.4)',1);//desc box
                    drawShape('rec',x,y,z,.225, .3, 1.8, 1.3, 0,0,0,0,'rgba(48,48,48,.5)',0);//desc box
                    drawText(x+.24*z,y+.3*z,1.8,1.3,this.desc,'black',z);
                    }
                    break;
                case 1: //item
                    color = 'rgb(0, 183, 235)';
                    drawShape('rec',x,y,z,0-.05,0-.05,this.l+.1,this.h+.1,0,0,0,0,'black',0);//gray border
                    drawShape('rec',x,y,z,0-.05,0-.05,this.l+.1,this.h+.1,0,0,0,0,'rgb(48, 48, 48)',1);//gray border
                    drawShape('rec',x,y,z,0,0,this.l,this.h,0,0,0,0,color,1);  // card red layer
                    drawShape('rec',x,y,z,.225, .3, 1.8, 1.3, 0,0,0,0,'rgba(255,255,255,.6)',1);//desc box
                    drawShape('rec',x,y,z,.225, .3, 1.8, 1.3, 0,0,0,0,'rgba(48,48,48,.5)',0);//desc box
                    drawText(x+(.3*z),y+(.34*z),1.75,1.25,this.desc,'black',z);//desc text
                    break;
                case 2: //spell
                    color = 'rgb(212, 45, 158)';
                    drawShape('rec',x,y,z,0-.05,0-.05,this.l+.1,this.h+.1,0,0,0,0,'black',0);//gray border
                    drawShape('rec',x,y,z,0-.05,0-.05,this.l+.1,this.h+.1,0,0,0,0,'rgb(48, 48, 48)',1);
                    drawShape('rec',x,y,z,0,0,this.l,this.h,0,0,0,0,color,1);//card
                    drawShape('rec',x,y,z,.225, .3, 1.8, 1.3, 0,0,0,0,'rgba(255,255,255,.4)',1);//desc box
                    drawShape('rec',x,y,z,.225, .3, 1.8, 1.3, 0,0,0,0,'rgba(48,48,48,.5)',0);//desc box
                    drawText(x+.24*z,y+.3*z,1.8,1.3,this.desc,'black',z);
                    break;
                default:
                    color = 'black'
                    break;
            }//end switch

            // --- SUIT AND RANK VISUALS ---
            const majorSuitId = -26; 
            const suitIds = [-12, -14, -11, -13]; // 0:Wands, 1:Cups, 2:Swords, 3:Pentacles
            const faceCardIds = [-15, -16, -24, -25]; // 0:Page, 1:Knight, 2:Queen, 3:King
            const roman = ['0', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X', 
                           'XI', 'XII', 'XIII', 'XIV', 'XV', 'XVI', 'XVII', 'XVIII', 'XIX', 'XX', 'XXI'];

            let iconToDraw = null; 
            let rankImgToDraw = null; 
            let rankTextToDraw = null; 

            // 1. MAJOR ARCANA (0 - 21)
            if (this.index <= 21) {
                iconToDraw = majorSuitId;
                rankTextToDraw = roman[this.index]; 
            } 
            // 2. STANDARD MINOR ARCANA (22 - 77)
            else if (this.index <= 77) {
                let calcIndex = this.index - 22; 
                let suitType = Math.floor(calcIndex / 14); 
                let rankType = calcIndex % 14; 

                if(suitType >= 0 && suitType < suitIds.length) {
                    iconToDraw = suitIds[suitType];
                }

                if (rankType < 10) {
                    rankTextToDraw = roman[rankType + 1]; 
                } else {
                    rankImgToDraw = faceCardIds[rankType - 10]; 
                }
            }
            // 3. EXPANSION CARDS (78+) - MANUAL CHECK
            else {
                // Set Suit Icon
                if (this.suit === 'Wands') iconToDraw = suitIds[0];
                else if (this.suit === 'Cups') iconToDraw = suitIds[1];
                else if (this.suit === 'Swords') iconToDraw = suitIds[2];
                else if (this.suit === 'Pentacles') iconToDraw = suitIds[3];
                else if (this.suit === 'Major Arcana') iconToDraw = majorSuitId;

                // Set Rank Image/Text
                if (this.rank === 'Page') rankImgToDraw = faceCardIds[0];
                else if (this.rank === 'Knight' || this.rank === 'Corrupt Sylph') rankImgToDraw = faceCardIds[1];
                else if (this.rank === 'Queen') rankImgToDraw = faceCardIds[2];
                else if (this.rank === 'King' || this.rank === 'The Emperor') rankImgToDraw = faceCardIds[3];
                // Number logic
                else if (this.rank === 'Ace') rankTextToDraw = 'I';
                else if (this.rank === 'Two') rankTextToDraw = 'II';
                else if (this.rank === 'Three') rankTextToDraw = 'III';
                else if (this.rank === 'Four') rankTextToDraw = 'IV';
                else if (this.rank === 'Five') rankTextToDraw = 'V';
                else if (this.rank === 'Six') rankTextToDraw = 'VI';
                else if (this.rank === 'Seven') rankTextToDraw = 'VII';
                else if (this.rank === 'Eight') rankTextToDraw = 'VIII';
                else if (this.rank === 'Nine') rankTextToDraw = 'IX';
                else if (this.rank === 'Ten') rankTextToDraw = 'X';
            }

            // --- DRAWING EXECUTION ---
            if (iconToDraw !== null) {
                drawPortrait(iconToDraw, x+(this.l-.26)*z, y+(.029*z), .023*z);
            }

            if (rankImgToDraw !== null) {
                drawPortrait(rankImgToDraw, x+(.031*z), y+(.029*z), .023*z);
            } 
            else if (rankTextToDraw !== null) {
                drawText(x+(.029*z), y+(.05*z), this.l*.11, this.h*.0857, rankTextToDraw, 'black', z);
            }

            // NAME
            ctx.textAlign= 'center';
            drawText(x+(this.l*z/1.97),y+(this.h-this.h*.989),this.l*.73,this.h*.0857,this.name,'black',z);
            ctx.textAlign= 'left';
            
            // PORTRAIT
            drawShape('rec',x,y,z,.221,1.66, 1.809, 1.75, 0,0,0,0,'rgba(48,48,48,.5)',1);
            drawShape('rec',x,y,z,.25,1.66, 1.75, 1.75, 0,0,0,0,'black',1);
            drawPortrait(this.portrait,x+.25*z,y+ 1.66*z,(((tL/10)*1.75)/tL)*z);
        }
    }
}//end class
class Dice {
  constructor(type = 'd6') {
    this.targetRx = 0;
    this.targetRy = 0;
    this.targetRz = 0;
    this.type = type;
    this.vertices = [];
    this.faces = [];
    this.faceNormals = [];
    this.rx = 0;
    this.ry = 0;
    this.rz = 0;
    this.rs = 0;
    this.beamDirection = [-1, 0, 0]; // Light from left
    
    // Type-specific properties
    this.colors = this.getColors();
    this.scale = this.getScale();
    
    // Generate geometry based on type
    this.generateGeometry();
  }
  setColor(r, g, b) {
    this.colors = { r, g, b };
}
  getColors() {
    const colors = {
      'd2': { r: 1, g: 0.85, b: 0.3 },
      'd4': { r: 1, g: 0.1, b: 0.2 },
      'd6': { r: 0.1, g: 1, b: 0.3 },
      'd8': { r: 0.8, g: 0.8, b: 1 },
      'd10': { r: 0.8, g: 0.4, b: 0.2 },
      'd12': { r: 1, g: 0.2, b: 0.6 },
      'd20': { r: 0.2, g: 0.4, b: 1 }
    };
    return colors[this.type] || { r: 1, g: 1, b: 1 };
  }
  // Inside class Dice...
setGlow(color) {
    this.glowColor = color;
}
  getScale() {
    const scales = {
      'd2': 1.9,
      'd4': 1.9,
      'd6': 1,
      'd8': 1.9,
      'd10': 2.8,
      'd12': 1,
      'd20': 2.3
    };
    return scales[this.type] || 1;
  }
  
  generateGeometry() {
    switch(this.type) {
      case 'd2':
        this.generateD2();
        break;
      case 'd4':
        this.generateD4();
        break;
      case 'd6':
        this.generateD6();
        break;
      case 'd8':
        this.generateD8();
        break;
      case 'd10':
        this.generateD10();
        break;
      case 'd12':
        this.generateD12();
        break;
      case 'd20':
        this.generateD20();
        break;
      default:
        this.generateD6();
    }
    
    // Compute face normals for all non-d2 types
    if (this.type !== 'd2') {
      this.computeFaceNormals();
    }
  }
  
  generateD2() {
    const slices = 32;
    const radius = 1;
    const thickness = 0.1;
    
    // Edge ring
    for (let i = 0; i < slices; i++) {
      const angle = 2 * Math.PI * i / slices;
      const x = radius * Math.cos(angle);
      const y = radius * Math.sin(angle);
      this.vertices.push([x, y, thickness]);  // front
      this.vertices.push([x, y, -thickness]); // back
    }
    
    // Center points
    this.frontCenter = this.vertices.length;
    this.vertices.push([0, 0, thickness]);
    this.backCenter = this.vertices.length;
    this.vertices.push([0, 0, -thickness]);
    
    // Side quads
    for (let i = 0; i < slices; i++) {
      const i1 = i * 2;
      const i2 = (i * 2 + 2) % (slices * 2);
      const i3 = i2 + 1;
      const i4 = i1 + 1;
      this.faces.push([i1, i2, i3, i4]);
    }
    
    // Front fan
    for (let i = 0; i < slices; i++) {
      const v1 = i * 2;
      const v2 = (i * 2 + 2) % (slices * 2);
      this.faces.push([this.frontCenter, v1, v2]);
    }
    
    // Back fan
    for (let i = 0; i < slices; i++) {
      const v1 = i * 2 + 1;
      const v2 = (i * 2 + 3) % (slices * 2);
      this.faces.push([this.backCenter, v2, v1]);
    }
    
    // Precompute normals for d2
    this.faceNormals = this.faces.map(face => {
      const [p0, p1, p2] = face.map(i => this.vertices[i]);
      const ux = p1[0]-p0[0], uy = p1[1]-p0[1], uz = p1[2]-p0[2];
      const vx = p2[0]-p0[0], vy = p2[1]-p0[1], vz = p2[2]-p0[2];
      const nx = uy*vz - uz*vy;
      const ny = uz*vx - ux*vz;
      const nz = ux*vy - uy*vx;
      const len = Math.hypot(nx,ny,nz);
      return [nx/len, ny/len, nz/len];
    });
  }
  
  generateD4() {
    // Tetrahedron vertices
    this.vertices = [
      [1, 1, 1],
      [-1, -1, 1],
      [-1, 1, -1],
      [1, -1, -1]
    ];
    
    // Normalize vertices
    for (let i = 0; i < this.vertices.length; i++) {
      const [x, y, z] = this.vertices[i];
      const length = Math.hypot(x, y, z);
      this.vertices[i] = [x/length, y/length, z/length];
    }
    
    // Faces
    this.faces = [
      [0, 1, 2],
      [0, 3, 1],
      [0, 2, 3],
      [1, 3, 2]
    ];
  }
  
  generateD6() {
    // Cube vertices
    this.vertices = [
      [-1, -1, -1],
      [-1, -1, 1],
      [-1, 1, -1],
      [-1, 1, 1],
      [1, -1, -1],
      [1, -1, 1],
      [1, 1, -1],
      [1, 1, 1]
    ];
    
    // Faces (quads)
    this.faces = [
      [0, 1, 3, 2], // Left
      [4, 6, 7, 5], // Right
      [0, 4, 5, 1], // Bottom
      [2, 3, 7, 6], // Top
      [0, 2, 6, 4], // Back
      [1, 5, 7, 3]  // Front
    ];
  }
  
  generateD8() {
    // Octahedron vertices
    this.vertices = [
      [ 1,  0,  0], // Right
      [-1,  0,  0], // Left
      [ 0,  1,  0], // Top
      [ 0, -1,  0], // Bottom
      [ 0,  0,  1], // Front
      [ 0,  0, -1]  // Back
    ];
    
    // Faces
    this.faces = [
      [0, 2, 4],
      [2, 1, 4],
      [1, 3, 4],
      [3, 0, 4],
      [2, 0, 5],
      [1, 2, 5],
      [3, 1, 5],
      [0, 3, 5]
    ];
  }
  
  generateD10() {
    const shrink = 0.7;
    const flatZ = 0.515;
    const tiltAmount = 0.75;
    const tiltAmount2 = -0.75;
    
    // Top ring (tilting inward)
    for (let i = 0; i < 5; i++) {
      const angle = (i / 5) * Math.PI * 2;
      const x = Math.cos(angle) * shrink;
      const y = Math.sin(angle) * shrink;
      const z = flatZ - Math.hypot(x, y) * tiltAmount;
      this.vertices.push([x, y, z]);
    }
    
    // Bottom ring (tilting outward)
    for (let i = 0; i < 5; i++) {
      const angle = (i / 5) * Math.PI * 2;
      const x = Math.cos(angle) * shrink;
      const y = Math.sin(angle) * shrink;
      const z = -flatZ - Math.hypot(x, y) * tiltAmount2;
      this.vertices.push([x, y, z]);
    }
    
    // Poles
    this.vertices.push([0, 0, 0.65]);
    this.vertices.push([0, 0, -0.65]);
    
    // Faces
    // Top faces
    for (let i = 0; i < 5; i++) {
      this.faces.push([10, i, (i+1)%5]);
    }
    
    // Bottom faces
    for (let i = 0; i < 5; i++) {
      this.faces.push([11, (i+5), (i+6)%5 + 5]);
    }
  }
  
  generateD12() {
    const phi = (1 + Math.sqrt(5)) / 2;
    
    // Dodecahedron vertices
    this.vertices = [
      [1,1,1], [1,1,-1], [1,-1,1], [1,-1,-1],
      [-1,1,1], [-1,1,-1], [-1,-1,1], [-1,-1,-1],
      [0,1/phi,phi], [0,1/phi,-phi], [0,-1/phi,phi], [0,-1/phi,-phi],
      [1/phi,phi,0], [1/phi,-phi,0], [-1/phi,phi,0], [-1/phi,-phi,0],
      [phi,0,1/phi], [phi,0,-1/phi], [-phi,0,1/phi], [-phi,0,-1/phi]
    ];
    
    // Build edges
    const edges = [];
    const threshold = 0.05;
    const idealDistance = Math.hypot(
      this.vertices[0][0]-this.vertices[8][0],
      this.vertices[0][1]-this.vertices[8][1],
      this.vertices[0][2]-this.vertices[8][2]
    );
    
    for (let i = 0; i < this.vertices.length; i++) {
      for (let j = i+1; j < this.vertices.length; j++) {
        const [x1,y1,z1] = this.vertices[i];
        const [x2,y2,z2] = this.vertices[j];
        const d = Math.hypot(x2-x1, y2-y1, z2-z1);
        if (Math.abs(d - idealDistance) < threshold) {
          edges.push([i,j]);
        }
      }
    }
    
    // Build neighbor map
    const neighbors = {};
    for (let [a,b] of edges) {
      if (!neighbors[a]) neighbors[a] = [];
      if (!neighbors[b]) neighbors[b] = [];
      neighbors[a].push(b);
      neighbors[b].push(a);
    }
    
    // Find pentagonal faces
    this.faces = [];
    const seen = new Set();
    
    const walk = (path) => {
      const current = path[path.length-1];
      if (path.length === 6) {
        if (path[0] === path[5]) {
          const face = path.slice(0,5);
          const key = face.slice().sort((a,b) => a-b).join('-');
          if (!seen.has(key)) {
            this.faces.push(face);
            seen.add(key);
          }
        }
        return;
      }
      for (let neighbor of neighbors[current]) {
        if (path.length > 1 && neighbor === path[path.length-2]) continue;
        if (path.includes(neighbor) && !(path.length===5 && neighbor===path[0])) continue;
        walk([...path, neighbor]);
      }
    };
    
    for (let v = 0; v < this.vertices.length; v++) {
      walk([v]);
    }
  }
  
  generateD20() {
    // Icosahedron vertices
    const t = (1 + Math.sqrt(5)) / 2;
    this.vertices = [
      [-1, t, 0], [1, t, 0], [-1, -t, 0], [1, -t, 0],
      [0, -1, t], [0, 1, t], [0, -1, -t], [0, 1, -t],
      [t, 0, -1], [t, 0, 1], [-t, 0, -1], [-t, 0, 1]
    ];
    
    // Normalize vertices
    for (let i = 0; i < this.vertices.length; i++) {
      const [x, y, z] = this.vertices[i];
      const length = Math.hypot(x, y, z);
      this.vertices[i] = [x/length, y/length, z/length];
    }
    
    // Faces
    this.faces = [
      [0, 11, 5], [0, 5, 1], [0, 1, 7], [0, 7, 10], [0, 10, 11],
      [1, 5, 9], [5, 11, 4], [11, 10, 2], [10, 7, 6], [7, 1, 8],
      [3, 9, 4], [3, 4, 2], [3, 2, 6], [3, 6, 8], [3, 8, 9],
      [4, 9, 5], [2, 4, 11], [6, 2, 10], [8, 6, 7], [9, 8, 1]
    ];
  }
  
  computeFaceNormals() {
    this.faceNormals = this.faces.map(face => {
      const [p0, p1, p2] = face.map(i => this.vertices[i]);
      const ux = p1[0]-p0[0], uy = p1[1]-p0[1], uz = p1[2]-p0[2];
      const vx = p2[0]-p0[0], vy = p2[1]-p0[1], vz = p2[2]-p0[2];
      const nx = uy*vz - uz*vy;
      const ny = uz*vx - ux*vz;
      const nz = ux*vy - uy*vx;
      const len = Math.hypot(nx,ny,nz);
      return [nx/len, ny/len, nz/len];
    });
  }
  
  rotateVertex([x, y, z], rx, ry, rz) {
    let cosa = Math.cos(rx), sina = Math.sin(rx);
    let y1 = y * cosa - z * sina, z1 = y * sina + z * cosa;
    let cosb = Math.cos(ry), sinb = Math.sin(ry);
    let x2 = x * cosb + z1 * sinb, z2 = -x * sinb + z1 * cosb;
    let cosc = Math.cos(rz), sinc = Math.sin(rz);
    let x3 = x2 * cosc - y1 * sinc, y3 = x2 * sinc + y1 * cosc;
    return [x3, y3, z2];
  }
  
  project([x, y, z], size, cx, cy, d) {
    const scale = size / (z + d);
    return [cx + x * scale, cy + y * scale, z];
  }
  
  stepRotation(dt) {
    // Safety check: if dt is missing, assume 60fps (0.016)
    if (!dt) dt = 0.016;
    
    // We multiply by 60 to match your original speed settings (like '99')
    // 0.02 * 60 = 1.2 multiplier
    const speed = 1.2 * this.rs * dt;

    if (this.type === 'd2' && this.rs === 'stop') {
      this.rx = 0;
      this.ry = 0;
      this.rz = 0;
    } else {
      this.rx += speed;
      this.ry += (speed * 0.75); // Maintains your original ratio
      this.rz += (this.type === 'd2' ? 0 : (speed * 0.5)); 
    }
  }
  
  draw(ctx, cx, cy, size, d, light) {
    if (!light) light = this.beamDirection;
    
    const verts3d = this.vertices.map(v => this.rotateVertex(v, this.rx, this.ry, this.rz));
    const verts2d = verts3d.map(v => this.project(v, size, cx, cy, d));
    
    const faceDepths = this.faces.map((face, idx) => {
      const depth = face.reduce((sum, i) => sum + verts3d[i][2], 0) / face.length;
      return { face, depth, idx };
    }).sort((a, b) => b.depth - a.depth);
    
    ctx.save();
    ctx.lineWidth = 1;
    // --- NEW GLOW LOGIC START ---
    if (this.glowColor) {
        // 1. Set the Glow Color
        ctx.shadowColor = this.glowColor;
        
        // 2. Scale the Blur based on size (so it doesn't look huge when far away)
        ctx.shadowBlur = size * 0.6; 

        // 3. (Optional) "Lighter" mode makes overlapping faces blindingly bright (FIRE EFFECT)
        // If you want a solid neon object instead of fire, remove this line.
        ctx.globalCompositeOperation = 'lighter';
    }
    for (let { face, idx } of faceDepths) {
      const pts2d = face.map(i => verts2d[i]);
      const normal = this.faceNormals[idx];
      const rotatedNormal = this.rotateVertex(normal, this.rx, this.ry, this.rz);
      
      let dot = rotatedNormal[0] * light[0] + rotatedNormal[1] * light[1] + rotatedNormal[2] * light[2];
      dot = Math.max(0, dot);
      const shade = Math.floor(30 + dot * 225);
      
      // Draw face
      ctx.beginPath();
      ctx.moveTo(pts2d[0][0], pts2d[0][1]);
      for (let p of pts2d.slice(1)) ctx.lineTo(p[0], p[1]);
      ctx.closePath();
      
      // Apply color based on type
      const c = this.colors;
      ctx.fillStyle = `rgb(${Math.floor(shade*c.r)},${Math.floor(shade*c.g)},${Math.floor(shade*c.b)})`;
      ctx.strokeStyle = `rgb(${Math.floor((15+shade)*c.r)},${Math.floor((15+shade)*c.g)},${Math.floor((20+shade)*c.b)})`;
      ctx.fill();
      ctx.stroke();
      
      // Draw number (skip entirely for d2/coin)
      if (this.type == 'd100') {
        const centerX = pts2d.reduce((sum,p) => sum + p[0], 0) / pts2d.length;
        const centerY = pts2d.reduce((sum,p) => sum + p[1], 0) / pts2d.length;
        
        ctx.fillStyle = dot > 0.3 ? "#000" : "#fff";
        ctx.font = `bold ${this.type === 'd20' ? 14 : 18}px sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText((idx+1).toString(), centerX, centerY);
      }
    }
    
    ctx.restore();
  }
  
  // New helper to set the "landing" angles
  setStaticPosition(rx, ry, rz) {
    this.targetRx = rx;
    this.targetRy = ry;
    this.targetRz = rz;
  }

  animate(x, y, z, rs, dt) {
    this.rs = rs;
    if (!dt) dt = 0.016;

    if (rs === 0) {
      // Snap to the specific defined position
      this.rx = this.targetRx || 0;
      this.ry = this.targetRy || 0;
      this.rz = this.targetRz || 0;
    } else {
      // Standard rotation logic
      if (this.type === 'd2') {
        this.stepRotation(dt);
      } else {
        const speed = 1.2 * rs * dt;
        this.rx += speed;
        this.ry += speed * 0.75;
        this.rz += speed * 0.5;
      }
    }
    
    const scale = this.scale * (tL / 10) * z;
    const posX = tX + (tL / 10) * x;
    const posY = tY + (tH / 10) * y;
    
    this.draw(ctx, posX, posY, scale, 4);
  }
}
class stone{
  constructor(x,y,z,stat){
    this.applied = 0;
    //current position
    this.x = x;
    this.y = y;
    this.z = z;
    //target position
    this.tx = x;
    this.ty = y;

    this.stat = stat;
    this.owner = 2; //0-player, 1-foe,2-field

    this.tSX = 1.545; this.tSY = 4.545;
    this.tCX = 7.625; this.tCY = 4.625;
    this.tIX = 3.545; this.tIY = 4.49;
    this.tAX = 5.545; this.tAY = 4.53;

    this.pSX = 3.23; this.pSY = 6.48;
    this.pCX = 6.12; this.pCY = 6.48;
    this.pIX = 3.19; this.pIY = 9.1;
    this.pAX = 6.10; this.pAY = 9.1;

    this.fSX = this.pSX; this.fSY = this.pSY;
    this.fCX = this.pCX; this.fCY = this.pCY;
    this.fIX = this.pIX; this.fIY = this.pIY;
    this.fAX = this.pIX+2.9; this.fAY = this.pIY;
    }
  refresh(dt){
    //Movement logic
    const speed = 6*dt;
    if (Math.abs(this.tx - this.x) > 0.01) 
    {this.x += (this.tx - this.x)*speed}
    else{this.x = this.tx;}
    if (Math.abs(this.ty - this.y) > 0.01){
      this.y +=(this.ty - this.y)*speed}
    else{this.y = this.ty}
    //Drawing logic
    if (this.owner == 1){
      ctx.translate(wX/2,wY/2);
      ctx.rotate(Math.PI);
      ctx.translate(-wX/2,-wY/2);
    }
    switch(this.stat){
      case eSTAT.S:
            drawShape('qua',this.x,this.y,this.z*.9, .5,0, 0,.5, .5,1, 1,.5,'yellow',1);
            drawShape('qua',this.x,this.y,this.z*.9, .5,0, 0,.5, .5,1, 1,.5,'rgba(255,255,255,.25)',1);
            drawShape('tri',this.x,this.y,this.z*.9, 0,.5, .5,1, 1,.5, 0,0,'rgba(0,0,0,.15)',1);
            drawShape('tri',this.x,this.y,this.z*.9, .5,0, 1,.5, .5,1, 0,0,'rgba(255,255,255,.25)',1);
            drawPortrait(-4,this.x+.25,this.y+.25,.0420)
          
            break;
      case eSTAT.C:
         drawShape('qua',this.x,this.y,this.z*.75, 0,0.1, .5,0, 1,.1, .5,.2,'green',1);
         drawShape('qua',this.x,this.y,this.z*.75, 0,0.1, .5,0, 1,.1, .5,.2,'rgba(0,0,0,.25)',1);
         drawShape('qua',this.x,this.y,this.z*.75, 0,0.1, 0,.9, .5,1, .5,.2,'green',1);
         drawShape('qua',this.x,this.y,this.z*.75, 1,0.1, 1,.9, .5,1, .5,.2,'green',1);
         drawShape('qua',this.x,this.y,this.z*.75, 1,0.1, 1,.9, .5,1, .5,.2,'rgba(255,255,255,.25)',1);
          //drawShape('rec',this.x,this.y,this.z*.75,0,0,1,1,0,0,0,0,'green',1);
          //drawShape('rec',this.x,this.y,this.z*.75,0,0,1,1,0,0,0,0,'rgba(255,255,255,.45)',1);
          //drawShape('rec',this.x,this.y,this.z*.5,.5,.5,1,1,0,0,0,0,'rgba(255,255,255,.45)',1);
          drawPortrait(-6,this.x+.165,this.y+.165,.0420)
        

         break;
      case eSTAT.I:
        drawShape('qua',this.x,this.y,this.z*.9, 0,.9, 0.5,0.1, 1,.9, .5,1,'red',1);
        drawShape('tri',this.x,this.y,this.z*.9, .5,0.1, 1,.9, .5,1, 1,.5,'rgba(255,255,255,.45)',1);
        drawPortrait(-5,this.x+.22,this.y+.38,.0360)
       
        break;
      case eSTAT.A:
        drawShape('arc',this.x,this.y,this.z, .45,.47, .4,0, 2,0, .0,0,'rgba(0,0,255,.5)',1);
        drawShape('arc',this.x,this.y,this.z, .45,.47, .4,0, 2,0, .0,0,'rgba(0,0,255,.5)',1);
        drawShape('arc',this.x,this.y,this.z, .5,.47, .36,0, 2,0, .0,0,'rgba(255,255,255,.075)',1);
        drawShape('arc',this.x,this.y,this.z, .55,.47, .3,0, 2,0, .0,0,'rgba(255,255,255,.075)',1);
        drawShape('arc',this.x,this.y,this.z, .65,.47, .2,0, 2,0, .0,0,'rgba(255,255,255,.075)',1);
        drawShape('arc',this.x,this.y,this.z, .75,.47, .1,0, 2,0, .0,0,'rgba(255,255,255,.075)',1);
        drawShape('arc',this.x,this.y,this.z, .45,.47, .4,0, 2,0, .0,0,'rgba(0,0,0,.15)',1);
        drawShape('arc',this.x,this.y,this.z, .45,.47, .4,0, 2,0, .0,0,'rgba(255,255,255,.075)',1);
        //drawShape('qua',this.x,this.y,this.z*.9, .5,0, 0,.5, .5,1, 1,.5,'rgba(255,255,255,.25)',1);
        drawPortrait(-7,this.x+.25,this.y+.25,.0420)
     
        break;
    }
    if (this.owner == 1){
      ctx.translate(wX/2,wY/2);
      ctx.rotate(Math.PI);
      ctx.translate(-wX/2,-wY/2);
    }
  }
  changeOwner(newowner){
    switch (this.owner){
      case 0://player currently owns
        switch (this.stat){
          case eSTAT.S:
            if (newowner == 2){//if table takes ownership from player
              this.tx =this.tSX;
              this.ty = this.tSY;
              Player[0].runeStat[0]= 0;
            }
            if (newowner == 1){//if foe takes ownership of stone from player
              this.tx =this.fSX;
              this.ty = this.fSY;
              
              Player[1].runeStat[0]= 1;
              Player[0].runeStat[0] = 0;
              
            }
            if (newowner == 0){//if Player monster dies while owning stone, the next monster gets the effect applied
              Player[0].runeStat[0] = 1;
            }
            break;//end case eSTAT.S
          case eSTAT.C:
            if (newowner == 2){//if table takes ownership from player
              this.tx = this.tCX;
              this.ty = this.tCY;
              Player[0].runeStat[1]= 0;
            }
            if (newowner == 1){//if foe takes ownership of stone from player
              this.tx = this.fCX;
              this.ty = this.fCY;
              Player[1].runeStat[1]= 1;
              Player[0].runeStat[1] = 0;
            }
            if (newowner == 0){//if Player monster dies while owning stone, the next monster gets the effect applied
              Player[0].runeStat[1] = 1;
            }
            break;
          case eSTAT.I:
            if (newowner == 2){//if table takes ownership from player
              this.tx = this.tIX;
              this.ty = this.tIY;
              Player[0].runeStat[2] = 0;
            }
            if (newowner == 1){//if foe takes ownership of stone from player
              this.tx = this.fIX;
              this.ty = this.fIY;
              Player[1].runeStat[2] = 1;
              Player[0].runeStat[2] = 0;
            }
            if (newowner == 0){//if Player monster dies while owning stone, the next monster gets the effect applied
              Player[0].runeStat[2] = 1;
            }
            break;
          case eSTAT.A:
            if (newowner == 2){//if table takes ownership from player
              this.tx = this.tAX;
              this.ty = this.tAY;
             Player[0].runeStat[3]= 0;
            }
            if (newowner == 1){//if foe takes ownership of stone from player
              this.tx = this.fAX;
              this.ty = this.fAY;
              Player[0].runeStat[3] = 0;
              Player[1].runeStat[3] = 1;
            }
            if (newowner == 0){//if Player monster dies while owning stone, the next monster gets the effect applied
              Player[0].runeStat[3] = 1;
            }
            break;
        }//end this.stat switch
        break;//end case 0 player currently owns
      case 1://foe currently owns
        switch (this.stat){
          case eSTAT.S:
            if (newowner == 2){//if table takes ownership from foe
              this.tx =this.tSX;
              this.ty = this.tSY;
              Player[1].runeStat[0] = 0;
            }
            if (newowner == 0){//if player takes ownership of stone from foe
              this.tx =this.pSX;
              this.ty = this.pSY;
              Player[0].runeStat[0] = 1;
              Player[1].runeStat[0] = 0;
            }
            if (newowner == 1){//if Foe monster dies while owning stone, the next monster gets the effect applied
              Player[1].runeStat[0] = 1;
            }
            break;//end case eSTAT.S
          case eSTAT.C:
            if (newowner == 2){//if table takes ownership from foe
              this.tx =this.tCX;
              this.ty = this.tCY;
              Player[1].runeStat[1] = 0;
            }
            if (newowner == 0){//if player takes ownership of stone from foe
              this.tx =this.pCX;
              this.ty = this.pCY;
              Player[0].runeStat[1] = 1;
              Player[1].runeStat[1] = 0;
            }
            if (newowner == 1){//if Foe monster dies while owning stone, the next monster gets the effect applied
              Player[1].runeStat[1] = 1;
            }
            break;
          case eSTAT.I:
            if (newowner == 2){//if table takes ownership from foe
              this.tx =this.tIX;
              this.ty = this.tIY;
              Player[1].runeStat[2] = 0;
            }
            if (newowner == 0){//if player takes ownership of stone from foe
              this.tx =this.pIX;
              this.ty = this.pIY;
              Player[0].runeStat[2] = 1;
              Player[1].runeStat[2] = 0;
            }
            if (newowner == 1){//if Foe monster dies while owning stone, the next monster gets the effect applied
              Player[1].runeStat[2] = 1;
            }
            break;
          case eSTAT.A:
            if (newowner == 2){//if table takes ownership from foe
              this.tx =this.tAX;
              this.ty = this.tAY;
              Player[1].runeStat[3] = 0;
            }
            if (newowner == 0){//if player takes ownership of stone from foe
              this.tx =this.pAX;
              this.ty = this.pAY;
              Player[0].runeStat[3] = 1;
              Player[1].runeStat[3] = 0;
            }
            if (newowner == 1){//if Foe monster dies while owning stone, the next monster gets the effect applied
              Player[1].runeStat[3] = 1;
            }
            break;
          }//end switch this.stat switch
        break;//end case 1 foe currently owns
      case 2://table currently owns
        switch(this.stat){
          case eSTAT.S:
            if (newowner == 0){//if player takes ownership from table
              this.tx =this.pSX;
              this.ty = this.pSY;
              Player[0].runeStat[0] = 1;
            }
            if (newowner == 1){//if foe takes ownership of stone from table
              this.tx =this.fSX;
              this.ty = this.fSY;
              Player[1].runeStat[0] = 1;
            }
            break;//end case eSTAT.S
          case eSTAT.C:
            if (newowner == 0){//if player takes ownership from table
              this.tx =this.pCX;
              this.ty = this.pCY;
              Player[0].runeStat[1] = 1;
            }
            if (newowner == 1){//if foe takes ownership of stone from table
              this.tx =this.fCX;
              this.ty = this.fCY;
              Player[1].runeStat[1] = 1;
            }
            break;
          case eSTAT.I:
            if (newowner == 0){//if player takes ownership from table
              this.tx =this.pIX;
              this.ty = this.pIY;
              Player[0].runeStat[2] = 1;
            }
            if (newowner == 1){//if foe takes ownership of stone from table
              this.tx =this.fIX;
              this.ty = this.fIY;
              Player[1].runeStat[2] = 1;
            }
            if (newowner == 'tutorial'){
              this.tx =2.9;
              this.ty = 1;
              
            }
            break;
          case eSTAT.A:
            if (newowner == 0){//if player takes ownership from table
              this.tx =this.pAX;
              this.ty = this.pAY;
              Player[0].runeStat[3] = 1;
            }
            if (newowner == 1){//if foe takes ownership of stone from table
              this.tx =this.fAX;
              this.ty = this.fAY;
              Player[1].runeStat[2] = 1;
            }
            break;
        }//end this.stat switch
        break;//case 2 this.owner break
      case 'tutorial':
        if (newowner == 2){
              this.tx =this.tIX;
              this.ty = this.tIY;
        }
      break;

      }//end this.ownerswitch
    this.owner = newowner;
  }//end changeowner
  
}//end class stone
////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////
var sRune = new stone(1.545,4.545,1,eSTAT.S);
var cRune = new stone(7.625,4.625,1,eSTAT.C);
var iRune = new stone(3.545,4.49,1,eSTAT.I);
var aRune = new stone(5.545,4.53,1,eSTAT.A);
var Player = [
    new Field(0),
    new Field(1, 1)
];
Player[1].opponent = Player[0];
Player[0].opponent = Player[1];
var Dungeon = new Explore()
var Player = [
    new Field(0),
    new Field(1, 1)
];
Player[1].opponent = Player[0];
Player[0].opponent = Player[1];
var song = 0;
var cursong= 0;
var MessageBox = new btn(0,0,1,3,3,'Testing the message box','red','blue',0,1) //x,y,z,l,h,text,framecolor,textColor,visible = 0
var btnYes = new btn(0,0,1,3,3,'Yes','red','blue',1,1)
var btnNo = new btn(0,0,1,3,3,'No','red','blue',2,1)
var btnAction = new btn(0,0,1,3,3,'Action','red','blue',3,1)
var btnAction2 = new btn(0,0,1,3,3,'Action','red','blue',3,1)
var btnAdd = new btn(0,0,1,3,3,'Action','red','blue',4,1)
var btnDeck = new btn(0, 0, 1, 1, 1, 'Deck', 'blue', 'white', 'deck_view', 1);     

var aniDice = new Dice('d8');
var aniDice2 = new Dice('d6');
var Oracle = new Field(369);
//////////////////////[EVENT LISTENERS]////////////////////////////
//////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////

// Paste this anywhere in your global scope (e.g., near your drawPortrait function)
function drawChatInterface() {
    // 1. Draw the "CHAT" button indicator (Bottom Left)
    let btnX = tX + (tL/10) * 0.05; 
    let btnY = tY + (tH/10) * 9.39;
    let btnS = (tH/10) * 0.5;

    ctx.fillStyle = "rgba(0,0,0,0.5)";
    ctx.fillRect(btnX, btnY, btnS * 1.5, btnS);
    
    ctx.fillStyle = "white";
    ctx.font = (btnS * 0.5) + "px Arial";
    ctx.fillText("CHAT", btnX + 4.5, btnY + (btnS/1.5));

    // 2. Logic: If chat is empty/closed, stop here
    if (chatLog.length === 0 && !isChatActive) return;

    let timeSince = Date.now() - lastChatTime;
    let fadeStart = 5000; 
    let fadeTime = 2000;
    let alpha = 1;

    if (!isChatActive) {
        if (timeSince > fadeStart) {
            alpha = 1 - ((timeSince - fadeStart) / fadeTime);
        }
    }
    
    if (alpha <= 0) return; 

    // 3. Draw the Chat Box
    ctx.globalAlpha = alpha;
    
    let chatX = .9;        
    let chatY = 6.3;      
    let chatW = 8;       
    let rowHeight = 0.25; 

    // Background
    ctx.fillStyle = "rgba(0, 0, 0, 0.6)";
    let bgX = tX + (tL/10) * chatX;
    let bgY = tY + (tH/10) * chatY;
    let bgW = (tL/10) * chatW;
    let bgH = (tH/10) * 3.69; 
    ctx.fillRect(bgX, bgY, bgW, bgH);

    // History
    let maxLines = 13;
    let visibleLog = chatLog.slice(-maxLines); 
    
    for (let i = 0; i < visibleLog.length; i++) {
        let lineY = chatY + (i * rowHeight) + 0.1;
        drawText(chatX + 0.2, lineY, chatW - 0.4, rowHeight, visibleLog[i], "white", 1, "left");
    }

    // Input Line (What you are typing)
    if (isChatActive) {
        let inputY = chatY + (maxLines * rowHeight) + 0.9;
        let cursor = (Date.now() % 1000 < 500) ? "_" : " "; 
        drawText(chatX + 0.2, 9.75, chatW - 0.4, rowHeight, "> " + chatDraft + cursor, "yellow", 1, "left");
    }

    ctx.globalAlpha = 1; // Reset opacity
}
window.addEventListener('resize', resizeCanvas, false);
window.addEventListener("orientationchange", function() {setTimeout(resizeCanvas, 200);}, false);
window.addEventListener("deviceorientation", resizeCanvas, true);
function handleInput(e) {
  const now = Date.now();
  if (now - lastInputTime < 100) return; 
  lastInputTime = now;
  const clientX = e.clientX;
  const clientY = e.clientY;
  let tl = (tL/10);
  let newX = Dungeon.x;
  let newY = Dungeon.y;
  let isMoving = false;
  const pos = {x: clientX - (wX-tL)/2, y: clientY - (wY-tH)/2}
  // Convert pixels to Grid Units so they match the MessageBox coordinates
  const gridPos = {x: pos.x / (tL/10),y: pos.y / (tH/10)};
//ONLINE
  if (startGame == 'charSelect') {
      // Coordinates for the Name Box (x: 2-8, y: 7-8.5)
      if (gridPos.x > 2 && gridPos.x < 8 && gridPos.y > 7 && gridPos.y < 8.5) {
          
          // PREVENT DEFAULT FOCUS STEALING
          e.preventDefault(); 
          
          // Sync draft so name doesn't vanish
          chatInput.value = playerName;
          chatDraft = playerName; 
          
          chatInput.focus();
          isChatActive = true;
          return; // STOP HERE! Do not run "Close Chat" logic below.
      }
  }

  // --- 2. PRIORITY CHECK: Are we clicking the Chat Button? ---
  // (Your bottom-left chat button logic)
  if (gridPos.x >= 0 && gridPos.x <= 8 && gridPos.y >= 9.5 && gridPos.y <= 10.5) {
      e.preventDefault();
      
      

      //setTimeout(function() {}, 500);
        isChatActive = true;
          chatInput.focus();
      
      return; 
  }
  
  // --- 3. CLOSER CHECK: If we clicked anywhere else, Close Chat ---
  if (isChatActive) {
      chatInput.blur();
      isChatActive = false;
      return;
  }
  ////////////////
  if (startGame == 'dialogue'||startGame == 'tutorial'){
      if (btnYes.visible && btnYes.isTouched(gridPos.x, gridPos.y)) { btnYes.press(); return; }
      if (btnNo.visible && btnNo.isTouched(gridPos.x, gridPos.y)) { btnNo.press(); return; }
      //ONLINE
      if (Dungeon.dCounter == 1) {
        if (Dungeon.currentSpeaker.isChallenger == true) {
          Dungeon.dCounter = 0;
          return; 
        }
      }
      //////
      if (startGame == 'dialogue' && Dungeon.dCounter == 1 && 
         ((Dungeon.currentSpeaker.type == 2 &&Dungeon.MainQuest == 0)|| Dungeon.currentSpeaker.type == 4)) {
          // Do nothing. Wait for button press.
          return; 
      } 
      if (startGame == 'dialogue' && Dungeon.dCounter == 2 && Dungeon.currentSpeaker.type == 77.1 &&Dungeon.gd ==2) {
          // Do nothing. Wait for button press.
          return; 
      } 
      // 2. Otherwise, advance the text
      else {
        if (startGame == 'tutorial'){
          if (Dungeon.option == 1){
            if (pos.x >= (tL/10)* mX && pos.x <= (tL/10)*(mX+cL) && pos.y > (tH/10)*cY  && pos.y < (tH/10)*(cY+cH)){
              Dungeon.option =2;Dungeon.dCounter = 0;
              MusicEngine.playSFX('heal')
            }
          }
          if (Dungeon.option == 3){
            if (pos.x >= (tL/10)*maX && pos.x <= (tL/10)*(maX+actLH) && pos.y > (tH/10)*actY   && pos.y < (tH/10)*(actY+actLH)){
              MusicEngine.stop();
              MusicEngine.playSFX('slash');
              MusicEngine.play(15)
              Dungeon.option = 4;
              Dungeon.dCounter = 0;
            }
          }
          if(Dungeon.option == 4||Dungeon.option == 5||Dungeon.option == 8){
            Dungeon.option = Dungeon.option + 1
            if(Dungeon.option == 6){MusicEngine.stop();MusicEngine.play(8)}
          }
          if(Dungeon.option == 7){
                        if (Dungeon.dCounter == 0){Dungeon.dCounter = 1; return;}

            if (Dungeon.dCounter == 1){
              if (pos.x > (tL/10)*0 && pos.x < (tL/10)*1&& pos.y > (tH/10)*7.5   && pos.y < (tH/10)*9){Dungeon.dCounter = 2;MusicEngine.playSFX('heal');return;}//larrow
              if (pos.x > (tL/10)*3 && pos.x <= (tL/10)*4 && pos.y > (tH/10)*7.5   && pos.y < (tH/10)*9){Dungeon.dCounter = 2;MusicEngine.playSFX('heal');return;}//rarrow
            }
            if (Dungeon.dCounter == 2||Dungeon.dCounter==4){Dungeon.dCounter = Dungeon.dCounter+1;return;}
            if (Dungeon.dCounter == 3){if (pos.x > (tL/10)*.875 && pos.x < (tL/10)*(.875 + 2.25) && pos.y > (tH/10)*6.5   && pos.y < (tH/10)*10){Dungeon.dCounter = 4;MusicEngine.playSFX('heal')}}
            if(Dungeon.dCounter == 5){
              if (pos.x >= (tL/10)*huX && pos.x <= (tL/10)*(huX+actLH) && //pHand use 5
                  pos.y > (tH/10)*actY  && pos.y < (tH/10)*(actY+actLH)){Dungeon.dCounter =6; MusicEngine.stop();MusicEngine.playSFX('slash'); MusicEngine.play(25)} 
                }
          }
        }
        if (Dungeon.option != 7){
            Dungeon.dCounter = Dungeon.dCounter + 1;
           
        }
      }
      
      return; // Stop here so we don't trigger movement logic below
  }
  //END OF BATTLE SCREEN CLICKS
  if (Player[0].option ===10 ) { 
    //DUNGEON BATTLES
    if ((preGame == 'explore' && (startGame ==4||startGame == 8))||startGame == 'battle'){
      //emperor battle
      if (Player[1].option === 10.1 && startGame == 8&&preGame=='explore') {  
        // Give the Crown (Index 21)
        if(Dungeon.currentSpeaker.socketId === 'NPC_SUNCAT'){
          // Set flags to ensure the dialogue box opens
        Player[0].option = 0;
        Player[1].option = 0;
        Player[1].at = 0; Player[1].ay = 0; Player[0].at = 0; Player[0].ay = 0;Player[0].ax = 0; Player[1].ax = 0;
        sRune = new stone(1.545,4.545,1,eSTAT.S);
        cRune = new stone(7.625,4.625,1,eSTAT.C);
        iRune = new stone(3.545,4.49,1,eSTAT.I);
        aRune = new stone(5.545,4.53,1,eSTAT.A);
        Dungeon.dCounter = 0; 
        resize = 0;
        startGame = 'explore'; 
        Dungeon.status = 'normal';

          Dungeon.saveGame();
          return;
        }
        Dungeon.deck.push(new Card(21, 0)); 
        // Force the "You obtained a card" dialogue for the Crown
        Dungeon.currentSpeaker = {
          type: -27,          // Loot UI type
          deck: [21],         // SHOW THE CROWN
          visible: true       
        };
        // Set flags to ensure the dialogue box opens
        Player[0].option = 0;
        Player[1].option = 0;
        Player[1].at = 0; Player[1].ay = 0; Player[0].at = 0; Player[0].ay = 0;Player[0].ax = 0; Player[1].ax = 0;
        sRune = new stone(1.545,4.545,1,eSTAT.S);
        cRune = new stone(7.625,4.625,1,eSTAT.C);
        iRune = new stone(3.545,4.49,1,eSTAT.I);
        aRune = new stone(5.545,4.53,1,eSTAT.A);
        
        let emperor = Dungeon.npcs.find(npc => npc.type === 4);
        // Only kill him if we found him
        if (emperor) {Dungeon.killNPC(emperor, true);}
        startGame = 'dialogue'; 
        Dungeon.dCounter = 0;   
        lootDropped = true;     
        preGame = 'emperor battle'
        console.log("IMPOSSIBLE VICTORY! Crown Obtained.");
        if(typeof MusicEngine !== 'undefined') MusicEngine.playSFX('heal');
          MusicEngine.stop();
          MusicEngine.play(22);
          resize = 0;
          Dungeon.saveGame();
          return;
      }
      else if (Player[1].option === 10.2&& startGame == 4&&preGame=='explore'){
        if(Dungeon.currentSpeaker.socketId === 'NPC_SUNCAT'){
          // Set flags to ensure the dialogue box opens
        Player[0].option = 0;
        Player[1].option = 0;
        Player[1].at = 0; Player[1].ay = 0; Player[0].at = 0; Player[0].ay = 0;Player[0].ax = 0; Player[1].ax = 0;
        sRune = new stone(1.545,4.545,1,eSTAT.S);
        cRune = new stone(7.625,4.625,1,eSTAT.C);
        iRune = new stone(3.545,4.49,1,eSTAT.I);
        aRune = new stone(5.545,4.53,1,eSTAT.A);
        Dungeon.dCounter = 0; 
        resize = 0;
        startGame = 'explore'; 
          Dungeon.saveGame();
          Dungeon.status = 'normal';

          return;
        }
        Dungeon.saveGame();
        // Force the "You obtained a card" dialogue for the Emperor
        Dungeon.currentSpeaker = {
          type: -27,          // Loot UI type
          deck: [4],         // SHOW THE Emperor
          visible: true       
        };
        let emperor = Dungeon.npcs.find(npc => npc.type === 4);
        // Only kill him if we found him
        if (emperor) {Dungeon.killNPC(emperor, true);}
        // Set flags to ensure the dialogue box opens
                

        startGame = 'dialogue'; 
        preGame = 'emploss';
        Dungeon.dCounter = 0;   
        lootDropped = true;     
        Player[0].option = 0;
        Player[1].option = 0;
        Player[1].at = 0; Player[1].ay = 0; Player[0].at = 0; Player[0].ay = 0;
        sRune = new stone(1.545,4.545,1,eSTAT.S);
        cRune = new stone(7.625,4.625,1,eSTAT.C);
        iRune = new stone(3.545,4.49,1,eSTAT.I);
        aRune = new stone(5.545,4.53,1,eSTAT.A);
        console.log("Emperor wins! He joins you in your quest.");
        if(typeof MusicEngine !== 'undefined') MusicEngine.playSFX('heal');
        MusicEngine.stop();
        MusicEngine.play(18);
        resize = 0;
        return;
      }
      //standard dungeon battles
      else if (Player[1].option === 10.1&&startGame == 'battle') {
        let lootDropped = false;
       // 1. LOOT DROP LOGIC
        if (Math.random() < 1.0) { 
           // FIX: Check both Deck AND Hand for cards
           if (typeof Foe !== 'undefined' && (Player[1].deck.length > 0 || Player[1].hand.length > 0)) {
             
             // A. Combine IDs from Deck AND Hand
             let deckIDs = Player[1].deck.map(c => c.index);
             let handIDs = Player[1].hand.map(c => c.index);
             let availableLootIDs = deckIDs.concat(handIDs);
  
             // B. Get IDs of cards the Player already owns
             let playerOwnedIDs = Dungeon.deck.map(c => c.index);
  
             // C. Filter: Find IDs in loot that are NOT in player's deck
             let uniqueLoot = availableLootIDs.filter(id => !playerOwnedIDs.includes(id));
  
             let cardID;
  
             // D. SELECTION LOGIC
             if (uniqueLoot.length > 0) {
                  let rndIndex = Math.floor(Math.random() * uniqueLoot.length);
                  cardID = uniqueLoot[rndIndex];
                  // --- TRIGGER NOTIFICATION ---
                  // E. Add to Master Deck
                Dungeon.deck.push(new Card(cardID, 0));
               Dungeon.currentSpeaker = {
              type: -27,          // Triggers the "You obtained a card" UI
              deck: [cardID],     // The card to show
              visible: true       // Required for safety checks
              };
              startGame = 'dialogue'; // Switch mode to show the box
              Dungeon.dCounter = 0;   // Reset dialogue step
              lootDropped = true;     // Flag that we are busy 
              if(typeof MusicEngine !== 'undefined') MusicEngine.playSFX('heal');
              
             } else {
                 
             }
            

            
          }
        }
        //MAP MODIFICATIONS UPON NPC DEATH
        if(Dungeon.currentEnemy.type == 35.1&&Dungeon.mapID == 5){Dungeon.mapSong[5]=11}
        if(Dungeon.currentEnemy.type == 35.1&&Dungeon.mapID == 17){Dungeon.spawnPersistentNPC(17, 1,2.5, 1.5, 99, 'stationary', '#00ff00');}
        if(Dungeon.currentEnemy.type == 49.1&&Dungeon.mapID == 18){Dungeon.spawnPersistentNPC(18, 1,2.5, 1.5, 99, 'stationary', '#00ff00');}
        if(Dungeon.currentEnemy.type == 63.1&&Dungeon.mapID == 19){Dungeon.spawnPersistentNPC(19, 1,2.5, 1.5, 99, 'stationary', '#00ff00');}
        if(Dungeon.currentEnemy.type == 0&&Dungeon.mapID == 21){
          Dungeon.spawnPersistentNPC(21, 2,2.5, 6.5, 99, 'stationary', '#00ff00');
                    Dungeon.weather.setMode('apocalypse');
        }
        if(Dungeon.currentEnemy.type == 49.1&&Dungeon.mapID == 9){
          Dungeon.mapSong[9]=3;
          Dungeon.weather.setMode('clear');
          Dungeon.skyColor = 'rgba(0,0,255,1)';
          Dungeon.npcs.push(new NPC(9,Dungeon.x-1, Dungeon.y, 48,'chasing','#00ff00')); //Ice queen appears after kraken death
          Dungeon.npcs.forEach(npc => {if (!npc.isDead&& npc.type == 83) Dungeon.killNPC(npc, true)});//kill all leftover tentacles
        }
        if(Dungeon.currentEnemy.type == 4.1){
          Dungeon.npcs.push(new NPC(4,Dungeon.x, Dungeon.y-1, 4.1,'stationary','#00ff00')); //Arthur appears again after death
        }
        if(Dungeon.currentEnemy.type == 77.1&&Dungeon.mapID != 20){
          Dungeon.spawnPersistentNPC(14, 15, Dungeon.x-.5, Dungeon.y-.5, 77.1, 'chasing', '#00ff00',[50,65,59,51,8,28,77]);    
        }
        // 2. HANDLE ENEMY DEATH (Always happens)
        if (Dungeon.currentEnemy) {
            Dungeon.killNPC(Dungeon.currentEnemy, true);
        }
        // 3. MUSIC RESET (Always happens)
        if (typeof MusicEngine !== 'undefined') {
              
              MusicEngine.stop(); 
              if (Dungeon.mapID <4){MusicEngine.play(24)}
              else{MusicEngine.play(Dungeon.mapSong[Dungeon.mapID]); }
        }
        // 4. TRANSITION
        // Reset the Battle Result flag immediately
        Player[0].option = 0; 
        Player[1].option = 0;
        Player[1].at = 0; Player[1].ay = 0; Player[0].at = 0; Player[0].ay = 0;Player[0].ax = 0; Player[1].ax = 0;
        sRune = new stone(1.545,4.545,1,eSTAT.S);
        cRune = new stone(7.625,4.625,1,eSTAT.C);
        iRune = new stone(3.545,4.49,1,eSTAT.I);
        aRune = new stone(5.545,4.53,1,eSTAT.A);
        
        resize = 0;
        if (lootDropped) {
            // If we got loot, stay in 'dialogue' mode so we see the box
            Dungeon.saveGame()
            return; 
        } 
        else {
          // Otherwise, go straight back to exploration
          startGame = 'explore';
          Dungeon.saveGame()
          return;
        }
        
      }
      else if (Player[1].option === 10.2&&startGame == 'battle') {
              Dungeon.deleteGame();
             window.location.reload();

        return;
      }
      
    }
    //vsCPU and vsLOCAL battles
    window.location.reload();
    return;
  }
  //GAME START CLICKS///////////////
  if(startGame == 'jukebox'){
     
     // --- LEFT ARROW ---
     if (pos.x > (tL/10)*1 && pos.x <= (tL/10)*3  && 
         pos.y > (tH/10)*3 && pos.y < (tH/10)*5 ){
         
         if (song == 'shuffle') {
             song = songcount - 1;
         } else {
             song = song - 1;
         }

         MusicEngine.stop();

         if (song < 0) {
             song = 'shuffle';
             cursong = rnd(0,songcount - 1)
             MusicEngine.play(cursong);
         } else {
             MusicEngine.play(song);
         }
         
         // CRITICAL FIX: Reset the timer so the game loop doesn't 
         // immediately try to play another song on top of this one.
         lastSongTime = Date.now(); 
         return; 
     }

     // --- RIGHT ARROW ---
     if (pos.x > (tL/10)*7 && pos.x <= (tL/10)*9  && 
         pos.y > (tH/10)*3 && pos.y < (tH/10)*5 ){
         
         if (song == 'shuffle') {
             song = 0;
         } else {
             song = song + 1;
         }

         MusicEngine.stop();

         if (song > songcount - 1) {
             song = 'shuffle';
             cursong = rnd(0,songcount - 1);
             MusicEngine.play(cursong);
         } else {
             MusicEngine.play(song);
         }

         // CRITICAL FIX: Reset the timer here too
         lastSongTime = Date.now(); 
         return;
     }

     // --- STOP BUTTON ---
     if (pos.x > (tL/10)*4.4 && pos.x <= (tL/10)*5.6  && 
         pos.y > (tH/10)*3.4 && pos.y < (tH/10)*4.6 ){
         MusicEngine.stop();
         return;
     }

     // --- EXIT BUTTON ---
     if (pos.x > (tL/10)*0 && pos.x <= (tL/10)*3  && 
        pos.y > (tH/10)*8.25 && pos.y < (tH/10)*10 ){
         MusicEngine.stop();
         cursong = rnd(0,songcount - 1)
             MusicEngine.play(cursong);
         startGame = 'options';
         MusicEngine.playSFX('cancel');
         return;
     }
  }
  if (startGame == 'explore'){
    Dungeon.registerClick(e.clientX, e.clientY);
    if (btnDeck.isTouched(gridPos.x, gridPos.y) && btnDeck.visible == true&&btnDeck.type != 'jrpg') {
        // Just call press(). The Btn class handles the sound, animation, and logic.
        btnDeck.press(); 
        return; 
    }
    if (pos.x > (tL/10)*-1   && pos.x <= (tL/10)*2.5  && //TURN LEFT
        pos.y > (tH/10)* 0   && pos.y <  (tH/10)*10 ){
        //0=N, 1=E, 2=S, 3=W
        Dungeon.dir = (Dungeon.dir + 3) % 4;
        Dungeon.clickInput = null; //
        return;
    }
    if (pos.x > (tL/10)*7.5   && pos.x <= (tL/10)*11  && //TURN RIGHT
        pos.y > (tH/10)*0 && pos.y < (tH/10)*10 ){
        //0=N, 1=E, 2=S, 3=W
        Dungeon.dir = (Dungeon.dir + 1) % 4;
        Dungeon.clickInput = null; //
        return;  
    }
    // --- 1. Determine Movement Intention ---
    let moveX = 0;
    let moveY = 0;
    let movingForward = false;

    // FORWARD
    if (pos.x > (tL/10)*2.5 && pos.x <= (tL/10)*7.5 && 
        pos.y > (tH/10)*0 && pos.y < (tH/10)*7 ){
        movingForward = true;
        if (Dungeon.dir === 0) moveY = -1; // N
        if (Dungeon.dir === 1) moveX = 1;  // E
        if (Dungeon.dir === 2) moveY = 1;  // S
        if (Dungeon.dir === 3) moveX = -1; // W
    }
    // BACKWARD
    else if (pos.x > (tL/10)*2.5 && pos.x <= (tL/10)*7.5 && 
             pos.y > (tH/10)*7 && pos.y < (tH/10)*10 ){
        // Opposite directions
        if (Dungeon.dir === 0) moveY = 1;  // Back from N is S
        if (Dungeon.dir === 1) moveX = -1; // Back from E is W
        if (Dungeon.dir === 2) moveY = -1; // Back from S is N
        if (Dungeon.dir === 3) moveX = 1;  // Back from W is E
    }

    // --- 2. Predict Target Tile ---
    if (moveX !== 0 || moveY !== 0) {
      // Get CURRENT tile indices (using floor prevents the 2.999 vs 3.0 issue)
      let currentTileX = Math.floor(Dungeon.x);
      let currentTileY = Math.floor(Dungeon.y);

      // Calculate TARGET tile indices
      let targetX = currentTileX + moveX;
      let targetY = currentTileY + moveY;

      // --- 3. Check for Obstacles ---
        
      // A. WALL CHECK
      if (Dungeon.isWall(targetX, targetY)) {
        // Hit a wall. Do nothing.
        if(typeof MusicEngine !== 'undefined') { 
          MusicEngine.playSFX('cancel')
          // Optional: Play a tiny 'thud' sound if you want feedback
        }
        return; 
      }

      // B. NPC CHECK
      let hitNPC = null;
      for (let npc of Dungeon.npcs) {
        // Ignore dead/invisible NPCs
        if (!npc.visible || npc.isDead) continue;

        // Check if NPC is in the TARGET tile
        // We use floor to see if they share the same grid coordinate
        if (Math.floor(npc.x) === targetX && Math.floor(npc.y) === targetY) {
          hitNPC = npc;
          break;
        }
      }

      if (hitNPC) {
        // We are trying to walk into a tile occupied by an NPC.
        // 1. If moving FORWARD: Talk/Interact
        if (movingForward) {
          Dungeon.saveGame();
          hitNPC.triggerInteraction(Dungeon);
        }
        // 2. If moving BACKWARD: Just block (don't auto-talk with your butt)
        // Stop movement regardless
        return;
      }

      //ONLINE
      if (window.remotePlayers) {
        for (let id in window.remotePlayers) {
          let p = window.remotePlayers[id];
          if (p.mapID !== Dungeon.mapID) continue;
          // Check if a remote player is on the target tile
          if (Math.floor(p.x) === targetX && Math.floor(p.y) === targetY) {                       
            if (movingForward) {
              if (p.socketId === "NPC_SUNCAT"){
                Dungeon.currentSpeaker = p; 
                startGame = 'dialogue';
                Dungeon.status = 'dueling'; // Mark myself as busy
                Dungeon.isChallenger = true; // <--- MARK AS SENDER
                Dungeon.dCounter = 0; 
                return
              }
              if (p.status === 'dueling') {
                console.log("Target is already in a battle.");
                MessageBox.show(0.5, 8, 1, 9, 2, 'That player is busy fighting!', 'dialogue', 1, 0);    
              }
              else{
                console.log(">> SENDING CHALLENGE...");
                // 1. Sanitize Deck: Convert complex Card objects to simple ID array
                let mySimpleDeck = Dungeon.deck.map(c => c.index);
                  // 2. Send Challenge + Deck
                socket.emit("challenge_request", {
                  targetId: p.socketId,
                  deck: mySimpleDeck
                });                            
                // 2. Set Game State
                Dungeon.currentSpeaker = p; 
                Dungeon.dCounter = 0; 
                Dungeon.status = 'dueling'; // Mark myself as busy
                Dungeon.isChallenger = true; // <--- MARK AS SENDER
                startGame = 'dialogue';  // STOP exploring, START talking
                MessageBox.show(0.5, 8, 1, 9, 2, 'Challenge sent!', 'dialogue', 1, 0);
                // Optional: play a sound or log interaction
                console.log("Blocked by player: " + id);
                
              }
            }         
          }
        }
      }
      ////////////////////////////////////
      // --- 4. Move Safely ---
      // If we get here, the tile is empty. 
      // Move to the CENTER of the target tile (Index + 0.5)
      Dungeon.x = targetX + 0.5;
      Dungeon.y = targetY + 0.5;
      Dungeon.checkFloorTriggers();
      if (typeof socket !== 'undefined') {
        socket.emit("move", {
          x: Dungeon.x,
          y: Dungeon.y,
          dir: Dungeon.dir, // Send direction so you face the right way
          mapID: Dungeon.mapID || 0, // Useful if you have multiple rooms
          status: Dungeon.status, // 'normal' vs 'dueling' (optional, for visual cues)
        portrait: playerSprite, 
        });
      }
    }
  }
  if (startGame == 'options'){
    if (pos.x > (tL/10)*1 && pos.x <= (tL/10)*4  && //Jukebox
        pos.y > (tH/10)*6 && pos.y < (tH/10)*8 ){
      Player[1].isCPU = 1;
      MusicEngine.stop();
      startGame = 'jukebox';
      MusicEngine.playSFX('heal');
      return;
    }
    else if (pos.x > (tL/10)*6 && pos.x <= (tL/10)*9.5  && //grimoire
      pos.y > (tH/10)*6 && pos.y < (tH/10)*8 ){
      Player[1].isCPU = 0;
      MusicEngine.stop();
      cursong = rnd(0,songcount - 1)
             MusicEngine.play(cursong);
      viewingFullDeck = true; 
      // Initialize the playlist immediately with all cards
      let fullLib = getFullLibrary();
      activePlaylist = fullLib.map(c => c.index);
      startGame = 'grimoire';
      MusicEngine.playSFX('heal');
      return;
    }
     else if (pos.x > (tL/10)*0 && pos.x <= (tL/10)*3  && 
        pos.y > (tH/10)*8.25 && pos.y < (tH/10)*10 ){
      //Player[1].isCPU = 0;
      //MusicEngine.stop();
      //MusicEngine.play(4);
      //startGame = 'rulebook';
      startGame = 3;
      MusicEngine.playSFX('cancel');
      return;
    }
    else if (pos.x > (tL/10)*6&& pos.x <= (tL/10)*9.5  && //tarot
      pos.y > (tH/10)*8.5 && pos.y < (tH/10)*10 ){
     // Player[1].isCPU = 0;
     //MusicEngine.stop();
      
      startGame = 'tarot';
      return;
     // MusicEngine.playSFX('heal');
      //return;
    }
  }
  if (startGame == 'grimoire') {
     if (pos.x >= (tL/10)*8 && pos.x <= (tL/10)*9 && 
        pos.y > (tH/10)*6 && pos.y < (tH/10)*7.5) {
          MusicEngine.playSFX('cancel');
          if (preGame == 'explore'){startGame =preGame;}
          else{
        startGame = '0';}
        return;
    }
    // --- 1. Cycle Buttons (Left/Right) ---
    // RIGHT ARROW (Next Card)
    if (pos.x >= (tL/10)*8 && pos.x <= (tL/10)*9.5 && 
        pos.y > (tH/10)*8.25 && pos.y < (tH/10)*10) {
        playlistIndex++;
        if (playlistIndex >= activePlaylist.length) { playlistIndex = 0; }
        return;
    }
    
    // LEFT ARROW (Prev Card)
    if (pos.x >= (tL/10)*.5 && pos.x <= (tL/10)*2 && 
        pos.y > (tH/10)*8.25 && pos.y < (tH/10)*10) {
        playlistIndex--;
        if (playlistIndex < 0) { playlistIndex = activePlaylist.length - 1; }
        return;
    }

    // --- 2. Filter Buttons ---

    // "ALL" Text Button 
    if (pos.x >= (tL/10)*0.25 && pos.x <= (tL/10)*1.25 && 
        pos.y >= (tH/10)*4.2 && pos.y <= (tH/10)*5.0) {
        rankFilterIndex = 0; 
        filterGrimoire('ALL', 'All'); // <--- UPDATED
        return;
    }

    // Major Arcana Icon
    if (pos.x >= (tL/10)*1.5 && pos.x <= (tL/10)*2.5 && 
        pos.y >= (tH/10)*3.9 && pos.y <= (tH/10)*4.9) {
        rankFilterIndex = 0; 
        filterGrimoire('SUIT', 'Major'); // <--- UPDATED
        return;
    }

    // Wands Icon
    if (pos.x >= (tL/10)*0.25 && pos.x <= (tL/10)*1.25 && 
        pos.y >= (tH/10)*5.3 && pos.y <= (tH/10)*6.3) {
        rankFilterIndex = 0; 
        filterGrimoire('SUIT', 'Wands'); // <--- UPDATED
        return;
    }

    // Cups Icon
    if (pos.x >= (tL/10)*1.5 && pos.x <= (tL/10)*2.5 && 
        pos.y >= (tH/10)*5.3 && pos.y <= (tH/10)*6.3) {
        rankFilterIndex = 0; 
        filterGrimoire('SUIT', 'Cups'); // <--- UPDATED
        return;
    }

    // Swords Icon
    if (pos.x >= (tL/10)*1.5 && pos.x <= (tL/10)*2.5 && 
        pos.y >= (tH/10)*6.9 && pos.y <= (tH/10)*7.9) {
        rankFilterIndex = 0; 
        filterGrimoire('SUIT', 'Swords'); // <--- UPDATED
        return;
    }

    // Pentacles Icon
    if (pos.x >= (tL/10)*0.25 && pos.x <= (tL/10)*1.25 && 
        pos.y >= (tH/10)*6.9 && pos.y <= (tH/10)*7.9) {
        rankFilterIndex = 0; 
        filterGrimoire('SUIT', 'Pentacles'); // <--- UPDATED
        return;
    }

    // --- 3. RANK CYCLE BUTTON ---
    // Updated Hitbox to match your visual Arrow (8, 4.2) better
    if(pos.x >= (tL/10)*7.5 && pos.x <= (tL/10)*9 && 
       pos.y > (tH/10)*3.5 && pos.y < (tH/10)*5.0){
       
       rankFilterIndex++;
       
       // Loop back to 0 (All)
       if (rankFilterIndex >= rankList.length) {
           rankFilterIndex = 0;
       }
       
       var newTarget = rankList[rankFilterIndex];
       
       if (rankFilterIndex === 0) {
           filterGrimoire('ALL');
       } else {
           filterGrimoire('RANK', newTarget);
       }
       return;
    }
}
  if (startGame == 'tarot') {
    if(spread == 0){
    //back
     if (pos.x > (tL/10)*0 && pos.x <= (tL/10)*3  && 
        pos.y > (tH/10)*8.25 && pos.y < (tH/10)*10 ){
          startGame = 'options';
          return;
        }
        //wands
    if (pos.x >= (tL/10)*1 && pos.x <= (tL/10)*4 && 
        pos.y > (tH/10)*2 && pos.y < (tH/10)*5) {
          spread = 1;
          Oracle = new Field(0)
          for (let i = 0;i <Oracle.deck.length - 1;i++){
            Oracle.deck[i].desc = getOracleText(Oracle.deck[i])
          }
        }
        //cups
    else if (pos.x >= (tL/10)*6 && pos.x <= (tL/10)*9 && 
        pos.y > (tH/10)*2 && pos.y < (tH/10)*5) {
          spread = 2
          Oracle = new Field(0)
          for (let i = 0;i <Oracle.deck.length - 1;i++){
            Oracle.deck[i].desc = getOracleText(Oracle.deck[i])
          }
        }
         //swords
    else if (pos.x >= (tL/10)*1 && pos.x <= (tL/10)*4 && 
        pos.y > (tH/10)*5 && pos.y < (tH/10)*8) {
          spread = 3;
          Oracle = new Field(0)
          for (let i = 0;i <Oracle.deck.length - 1;i++){
            Oracle.deck[i].desc = getOracleText(Oracle.deck[i])
          }
        }
         //pentacles
    else if (pos.x >= (tL/10)*6 && pos.x <= (tL/10)*9 && 
        pos.y > (tH/10)*5 && pos.y < (tH/10)*8) {
          spread = 4;
          Oracle = new Field(0)
          for (let i = 0;i <Oracle.deck.length - 1;i++){
            Oracle.deck[i].desc = getOracleText(Oracle.deck[i])
          }
        }
      }
      //X
    if(spread > 0){
        //back
     if (pos.x > (tL/10)*0 && pos.x <= (tL/10)*3  && 
        pos.y > (tH/10)*8.25 && pos.y < (tH/10)*10 ){
          spread = 0;
          return;
        }
    }
    }
  if (startGame == 3){
    if (pos.x > (tL/10)*1 && pos.x <= (tL/10)*4  && //CPU
        pos.y > (tH/10)*6 && pos.y < (tH/10)*8 ){
      Player[1].isCPU = 1;
      
      startGame = 4;
      MusicEngine.playSFX('heal');
      return;
    }
    else if (pos.x > (tL/10)*6 && pos.x <= (tL/10)*9.5  && //LOCAL
      pos.y > (tH/10)*6 && pos.y < (tH/10)*8 ){
      Player[1].isCPU = 0;
      MusicEngine.stop();
      MusicEngine.play(4);
      startGame = 4;
      MusicEngine.playSFX('heal');
      return;
    }
    else if (pos.x > (tL/10)*1 && pos.x <= (tL/10)*4  && //Tutorial
      pos.y > (tH/10)*8.5 && pos.y < (tH/10)*10 ){
      Player[1].isCPU = 0;
      MusicEngine.stop();
      MusicEngine.play(4);
      if (Dungeon.loadGame()) {
        startGame = 'explore'; // Jump straight to game
        MusicEngine.play(Dungeon.mapSong[Dungeon.mapID]); // Play correct music
    } else {
      startGame = 'charSelect';
    }
      MusicEngine.playSFX('heal');
      return;
    }
    else if (pos.x > (tL/10)*6&& pos.x <= (tL/10)*9.5  && //options
      pos.y > (tH/10)*8.5 && pos.y < (tH/10)*10 ){
      Player[1].isCPU = 0;
      
      startGame = 'options';
      MusicEngine.playSFX('click');
      return;
    }
  }
  if (startGame == 2){
    lastSongTime = Date.now();
    lastTriggerTime = Date.now();
    startGame = 3
    MusicEngine.playSFX('click');
    return;
  }
  if (startGame == 1){
    lastTriggerTime = Date.now();
    lastSongTime = Date.now();
    startGame = 2;
    MusicEngine.playSFX('click');
    
    return;
  }
  if (startGame == 0){
    MusicEngine.init();
    MusicEngine.init();
    MusicEngine.init();

  

MusicEngine.playSFX('warp');
    
    
    startGame = 1;
    lastSongTime = Date.now();
    lastTriggerTime = Date.now();
    return;
  }
  if (startGame == 'charSelect') {
    
    // 1. LEFT ARROW (Prev Sprite)
    // Coords: x=1.5 to 2.5 (roughly based on drawPortrait -1 above)
    if (gridPos.x > 1 && gridPos.x < 3 && gridPos.y > 4 && gridPos.y < 6) {
        ps--;
        if (ps < 0) ps = 33; // Wrap around (assuming 77 sprites)
        return;
    }

    // 2. RIGHT ARROW (Next Sprite)
    if (gridPos.x > 7 && gridPos.x < 9 && gridPos.y > 4 && gridPos.y < 6) {
        ps++;
        if (ps > 33) ps = 0; 
        return;
    }

    // 3. NAME INPUT CLICK (Center)
    if (gridPos.x > 2 && gridPos.x < 8 && gridPos.y > 7 && gridPos.y < 8.5) {
        chatInput.value = playerName; // Pre-fill with current name
        chatInput.focus();
        isChatActive = true;
        return;
    }

    // 4. START BUTTON (Bottom Center)
    if (gridPos.x > 3.5 && gridPos.x < 6.5 && gridPos.y > 8.5 && gridPos.y < 9.5) {

        // SAVE NAME
        if (chatDraft.trim() !== "") playerName = chatDraft;
        chatDraft = ""; // Clear the draft so it doesn't show up in chat later
        isChatActive = false;
        chatInput.blur();

        // START GAME
        MusicEngine.playSFX('warp');
        startGame = 'explore'; // OR 'tutorial' if you prefer
              resizeCanvas()
        Player[0].name = playerName; // Attach the name to the local Player object too
        // Optional: Tell server our new identity
        if (typeof socket !== 'undefined') {
            socket.emit('setIdentity', { name: playerName, sprite: playerSprite });
          }
        
            
         
        
     
        Dungeon.saveGame()

        return;
    }
}
  ////////////////////////

  //MAIN GAME CLICKING////////////
  //Player non battle clicks
  if (Player[1].option != 2 && Player[1].option != 4 && Player[1].option < 6 && Player[0].draw == 0 && Player[1].draw == 0){//PLAYER CLICKING
    switch(Player[0].option){
      case 0://Initiate Click Menus and Buttons
        //PLAYER
          if (pos.x >= (tL/10)*hX   && pos.x <= (tL/10)*(hX+cL)  && //pHand menu visible 1
              pos.y > (tH/10)*cY && pos.y < (tH/10)*(cY+cH) ){
                Player[0].preOpt = 0;
            Player[0].btnDo('hm');
            Player[0].sendAction('SELECTION', { look: Player[0].look });
            Player[0].sendAction('PHASE_CHANGE', { option: Player[0].option });
            Player[0].sendAction('PRE_OPT', { preOpt: 0 });
          }
          if (pos.x >= (tL/10)*harX && pos.x <= (tL/10)*(harX+aLH)   && //pHand right arrow button
              pos.y > (tH/10)*arY  && pos.y < (tH/10)*(arY+aLH)){
            Player[0].preOpt = 0;
                Player[0].btnDo('hra');
            Player[0].sendAction('SELECTION', { look: Player[0].look });
            Player[0].sendAction('PHASE_CHANGE', { option: Player[0].option });
            Player[0].sendAction('PRE_OPT', { preOpt: 0 });
          }
          if (pos.x >= (tL/10)*halX  && pos.x <= (tL/10)*(halX+aLH)   && //pHand left arrow button
              pos.y > (tH/10)*arY  && pos.y < (tH/10)*(arY+aLH)){
            Player[0].preOpt = 0;
                Player[0].btnDo('hla');
            Player[0].sendAction('SELECTION', { look: Player[0].look });
            Player[0].sendAction('PHASE_CHANGE', { option: Player[0].option });
            Player[0].sendAction('PRE_OPT', { preOpt: 0 });         
            //   Player[1].hand.length  = 0;

           //Player[0].hand[0] = new Card(17, 0);
          //Player[0].hand[1] = new Card(7, 0);
           // Player[0].hand[2] = new Card(15, 0);
           // Player[0].hand[3] = new Card(50, 0);
           // Player[1].hand[0] = new Card(17, 1);
           // Player[1].hand[1] = new Card(26, 1);
            //Player[1].hand[2] = new Card(15, 1);
            //Player[1].hand[3] = new Card(50, 1);

           // Player[1].hand[0] = new Card(17, 1);
            // Player[1].hand[1] = new Card(7, 1);
             // Player[0].hand[3] = new Card(40, 0);
             // Player[0].hand[4] = new Card(39, 0);
             // Player[0].hand[5] = new Card(38, 0);
              //Player[0].hand[6] = new Card(45, 0);
        //   Player[0].aMonster[0] = new Card(3, 0);
              
              
          }

          if (pos.x >= (tL/10)*marX && pos.x <= (tL/10)*(marX+aLH)   && //pMon right arrow button
              pos.y > (tH/10)*arY  && pos.y < (tH/10)*(arY+aLH)){
              Player[0].preOpt = 0;
                Player[0].btnDo('mra');
              Player[0].sendAction('SELECTION', { look: Player[0].look });
              Player[0].sendAction('PHASE_CHANGE', { option: Player[0].option });
              Player[0].sendAction('PRE_OPT', { preOpt: 0 });
            }
          if (pos.x >= (tL/10)*malX  && pos.x <= (tL/10)*(malX+aLH)  && //pMon left arrow button
              pos.y > (tH/10)*arY  && pos.y < (tH/10)*(arY+aLH)){
              Player[0].preOpt = 0;
                Player[0].btnDo('mla')
              Player[0].sendAction('SELECTION', { look: Player[0].look });
              Player[0].sendAction('PHASE_CHANGE', { option: Player[0].option });
              Player[0].sendAction('PRE_OPT', { preOpt: 0 });
          }
          if (pos.x >= (tL/10)* mX   && pos.x <= (tL/10)*(mX+cL)  && //pMonster menu visible 3
              pos.y > (tH/10)*cY  && pos.y < (tH/10)*(cY+cH)){
              Player[0].preOpt = 0;
                Player[0].btnDo('mmo')
              Player[0].sendAction('SELECTION', { look: Player[0].look });
              Player[0].sendAction('PHASE_CHANGE', { option: Player[0].option });
              Player[0].sendAction('PRE_OPT', { preOpt: 0 });
          } 
          
      
      break;
      case 1://Player Hand Menu Visible
        //non redundant buttons
        if (pos.x <= (tL/10)*(hX-.8)  || pos.x >= (tL/10)*((hX+cL)+1) || //pHand menu close 0
            pos.y < (tH/10)*(cY) || pos.y > (tH/10)*(cY+cH)){
         Player[0].preOpt = 1;
              Player[0].btnDo('mc')
          Player[0].sendAction('SELECTION', { look: Player[0].look });
            Player[0].sendAction('PHASE_CHANGE', { option: Player[0].option });
            Player[0].sendAction('PRE_OPT', { preOpt: 1 });
        }
        if (pos.x >= (tL/10)*heX  && pos.x <= (tL/10)*(heX+actLH) && //pHand examine 2
            pos.y > (tH/10)*actY  && pos.y < (tH/10)*(actY+actLH)){
          Player[0].btnDo('hex')
        }
        if (pos.x >= (tL/10)*huX && pos.x <= (tL/10)*(huX+actLH) && //pHand use 5
            pos.y > (tH/10)*actY  && pos.y < (tH/10)*(actY+actLH)){
              Player[0].preOpt = 1;
          Player[0].btnDo('use')
          Player[0].sendAction('SELECTION', { look: Player[0].look });
            Player[0].sendAction('PHASE_CHANGE', { option: Player[0].option });
            Player[0].sendAction('PRE_OPT', { preOpt: 1 });
        }
        //redundant
        if (pos.x >= (tL/10)*(harX-.5) && pos.x <= (tL/10)*((harX+aLH)+.5)   && //pHand right arrow button
            pos.y > (tH/10)*(arY-.5)  && pos.y < (tH/10)*((arY+aLH)+.5)){
            Player[0].preOpt = 1;
              Player[0].btnDo('hra');
            Player[0].sendAction('SELECTION', { look: Player[0].look });
            Player[0].sendAction('PHASE_CHANGE', { option: Player[0].option });
              Player[0].sendAction('PRE_OPT', { preOpt: 1 });
          }
        if (pos.x >= (tL/10)*(halX-.5)  && pos.x <= ((tL/10)*(halX+aLH)+.5)   && //pHand left arrow button
            pos.y > (tH/10)*(arY-.5)  && pos.y < (tH/10)*((arY+aLH)+.5)){
            Player[0].preOpt = 1;
              Player[0].btnDo('hla');
            Player[0].sendAction('SELECTION', { look: Player[0].look });
            Player[0].sendAction('PHASE_CHANGE', { option: Player[0].option });
        Player[0].sendAction('PRE_OPT', { preOpt: 1 });
          }
        if (pos.x >= (tL/10)*marX && pos.x <= (tL/10)*(marX+aLH)   && //pMon right arrow button
            pos.y > (tH/10)*arY  && pos.y < (tH/10)*(arY+aLH)){
            Player[0].preOpt = 1;
              Player[0].btnDo('mra');
            Player[0].sendAction('SELECTION', { look: Player[0].look });
            Player[0].sendAction('PHASE_CHANGE', { option: Player[0].option });
              Player[0].sendAction('PRE_OPT', { preOpt: 1 });
          }
        if (pos.x >= (tL/10)*malX  && pos.x <= (tL/10)*(malX+aLH)  && //pMon left arrow button
            pos.y > (tH/10)*arY  && pos.y < (tH/10)*(arY+aLH)){
              if(Player[0].hand.length <= 1){
                Player[0].preOpt = 1;
                Player[0].btnDo('mla')
                Player[0].sendAction('SELECTION', { look: Player[0].look });
              Player[0].sendAction('PHASE_CHANGE', { option: Player[0].option });
             Player[0].sendAction('PRE_OPT', { preOpt: 1 });
            }
            
        }
        if (pos.x >= (tL/10)* mX   && pos.x <= (tL/10)*(mX+cL)  && //pMonster menu visible 3
            pos.y > (tH/10)*cY  && pos.y < (tH/10)*(cY+cH)){
            Player[0].preOpt = 1;
              Player[0].btnDo('mmo')
            Player[0].sendAction('SELECTION', { look: Player[0].look });
            Player[0].sendAction('PHASE_CHANGE', { option: Player[0].option });
              Player[0].sendAction('PRE_OPT', { preOpt: 1 });
          }
        break;
      case 2://Player Hand Examine Visible
        if(pos.x >= (tL/10)*3 && pos.x <= (tL/10)*9  && //examine right arrow button
           pos.y > (tH/10)*4  && pos.y < (tH/10)*6){
          Player[0].btnDo('hra')
          Player[0].sendAction('SELECTION', { look: Player[0].look });
        }
        if(pos.x >= (tL/10)*1 && pos.x <= (tL/10)*3  && //examine left arrow button
           pos.y > (tH/10)*4  && pos.y < (tH/10)*6){
          Player[0].btnDo('hla')
          Player[0].sendAction('SELECTION', { look: Player[0].look });
        }
        if(pos.x >= (tL/10)*8.25 && pos.x <= (tL/10)*9.1 &&//exit from hand zoom
           pos.y > (tH/10)*0.5  && pos.y < (tH/10)*1.5){
          Player[0].btnDo('hec');
          cardIDO = 0;
        }
          break;
      case 3://Player Monster Menu Visible
      //non redundant buttons
        if (pos.x <= (tL/10)*(mX-1)    || pos.x >= (tL/10)*((mX+cL)+.5)  || //pMonster menu close p0
            pos.y < (tH/10)*cY  || pos.y > (tH/10)*(cY+cL)){
          Player[0].preOpt = 3;
          Player[0].btnDo('mc')
          Player[0].sendAction('SELECTION', { look: Player[0].look });
          Player[0].sendAction('PHASE_CHANGE', { option: Player[0].option });
          Player[0].sendAction('PRE_OPT', { preOpt: 3 });  
        }
        if (pos.x >= (tL/10)*meX    && pos.x <= (tL/10)*(meX+actLH)  && //pMonster examine click p4
            pos.y > (tH/10)*actY   && pos.y < (tH/10)*(actY+actLH)){
            
            Player[0].preOpt = 3;
            Player[0].btnDo('me')
            Player[0].sendAction('PRE_OPT', { preOpt: 3 });
            
        }
        if (pos.x >= (tL/10)*maX    && pos.x <= (tL/10)*(maX+actLH)  && //pMonster attack click p6
            pos.y > (tH/10)*actY   && pos.y < (tH/10)*(actY+actLH)&&Player[0].aMonster[Player[0].look[eLOOK.M]].type == 0){
            Player[0].preOpt = 3;
              Player[0].btnDo('atk')
            Player[0].sendAction('SELECTION', { look: Player[0].look });
            Player[0].sendAction('PHASE_CHANGE', { option: Player[0].option });
            MusicEngine.playSFX('slash');
            Player[0].sendAction('PRE_OPT', { preOpt: 3 });
        }
        //redundant buttons


        if (pos.x >= (tL/10)*(marX-.5) && pos.x <= (tL/10)*((marX+aLH)+.5)   && //pMon right arrow button
            pos.y > (tH/10)*(arY-.5)  && pos.y < (tH/10)*((arY+aLH)+.5)){
            Player[0].preOpt = 3;
              Player[0].btnDo('mra');
            Player[0].sendAction('SELECTION', { look: Player[0].look });
            Player[0].sendAction('PHASE_CHANGE', { option: Player[0].option });
              Player[0].sendAction('PRE_OPT', { preOpt: 3 });
        }
        if (pos.x >= (tL/10)*(malX-.5)  && pos.x <= (tL/10)*((malX+aLH)+.5)  && //pMon left arrow button
            pos.y > (tH/10)*(arY-.5)  && pos.y < (tH/10)*((arY+aLH)+.5)){
           Player[0].preOpt = 3;
              Player[0].btnDo('mla')
            Player[0].sendAction('SELECTION', { look: Player[0].look });
            Player[0].sendAction('PHASE_CHANGE', { option: Player[0].option });
              Player[0].sendAction('PRE_OPT', { preOpt: 3 });
          }
        if (pos.x >= (tL/10)*hX   && pos.x <= (tL/10)*(hX+cL)  && //pHand menu visible 1
              pos.y > (tH/10)*cY && pos.y < (tH/10)*(cY+cH) ){
            Player[0].preOpt = 3;
                Player[0].btnDo('hm');
            Player[0].sendAction('SELECTION', { look: Player[0].look });
            Player[0].sendAction('PHASE_CHANGE', { option: Player[0].option });
          Player[0].sendAction('PRE_OPT', { preOpt: 3 });
          }
        if (pos.x >= (tL/10)*harX && pos.x <= (tL/10)*(harX+aLH)   && //pHand right arrow button
            pos.y > (tH/10)*arY  && pos.y < (tH/10)*(arY+aLH)){
              if (Player[0].aMonster.length == 1){
              Player[0].preOpt = 3;
                Player[0].btnDo('hra');}
              Player[0].sendAction('SELECTION', { look: Player[0].look });
            Player[0].sendAction('PHASE_CHANGE', { option: Player[0].option });
          Player[0].sendAction('PRE_OPT', { preOpt: 3 });
          }
        if (pos.x >= (tL/10)*halX  && pos.x <= (tL/10)*(halX+aLH)   && //pHand left arrow button
            pos.y > (tH/10)*arY  && pos.y < (tH/10)*(arY+aLH)){
            Player[0].preOpt = 3;
              Player[0].btnDo('hla');
            Player[0].sendAction('SELECTION', { look: Player[0].look });
            Player[0].sendAction('PHASE_CHANGE', { option: Player[0].option });
        Player[0].sendAction('PRE_OPT', { preOpt: 3 });
          }
        /*
        //Foe buttons
        if (Player[1].option < 5){
          if (pos.x >= (tL/10)*4    && pos.x <= (tL/10)*6.25  && //fMonster menu visible f1
              pos.y > (tH/10)*0  && pos.y < (tH/10)*3.5 && Player[1].aMonster.length >0){//foe monster
            Player[0].option =0;
            Player[1].option = 3;
          }
          if (pos.x >= (tL/10)*6.8  && pos.x <= (tL/10)*9.1   && //fHand menu visible f3
              pos.y > (tH/10)*0 && pos.y < (tH/10)*3.5 && Player[1].hand.length > 0){
            Player[0].option = 0;
            Player[1].option = 1;
          }
        }*/
        break;
      case 4://Player Monster Examine
        if(pos.x >= (tL/10)*7 && pos.x <= (tL/10)*9  && //examine right arrow button
           pos.y > (tH/10)*4  && pos.y < (tH/10)*6){
          Player[0].btnDo('mra')
          Player[0].sendAction('SELECTION', { look: Player[0].look });
        }
        if(pos.x >= (tL/10)*1 && pos.x <= (tL/10)*3  && //examine left arrow button
           pos.y > (tH/10)*4  && pos.y < (tH/10)*6){
          Player[0].btnDo('mla')
          Player[0].sendAction('SELECTION', { look: Player[0].look });
        }
        if(pos.x >= (tL/10)*8.25 && pos.x <= (tL/10)*9.1 &&//exit from monster zoom
           pos.y > (tH/10)*0.5  && pos.y < (tH/10)*1.5){
          Player[0].btnDo('mec');
          cardIDO = 0;
        }
        break;
      case 5://Player ready state
        if(pos.x >= (tL/10)*1.7 && pos.x <= (tL/10)*2.5  &&//clicking the x cancels the ready state and sets A to -1
           pos.y > (tH/10)*5  && pos.y < (tH/10)*6){
          Player[0].btnDo('rex')
          Player[0].sendAction('SELECTION', { look: Player[0].look });
            Player[0].sendAction('PHASE_CHANGE', { option: Player[0].option });
        }
        break;
      }//end switch
  }//end player clicking
  //Player battle and after battle clicks
  if (Player[0].option >= 6){
    switch(Player[0].option){
      case 6:
        if ((Player[0].at >= 31&&Player[0].at <69)&& Player[1].option != 6.1){
          if(Player[0].battleOpponentId){
         Player[0].option = 5;Player[0].preOpt = 6;
          Player[0].sendAction('PHASE_CHANGE', { option: 5 });
          Player[0].sendAction('PRE_OPT', { preOpt: 6 });
          return;
          }
          else{
            Player[0].at = 69;
            return;
          }
        }
        break;
      case 6.6://Cultivate
      if(attacker == 1&&Player[0].battleOpponentId){return}
        if (Player[0].statPoints > 0){
          if (pos.x >= (tL/10)*7 && pos.x <= (tL/10)*8  &&//AGI
            pos.y > (tH/10)*8.5  && pos.y < (tH/10)*9.5){
              Player[0].aMonster[0].stat[eSTAT.A][eDICE.MOD]=Player[0].aMonster[0].stat[eSTAT.A][eDICE.MOD] + 1;
              Player[0].statPoints = Player[0].statPoints - 1;
              Player[0].sendAction('CULTIVATE', { s: 3 });
            return;
            }
          if (pos.x >= (tL/10)*2 && pos.x <= (tL/10)*3  &&//INT
            pos.y > (tH/10)*8.5  && pos.y < (tH/10)*9.5){
            Player[0].aMonster[0].stat[eSTAT.I][eDICE.MOD]=Player[0].aMonster[0].stat[eSTAT.I][eDICE.MOD] + 1;              
            Player[0].statPoints = Player[0].statPoints - 1;
            Player[0].sendAction('CULTIVATE', { s: 2 });
            return;
            }
          if (pos.x >= (tL/10)*7 && pos.x <= (tL/10)*8  &&//CON
            pos.y > (tH/10)*6  && pos.y < (tH/10)*7){
            Player[0].aMonster[0].stat[eSTAT.C][eDICE.MOD]=Player[0].aMonster[0].stat[eSTAT.C][eDICE.MOD] + 1;              
            Player[0].statPoints = Player[0].statPoints - 1;
            Player[0].sendAction('CULTIVATE', { s: 1 });
            return;
            }
          if (pos.x >= (tL/10)*2 && pos.x <= (tL/10)*3  &&//STR
            pos.y > (tH/10)*6  && pos.y < (tH/10)*7){
             Player[0].aMonster[0].stat[eSTAT.S][eDICE.MOD]=Player[0].aMonster[0].stat[eSTAT.S][eDICE.MOD] + 1;
              Player[0].statPoints = Player[0].statPoints - 1;
              Player[0].sendAction('CULTIVATE', { s: 0 });
              return;
            }
            
        }
        break;
      case 6.5://Protect Orb
        if (Player[0].at == 0){
          if (pos.x >= (tL/10)*1 && pos.x <= (tL/10)*4.5  &&//yes
              pos.y > (tH/10)*5  && pos.y < (tH/10)*7&&defender == 0){
            for (let i = 0; i < Player[0].aMonster.length; i++){
              if (Player[0].aMonster[i].index == 30 && Player[0].aMonster[i].effectTriggered == 0){
                Player[0].aMonster[i].effectTriggered = 1;
                Player[0].option =7;
                Player[1].option =7;
                Player[0].defStat = 2
                if(Player[0].battleOpponentId){
                  Player[0].sendAction('P_ORB',{ choice: 1 });
                }
              }
            }
          }
          
          if (pos.x >= (tL/10)*6 && pos.x <= (tL/10)*9 &&//no
              pos.y > (tH/10)*5  && pos.y < (tH/10)*7&&defender == 0){
            //if previous = defend 1 or 2
            for (let i = 0; i < Player[0].aMonster.length; i++){
              if (Player[0].aMonster[i].index == 30 && Player[0].aMonster[i].effectTriggered == 0){
                Player[0].aMonster[i].effectTriggered = 1;
                Player[0].option =7;
                Player[1].option =7;
                Player[0].defStat = 1;
                if(Player[0].battleOpponentId){
                  Player[0].sendAction('P_ORB',{ choice: 0 });
                }
              }
            }
          }
        }
        break;
      case 6.4://Scry
          //if foe is scrying return if clicking on player side
          if(pos.x > (tL/10)*0 && pos.x <= (tL/10)*10  &&
          pos.y > (tH/10)*5  && pos.y < (tH/10)*10&&attacker == 1){return}
          //if player scrying return if click on foe side
          if(pos.x > (tL/10)*0 && pos.x <= (tL/10)*10  &&
          pos.y > (tH/10)*0  && pos.y < (tH/10)*5&&attacker == 0){return}
        break;
      case 6.3://Alchemy
      if(attacker == 1&&Player[0].battleOpponentId){return}
        if (Player[0].hasScalesOfJustice == 2){
          if (pos.x >= (tL/10)*7 && pos.x <= (tL/10)*8  &&//AGI
            pos.y > (tH/10)*8.5  && pos.y < (tH/10)*9.5){
              Player[0].look[eLOOK.STAT] = eSTAT.A;
              Player[0].hasScalesOfJustice = 3;
              Player[0].sendAction('ALCHEMY',{ s: 3, soj:0 });
              return;
            }
          if (pos.x >= (tL/10)*2 && pos.x <= (tL/10)*3  &&//INT
            pos.y > (tH/10)*8.5  && pos.y < (tH/10)*9.5){
              Player[0].look[eLOOK.STAT] = eSTAT.I;
              Player[0].hasScalesOfJustice = 3;
              Player[0].sendAction('ALCHEMY',{ s: 2, soj:0 });
              return;
            }
          if (pos.x >= (tL/10)*7 && pos.x <= (tL/10)*8  &&//CON
            pos.y > (tH/10)*6  && pos.y < (tH/10)*7){
              Player[0].look[eLOOK.STAT] = eSTAT.C;
              Player[0].hasScalesOfJustice = 3;
              Player[0].sendAction('ALCHEMY',{ s: 1, soj:0 });
              return;
            }
          if (pos.x >= (tL/10)*2 && pos.x <= (tL/10)*3  &&//STR
            pos.y > (tH/10)*6  && pos.y < (tH/10)*7){
              Player[0].look[eLOOK.STAT] = eSTAT.S;
              Player[0].hasScalesOfJustice = 3;
              Player[0].sendAction('ALCHEMY',{ s: 0, soj:0 });
              return;
            }
            
        }
        if (Player[0].hasScalesOfJustice == 3){
          if (pos.x >(tL/10)*2 && pos.x <(tL/10)*3  &&//AGI
            pos.y > (tH/10)*.5  && pos.y < (tH/10)*1.5){
              Player[1].look[eLOOK.STAT] = eSTAT.A;
              Player[0].hasScalesOfJustice = 4;
              Player[0].preOpt = 6.3;
              Player[1].preOpt = 6.3;
              Player[0].sendAction('ALCHEMY',{ s: 3, soj:1 });
            }
          if (pos.x >(tL/10)*7 && pos.x <(tL/10)*8  &&//INT
            pos.y > (tH/10)*.5  && pos.y < (tH/10)*1.5){
              Player[1].look[eLOOK.STAT] = eSTAT.I;
              Player[0].hasScalesOfJustice = 4;
              Player[0].preOpt = 6.3;
              Player[1].preOpt = 6.3;
              Player[0].sendAction('ALCHEMY',{ s: 2, soj:1 });
            }
          if (pos.x >= (tL/10)*2 && pos.x <= (tL/10)*3  &&//CON
            pos.y > (tH/10)*3  && pos.y < (tH/10)*4){
              Player[1].look[eLOOK.STAT] = eSTAT.C;
              Player[0].hasScalesOfJustice = 4;
              Player[0].preOpt = 6.3;
              Player[1].preOpt = 6.3;
              Player[0].sendAction('ALCHEMY',{ s: 1, soj:1 });
            }
          if (pos.x >= (tL/10)*7 && pos.x <= (tL/10)*8  &&//STR
            pos.y > (tH/10)*3  && pos.y < (tH/10)*4){
              Player[1].look[eLOOK.STAT] = eSTAT.S;
              Player[0].hasScalesOfJustice = 4;
              Player[0].preOpt = 6.3;
              Player[1].preOpt = 6.3;
              Player[0].sendAction('ALCHEMY',{ s: 0, soj:1 });
            }
            
        }
        break;
      case 6.2://Winged Boots
        if (Player[0].at == 0){
          if (pos.x >= (tL/10)*1 && pos.x <= (tL/10)*4.5  &&//yes
              pos.y > (tH/10)*5  && pos.y < (tH/10)*7&&defender == 0){
            
            for (let i = 0; i < Player[0].aMonster.length; i++){
              if (Player[0].aMonster[i].index == 7 && Player[0].aMonster[i].effectTriggered == 0){
                Player[0].aMonster[i].effectTriggered = 1;
                Player[0].defStat = 3
                Player[0].option =7;
                Player[1].option =7;
                if(Player[0].battleOpponentId){
                  Player[0].sendAction('W_BOOT',{ choice: 1 });
                }
              }
            }
          }
          
          if (pos.x >= (tL/10)*6 && pos.x <= (tL/10)*9 &&//no
              pos.y > (tH/10)*5  && pos.y < (tH/10)*7&&defender == 0){
            
            //if previous = defend 1 or 2
            for (let i = 0; i < Player[0].aMonster.length; i++){
              if (Player[0].aMonster[i].index == 7 && Player[0].aMonster[i].effectTriggered == 0){
                Player[0].aMonster[i].effectTriggered = 1;
                Player[0].defStat = 1;
                Player[0].option =7;
                Player[1].option =7;
                if(Player[0].battleOpponentId){
                Player[0].sendAction('W_BOOT',{ choice: 0 });
                }
              }
            }
          }
        }
        break;
      case 6.1://Star Pendant   
        if (pos.x > (tL/10)*1 && pos.x < (tL/10)*4.5  &&//yes
            pos.y > (tH/10)*5 && pos.y < (tH/10)*8&&Player[1].option == 6.11){
          for (let i = 0; i < Player[0].aMonster.length; i++){
            if (Player[0].aMonster[i].index == 17 && Player[0].aMonster[i].effectTriggered == 0){
              Player[0].ax = 0;
              Player[0].ay = 0;
              Player[0].az = 0;
              Player[0].at = 0
              Player[0].aMonster[i].effectTriggered = 1;
              Player[0].option = 7; 
              Player[1].option = 7
              Player[0].hasReroll = 1;
              if(Player[0].battleOpponentId){
              Player[0].rollSent = 0;
              Player[0].sendAction('REROLL',{ choice: 1 });
              }

             
              return;
            }
          }
        }
        if (pos.x >= (tL/10)*6 && pos.x <= (tL/10)*9 &&//no
            pos.y > (tH/10)*5  && pos.y < (tH/10)*8&&Player[1].option == 6.11){
              //if previous = defend 1 or 2
          for (let i = 0; i < Player[0].aMonster.length; i++){
            if (Player[0].aMonster[i].index == 17 && Player[0].aMonster[i].effectTriggered == 0){
              Player[0].aMonster[i].effectTriggered = 1;
              Player[0].option = 7; 
              Player[1].option = 7
              if(Player[0].battleOpponentId){
              Player[0].sendAction('REROLL',{ choice: 0});
              }
              return;
            }
          }
        }
      break; 
      case 7://combat
        //atk defend
        if ((Player[0].at >= 31&&Player[0].at <69)&&Player[1].option != 6.1 && Player[1].option != 6.2&& Player[1].option != 6.3&&Player[1].opponent.option != 6.5&& Player[1].opponent.option != 6.4&& Player[1].opponent.option != 6.6){
          if(Player[0].battleOpponentId){
           Player[0].option = 5;Player[0].preOpt = 7;
            Player[0].sendAction('PHASE_CHANGE', { option: 5 });
            Player[0].sendAction('PRE_OPT', { preOpt: 7 });
            return;
          }
          else{
            Player[0].at = 69;
            return;
          }
        }
        //spell defend
        if ((Player[0].at >= 101&&Player[0].at <139)&&Player[1].option != 6.1 && Player[1].option != 6.2&& Player[1].option != 6.3&&Player[1].opponent.option != 6.5&& Player[1].opponent.option != 6.4&& Player[1].opponent.option != 6.6){
          if(Player[0].battleOpponentId){
           Player[0].option = 5;Player[0].preOpt = 7;
            Player[0].sendAction('PHASE_CHANGE', { option: 5 });
            Player[0].sendAction('PRE_OPT', { preOpt: 7 });
            return;
          }
          else{
            Player[0].at = 139;
            return;
          }
         }
         
        if (pos.x > (tL/10)*1.5 && pos.x <= (tL/10)*3.88  &&//yes
          pos.y > (tH/10)*5.5  && pos.y < (tH/10)*10&&attacker == 0){
            if (Player[0].hasTreasureChest == 1){
              Player[0].hasTreasureChest = 2;
              Player[0].sendAction('TREASURE',{ choice: 0 });
            
            }
            
            return;
        }
        if (pos.x > (tL/10)*6 && pos.x <= (tL/10)*8.25 &&//no
            pos.y > (tH/10)*5.5  && pos.y < (tH/10)*10&&attacker == 0){
            if (Player[0].hasTreasureChest == 1){
              Player[0].hasTreasureChest = 3;
              Player[0].sendAction('TREASURE',{ choice: 1 });
            }
            return;
        }
         break;
      case 8://rune select
        let noneOnTable = 0;
        if (sRune.owner != 2){noneOnTable = noneOnTable+ 1};
        if (cRune.owner != 2){noneOnTable = noneOnTable+ 1};
        if (iRune.owner != 2){noneOnTable = noneOnTable+ 1};
        if (aRune.owner != 2){noneOnTable = noneOnTable+ 1};
        //str rune
        if(pos.x >= (tL/10)*1.5 && pos.x <= (tL/10)*2.6  &&//take STR rune from table
           pos.y > (tH/10)*4.5  && pos.y < (tH/10)*5.5 && sRune.owner == 2){
          if (Player[1].option == 8.1){
            Player[0].at = 1;
            Player[0].look[eLOOK.S] = eSTAT.S;
            Player[0].sendAction('SYNC_TIMER', { at: 1 });
            Player[0].sendAction('SELECTION', { look: Player[0].look });
            MusicEngine.playSFX('heal');
          }
          else if (Player[1].option == 8.2&&!Player[1].battleOpponentId){
            Player[1].at = 1;
            Player[1].look[eLOOK.S] = eSTAT.S;
            Player[0].sendAction('SYNC_TIMER', { at: 1 });
            Player[0].sendAction('SELECTION', { look: Player[0].look });
            MusicEngine.playSFX('heal');
          }
          if(startGame != 'battle'){startGame = 4;}
        }
        else if(pos.x >= (tL/10)*5.9 && pos.x <= (tL/10)*6.9  &&//take STR rune from foe
                pos.y > (tH/10)*2.5  && pos.y < (tH/10)*3.5 && sRune.owner == 1&& noneOnTable == 4){
          if (Player[1].option == 8.1){
            Player[0].at = 1;
            Player[0].look[eLOOK.S] = eSTAT.S;
            Player[0].sendAction('SYNC_TIMER', { at: 1 });
            Player[0].sendAction('SELECTION', { look: Player[0].look });
            MusicEngine.playSFX('heal');
          }
          else if (Player[1].option == 8.2&&!Player[1].battleOpponentId){
            Player[1].at = 1;
            Player[1].look[eLOOK.S] = eSTAT.S;
            Player[0].sendAction('SYNC_TIMER', { at: 1 });
            Player[0].sendAction('SELECTION', { look: Player[0].look });
            MusicEngine.playSFX('heal');
          }
          if(startGame != 'battle'){startGame = 4;}
        }
        //con rune
        else if(pos.x >= (tL/10)*7.5 && pos.x <= (tL/10)*8.6  &&//take CON rune from table
                pos.y > (tH/10)*4.5  && pos.y < (tH/10)*5.5 && cRune.owner == 2){
           if (Player[1].option == 8.1){
            Player[0].at = 1;
            Player[0].look[eLOOK.S] = eSTAT.C;
            Player[0].sendAction('SYNC_TIMER', { at: 1 });
            Player[0].sendAction('SELECTION', { look: Player[0].look });
            MusicEngine.playSFX('heal');
          }
          else if (Player[1].option == 8.2&&!Player[1].battleOpponentId){
            Player[1].at = 1;
            Player[1].look[eLOOK.S] = eSTAT.C;
            Player[0].sendAction('SYNC_TIMER', { at: 1 });
            MusicEngine.playSFX('heal');
          }
          if(startGame != 'battle'){startGame = 4;}
        }
        //con rune
        else if(pos.x >= (tL/10)*3 && pos.x <= (tL/10)*4  &&//take CON rune from foe
                pos.y > (tH/10)*2.5  && pos.y < (tH/10)*3.5 && cRune.owner == 1&& noneOnTable == 4){
          if (Player[1].option == 8.1){
            Player[0].at = 1;
            Player[0].look[eLOOK.S] = eSTAT.C;
            Player[0].sendAction('SYNC_TIMER', { at: 1 });
            Player[0].sendAction('SELECTION', { look: Player[0].look });
            MusicEngine.playSFX('heal');
          }
          else if (Player[1].option == 8.2&&!Player[1].battleOpponentId){
            Player[1].at = 1;
            Player[1].look[eLOOK.S] = eSTAT.C;
            Player[0].sendAction('SYNC_TIMER', { at: 1 });
            Player[0].sendAction('SELECTION', { look: Player[0].look });
            MusicEngine.playSFX('heal');
          }
          if(startGame != 'battle'){startGame = 4;}}
        //int rune
        else if(pos.x >= (tL/10)*3.5 && pos.x <= (tL/10)*4.6  &&//take int rune from table
                pos.y > (tH/10)*4.5  && pos.y < (tH/10)*5.5 && iRune.owner == 2){
          if (Player[1].option == 8.1){
            Player[0].at = 1;
            Player[0].look[eLOOK.S] = eSTAT.I;
            Player[0].sendAction('SYNC_TIMER', { at: 1 });
            Player[0].sendAction('SELECTION', { look: Player[0].look });
            MusicEngine.playSFX('heal');
          }
          else if (Player[1].option == 8.2&&!Player[1].battleOpponentId){
            Player[1].at = 1;
            Player[1].look[eLOOK.S] = eSTAT.I;
            Player[0].sendAction('SYNC_TIMER', { at: 1 });
            Player[0].sendAction('SELECTION', { look: Player[0].look });
            MusicEngine.playSFX('heal');
          }
          if(startGame != 'battle'){startGame = 4;}
        }
        else if(pos.x >= (tL/10)*5.9 && pos.x <= (tL/10)*6.9  &&//take int rune from foe
                pos.y > (tH/10)*0  && pos.y < (tH/10)*1 && iRune.owner == 1&& noneOnTable == 4){
          if (Player[1].option == 8.1){
            Player[0].at = 1;
            Player[0].look[eLOOK.S] = eSTAT.I;
            Player[0].sendAction('SYNC_TIMER', { at: 1 });
            Player[0].sendAction('SELECTION', { look: Player[0].look });
            MusicEngine.playSFX('heal');
          }
          else if (Player[1].option == 8.2&&!Player[1].battleOpponentId){
            Player[1].at = 1;
            Player[1].look[eLOOK.S] = eSTAT.I;
            Player[0].sendAction('SYNC_TIMER', { at: 1 });
            Player[0].sendAction('SELECTION', { look: Player[0].look });
            MusicEngine.playSFX('heal');
          }
          if(startGame != 'battle'){startGame = 4;}
        }
        //agi rune
        else if(pos.x >= (tL/10)*5.5 && pos.x <= (tL/10)*6.6  &&//take agi rune from table
                pos.y > (tH/10)*4.5  && pos.y < (tH/10)*5.5 && aRune.owner == 2){
          if (Player[1].option == 8.1){
          Player[0].at = 1;
          Player[0].look[eLOOK.S] = eSTAT.A;
          Player[0].sendAction('SYNC_TIMER', { at: 1 });
          Player[0].sendAction('SELECTION', { look: Player[0].look });
                    MusicEngine.playSFX('heal');

            }
            else if (Player[1].option == 8.2&&!Player[1].battleOpponentId){
              Player[1].at = 1;
              Player[1].look[eLOOK.S] = eSTAT.A;
              Player[0].sendAction('SYNC_TIMER', { at: 1 });
          Player[0].sendAction('SELECTION', { look: Player[0].look });
                    MusicEngine.playSFX('heal');

            }
          if(startGame != 'battle'){
          startGame = 4;}
        }
        else if(pos.x >= (tL/10)*3 && pos.x <= (tL/10)*4  &&//take agi rune from foe
                pos.y > (tH/10)*0  && pos.y < (tH/10)*1 && aRune.owner == 1&& noneOnTable == 4){
          if (Player[1].option == 8.1){
          Player[0].at = 1;
          Player[0].look[eLOOK.S] = eSTAT.A;
          Player[0].sendAction('SYNC_TIMER', { at: 1 });
          Player[0].sendAction('SELECTION', { look: Player[0].look });
                    MusicEngine.playSFX('heal');

            }
            else if (Player[1].option == 8.2&&!Player[1].battleOpponentId){
              Player[1].at = 1;
              Player[1].look[eLOOK.S] = eSTAT.A;
              Player[0].sendAction('SYNC_TIMER', { at: 1 });
          Player[0].sendAction('SELECTION', { look: Player[0].look });
                    MusicEngine.playSFX('heal');

            }
          if(startGame != 'battle'){
          startGame = 4;}
        }
        break;
    }
  }
  
  //Foe clicks
  //if cpu only allow examine field
  if (Player[1].isCPU == 1){//CPU
    switch(Player[1].option){
      case 0:
        if (pos.x >= (tL/10)*(10-marX-aLH) && pos.x <= (tL/10)*(10-marX)   && //fMon right arrow button
            pos.y > (tH/10)*(10-arY-cH)  && pos.y < (tH/10)*(10-arY)){
            Player[1].btnDo('mra');
        }
        if (pos.x >= (tL/10)*(10-malX-aLH)  && pos.x <= (tL/10)*(10-aLH)  && //fMon left arrow button
            pos.y > (tH/10)*(10-arY-aLH)  && pos.y < (tH/10)*(10-arY)){
            Player[1].btnDo('mla')
        }
        if (pos.x >= (tL/10)* (10-mX-cL)   && pos.x <= (tL/10)*(10-mX)  && //fMonster menu visible 3
            pos.y > (tH/10)*(10-cY-cH)  && pos.y < (tH/10)*(10-cY)){
            Player[1].btnDo('mmo')
        } 
        break;
      case 3:
      if (pos.x <= (tL/10)*(mX-cL)    || pos.x >= (tL/10)*(mX)  || //fMonster menu close p0
          pos.y < (tH/10)*(10-cY-cH)  || pos.y > (tH/10)*(cY)){
          Player[1].btnDo('mc')
        }
        if (pos.x >= (tL/10)*(10-meX-actLH)    && pos.x <= (tL/10)*(10-meX)  && //fMonster examine click p4
            pos.y > (tH/10)*(10-actY-actLH)   && pos.y < (tH/10)*(10-actY)){
            Player[1].btnDo('me')
        }
        if (pos.x >= (tL/10)*(10-marX-aLH) && pos.x <= (tL/10)*(10-marX)   && //fMon right arrow button
            pos.y > (tH/10)*(10-arY-aLH)  && pos.y < (tH/10)*(10-arY)){
            Player[1].btnDo('mra');
        }
        if (pos.x >= (tL/10)*(10-malX-aLH)  && pos.x <= (tL/10)*(10-aLH)  && //fMon left arrow button
            pos.y > (tH/10)*(10-arY-aLH)  && pos.y < (tH/10)*(10-arY)){
            Player[1].btnDo('mla')
        }
    break;
      case 4:
        if (pos.x >= (tL/10)*7 && pos.x <= (tL/10)*9  && //examine right arrow button
            pos.y > (tH/10)*4  && pos.y < (tH/10)*6){
            Player[1].btnDo('mra')
        }
        if (pos.x >= (tL/10)*1 && pos.x <= (tL/10)*3  && //examine left arrow button
            pos.y > (tH/10)*4  && pos.y < (tH/10)*6){
            Player[1].btnDo('mla')
        }
        if(pos.x >= (tL/10)*8.25 && pos.x <= (tL/10)*9.1 &&//exit from monster zoom
           pos.y > (tH/10)*0.5  && pos.y < (tH/10)*1.5){
            Player[1].btnDo('mec')
            cardIDO = 0;
        }
    }
  }
  
  if(Player[1].isCPU === 0&&!Player[0].battleOpponentId){//HUMAN
    //FOE NON BATTLE CLICKS
    if (Player[0].option != 2 && Player[0].option != 4 && Player[0].option < 6 && Player[0].draw == 0 && Player[1].draw == 0) {
      switch(Player[1].option){//FOE SIDE CLICKING
        case 0://Initiate Click Menus and Buttons
        if (pos.x >= (tL/10)*(10-hX-cL)   && pos.x <= (tL/10)*(10-hX)  && //fHand menu visible 1
            pos.y > (tH/10)*(10-cY-cH) && pos.y < (tH/10)*(10-cY) ){
            Player[1].btnDo('hm');
        }
        if (pos.x >= (tL/10)*(10-harX-aLH) && pos.x <= (tL/10)*(10-harX)   && //fHand right arrow button
            pos.y > (tH/10)*(10-arY-aLH)  && pos.y < (tH/10)*(10-arY)){
            Player[1].btnDo('hra');
            return;
        }
        if (pos.x >= (tL/10)*(10-halX-aLH)  && pos.x <= (tL/10)*(10-halX)   && //fHand left arrow button
            pos.y > (tH/10)*(10-arY-aLH)  && pos.y < (tH/10)*(10-arY)){
            Player[1].btnDo('hla');
            return;
        }
        if (pos.x >= (tL/10)*(10-marX-aLH) && pos.x <= (tL/10)*(10-marX)   && //fMon right arrow button
            pos.y > (tH/10)*(10-arY-cH)  && pos.y < (tH/10)*(10-arY)){
            Player[1].btnDo('mra');
        }
        if (pos.x >= (tL/10)*(10-malX-aLH)  && pos.x <= (tL/10)*(10-aLH)  && //fMon left arrow button
            pos.y > (tH/10)*(10-arY-aLH)  && pos.y < (tH/10)*(10-arY)){
            Player[1].btnDo('mla')
        }
        if (pos.x >= (tL/10)* (10-mX-cL)   && pos.x <= (tL/10)*(10-mX)  && //fMonster menu visible 3
            pos.y > (tH/10)*(10-cY-cH)  && pos.y < (tH/10)*(10-cY)){
            Player[1].btnDo('mmo')
        } 
        break;
        case 1://Foe Hand Menu Visible
        //non redundant buttons
        if (pos.x <= (tL/10)*(10-hX-cL)    || pos.x >= (tL/10)*(10-hX) || //pHand menu close 0
            pos.y < (tH/10)*(10-cY-cH) || pos.y > (tH/10)*(10-cY)){
            Player[1].btnDo('mc')
        }
        if (pos.x >= (tL/10)*(10-heX-actLH)  && pos.x <= (tL/10)*(10-heX) && //pHand examine 2
            pos.y > (tH/10)*(10-actY-actLH)  && pos.y < (tH/10)*(10-actY)){
            Player[1].btnDo('hex')
        }
        if (pos.x >= (tL/10)*(10-huX-actLH) && pos.x <= (tL/10)*(10-huX) && //pHand use 5
            pos.y > (tH/10)*(10-actY-actLH)  && pos.y < (tH/10)*(10-actY)){
            Player[1].btnDo('use')
        }
        //redundant
        if (pos.x >= (tL/10)*(10-harX-aLH) && pos.x <= (tL/10)*(10-harX)   && //fHand right arrow button
            pos.y > (tH/10)*(10-arY-aLH)  && pos.y < (tH/10)*(10-arY)){
            Player[1].btnDo('hra');
            return;
        }
        if (pos.x >= (tL/10)*(10-halX-aLH)  && pos.x <= (tL/10)*(10-halX)   && //fHand left arrow button
            pos.y > (tH/10)*(10-arY-aLH)  && pos.y < (tH/10)*(10-arY)){
            Player[1].btnDo('hla');
            return;
        }
        if (pos.x >= (tL/10)*(10-marX-aLH) && pos.x <= (tL/10)*(10-marX)   && //fMon right arrow button
            pos.y > (tH/10)*(10-arY-aLH)  && pos.y < (tH/10)*(10-arY)){
            Player[1].btnDo('mra');
        }
        if (pos.x >= (tL/10)*(10-malX-aLH)  && pos.x <= (tL/10)*(10-aLH)  && //fMon left arrow button
            pos.y > (tH/10)*(10-arY-aLH)  && pos.y < (tH/10)*(10-arY)){
            Player[1].btnDo('mla')
        }
        if (pos.x >= (tL/10)* (10-mX-cL)   && pos.x <= (tL/10)*(10-mX)  && //fMonster menu visible 3
            pos.y > (tH/10)*(10-cY-cH)  && pos.y < (tH/10)*(10-cY)){
            Player[1].btnDo('mmo')
        } 
       
        break;
        case 2://Foe Hand Examine
        if (pos.x >= (tL/10)*7  && pos.x <= (tL/10)*9  && //examine right arrow button
            pos.y > (tH/10)*4  && pos.y < (tH/10)*6){
            
            Player[1].btnDo('hla')
        }
        if (pos.x >= (tL/10)*1  && pos.x <= (tL/10)*3  && //examine left arrow button
            pos.y > (tH/10)*4  && pos.y < (tH/10)*6){
            Player[1].btnDo('hra')
        }
        if(pos.x >= (tL/10)*8.25 && pos.x <= (tL/10)*9.1 &&//exit from monster zoom
           pos.y > (tH/10)*0.5  && pos.y < (tH/10)*1.5){
            Player[1].btnDo('hec')
            cardIDO = 0;
            
        }
        break;
        case 3://Foe Monster Menu
          //non redundant buttons
          if (pos.x <= (tL/10)*(10-mX-cL)    || pos.x >= (tL/10)*(10-mX)  || //fMonster menu close p0
              pos.y < (tH/10)*(10-cY-cH)  || pos.y > (tH/10)*(10-cY)){
              Player[1].btnDo('mc')
          }
          if (pos.x >= (tL/10)*(10-meX-actLH)    && pos.x <= (tL/10)*(10-meX)  && //fMonster examine click p4
              pos.y > (tH/10)*(10-actY-actLH)   && pos.y < (tH/10)*(10-actY)){
              Player[1].btnDo('me')
          }
          if (pos.x >= (tL/10)*(10-maX-actLH)    && pos.x <= (tL/10)*(10-maX)  && //fMonster attack click p6
              pos.y > (tH/10)*(10-actY-actLH)   && pos.y < (tH/10)*(10-actY)){
              Player[1].btnDo('atk')
          }
        
          //redundant buttons
          if (pos.x >= (tL/10)*(10-hX-cL)   && pos.x <= (tL/10)*(10-hX)  && //fHand menu visible 1
              pos.y > (tH/10)*(10-cY-cH) && pos.y < (tH/10)*(10-cY) ){
              Player[1].btnDo('hm');
          }
          if (pos.x >= (tL/10)*(10-harX-aLH) && pos.x <= (tL/10)*(10-harX)   && //fHand right arrow button
              pos.y > (tH/10)*(10-arY-aLH)  && pos.y < (tH/10)*(10-arY)){
              Player[1].btnDo('hra');
              return;
          }
          if (pos.x >= (tL/10)*(10-halX-actLH)  && pos.x <= (tL/10)*(10-halX)   && //fHand left arrow button
              pos.y > (tH/10)*(10-arY-aLH)  && pos.y < (tH/10)*(10-arY)){
              Player[1].btnDo('hla');
              return;
          }
          if (pos.x >= (tL/10)*(10-marX-aLH) && pos.x <= (tL/10)*(10-marX)   && //fMon right arrow button
              pos.y > (tH/10)*(10-arY-aLH)  && pos.y < (tH/10)*(10-arY)){
              Player[1].btnDo('mra');
          }
          if (pos.x >= (tL/10)*(10-malX-aLH)  && pos.x <= (tL/10)*(10-aLH)  && //fMon left arrow button
              pos.y > (tH/10)*(10-arY-aLH)  && pos.y < (tH/10)*(10-arY)){
              Player[1].btnDo('mla')
          }
        break;
        case 4://Foe Monster Examine
          if(pos.x >= (tL/10)*7 && pos.x <= (tL/10)*9  && //m examine right arrow button
            pos.y > (tH/10)*4  && pos.y > (tH/10)*4){
              Player[1].btnDo('mla')
              
          }
          if(pos.x >= (tL/10)*1 && pos.x <= (tL/10)*3  && //m examine left arrow button
            pos.y > (tH/10)*4  && pos.y < (tH/10)*6){
              Player[1].btnDo('mra')
          }
          if(pos.x >= (tL/10)*8.25 && pos.x <= (tL/10)*9.1 &&//exit from monster zoom
           pos.y > (tH/10)*0.5  && pos.y < (tH/10)*1.5){
              Player[1].btnDo('mec')
              cardIDO = 0;
          }
        break;
        case 5://Foe ready state active
          if (pos.x >= (tL/10)*7.5 && pos.x <= (tL/10)*8.5  && //exit ready
              pos.y > (tH/10)*4  && pos.y < (tH/10)*5){
             Player[1].btnDo('rex')
          }
        break
      }//end switch
    }//end foe clicking
    //FOE BATTLE and POST BATTLE CLICKS 
    if (Player[1].option >= 6&&!Player[0].battleOpponentId){
      switch(Player[1].option){
        case 6:
          break;
        case 6.6: //Cultivate
          if (Player[1].statPoints > 0){
            if (pos.x >(tL/10)*2 && pos.x <(tL/10)*3  &&//AGI
                pos.y > (tH/10)*.5  && pos.y < (tH/10)*1.5){
                Player[1].aMonster[0].stat[eSTAT.A][eDICE.MOD]=Player[1].aMonster[0].stat[eSTAT.A][eDICE.MOD] + 1;

                Player[1].statPoints = Player[1].statPoints - 1;
              return;
              }
            if (pos.x >(tL/10)*7 && pos.x <(tL/10)*8  &&//INT
                pos.y > (tH/10)*.5  && pos.y < (tH/10)*1.5){
                Player[1].aMonster[0].stat[eSTAT.I][eDICE.MOD]=Player[1].aMonster[0].stat[eSTAT.I][eDICE.MOD] + 1;
                Player[1].statPoints = Player[1].statPoints - 1;
              return;
              }
            if (pos.x >= (tL/10)*2 && pos.x <= (tL/10)*3  &&//CON
                pos.y > (tH/10)*3  && pos.y < (tH/10)*4){
                Player[1].aMonster[0].stat[eSTAT.C][eDICE.MOD]=Player[1].aMonster[0].stat[eSTAT.C][eDICE.MOD] + 1;
                Player[1].statPoints = Player[1].statPoints - 1;
              return;
              }
            if (pos.x >= (tL/10)*7 && pos.x <= (tL/10)*8  &&//STR
                pos.y > (tH/10)*3  && pos.y < (tH/10)*4){
                Player[1].aMonster[0].stat[eSTAT.S][eDICE.MOD]=Player[1].aMonster[0].stat[eSTAT.S][eDICE.MOD] + 1;
                Player[1].statPoints = Player[1].statPoints - 1;
                return;
              }
              
          }
          break;
        case 6.5://Protect Orb
          if (Player[0].at == 0){
            if (pos.x < (tL/10)*8 && pos.x > (tL/10)*6 &&//yes
                pos.y < (tH/10)*4.5  && pos.y > (tH/10)*3&&defender == 1){
              Player[1].defStat = 2
              for (let i = 0; i < Player[1].aMonster.length; i++){
                if (Player[1].aMonster[i].index == 30 && Player[1].aMonster[i].effectTriggered == 0){
                  Player[1].aMonster[i].effectTriggered = 1;
                  Player[0].option =7;
                  Player[1].option =7;
                }
              }
            }
            if (pos.x < (tL/10)*4 && pos.x >= (tL/10)*2 &&//no
                pos.y < (tH/10)*4.5  && pos.y > (tH/10)*3&&defender == 1){
              Player[1].defStat = 1;
              //if previous = defend 1 or 2
              if (Player[1].hasWingedBoots == 1){
                for (let i = 0; i < Player[1].aMonster.length; i++){
                  if (Player[1].aMonster[i].index == 30 && Player[1].aMonster[i].effectTriggered == 0){
                    Player[0].option =7;
                    Player[1].option =7;
                  }
                }
              } 
            }
            
          }
        break;
        case 6.4:
        break;
        case 6.3://Alchemy
          if (Player[1].hasScalesOfJustice == 2){
            if (pos.x >(tL/10)*2 && pos.x <(tL/10)*3  &&//AGI
              pos.y > (tH/10)*.5  && pos.y < (tH/10)*1.5){
                Player[1].look[eLOOK.STAT] = eSTAT.A;
                Player[1].hasScalesOfJustice = 3;
              return;
              }
            if (pos.x >(tL/10)*7 && pos.x <(tL/10)*8  &&//INT
              pos.y > (tH/10)*.5  && pos.y < (tH/10)*1.5){
                Player[1].look[eLOOK.STAT] = eSTAT.I;
                Player[1].hasScalesOfJustice = 3;
              return;
              }
            if (pos.x >= (tL/10)*2 && pos.x <= (tL/10)*3  &&//CON
              pos.y > (tH/10)*3  && pos.y < (tH/10)*4){
                Player[1].look[eLOOK.STAT] = eSTAT.C;
                Player[1].hasScalesOfJustice = 3;
              return;
              }
            if (pos.x >= (tL/10)*7 && pos.x <= (tL/10)*8  &&//STR
              pos.y > (tH/10)*3  && pos.y < (tH/10)*4){
                Player[1].look[eLOOK.STAT] = eSTAT.S;
                Player[1].hasScalesOfJustice = 3;
                return;
              }
              
          }
          if (Player[1].hasScalesOfJustice == 3){
            if (pos.x >= (tL/10)*7 && pos.x <= (tL/10)*8  &&//AGI
              pos.y > (tH/10)*8.5  && pos.y < (tH/10)*9.5){
                Player[0].look[eLOOK.STAT] = eSTAT.A;
                Player[1].hasScalesOfJustice = 4;
              Player[1].option = Player[1].preOpt
              }
            if (pos.x >= (tL/10)*2 && pos.x <= (tL/10)*3  &&//INT
              pos.y > (tH/10)*8.5  && pos.y < (tH/10)*9.5){
                Player[0].look[eLOOK.STAT] = eSTAT.I;
                Player[1].hasScalesOfJustice = 4;
              Player[1].option = Player[1].preOpt
              }
            if (pos.x >= (tL/10)*7 && pos.x <= (tL/10)*8  &&//CON
              pos.y > (tH/10)*6  && pos.y < (tH/10)*7){
                Player[0].look[eLOOK.STAT] = eSTAT.C;
                Player[1].hasScalesOfJustice = 4;
              Player[1].option = Player[1].preOpt
              }
            if (pos.x >= (tL/10)*2 && pos.x <= (tL/10)*3  &&//STR
              pos.y > (tH/10)*6  && pos.y < (tH/10)*7){
                Player[0].look[eLOOK.STAT] = eSTAT.S;
                Player[1].hasScalesOfJustice = 4;
              Player[1].option = Player[1].preOpt
              }
              
          }
        break;
        case 6.2://Winged Boots
          if (Player[0].at == 0){
            if (pos.x < (tL/10)*8 && pos.x > (tL/10)*6 &&//yes
                pos.y < (tH/10)*4.5  && pos.y > (tH/10)*3&&defender == 1){
              Player[1].defStat = 3
              for (let i = 0; i < Player[1].aMonster.length; i++){
                if (Player[1].aMonster[i].index == 7 && Player[1].aMonster[i].effectTriggered == 0){
                  Player[1].aMonster[i].effectTriggered = 1;
                  Player[0].option =7;
                  Player[1].option =7;
                }
              }
            }
            if (pos.x < (tL/10)*4 && pos.x >= (tL/10)*2 &&//no
                pos.y < (tH/10)*4.5  && pos.y > (tH/10)*3&&defender == 1){
              Player[1].defStat = 1;
              //if previous = defend 1 or 2
              if (Player[1].hasWingedBoots == 1){
                for (let i = 0; i < Player[1].aMonster.length; i++){
                  if (Player[1].aMonster[i].index == 7 && Player[1].aMonster[i].effectTriggered == 0){
                    Player[0].option =7;
                    Player[1].option =7;
                  }
                }
              } 
            }
          }
          break;
        case 6.12://Star Pendant
          if (pos.x > (tL/10)*6 && pos.x < (tL/10)*7.5  &&//yes
              pos.y > (tH/10)*3 && pos.y < (tH/10)*4.5){
            for (let i = 0; i < Player[1].aMonster.length; i++){
              if (Player[1].aMonster[i].index == 17 && Player[1].aMonster[i].effectTriggered == 0){
                Player[0].ax = 0;
                Player[0].ay = 0;
                Player[0].az = 0;
                Player[0].at = 0
                Player[1].aMonster[i].effectTriggered = 1;
                Player[1].hasReroll = 1;
                Player[0].option = 7; 
                Player[1].option = 7
              }
            }
          
            }
          if (pos.x > (tL/10)*2.5 && pos.x < (tL/10)*4  &&//no
              pos.y > (tH/10)*3 && pos.y < (tH/10)*4.5){
              //if previous = defend 1 or 2
                for (let i = 0; i < Player[1].aMonster.length; i++){
                  if (Player[1].aMonster[i].index == 17 && Player[1].aMonster[i].effectTriggered == 0){
                    Player[1].aMonster[i].effectTriggered = 1;
                    Player[0].option = 7; 
                    Player[1].option = 7
                  }
                }
          }
        break;
        case 7://combat
        if (pos.x < (tL/10)*8 && pos.x > (tL/10)*7  &&//yes
              pos.y < (tH/10)*4.5  && pos.y > (tH/10)*3.5&&attacker == 1){
            if (Player[1].hasTreasureChest == 1){Player[1].hasTreasureChest = 2}
            return;
        }
        if (pos.x < (tL/10)*3.5 && pos.x > (tL/10)*2.5  &&//no
              pos.y < (tH/10)*4.5  && pos.y > (tH/10)*3.5&&attacker == 1){
            if (Player[1].hasTreasureChest == 1){Player[1].hasTreasureChest = 3}
            return;
        }
          break;
        case 8.2://rune select
          let noneOnTable = 0;
          if (sRune.owner != 2){noneOnTable = noneOnTable+ 1};
          if (cRune.owner != 2){noneOnTable = noneOnTable+ 1};
          if (iRune.owner != 2){noneOnTable = noneOnTable+ 1};
          if (aRune.owner != 2){noneOnTable = noneOnTable+ 1};
          
          //str rune
          if (pos.x >= (tL/10)*1.5 && pos.x <= (tL/10)*2.6  &&//take STR rune from table
              pos.y > (tH/10)*4.5  && pos.y < (tH/10)*5.5 && sRune.owner == 2 ){
            Player[0].at = 1;
            Player[1].look[eLOOK.S] = eSTAT.S;
            startGame = 4;
          }
          else if(pos.x >= (tL/10)*3.4 && pos.x <= (tL/10)*4.4  &&//take STR rune from player
                  pos.y > (tH/10)*6.5  && pos.y < (tH/10)*7.5 && sRune.owner == 0 && noneOnTable == 4){
            Player[0].at = 1;
            Player[1].look[eLOOK.S] = eSTAT.S;
            startGame = 3;
          }
          //con rune
          else if(pos.x >= (tL/10)*7.5 && pos.x <= (tL/10)*8.5  &&//take con rune from table
                  pos.y > (tH/10)*4.5  && pos.y < (tH/10)*5.5 && cRune.owner == 2){
            Player[0].at = 1;
            Player[1].look[eLOOK.S] = eSTAT.C;
            startGame = 4;
          }
          else if(pos.x >= (tL/10)*6 && pos.x <= (tL/10)*7  &&//take con rune from player
                  pos.y > (tH/10)*6.5  && pos.y < (tH/10)*7.5 && cRune.owner == 0&& noneOnTable == 4){
            Player[0].at = 1;
            Player[1].look[eLOOK.S] = eSTAT.C;
            startGame = 4;
          }
          //int rune
          else if(pos.x >= (tL/10)*3.4 && pos.x <= (tL/10)*4.4  &&//take int rune from table
                  pos.y > (tH/10)*4.5  && pos.y < (tH/10)*5.5 && iRune.owner == 2){
            Player[0].at = 1;
            Player[1].look[eLOOK.S] = eSTAT.I;
            startGame = 4;
          }
          else if(pos.x >= (tL/10)*3.5 && pos.x <= (tL/10)*4.5  &&//take int rune from player
                  pos.y > (tH/10)*9  && pos.y < (tH/10)*10 && iRune.owner == 0&& noneOnTable == 4){
            Player[0].at = 1;
            Player[1].look[eLOOK.S] = eSTAT.I;
            startGame = 4;
          }
          //agi rune
          else if(pos.x >= (tL/10)*5.5 && pos.x <= (tL/10)*6.5  &&//take agi rune from table
                  pos.y > (tH/10)*4.5  && pos.y < (tH/10)*5.5 && aRune.owner == 2){
            Player[0].at = 1;
              Player[1].look[eLOOK.S] = eSTAT.A;
              startGame = 4;
            }
          else if(pos.x >= (tL/10)*6 && pos.x <= (tL/10)*7  &&//take agi rune from player
                  pos.y > (tH/10)*9  && pos.y < (tH/10)*10 && aRune.owner == 0 && noneOnTable == 4){
            Player[0].at = 1;
            Player[1].look[eLOOK.S] = eSTAT.A;
            startGame = 4;
          }
        break;
      }
    }
  }
  
  // Now check collision using gridPos instead of pos
  if (MessageBox.isTouched(gridPos.x, gridPos.y) && MessageBox.visible  == true&&MessageBox.type != 'jrpg') {
      MessageBox.press();
      return;
  }
  if (btnYes.isTouched(gridPos.x, gridPos.y) && btnYes.visible  == true&&btnYes.type != 'jrpg') {
      btnYes.press();
      return;
  }
  if (btnNo.isTouched(gridPos.x, gridPos.y) && btnNo.visible  == true&&btnNo.type != 'jrpg') {
      btnNo.press();
      return;
  }
  if (btnAction.isTouched(gridPos.x, gridPos.y) && btnAction.visible  == true&&btnAction.type != 'jrpg') {
      btnAction.press();
      return;
  }
  if (btnAction2.isTouched(gridPos.x, gridPos.y) && btnAction2.visible  == true&&btnAction2.type != 'jrpg') {
      btnAction2.press();
      return;
  }
  if (btnAdd.isTouched(gridPos.x, gridPos.y) && btnAdd.visible == true&&btnAdd.type != 'jrpg') {
      btnAdd.press();
      return;
  }
  // 1. Grid Logic & "The Flip"
    let gx = (e.clientX - (wX - tL) / 2) / (tL / 10);
    let gy = (e.clientY - (wY - tH) / 2) / (tH / 10);

    let activeActor = Player[0]; 
    let isFoeSide = false;

    if (gy < 5) { // Clicked Top Half (Foe Side)
        activeActor = Player[1];
        isFoeSide = true;
        gx = 10 - gx; // Flip X
        gy = 10 - gy; // Flip Y
    }
    if (MessageBox.isTouched(gx ,gy) && MessageBox.visible > 0&&MessageBox.type != 'jrpg') {
      MessageBox.press();
  }
  if (btnYes.isTouched(gx, gy) && btnYes.visible > 0&&btnYes.type != 'jrpg') {
      btnYes.press();
  }
  if (btnNo.isTouched(gx, gy) && btnNo.visible > 0&&btnNo.type != 'jrpg') {
      btnNo.press();
  }
  if (btnAction.isTouched(gx, gy) && btnAction.visible > 0&&btnAction.type != 'jrpg') {
      btnAction.press();
  }
  if (btnAction2.isTouched(gx, gy) && btnAction2.visible > 0&&btnAction2.type != 'jrpg') {
      btnAction2.press();
  }
  if (btnAdd.isTouched(gx, gy) && btnAdd.visible > 0&&btnAdd.type != 'jrpg') {
      btnAdd.press();
  }
 
}
window.addEventListener('pointerdown', handleInput, { passive: false });
//////////////////////////[FUNCTIONS]/////////////////////////////
//////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
function random(max){
	return Math.floor(Math.random()*Math.floor(max));
}
function rnd(min, max){
	min = Math.ceil(min);
	max = Math.floor(max);
	return Math.floor(Math.random() * (max - min + 1)+ min);
}
function resizeCanvas(){  //USED IN EVENT LISTENER TO GET NEW WINDOW X,Y(tX,tY)
	//after event handler detects window resize, sets canvas x,y to window x,y
	// 1. Get the scaling factor (2 or 3 for iPhones)
  if (isChatActive&&startGame!='charSelect') return;
    var dpr = window.devicePixelRatio || 1;

    wX = window.innerWidth;
    wY = window.innerHeight;

    // 2. Set actual canvas memory size to scaled value
    canvas.width = wX * dpr;
    canvas.height = wY * dpr;

    // 3. Force the CSS size to match the window
    canvas.style.width = wX + "px";
    canvas.style.height = wY + "px";

    // 4. Normalize the coordinate system
    ctx.scale(dpr, dpr);

	//canvas redimensioned, so re-set values for playing table width and length
	tX = wX; //table length (actual x determined after funtion)
	tY = wY; //table height (actual y determined after function)

	//find largest dimension for tX and tY that is divisible by 2 without remainder
	if (tX % 2 !== 0) tX--;
if (tY % 2 !== 0) tY--;
	//make sure table dimensions have ratio of 1:1 for x and y respectively
	//if table too wide make shorter
	if (tX > tY){
		tX = tY;
	}
	//if table too high make shorter
	else if(tY > tX){
		tY = tX;
	}

	//find difference between window dimensions and ratio'd table dims for padding
	var dX = wX - tX;
	var dY = wY - tY;
	tL = tX;
	tH = tY;

	//find table top-left(0,0) with table centered and equal padding on all sides
	tX = dX/2;
	tY = dY/2;

	//set x,y, width, height,length for all frames[to do]
/////////ONLINE
if(startGame == 'explore'||startGame == 'battle'){
chatInput.type = 'text';
chatInput.style.position = 'fixed';
chatInput.style.top = `${tY+(tL/10)*9.36}px`;        // Put it at the top
chatInput.style.left = `${tX+(tL/10)*.85}px`;       // Put it at the left
chatInput.style.width = `${(tL/10)*7.9}px`;
chatInput.style.height = `${(tL/10)*.5}px`;
chatInput.style.opacity = `${.01}px`;       // VISIBLE
chatInput.style.background = 'rgba(255,255,255,.01)';  // RED BACKGROUND
chatInput.style.zIndex = '1000';     // On top of canvas
document.body.appendChild(chatInput);
}
	}
function drawShape(shape,x,y,z,x1,y1,x2,y2,x3,y3,x4,y4,color,fill,x5 = 0,y5 = 0){
	//frame
	let lx1 = 0;
	let ly1 = 0;
	let lx2 = 0;
	let ly2 = 0;
	let lx3 = 0;
	let ly3 = 0;
	let lx4 = 0;
	let ly4 = 0;
  let lx5 = 0;
	let ly5 = 0;
	let lDiv = (tL/10)*z;
	let hDiv = (tH/10)*z;
	x = tX + (tL/10) * x;
	y = tY + (tH/10) * y;
	//draw shape
	switch(shape){
    case 'pol':
			lx1 = x + (lDiv * x1);//x coord 1
			ly1 = y + (hDiv * y1);//y coord 1
			lx2 = x + (lDiv * x2);//x coord 2
			ly2 = y + (hDiv * y2);//y coord 2
			lx3 = x + (lDiv * x3);//x coord 3
			ly3 = y + (hDiv * y3);//y coord 3
			lx4 = x + (lDiv * x4);//x coord 4
			ly4 = y + (hDiv * y4);//y coord 4
      lx5 = x + (lDiv * x5);//x coord 4
			ly5 = y + (hDiv * y5);//y coord 4
			ctx.fillStyle = color;
			ctx.strokeStyle = color;
			ctx.beginPath();
			ctx.moveTo(lx1, ly1);
			ctx.lineTo(lx2, ly2);
			ctx.lineTo(lx3, ly3);
			ctx.lineTo(lx4, ly4);
      ctx.lineTo(lx5, ly5);
			ctx.lineTo(lx1, ly1);
			ctx.closePath();
			break;
		case 'qua':
			lx1 = x + (lDiv * x1);//x coord 1
			ly1 = y + (hDiv * y1);//y coord 1
			lx2 = x + (lDiv * x2);//x coord 2
			ly2 = y + (hDiv * y2);//y coord 2
			lx3 = x + (lDiv * x3);//x coord 3
			ly3 = y + (hDiv * y3);//y coord 3
			lx4 = x + (lDiv * x4);//x coord 4
			ly4 = y + (hDiv * y4);//y coord 4
			ctx.fillStyle = color;
			ctx.strokeStyle = color;
			ctx.beginPath();
			ctx.moveTo(lx1, ly1);
			ctx.lineTo(lx2, ly2);
			ctx.lineTo(lx3, ly3);
			ctx.lineTo(lx4, ly4);
			ctx.lineTo(lx1, ly1);
			ctx.closePath();
			break;
		case 'tri'://+x, +y, z, x1,y1,x2,y2,x3,x4,0,0,color,fill
			lx1 = x + (lDiv * x1);
			ly1 = y + (hDiv * y1);
			lx2 = x + (lDiv * x2);
			ly2 = y + (hDiv * y2);
			lx3 = x + (lDiv * x3);
			ly3 = y + (hDiv * y3);
			ctx.fillStyle = color;
			ctx.strokeStyle = color;
			ctx.beginPath();
			ctx.moveTo(lx1, ly1);
			ctx.lineTo(lx2, ly2);
			ctx.lineTo(lx3, ly3);
			ctx.lineTo(lx1, ly1);
			ctx.closePath();
			break;
		case 'lin': //Start x:X1,end y(Y1) ,? linewidth
			lx1 = x + (lDiv * x1);
			ly1 = y + (hDiv * y1);
			lx2 = x + (lDiv * x2);
			ly2 = y + (hDiv * y2);
			ctx.strokeStyle = color;
			ctx.fillStyle = color;
			ctx.beginPath();
			ctx.moveTo(lx1, ly1);
			ctx.lineTo(lx2, ly2);
			ctx.closePath();
			break;
		case 'arc': //ex: drawshape('arc',x,y,z,x1:1,y1:1,x2:1,y2:0,6
			lx1 = x + (lDiv * x1);//center x coord
			ly1 = y + (hDiv * y1);//center y coord
			lx2 = (hDiv * x2);//radius
			ly2 = Math.PI * y2; //start angle for partial circles?
			lx3 = Math.PI * x3; //end angle
			ctx.fillStyle = color;
			ctx.strokeStyle = color;
			ctx.beginPath();
			ctx.arc(lx1, ly1, lx2, ly2, lx3);
			break;
		case 'rec':
			lx1 =  x + (lDiv * x1);//upper left start x coord of rec
			ly1 =  y + (hDiv * y1);//upper left start y coord of rec
			lx2 = (lDiv * x2);//width
			ly2 = (hDiv * y2);//length
			ctx.strokeStyle = color;
			ctx.fillStyle = color;
			ctx.beginPath();
			ctx.rect(lx1,ly1,lx2,ly2);
			break;
		case 'ell'://center x, center y, x-rad, y-rad, rotation, start angle, end angle
			//if ellipse function doesnt exist for the browser define it
			if (CanvasRenderingContext2D.prototype.ellipse == undefined) {
				CanvasRenderingContext2D.prototype.ellipse = function(x, y, radiusX, radiusY, rotation, startAngle, endAngle, antiClockwise) {
					this.save();
					this.translate(x, y);
					this.rotate(rotation);
					this.scale(radiusX, radiusY);
					this.arc(0, 0, 1, startAngle, endAngle, antiClockwise);
					this.restore();
				}
			}
			lx1 =  x + (lDiv * x1);
			ly1 =  y + (hDiv * y1);
			lx2 = (lDiv * x2);
			ly2 = (hDiv * y2);
			ctx.strokeStyle = color;
			ctx.fillStyle = color;
			ctx.beginPath();
				ctx.ellipse(lx1, ly1, lx2, ly2, Math.PI / (x3+.0001), Math.PI*y3, Math.PI*x4);
			break;
	} //END SWITCH x,y,radX,radY,rotation,start angle,end angle[,anticlockwise])
	if(fill>0){ctx.fill();}else{ctx.stroke();}
}//end function
function drawText(x, y, boxW, boxH, text, color, z, align) {
  
  // Default to 'left' if they forget to add the argument
  if (typeof align === 'undefined') align = 'left';

  // 1. Setup Coordinates
  var zx = x, zy = y; 
  var zl = boxW, zh = boxH;
  
  var drawX = tX + (tL / 10) * x; 
  var drawY = tY + (tH / 10) * y;
  var maxWidth = (tL / 10) * boxW * z;
  var maxHeight = (tH / 10) * boxH * z;

  // 2. Setup Font Initial State
  var fs = maxHeight; 
  ctx.textBaseline = "hanging";
  
  // 3. Helper: Wrap Text
  function getWrappedLines(ctx, text, limit) {
    var words = text.split(" ");
    var lines = [];
    var currentLine = words[0];

    for (var i = 1; i < words.length; i++) {
      var word = words[i];
      var width = ctx.measureText(currentLine + " " + word).width;
      if (width < limit) {
        currentLine += " " + word;
      } else {
        lines.push(currentLine);
        currentLine = word;
      }
    }
    lines.push(currentLine);
    return lines;
  }

  // 4. Autosize Loop
  var linesArr = [];
  var fitFound = false;
  
  while (!fitFound && fs > 1) {
    ctx.font = fs + "px Franklin Gothic, Helvetica, Arial, sans-serif";
    linesArr = getWrappedLines(ctx, text, maxWidth);
    
    if ((linesArr.length * fs) > maxHeight) {
      fs = fs * 0.95; 
    } else {
      fitFound = true;
    }
  }

  // 5. Render Loop
  var lineHeight = maxHeight / linesArr.length;
  
  for (let i = 0; i < linesArr.length; i++) {
    let lineStr = linesArr[i];
    let yLine = drawY + (i * lineHeight);

    // --- ALIGNMENT LOGIC ---
    let centerOffset = 0;
    
    // Only do the math if we specifically asked for 'center'
    if (align === 'center') {
        let previewStr = lineStr.replace(/\b(STR|CON|INT|AGI)\b/g, '   ');
        ctx.font = fs + "px Franklin Gothic, Helvetica, Arial, sans-serif"; 
        let lineWidth = ctx.measureText(previewStr).width;
        
        centerOffset = (maxWidth - lineWidth) / 2;
        if (centerOffset < 0) centerOffset = 0;
    }
    
    let gridOffset = centerOffset / (tL / 10);
    // -----------------------

    let parts = lineStr.split(' ');
    let drawStr = '';
    
    for (let h = 0; h < parts.length; h++) {
      let part = parts[h];
      let p = 0;
      switch (part) {
        case 'INT': p = -5; break;
        case 'STR': p = -4; break;
        case 'CON': p = -6; break;
        case 'AGI': p = -7; break;
      }

      if (p !== 0) {
        let currentWidth = ctx.measureText(drawStr).width;
        // Apply gridOffset here so portraits move with the text alignment
        let k = (zx + gridOffset) + (currentWidth / (tL / 10));
        let j = zy + (zh * z / linesArr.length) * i;
        let m = fs / tH;

        drawPortrait(p, k, j, m);
        part = '   '; 
      }
      
      drawStr += part + " ";
    }
    
    drawStr = drawStr.trimEnd();

    // Final Draw
    const diceRe = /^\s*\d+d\d+\s*$/;
    const hasToken = /\b(?:STR|CON|INT|AGI)\b/.test(lineStr);
    
    ctx.font = fs + "px Franklin Gothic, Helvetica, Arial, sans-serif";
    
    if (!hasToken) {
      let w = ctx.measureText(drawStr).width;
      
      // Force Left Align if we had to scale the text down to fit
      if (w > maxWidth) {
        let scale = maxWidth / w;
        if (diceRe.test(drawStr)) {
          ctx.font = "bold " + (fs * scale) + "px Franklin Gothic, Helvetica, Arial, sans-serif";
        } else {
          ctx.font = (fs * scale) + "px Franklin Gothic, Helvetica, Arial, sans-serif";
        }
        centerOffset = 0; // Reset offset because it now fills the line
      } else {
        if (diceRe.test(drawStr)) {
           ctx.font = "bold " + fs + "px Franklin Gothic, Helvetica, Arial, sans-serif";
        }
      }
    }
    
    ctx.fillStyle = color;
    // Add the offset (which is 0 for left, calculated for center)
    ctx.fillText(drawStr, drawX + centerOffset, yLine);
  }
  
  ctx.font = fs + "px Franklin Gothic, Helvetica, Arial, sans-serif";
}
function drawPortrait(index,x,y,z,card = 0){
  let sx = 0;
  let sy = 0;
  let sz = 0;
  switch(index){
    case 'wall':

    break;
    case -1: //L Arrow Button
      drawShape('arc',x,y,z,5,5,5,0,6,0,0,0,'rgba(255,255,255,.5)',1);//left
      drawShape('tri',x,y,z,7.5,1.5,7.5,8.5,1,5,0,0,'rgba(0,0,0,.5)',1);//left
      break;
    case -2: //R Arrow Button
      drawShape('arc',x,y,z,5,5,5,0,6,0,0,0,'rgba(255,255,255,.5)',1);//right
      drawShape('tri',x,y,z,2.5,8.5,2.5,1.5,9,5,0,0,'rgba(0,0,0,.5)',1);//right
      break;
    case -3: //green checkmark
      drawShape('tri',x,y,z,1,5, 1,7, 5,9, 0,0,'green',1);//right
      drawShape('tri',x,y,z,5,9, 4, 8, 10,2,0,0,'green',1);//right
      break
    case -4: //SWORD STR no yellow
      drawShape('qua',x,y,z,0,1, 2,3, 3,2, 1,0,'rgb(252,165,3)',1);//handle
      drawShape('qua',x,y,z,0,1, 2,3, 3,2, 1,0,'rgb(252,165,3)',0);//handle
      drawShape('tri',x,y,z,0,0, 1.4,0, 0,1.4 ,0,0,'darkgray',1);//pommel
      drawShape('tri',x,y,z,0,0, 1.4,0, 0,1.4 ,0,0,'rgb(252,165,3)',0);//pommel
      drawShape('qua',x,y,z,0,5, 1,5 ,5,1 ,5,0,'rgb(252,165,3)',1);//hilt guard
      drawShape('qua',x,y,z,2,4, 8,9, 8,8, 4,4,'gray',1);//lhalf blade
      drawShape('qua',x,y,z,4,2, 9,8, 8,8 ,4,4,'gray',1);//rhalf blade
      drawShape('tri',x,y,z,4,4, 4,2, 2,4, 0,0,'gray',1);//near hilt center
      drawShape('qua',x,y,z,9,8, 8,8, 8,9, 10,10,'gray',1);//sword tip
      drawShape('qua',x,y,z,0,5, 1,5, 5,1 ,5,0,'rgb(252,165,3)',0);//hilt guard outline
      drawShape('arc',x,y,z,3,3, .5,0, 6,0 ,0,0,'white',1);//hilt gem
      drawShape('arc',x,y,z,3,3 ,.51,0, 6,0, 0,0,'white',0);
      break;
    case -5://WAND INT NO RED
      drawShape('qua',x,y,z,0.2,9.5, 6.21,0, 10,3.77, .2,9.9,'rgba(85,43,0,1)',1);//handle
      drawShape('qua',x,y,z,0.2,9.5, 6.21,.1, 7,.8, .2,9.6,'rgba(0,0,0,.5)',1);//handle
      drawShape('qua',x,y,z,0.2,9.9, 6.5,4.5, 6.52,4.5, .2,9.9,'rgba(0,0,0,.5)',1);//handle
      //drawShape('tri',x,y,z,10,0, 6.21,0, 10,3.77, 0,0,'rgb(109,39,19)',1);//GFR
      drawShape('tri',x,y,z,10,0, 6.21,0, 8.2,2, 0,0,'rgba(255,0,0,.2)',1);//gfl
      drawShape('tri',x,y,z,10,0, 6.21,0, 10,3.77, 0,0,'rgba(209,70,47,.2)',1);//GFR
      //drawShape('tri',x,y,z,10,0, 6.21,0, 8.2,2, 0,0,'rgb(109,39,19)',1);//gfl
      drawShape('tri',x,y,z,6.21,0, 10,3.77, 9,1, 0,0,'rgba(255,0,0,.25)',1);//handle
      drawShape('tri',x,y,z,10,0, 6.21,0, 10,3.77, 0,0,'rgba(255,0,0,.3)',1);//gem mask
      break;
    case -6: //roundshield con no green
      drawShape('arc',x,y,z,4.8,5,4.5,0,6,0,0,0,'rgba(40,20,0,1)',1);
      drawShape('arc',x,y,z,5,5,4.5,0,6,0,0,0,'rgba(85,43,0,1)',1);
      drawShape('rec',x,y,z,0.5,5,9,.11,0,0,0,0,'rgba(0,0,0,.35)',1)
      drawShape('rec',x,y,z,.95,3,8.1,.11,0,0,0,0,'rgba(0,0,0,.35)',1)
      drawShape('rec',x,y,z,1,7,8,.11,0,0,0,0,'rgba(0,0,0,.35)',1)
      drawShape('qua',x,y,z,5,4,6,5,5,6,4,5,'green',1);
      drawShape('qua',x,y,z,3,1, 7,1.1, 2.8,1.2, 8,2,'rgba(0,0,0,.35)',1);
      drawShape('qua',x,y,z,3-1,1+1, 7-1,1.1+1, 2.8-1,1.2+1, 8-1,2+1,'rgba(0,0,0,.35)',1);
      drawShape('qua',x,y,z,1+3,1+2, 1+7,1.1+2, 1+2.8,1.2+2, 1+8,2+2,'rgba(0,0,0,.35)',1);
      drawShape('qua',x,y,z,1+3,1+5, 1+7,1.1+5, 1+2.8,1.2+5, 1+8,2+5,'rgba(0,0,0,.35)',1);
      drawShape('qua',x,y,z,3,1+6, 7,1.1+6, 2.8,1.2+6, 8,2+6,'rgba(0,0,0,.35)',1);
      drawShape('qua',x,y,z,3-1,1+7, 7-1,1.1+7, 2.8-1,1.2+7, 8-1,2+7,'rgba(0,0,0,.35)',1);
      //drawShape('qua',x,y,z,1,3, 7,1.1, 2.8,1.2, 8,2,'rgba(0,0,0,.35)',1);
      //drawShape('qua',x,y,z,1,3, 7,1.1, 2.8,1.2, 9,3,'rgba(0,0,0,.35)',1);
      break;
    case -7://hourglass agi no blue
      drawShape('qua',x,y,z,1,9,9,9,1,1,9,1,'white',1);//body
      drawShape('rec',x,y,z,1,.75,8,.25,0,0,0,0,'blue',1);
      drawShape('rec',x,y,z,1,9,8,.25,0,0,0,0,'blue',1);

      drawShape('tri',x,y,z,2.5,9,7.5,9,5,8.5,0,0,'blue',1);//bottom sand
      drawShape('tri',x,y,z,5,5,2.5,2.5,7.5,2.5,0,0,'blue',1);//top sand
      drawShape('qua',x,y,z,5,5, 4.9,6, 5.1,7, 4.9,8.5,'blue',1);//drip sand
      break;
    case -8://six sided star
      drawShape('tri',x,y,z,5,0,.5,7.5,9.5,7.5,0,0,'white',1);
      drawShape('tri',x,y,z,5,10,.5,2.5,9.5,2.5,0,0,'white',1);
      break;
    case -9://leaf
      drawShape('qua',x,y,z,0,10, 1,4, 3.5,1.5, 10,0,'green',1);
      drawShape('qua',x,y,z,10,0, 9,6, 6.5,8.5, 0,10,'green',1);
      drawShape('qua',x,y,z,0,10, 1,4, 3.5,1.5, 10,0,'rgba(0,0,0,.45)',0);
      drawShape('qua',x,y,z,0,10, 4,4, 5,3, 10,0,'rgba(0,0,0,.15)',1);
      break;
    case -10://yellow sphere
      drawShape('arc',x,y,z,9,1,.8,0,6,0,0,0,'gold',1);//bag
      drawShape('arc',x,y,z,8.95,.95,.75,0,6,0,0,0,'rgba(255,255,255,.15)',1);//bag
      drawShape('arc',x,y,z,8.9,1,.7,0,6,0,0,0,'rgba(255,255,255,.15)',1);//bag
      drawShape('arc',x,y,z,8.85,1,.65,0,6,0,0,0,'rgba(255,255,255,.15)',1);//bag
      drawShape('arc',x,y,z,8.8,1,.6,0,6,0,0,0,'rgba(255,255,255,.15)',1);//bag
    break;
    case -11: //YELLOW SWORD ICON STR STAT
      drawShape('rec',x,y,z,0,0,10,10,0,0,0,0,'yellow',1)
      drawShape('rec',x,y,z,0,0,10,10,0,0,0,0,'rgba(255,255,255,.45)',1)
  		drawShape('qua',x,y,z,0,1, 2,3, 3,2, 1,0,'rgb(252,165,3)',1);//handle
      drawShape('qua',x,y,z,0,1, 2,3, 3,2, 1,0,'rgb(252,165,3)',0);//handle
      drawShape('tri',x,y,z,0,0, 1.4,0, 0,1.4 ,0,0,'darkgray',1);//pommel
      drawShape('tri',x,y,z,0,0, 1.4,0, 0,1.4 ,0,0,'rgb(252,165,3)',0);//pommel
  		drawShape('qua',x,y,z,0,5, 1,5 ,5,1 ,5,0,'rgb(252,165,3)',1);//hilt guard
  		drawShape('qua',x,y,z,2,4, 8,9, 8,8, 4,4,'gray',1);//lhalf blade
  		drawShape('qua',x,y,z,4,2, 9,8, 8,8 ,4,4,'gray',1);//rhalf blade
  		drawShape('tri',x,y,z,4,4, 4,2, 2,4, 0,0,'gray',1);//near hilt center
  		drawShape('qua',x,y,z,9,8, 8,8, 8,9, 10,10,'gray',1);//sword tip
  		drawShape('qua',x,y,z,0,5, 1,5, 5,1 ,5,0,'rgb(252,165,3)',0);//hilt guard outline
  		drawShape('arc',x,y,z,3,3, .5,0, 6,0 ,0,0,'white',1);//hilt gem
  		drawShape('arc',x,y,z,3,3 ,.51,0, 6,0, 0,0,'white',0);
  		break;
    case -12://RED WAND ICON INT STAT
      drawShape('rec',x,y,z,0,0,10,10,0,0,0,0,'rgb(209,70,47)',1)
      drawShape('rec',x,y,z,0,0,10,10,0,0,0,0,'rgba(255,255,255,.13)',1)
                              //BASE    TL    tR
      drawShape('qua',x,y,z,0.2,9.5, 6.21,0, 10,3.77, .2,9.9,'rgba(85,43,0,1)',1);//handle
      drawShape('qua',x,y,z,0.2,9.5, 6.21,.1, 7,.8, .2,9.6,'rgba(0,0,0,.5)',1);//handle
      drawShape('qua',x,y,z,0.2,9.9, 6.5,4.5, 6.52,4.5, .2,9.9,'rgba(0,0,0,.5)',1);//handle
      //drawShape('tri',x,y,z,10,0, 6.21,0, 10,3.77, 0,0,'rgb(109,39,19)',1);//GFR
      drawShape('tri',x,y,z,10,0, 6.21,0, 8.2,2, 0,0,'rgba(255,0,0,.2)',1);//gfl
      drawShape('tri',x,y,z,10,0, 6.21,0, 10,3.77, 0,0,'rgba(209,70,47,.2)',1);//GFR
      //drawShape('tri',x,y,z,10,0, 6.21,0, 8.2,2, 0,0,'rgb(109,39,19)',1);//gfl
      drawShape('tri',x,y,z,6.21,0, 10,3.77, 9,1, 0,0,'rgba(255,0,0,.25)',1);//handle
      drawShape('tri',x,y,z,10,0, 6.21,0, 10,3.77, 0,0,'rgba(255,0,0,.3)',1);//gem mask
       break;
    case -13: //GREEN ROUNDSHIELD ICON CON STAT
      drawShape('rec',x,y,z,0,0,10,10,0,0,0,0,'green',1)
      drawShape('rec',x,y,z,0,0,10,10,0,0,0,0,'rgba(255,255,255,.35)',1)
      drawShape('arc',x,y,z,4.8,5,4.5,0,6,0,0,0,'rgba(40,20,0,1)',1);
			drawShape('arc',x,y,z,5,5,4.5,0,6,0,0,0,'rgba(85,43,0,1)',1);
      drawShape('rec',x,y,z,0.5,5,9,.11,0,0,0,0,'rgba(0,0,0,.35)',1)
      drawShape('rec',x,y,z,.95,3,8.1,.11,0,0,0,0,'rgba(0,0,0,.35)',1)
      drawShape('rec',x,y,z,1,7,8,.11,0,0,0,0,'rgba(0,0,0,.35)',1)
			drawShape('qua',x,y,z,5,4,6,5,5,6,4,5,'green',1);
      drawShape('qua',x,y,z,3,1, 7,1.1, 2.8,1.2, 8,2,'rgba(0,0,0,.35)',1);
      drawShape('qua',x,y,z,3-1,1+1, 7-1,1.1+1, 2.8-1,1.2+1, 8-1,2+1,'rgba(0,0,0,.35)',1);
      drawShape('qua',x,y,z,1+3,1+2, 1+7,1.1+2, 1+2.8,1.2+2, 1+8,2+2,'rgba(0,0,0,.35)',1);
      drawShape('qua',x,y,z,1+3,1+5, 1+7,1.1+5, 1+2.8,1.2+5, 1+8,2+5,'rgba(0,0,0,.35)',1);
      drawShape('qua',x,y,z,3,1+6, 7,1.1+6, 2.8,1.2+6, 8,2+6,'rgba(0,0,0,.35)',1);
      drawShape('qua',x,y,z,3-1,1+7, 7-1,1.1+7, 2.8-1,1.2+7, 8-1,2+7,'rgba(0,0,0,.35)',1);
      //drawShape('qua',x,y,z,1,3, 7,1.1, 2.8,1.2, 8,2,'rgba(0,0,0,.35)',1);
      //drawShape('qua',x,y,z,1,3, 7,1.1, 2.8,1.2, 9,3,'rgba(0,0,0,.35)',1);
			break;
    case -14://BLUE HOURGLASS ICON AGI STAT
      drawShape('rec',x,y,z,0,0,10,10,0,0,0,0,'blue',1)
      drawShape('rec',x,y,z,0,0,10,10,0,0,0,0,'rgba(255,255,255,.35)',1)
      drawShape('qua',x,y,z,1,9,9,9,1,1,9,1,'white',1);//body
      drawShape('rec',x,y,z,1,.75,8,.25,0,0,0,0,'rgb(128,64,0)',1);
      drawShape('rec',x,y,z,1,9,8,.25,0,0,0,0,'rgb(128,64,0)',1);
      drawShape('tri',x,y,z,2.5,9,7.5,9,5,8.5,0,0,'brown',1);//bottom sand
      drawShape('tri',x,y,z,5,5,2.5,2.5,7.5,2.5,0,0,'brown',1);//top sand
      drawShape('qua',x,y,z,5,5, 4.9,6, 5.1,7, 4.9,8.5,'brown',1);//drip sand
      break;
    case -15: //SWORD ATTACK ICON
    	drawShape('rec',x,y,z,0,0, 10,10, 0,0 ,0,0,'rgb(255,255,255)',0);

			drawShape('tri',x,y,z,0,8.6, 1.4,10, 0,10 ,0,0,'rgb(252,165,3)',1);
			drawShape('qua',x,y,z,0,9, 2,7, 3,8, 1,10,'rgb(252,165,3)',1);
			drawShape('qua',x,y,z,0,5, 1,5 ,5,9 ,5,10,'rgb(252,165,3)',1);
			drawShape('qua',x,y,z,2,6, 8,1, 8,2, 4,6,'gray',1);//
			drawShape('qua',x,y,z,4,8, 9,2, 8,2 ,4,6,'gray',1);
			drawShape('tri',x,y,z,2,6, 4,6, 4,8, 0,0,'gray',1);
			drawShape('qua',x,y,z,8,1, 8,2, 9,2, 10,0,'gray',1);
			drawShape('qua',x,y,z,0,5, 1,5, 5,9 ,5,10,'rgb(252,165,3)',0);
			drawShape('arc',x,y,z,3,7, .5,0, 6,0 ,0,0,'red',1);//pommel gem
			drawShape('arc',x,y,z,3,7 ,.5,0, 6,0, 0,0,'brown',0);
			break;
    case -15.1: //SWORD ATTACK ICON

			drawShape('tri',x,y,z,0,8.6, 1.4,10, 0,10 ,0,0,'rgb(252,165,3)',1);
			drawShape('qua',x,y,z,0,9, 2,7, 3,8, 1,10,'rgb(252,165,3)',1);
			drawShape('qua',x,y,z,0,5, 1,5 ,5,9 ,5,10,'rgb(252,165,3)',1);
			drawShape('qua',x,y,z,2,6, 8,1, 8,2, 4,6,'gray',1);//
			drawShape('qua',x,y,z,4,8, 9,2, 8,2 ,4,6,'gray',1);
			drawShape('tri',x,y,z,2,6, 4,6, 4,8, 0,0,'gray',1);
			drawShape('qua',x,y,z,8,1, 8,2, 9,2, 10,0,'gray',1);
			drawShape('qua',x,y,z,0,5, 1,5, 5,9 ,5,10,'rgb(252,165,3)',0);
			drawShape('arc',x,y,z,3,7, .5,0, 6,0 ,0,0,'red',1);//pommel gem
			drawShape('arc',x,y,z,3,7 ,.5,0, 6,0, 0,0,'brown',0);
			break;
    
    case -16: //SHIELD
			drawShape('rec',x,y,z,1,1,8,5,0,0,0,0,'gray',1);
			drawShape('tri',x,y,z,1,6,5.1,9,9,6,0,0,'gray',1);
			drawShape('lin',x,y,z,5.1,1,5.1,9,0,0,0,0,'blue',0);
			drawShape('lin',x,y,z,1,3.5,9,3.5,0,0,0,0,'blue',0);
			break;
    case -17: //EXAMINE
      drawShape('qua',x,y,z,4.2,4.5, .8,9.25, 1.5,9.88, 5.25,5.5,'rgba(128,64,0,1)',1)
      drawShape('arc',x,y,z,6.85,2.75,2.75,0,6,0,0,0,'rgba(255,255,255,.5)',1);
      drawShape('arc',x,y,z,6.75,3,3,0,6,0,0,0,'rgba(255,255,255,.5)',1);
      break;
    case -18://Potion
      drawShape('qua',x,y,z, 4.4,0.75, 5.6,0.75, 5.25,2.45, 4.75,2.45,'rgba(186,103,0,1)',1)//cork
      drawShape('qua',x,y,z, 3.95,3.449, 6.0456,3.4488, 5.5,1.25, 4.5,1.25,'rgba(249,255,255,.28)',1);//bottleneck
      drawShape('arc',x,y,z,5,6.38,  2.8,  1.667,1.337,0,0,0,'rgba(255,0,0,1)',1);//liquid
      drawShape('arc',x,y,z,5,6.25,  3,  1.6163,1.3836,0,0,0,'rgba(249,255,255,.28)',1);//bottle
      drawShape('ell',x,y,z,5,3.95, 1.4,.3, 1, 1,2,0,'rgba(0,0,0,.2)',1);//surface liquid
      drawShape('ell',x,y,z,6.3,5.44, .55,.35, 1, 0,2,0,'rgba(255,255,255,.8)',1);//reflection
    break;
    case -19: //TOME
			// hourglass example drawShape('qua',x,y,z,0,10,10,10,2.5,5,7.5,5,'rgba(63,72,204,.45)',1);
			//drawShape('arc',x,y,z,5,5.25,5.3,0,6,0,0,0,'rgba(255,255,255,.45)',1);
			drawShape('qua',x,y,z,0,7.5,10,7.5,7.5,2.5,2.5,2.5,'rgba(128,64,0,.85)',1);
			drawShape('qua',x,y,z,.2,7.1,9.8,7.1,7.5,2.5,2.5,2.5,'rgba(255,255,128,1)',1);
			drawShape('lin',x,y,z,5,7.5,5,2.5,0,0,0,0,'rgba(128,64,0,.85)',1);
			drawShape('arc',x,y,z,3.75,3.8,1.75,1.25,1.75,0,0,0,'rgba(255,255,128,1)',1);
			drawShape('arc',x,y,z,6.25,3.8,1.75,1.25,1.75,0,0,0,'rgba(255,255,128,1)',1);
			drawShape('arc',x,y,z,2.5,7.9,2.4,1.1,1.9,0,0,0,'rgba(248,179,16,.85)',1);
			drawShape('arc',x,y,z,7.5,7.9,2.4,1.1,1.9,0,0,0,'rgba(248,179,16,.85)',1);
			break;
    case -20: //broken SWORD
			drawShape('tri',x,y,z,0,8.5,1.5,10,0,10,0,0,'gold',1);
			drawShape('qua',x,y,z,0,9,2,7,3,8,1,10,'gold',1);
			drawShape('qua',x,y,z,0,5,1,5,5,9,5,10,'gold',1);
			drawShape('qua',x,y,z,2,6,8,1,8,2,4,6,'gray',1);
			drawShape('qua',x,y,z,4,8,9,2,8,2,4,6,'gray',1);
			drawShape('tri',x,y,z,2,6,4,6,4,8,0,0,'white',1);
			drawShape('qua',x,y,z,8,1,8,2,9,2,10,9,'white',1);
			drawShape('arc',x,y,z,3,7,.5,0,6,0,0,0,'red',1);
			break;
    case -21://Use item/cast spell
    drawShape('rec',x,y,z,0,0,10,10,0,0,0,0,'rgb(255,255,255)',0);
      //tomearc
      sx = 1.5*z;
      sy = 1*z;
      sz = .75;
      drawShape('qua',x+sx,y+sy,z*sz,0,7.5,10,7.5,7.5,2.5,2.5,2.5,'rgba(128,64,0,1)',1);
			drawShape('qua',x+sx,y+sy,z*sz,.2,7.1,9.8,7.1,7.5,2.5,2.5,2.5,'rgba(255,255,128,1)',1);
			drawShape('lin',x+sx,y+sy,z*sz,5,7.5,5,2.5,0,0,0,0,'rgba(128,64,0,.85)',1);
			drawShape('arc',x+sx,y+sy,z*sz,3.75,3.8,1.79,1.25,1.75,0,0,0,'rgba(255,255,128,1)',1);
			drawShape('arc',x+sx,y+sy,z*sz,6.25,3.8,1.79,1.25,1.75,0,0,0,'rgba(255,255,128,1)',1);
      drawShape('qua',x+sx,y+sy,z*sz,4.77,7.2, 4.9,2.4, 4,6, 4.488,6.51,'rgba(0,0,0,.1)',1);
      drawShape('qua',x+sx,y+sy,z*sz,5.188,7.2, 5.1,2.4, 6,6, 5.512,6.51,'rgba(0,0,0,.1)',1);
			drawShape('arc',x+sx,y+sy,z*sz,2.5,7.9,2.4,1.1,1.9,0,0,0,'rgba(248,179,16,.85)',1);
			drawShape('arc',x+sx,y+sy,z*sz,7.5,7.9,2.4,1.1,1.9,0,0,0,'rgba(248,179,16,.85)',1);
      for (let i = 0;i<40;i++){
        drawShape('arc',x+sx,y+sy,z*sz,2.5,7.89, 2.39-i*.05,1.1,1.9,0,0,0,'rgba(0,0,0,.25)',0);
			  drawShape('arc',x+sx,y+sy,z*sz,7.5,7.89, 2.39-i*.05,1.1,1.9,0,0,0,'rgba(0,0,0,.25)',0);
      }
      drawShape('rec',x+sx,y+sy,z*sz,0.2,7.13,9.6,.35,0,0,0,0,'rgb(128,64,0)',1);
      drawShape('pol',x+sx,y+sy,z*sz,4.75,7.1, 4.9,2.42, 5.1,2.42, 5.2,7.2,'rgba(0,0,0,.45)',1, 5,7.1);
      
      //sword pommel
      sx = -.15*z;
      sy = -2*z;
      sz = 1;
      drawShape('arc',x+sx,y+sy,z*sz,.5,8.25, .3,.3, 0,2  ,0,0,'gold',1);//sword-pommel
      drawShape('arc',x+sx,y+sy,z*sz,.5,8.25, .3,.3, 0,2  ,0,0,'rgba(0,0,0,.3)',1);//sword-pommel
      drawShape('ell',x+sx,y+sy,z*sz,.5,8.15, .2,.13, 0, 2  ,0 ,0,'rgba(128,0,0,1)',1);//sword-pommel
      drawShape('arc',x+sx,y+sy,z*sz,.45,8.3, .275,0, 2,2  ,0,0,'rgba(0,0,0,.15)',1);//sword-pommel
      drawShape('arc',x+sx,y+sy,z*sz,.5,8.25, .3,.2, .95, 0  ,0 ,0,'rgba(0,0,0,.24)',1);//sword-pommel
      drawShape('arc',x+sx,y+sy,z*sz,.5,8.25, .3,0, 1.2, 0  ,0 ,0,'rgba(0,0,0,.24)',1);//sword-pommel

      //sword
      sx = -3.65*z;
      sy = -2.25*z;
      sz = 1.5;
      drawShape('qua',x+sx,y+sy,z*sz,4.1,5.5, 4.1,5.8, 2.8,5.81, 2.8,5.5,'gold',1);//sword-handle
      drawShape('qua',x+sx,y+sy,z*sz,4.1,5.9, 4.1,6,   2.8,5.81, 2.8,5.7,'rgba(0,0,0,.4)',1);//sword-handle
      drawShape('qua',x+sx,y+sy,z*sz,4.1,5.7, 4.1,5.8, 2.8,5.81, 2.8,5.5,'rgba(0,0,0,.4)',1);//sword-handle
			drawShape('tri',x+sx,y+sy,z*sz,9,5.8, 4.1,5.35, 3.9,6.15  ,0,0,'white',1);//sword-blade
      drawShape('tri',x+sx,y+sy,z*sz,9,5.8, 4.1,5.5,  3.9,5.8  ,0,0,'rgba(0,0,0,.15)',1);//sword-blade
			drawShape('tri',x+sx,y+sy,z*sz,9,5.8, 4.1,5.35, 3.9,6.1  ,0,0,'rgba(0,0,0,.15)',1);//sword-blade
			drawShape('tri',x+sx,y+sy,z*sz,9,5.8, 4.1,5.45, 3.9,6.15  ,0,0,'rgba(0,0,0,.15)',1);//sword-blade
			drawShape('qua',x+sx,y+sy,z*sz,4.2,4.5, 4.1,5.7, 3.7,6.8, 3.6,6,'gold',1);//sword-crossguard
      drawShape('qua',x+sx,y+sy,z*sz,4.2,4.5, 3.8,5.7, 3.7,6.8, 3.6,6,'rgba(0,0,0,.4)',1);//sword-crossguard
			drawShape('qua',x+sx,y+sy,z*sz,4.2,4.5, 4.1,5.7, 3.7,6.8, 3.6,6,'rgba(0,0,0,.4)',1);//sword-crossguard

      //potion
      sx = 5*z;
      sy = 3*z;
      sz = .5;
      drawShape('qua',x+sx,y+sy,z*sz, 4.4,0.75, 5.6,0.75, 5.25,2.45, 4.75,2.45,'rgba(186,103,0,1)',1)//cork
      drawShape('qua',x+sx,y+sy,z*sz, 4.4,0.75, 5.6,0.75, 5.25,.9, 4.75,.9,'rgba(255,255,255,.1)',1)//cork
      drawShape('qua',x+sx,y+sy,z*sz, 4.4,0.75, 4.5,0.75, 5.25,2.45, 4.75,2.45,'rgba(0,0,0,.40)',1)//cork
      drawShape('qua',x+sx,y+sy,z*sz, 3.95,3.449, 6.0456,3.4488, 5.5,1.25, 4.5,1.25,'rgba(249,255,255,.28)',1);//bottleneck
      drawShape('qua',x+sx,y+sy,z*sz, 3.95,3.449, 6.0456,3.4488, 5.5,1.25, 4.5,1.25,'rgba(0,0,0,.28)',1);//bottleneck
      drawShape('arc',x+sx,y+sy,z*sz,5,6.38,  2.8,  1.667,1.337,0,0,0,'rgba(255,0,0,1)',1);//liquid
      drawShape('arc',x+sx,y+sy,z*sz,5,6.25,  3,  1.6163,1.3836,0,0,0,'rgba(249,255,255,.28)',1);//bottle
      drawShape('arc',x+sx,y+sy,z*sz,5,6.25,  3,  1.6163,1.3836,0,0,0,'rgba(0,0,0,.28)',1);//bottle
      drawShape('ell',x+sx,y+sy,z*sz,5,3.95, 1.4,.3, 1, 1,2,0,'rgba(0,0,0,.2)',1);//surface liquid
      drawShape('ell',x+sx,y+sy,z*sz,6.3,5.44, .55,.35, 1, 0,2,0,'rgba(255,255,255,.8)',1);//reflection
      
      //coins
      sx = 3.5*z;
      sy = 4.5*z;
      sz = 1;
      for (let i = 10;i>0;i--){
        drawShape('ell',x+sx,y+sy,z*sz,2,2.1+i*.1,.5,.15,  0,2,0,0,'rgba(0,0,0,.4)',1);
        drawShape('ell',x+sx,y+sy,z*sz,2,2.1+i*.1,.5,.15,  0,2,0,0,'rgba(0,0,0,.4)',0);
        drawShape('ell',x+sx,y+sy,z*sz,2,2+i*.1,.5,.15,  0,2,0,0,'rgba(255,255,0,1)',1);
      }

      break;
    case -22://Examine (eye)
      drawShape('rec',x,y,z,0,0,10,10,0,0,0,0,'rgb(255,255,255)',0);
      sx = 2.8*z;
      sy = -7.2*z;
      sz = 2;
      for (let i = 0;i<64;i++){
        drawShape('ell',x+sx,y+sy,z*sz,    1+i*.001, 6+i*.001,        2-i*.01,   .5+i*.01,  0,    0,   2,    0,   `rgba(${255},${155},${155},1)`,1)
        drawShape('ell',x+sx,y+sy,z*sz,    1+i*.001, 6+i*.001,        2-i*.01,   .5+i*.01,  0,    1.1,   -.1,    0,   `rgba(${255},${179},${102},1)`,1)
        drawShape('ell',x+sx,y+sy,z*sz,    1+i*.001, 6+i*.001,        2-i*.01,   .5+i*.01,  0,    .1,  .9,    0,   `rgba(${255},${179},${102},1)`,1)
        drawShape('ell',x+sx,y+sy,z*sz,    1+i*.001, 6+i*.001,        2-i*.01,   .5+i*.01,  0,    1.1,   -.1,    0,   `rgba(${0},${0},${0},.2)`,1)
        drawShape('ell',x+sx,y+sy,z*sz,    1+i*.001, 6+i*.001,        2-i*.01,   .5+i*.01,  0,    .1,  .9,    0,   `rgba(${0},${0},${0},.2)`,1)
      }
      sz = .75;
      sx = 1.05*z;
      sy = 1.1*z;

      drawShape('ell',x+sx,y+sy,z*sz,    5.1, 5.1,        4.1,   2.1,  0,    2,  0,    0,   `rgba(${255},${255},${255},1)`,1)
      drawShape('ell',x+sx,y+sy,z*sz,    5.1, 5.1,        2,   2,  0,    2,  0,    0,   `rgba(${180},${180},${255},1)`,1)
      drawShape('ell',x+sx,y+sy,z*sz,    5.1, 5.1,        .5,   .5,  0,    2,  0,    0,   `rgba(${0},${0},${0},1)`,1)

      break;
    case -23://add to hand

      //item
      sx = -1.25 *z;
      sy = -2 *z;
      sz = 1.25 *z;
      drawShape('rec',x+sx,y+sy,z*sz,1,2,8,7.5,0,0,0,0,'rgb(255,255,255)',0);

      drawShape('qua',x+sx,y+sy,z*sz, 9,5, 6,9, 4,7, 7,3,'rgba(0,255,255,1)',1)//cork
      drawShape('qua',x+sx,y+sy,z*sz, 7.5,6.5, 6,8.5, 4,6.7, 6.5,5.45,'rgba(0,0,0,1)',1)//cork
      drawShape('qua',x+sx,y+sy,z*sz, 8.6,5.2, 7,3.55, 6.1,4.6, 7.75,6.25,'rgba(0,0,0,.5)',1)//cork

      //spell
      drawShape('qua',x+sx,y+sy,z*sz, 1,5, 4,9, 6,7, 3,3,'rgba(255,0,255,1)',1)//cork
      drawShape('qua',x+sx,y+sy,z*sz, 2.5,6.5, 4,8.5, 6,6.7, 3.5,5.45,'rgba(0,0,0,1)',1)//cork
      drawShape('qua',x+sx,y+sy,z*sz, 1.4,5.2, 3,3.55, 3.9,4.6, 2.25,6.25,'rgba(255,255,255,.5)',1)//cork

      //monster
      drawShape('qua',x+sx,y+sy,z*sz, 3.5,3, 6.5,3, 6.5,8, 3.4,8,'rgba(255,255,0,1)',1)//cork
      drawShape('qua',x+sx,y+sy,z*sz, 3.7,5.25, 3.7,7.75, 6.3,7.75, 6.3,5.25,'rgba(0,0,0,1)',1)//cork
      drawShape('qua',x+sx,y+sy,z*sz, 3.7,3.5, 3.7,5, 6.3,5, 6.3,3.5,'rgba(255,255,255,.5)',1)//cork

    break;
    case -24://CrownQ
      drawShape('pol',x,y,z, 0,9, 0,0, 3,6, 5,0,'silver',1,5,9);//face
   drawShape('pol',x,y,z, 10,9, 10,0, 7,6, 5,0,'silver',1,5,9);//face
     
    drawShape('ell',x,y,z, 5,9, 5,.6, 0,1, 0,0,'black',1);
        drawShape('ell',x,y,z, 5,9, 5,1, 0,0, 1,0,'silver',1);

        drawShape('ell',x,y,z, 5,9, 4.9,.7, 0,0, 1,0,'black',1);
    drawShape('tri',x,y,z, 0,0, 3,8.5, 0,9, 5,0,'rgba(0,0,0,.2)',1,5,9);//face
      drawShape('tri',x,y,z, 10,0, 7,8.5, 10,9, 5,0,'rgba(0,0,0,.2)',1,5,9);//face


    break;
    case -25://CrownK
    drawShape('pol',x,y,z, 0,9, 0,0, 3,6, 5,0,'gold',1,5,9);//face
    drawShape('pol',x,y,z, 0,9, 0,0, 3,6, 5,0,'black',0,5,9);//face
   drawShape('pol',x,y,z, 10,9, 10,0, 7,6, 5,0,'gold',1,5,9);//face
     
   drawShape('pol',x,y,z, 10,9, 10,0, 7,6, 5,0,'black',0,5,9);//face
    drawShape('ell',x,y,z, 5,9, 5,.6, 0,1, 0,0,'black',1);
        drawShape('ell',x,y,z, 5,9, 5,1, 0,0, 1,0,'gold',1);

        drawShape('ell',x,y,z, 5,9, 4.9,.7, 0,0, 1,0,'black',1);
    drawShape('tri',x,y,z, 0,0, 3,8.5, 0,9, 5,0,'rgba(0,0,0,.2)',1,5,9);//face
      drawShape('tri',x,y,z, 10,0, 7,8.5, 10,9, 5,0,'rgba(0,0,0,.2)',1,5,9);//face

 
    break;
    case -26://Major Arcana Symbol
    
    drawShape('pol',x,y,z, 0,9, 0,0, 3,6, 5,0,'gray',1,5,9);//face
   drawShape('pol',x,y,z, 10,9, 10,0, 7,6, 5,0,'gray',1,5,9);//face
     
    drawShape('ell',x,y,z, 5,9, 5,.6, 0,1, 0,0,'black',1);
        drawShape('ell',x,y,z, 5,9, 5,1, 0,0, 1,0,'gray',1);

        drawShape('ell',x,y,z, 5,9, 4.9,.7, 0,0, 1,0,'black',1);

      sx = 8.1*z;
      sy = 4.05*z;
      sz = 2;
            drawShape('qua',x+sx,y+sy,z*sz*.9, .5,0, 0,.5, .5,1, 1,.5,'yellow',1);
            drawShape('qua',x+sx,y+sy,z*sz*.9, .5,0, 0,.5, .5,1, 1,.5,'rgba(255,255,255,.25)',1);
            drawShape('tri',x+sx,y+sy,z*sz*.9, 0,.5, .5,1, 1,.5, 0,0,'rgba(0,0,0,.15)',1);
            drawShape('tri',x+sx,y+sy,z*sz*.9, .5,0, 1,.5, .5,1, 0,0,'rgba(255,255,255,.25)',1);
            
          
           sx = .25*z;
      sy = 4.2*z;

          
          drawShape('qua',x+sx,y+sy,z*sz*.75, 0,0.1, .5,0, 1,.1, .5,.2,'green',1);
         drawShape('qua',x+sx,y+sy,z*sz*.75, 0,0.1, .5,0, 1,.1, .5,.2,'rgba(0,0,0,.25)',1);
         drawShape('qua',x+sx,y+sy,z*sz*.75, 0,0.1, 0,.9, .5,1, .5,.2,'green',1);
         drawShape('qua',x+sx,y+sy,z*sz*.75, 1,0.1, 1,.9, .5,1, .5,.2,'green',1);
         drawShape('qua',x+sx,y+sy,z*sz*.75, 1,0.1, 1,.9, .5,1, .5,.2,'rgba(255,255,255,.25)',1);
          
sx = 4.1*z;
      sy = 3.6*z;
        drawShape('qua',x+sx,y+sy,z*sz*.9, 0,.9, 0.5,0.1, 1,.9, .5,1,'black',1);
        drawShape('tri',x+sx,y+sy,z*sz*.9, .5,0.1, 1,.9, .5,1, 1,.5,'black',1);
        drawShape('qua',x+sx,y+sy,z*sz*.9, 0,.9, 0.5,0.1, 1,.9, .5,1,'red',1);
        drawShape('tri',x+sx,y+sy,z*sz*.9, .5,0.1, 1,.9, .5,1, 1,.5,'rgba(255,255,255,.25)',1);
       
       sx = 4.1*z;
      sy = 6.3*z;
   
        drawShape('arc',x+sx,y+sy,z*sz, .45,.47, .4,0, 2,0, .0,0,'rgba(0,0,255,.5)',1);
        drawShape('arc',x+sx,y+sy,z*sz, .45,.47, .4,0, 2,0, .0,0,'rgba(0,0,255,.5)',1);
        drawShape('arc',x+sx,y+sy,z*sz, .5,.47, .36,0, 2,0, .0,0,'rgba(255,255,255,.075)',1);
        drawShape('arc',x+sx,y+sy,z*sz, .55,.47, .3,0, 2,0, .0,0,'rgba(255,255,255,.075)',1);
        drawShape('arc',x+sx,y+sy,z*sz, .65,.47, .2,0, 2,0, .0,0,'rgba(255,255,255,.075)',1);
        drawShape('arc',x+sx,y+sy,z*sz, .75,.47, .1,0, 2,0, .0,0,'rgba(255,255,255,.075)',1);
        drawShape('arc',x+sx,y+sy,z*sz, .45,.47, .4,0, 2,0, .0,0,'rgba(0,0,0,.15)',1);
        drawShape('arc',x+sx,y+sy,z*sz, .45,.47, .4,0, 2,0, .0,0,'rgba(255,255,255,.075)',1);
        drawShape('tri',x,y,z, 0,0, 3,8.5, 0,9, 5,0,'rgba(0,0,0,.2)',1,5,9);//face
      drawShape('tri',x,y,z, 10,0, 7,8.5, 10,9, 5,0,'rgba(0,0,0,.2)',1,5,9);//face

    break;
    
    
    case -27://card
      let tempCard = new Card(card,0)
      tempCard.place(x+1.9*z,y+.24*z,z*2.75);
    break;
    case -28://Card Grimoire icon
      //item
      sx = -1.25 *z;
      sy = -2 *z;
      sz = 1.25 *z;

      drawShape('qua',x+sx,y+sy,z*sz, 9,5, 6,9, 4,7, 7,3,'rgba(0,255,255,1)',1)//cork
      drawShape('qua',x+sx,y+sy,z*sz, 7.5,6.5, 6,8.5, 4,6.7, 6.5,5.45,'rgba(0,0,0,1)',1)//cork
      drawShape('qua',x+sx,y+sy,z*sz, 8.6,5.2, 7,3.55, 6.1,4.6, 7.75,6.25,'rgba(0,0,0,.5)',1)//cork

      //spell
      drawShape('qua',x+sx,y+sy,z*sz, 1,5, 4,9, 6,7, 3,3,'rgba(255,0,255,1)',1)//cork
      drawShape('qua',x+sx,y+sy,z*sz, 2.5,6.5, 4,8.5, 6,6.7, 3.5,5.45,'rgba(0,0,0,1)',1)//cork
      drawShape('qua',x+sx,y+sy,z*sz, 1.4,5.2, 3,3.55, 3.9,4.6, 2.25,6.25,'rgba(255,255,255,.5)',1)//cork

      //monster
      drawShape('qua',x+sx,y+sy,z*sz, 3.5,3, 6.5,3, 6.5,8, 3.4,8,'rgba(255,255,0,1)',1)//cork
      drawShape('qua',x+sx,y+sy,z*sz, 3.7,5.25, 3.7,7.75, 6.3,7.75, 6.3,5.25,'rgba(0,0,0,1)',1)//cork
      drawShape('qua',x+sx,y+sy,z*sz, 3.7,3.5, 3.7,5, 6.3,5, 6.3,3.5,'rgba(255,255,255,.5)',1)//cork
      break;
    case -29://Cavern entrance BROWN
      drawShape('pol',x,y,z, 2,9, 2,4, 3,2, 5,1,'rgba(64,32,16,1)',1,5,9)//cork
      drawShape('pol',x,y,z, 8,9, 8,4, 7,2, 5,1,'rgba(64,32,16,1)',1,5,9)//cork
      drawShape('qua',x,y,z, 2,9, 2,7.9, 5,7.9, 5,9,'rgba(0,0,0,.25)',1,5,9)//cork
      drawShape('qua',x,y,z, 8,9, 8,7.9, 5,7.9, 5,9,'rgba(0,0,0,.25)',1,5,9)//cork
      drawShape('pol',x,y,z, 8,9, 7.5,5, 6,3, 5.5,2.5,'rgba(0,0,0,.75)',1,5,2.25)//cork
      drawShape('pol',x,y,z, 2,9, 2.5,5, 4,3, 4.5,2.5,'rgba(0,0,0,.75)',1,5,2.25)//cork
      drawShape('qua',x,y,z, 5,2.25, 2.48,7.9, 5,7, 7.52,7.9,'rgba(0,0,0,1)',1,5,2)//cork

      drawShape('tri',x,y,z, 5,7, 2.25,7.9, 8,7.9, 5,9,'rgba(0,0,0,.50)',1,5,9)//cork

      break;
    case -30: // CASTLE GATE / RED
      drawShape('pol', x, y, z, 1,10, 1,2, 5,0, 9,2, 'rgba(64,0,0,1)', 1, 9,10);
      drawShape('rec', x, y, z, 2.5, 3.5, 5, 6.5, 0, 0, 0, 0, 'black', 1);
      drawShape('qua', x, y, z, 2.5,10, 3.5,3.5, 1,2, 1,10, 'rgba(128,0,0,.15)', 1);
      drawShape('qua', x, y, z, 2.5,10, 2.5,3.5, 1,2, 1,10, 'rgba(64,0,0,1)', 1);
      drawShape('qua', x, y, z, 7.5,10, 6.5,3.5, 9,2, 9,10, 'rgba(128,0,0,.15)', 1);
      drawShape('qua', x, y, z, 7.5,10, 7.5,3.5, 9,2, 9,10, 'rgba(64,0,0,1)', 1);
      drawShape('tri', x, y, z, 4,3.5, 6,3.5, 5,2, 4.5,3.5, 'rgba(255,0,0,1)', 1, 4,1.5); 
      drawShape('qua', x, y, z, 2.5,10, 7.5,10, 7.27,8.5, 2.73,8.5, 'rgba(128,0,0,0.1)', 1);
      break;
    case -31: // CASTLE GATE / BLUE
      drawShape('pol', x, y, z, 1,10, 1,2, 5,0, 9,2, 'rgba(0,0,64,1)', 1, 9,10);
      drawShape('rec', x, y, z, 2.5, 3.5, 5, 6.5, 0, 0, 0, 0, 'black', 1);
            drawShape('rec', x, y, z, 2.5, 3.5, 5, 6.5, 0, 0, 0, 0, 'rgba(0,0,64,.2)', 1);

      drawShape('qua', x, y, z, 2.5,10, 3.5,3.5, 1,2, 1,10, 'rgba(0,0,128,.75)', 1);
      drawShape('qua', x, y, z, 2.5,10, 2.5,3.5, 1,2, 1,10, 'rgba(0,0,64,1)', 1);
      drawShape('qua', x, y, z, 7.5,10, 6.5,3.5, 9,2, 9,10, 'rgba(0,0,128,.75)', 1);
      drawShape('qua', x, y, z, 7.5,10, 7.5,3.5, 9,2, 9,10, 'rgba(0,0,64,1)', 1);
      drawShape('arc', x, y, z, 5,2.5, .75,0, 2,0, 0,0, 'rgba(0,0,255,1)', 1, 4,1.5); 
      drawShape('qua', x, y, z, 2.5,10, 7.5,10, 7.27,8.5, 2.73,8.5, 'rgba(0,0,128,0.1)', 1);
      break;
    case -32://Cavern entrance WHITE
      drawShape('pol',x,y,z, 2,9, 2,4, 3,2, 5,1,'rgba(210,210,255,1)',1,5,9)//cork
      drawShape('pol',x,y,z, 8,9, 8,4, 7,2, 5,1,'rgba(210,210,255,1)',1,5,9)//cork
      drawShape('qua',x,y,z, 2,9, 2,7.9, 5,7.9, 5,9,'rgba(0,0,0,.25)',1,5,9)//cork
      drawShape('qua',x,y,z, 8,9, 8,7.9, 5,7.9, 5,9,'rgba(0,0,0,.25)',1,5,9)//cork
      drawShape('pol',x,y,z, 8,9, 7.5,5, 6,3, 5.5,2.5,'rgba(0,0,0,.75)',1,5,2.25)//cork
      drawShape('pol',x,y,z, 2,9, 2.5,5, 4,3, 4.5,2.5,'rgba(0,0,0,.75)',1,5,2.25)//cork
      drawShape('qua',x,y,z, 5,2.25, 2.48,7.9, 5,7, 7.52,7.9,'rgba(0,0,0,1)',1,5,2)//cork

      drawShape('tri',x,y,z, 5,7, 2.25,7.9, 8,7.9, 5,9,'rgba(0,0,0,.50)',1,5,9)//cork

      break;
    case -33://CASTLE GATE / YELLOW
      drawShape('pol', x, y, z, 1,10, 1,2, 5,0, 9,2, 'rgba(64,64,0,1)', 1, 9,10);
      drawShape('rec', x, y, z, 2.5, 3.5, 5, 6.5, 0, 0, 0, 0, 'black', 1);
            drawShape('rec', x, y, z, 2.5, 3.5, 5, 6.5, 0, 0, 0, 0, 'rgba(64,64,0,.2)', 1);

      drawShape('qua', x, y, z, 2.5,10, 3.5,3.5, 1,2, 1,10, 'rgba(128,128,0,.75)', 1);
      drawShape('qua', x, y, z, 2.5,10, 2.5,3.5, 1,2, 1,10, 'rgba(64,64,0,1)', 1);
      drawShape('qua', x, y, z, 7.5,10, 6.5,3.5, 9,2, 9,10, 'rgba(128,128,0,.75)', 1);
      drawShape('qua', x, y, z, 7.5,10, 7.5,3.5, 9,2, 9,10, 'rgba(64,64,0,1)', 1);
      drawShape('qua', x, y, z, 5,1.75, 4.25,2.5, 5,3.25, 5.75,2.5, 'rgba(255,255,0,1)', 1, 4,1.5); 
      drawShape('qua', x, y, z, 2.5,10, 7.5,10, 7.27,8.5, 2.73,8.5, 'rgba(128,128,0,0.1)', 1);
      break;
    case -34://Cavern entrance GRAY
      drawShape('pol',x,y,z, 2,9, 2,4, 3,2, 5,1,'rgba(32,32,32,1)',1,5,9)//cork
      drawShape('pol',x,y,z, 8,9, 8,4, 7,2, 5,1,'rgba(32,32,32,1)',1,5,9)//cork
      drawShape('qua',x,y,z, 2,9, 2,7.9, 5,7.9, 5,9,'rgba(0,0,0,.25)',1,5,9)//cork
      drawShape('qua',x,y,z, 8,9, 8,7.9, 5,7.9, 5,9,'rgba(0,0,0,.25)',1,5,9)//cork
      drawShape('pol',x,y,z, 8,9, 7.5,5, 6,3, 5.5,2.5,'rgba(0,0,0,.75)',1,5,2.25)//cork
      drawShape('pol',x,y,z, 2,9, 2.5,5, 4,3, 4.5,2.5,'rgba(0,0,0,.75)',1,5,2.25)//cork
      drawShape('qua',x,y,z, 5,2.25, 2.48,7.9, 5,7, 7.52,7.9,'rgba(0,0,0,1)',1,5,2)//cork

      drawShape('tri',x,y,z, 5,7, 2.25,7.9, 8,7.9, 5,9,'rgba(0,0,0,.50)',1,5,9)//cork

      break;
    case -35://CASTLE GATE / GRAY
      drawShape('pol', x, y, z, 1,10, 1,2, 5,0, 9,2, 'rgba(255,255,255,.03)', 1, 9,10);
      drawShape('rec', x, y, z, 2.5, 3.5, 5, 6.5, 0, 0, 0, 0, 'black', 1);
            drawShape('rec', x, y, z, 2.5, 3.5, 5, 6.5, 0, 0, 0, 0, 'rgba(255,255,255,.02)', 1);

      drawShape('qua', x, y, z, 2.5,10, 3.5,3.5, 1,2, 1,10, 'rgba(255,255,255,.025)', 1);
      drawShape('qua', x, y, z, 2.5,10, 2.5,3.5, 1,2, 1,10, 'rgba(255,255,255,.01)', 1);
      drawShape('qua', x, y, z, 7.5,10, 6.5,3.5, 9,2, 9,10, 'rgba(255,255,255,.01)', 1);
      drawShape('qua', x, y, z, 7.5,10, 7.5,3.5, 9,2, 9,10, 'rgba(255,255,255,.021)', 1);
      drawShape('qua', x, y, z, 5,1.75, 4.25,2.5, 5,3.25, 5.75,2.5, 'rgba(255,255,255,.02)', 1, 4,1.5); 
      drawShape('qua', x, y, z, 2.5,10, 7.5,10, 7.27,8.5, 2.73,8.5, 'rgba(255,255,255,0.01)', 1);
      break;
    
    case 1.1://Magician No Artifacts
        sx =-.6391*z;
        sy = -.30691*z;
        sz = 1.13;
        drawShape('qua',x+sx,y+sy,z*sz,  5.2,8.4,   5.1,8.8,    6.25,9,   5.75, 8.75,'white',1);//right foot
        drawShape('qua',x+sx,y+sy,z*sz,  4.8,8.4,   4.9,8.8,    3.75,9,   4.25, 8.75,'white',1);//left foot
        drawShape('qua',x+sx,y+sy,z*sz,  6,5.51,   6.1,8.5,    3.9,8.5,   4, 5.51,'white',1);//robe botto,
        let caly = 0;
        let calx = 1.26;
        let calxt = 3.339;
        let calxs = calx;

        let calz = .8;
        let calzt = .6;
        let calzs = calz;
        let zrat = calzt/calzs;
        let xrat = (calxt-calxs)*zrat
        let caly2 = 0;
        let calx2 = 1.069*xrat
        let calz2 = 1 * zrat;
        calz = calzt;
        calx = calxt;
        sx =-.6391*z;
        sy = -.30691*z;
        sz = 1.13;
        drawShape('qua',x+sx,y+sy,z*calz*sz, 4.5+calx,3.5+caly, 4.5+calx,4+caly, 4.25+calx,4+caly,5+calx,4.5+caly,'rgb(185,122,87)',1);//neck left
        drawShape('qua',x+sx,y+sy,z*calz*sz, 5.5+calx,3.5+caly, 5.5+calx,4+caly, 5.75+calx,4+caly,5+calx,4.5+caly,'rgb(185,122,87)',1);//neck right
        drawShape('qua',x+sx,y+sy,z*calz*sz, 4.35+calx,3.2+caly, 5+calx,3.9+caly, 5.65+calx,3.2+caly, 5+calx,4.52+caly,'rgb(185,122,87)',1);//neck middle
        drawShape('qua',x+sx,y+sy,z*calz*sz, 4.35+calx,3.2+caly, 5+calx,3.9+caly, 5.65+calx,3.2+caly, 5.02+calx,4.52+caly,'rgba(0,0,0,.2)',1);//neck middle
        drawShape('qua',x+sx,y+sy,z*calz*sz, 5.02+calx,2+caly, 4.1+calx,2.5+caly, 4.25+calx,3.25+caly,5.02+calx,3.9+caly,'rgb(185,122,87)',1);//face left
        drawShape('qua',x+sx,y+sy,z*calz*sz, 5.02+calx,2+caly, 5.9+calx,2.5+caly, 5.75+calx,3.25+caly,5+calx,3.9+caly,'rgb(185,122,87)',1);//face right

        drawShape('rec',x+sx,y+sy,z*calz*sz, 4+calx,2+caly,2,.25,0,0,0,0,'white',1);//headband
        drawShape('qua',x+sx,y+sy,z*calz*sz, 5+calx,1.63+caly, 4.3+calx,1.75+caly, 4+calx,2+caly,5+calx,2+caly,'rgb(0,0,0)',1);//top head
        drawShape('qua',x+sx,y+sy,z*calz*sz, 5+calx,1.63+caly, 5.7+calx,1.75+caly, 6+calx,2+caly,5+calx,2+caly,'rgb(0,0,0)',1);//top head
        //DONOTDELETEdrawShape('qua',x,y,z,4,2.25, 3.9,3.5, 4.25,3,4.25,4.25,'rgb(119,43,79)',1);//lightning bolt

        drawShape('qua',x+sx,y+sy,z*calz*sz, 4+calx,2.25+caly, 5+calx,2.25+caly, 4.25+calx,2.5+caly,4.25+calx,4+caly,'rgb(0,0,0)',1);//bangs left
        drawShape('qua',x+sx,y+sy,z*calz*sz, 6+calx,2.25+caly, 5+calx,2.25+caly, 5.75+calx,2.5+caly,5.75+calx,4+caly,'rgb(0,0,0)',1);//bangs left

        drawShape('qua',x+sx,y+sy,z*calz2*sz, 5.6+calx2,3.2+caly2,    5+calx2,   3.6+caly2,    6+calx2,    6+caly2, 5.75+calx2, 3.2+caly2,'white',1);//shirt right
        drawShape('qua',x+sx,y+sy,z*calz2*sz,   5+calx2, 3.6+caly2,  4.5+calx2,  3.25+caly2, 4.25+calx2,    6+caly2,    6+calx2,   6+caly2,'white',1);//shirt left
        drawShape('qua',x+sx,y+sy,z*calz2*sz, 5.6+calx2,3.2+caly2, 5.75+calx2, 3.19+caly2,    6+calx2,  3.2+caly2,  6.5+calx2, 3.5+caly2,'darkred',1);//right shoulder
        drawShape('rec',x+sx,y+sy,z*sz,4,4.65,2,.3,0,0,0,0,'rgba(0,0,0,.75)',0);

        drawShape('rec',x,y,z, 4,4.75, 2,.125, 0,0,0,0,'rgba(255,255,255,.75)',1);//belt/midsection
        drawShape('rec',x,y,z, 4,4.75, 2,.2499, 0,0,0,0,'rgba(255,255,255,.75)',1);//belt/midsection
        drawShape('rec',x,y,z, 4,4.875, 2,.2499, 0,0,0,0,'rgba(255,255,255,.75)',1);//belt/midsection
        drawShape('rec',x,y,z, 4,5, 2,.2499, 0,0,0,0,'rgba(255,255,255,.75)',1);//belt/midsection
        drawShape('rec',x,y,z, 4,5.125, 2,.2499, 0,0,0,0,'rgba(255,255,255,.75)',1);//belt/midsection
        drawShape('rec',x,y,z, 4,5.25, 2,.2499, 0,0,0,0,'rgba(255,255,255,.75)',1);//belt/midsection
        drawShape('rec',x,y,z, 4,5.375, 2,.2499, 0,0,0,0,'rgba(255,255,255,.75)',1);//belt/midsection
        drawShape('rec',x,y,z, 4,5.5, 2,.2499, 0,0,0,0,'rgba(255,255,255,.75)',1);//belt/midsection
        drawShape('rec',x,y,z, 4,5.625, 2,.2499, 0,0,0,0,'rgba(255,255,255,.75)',1);//belt/midsection
        drawShape('rec',x,y,z, 4,5.75, 2,.2499, 0,0,0,0,'rgba(255,255,255,.75)',1);//belt/midsection
        drawShape('rec',x,y,z, 4,5.875, 2,.2499, 0,0,0,0,'rgba(255,255,255,.75)',1);//belt/midsection
                drawShape('qua',x+sx,y+sy,z*calz2*sz, 3.5+calx2,3.5+caly2,  3.1+calx2,    4+caly2,    2+calx2,   5.5+caly2,    2+calx2,   9+caly2,'darkred',1);//robeR Right

        drawShape('qua',x+sx,y+sy,z*calz2*sz, 6.5+calx2,3.5+caly2,  6.9+calx2,    4+caly2,    8+calx2,   5.5+caly2,    8+calx2,   9+caly2,'darkred',1);//robeR Right
        drawShape('tri',x,y,z, 7.14,5.6,  7.5, 7.25,    7.44,   5,    8,   9,'rgba(0,0,0,.35)',1);//robeR Right
        drawShape('tri',x,y,z, 2.86,5.6,  2.5, 7.25,    2.56,   5,    2,   9,'rgba(0,0,0,.35)',1);//robeR Right
        drawShape('qua',x+sx,y+sy,z*calz2*sz,4.5+calx2,3.2+caly2, 4+calx2,    9+caly2,    2+calx2,    9+caly2,  3.5+calx2, 3.5+caly2,'darkred',1);//robeR LEft

        drawShape('qua',x+sx,y+sy,z*calz2*sz,5.75+calx2,3.2+caly2, 6.25+calx2,    9+caly2,    8+calx2,    9+caly2,  6.5+calx2, 3.5+caly2,'darkred',1);//robeR LEft
        sx =-.6391*z;
        sy = -.6*z;
        sz = 1.13;
        drawShape('qua',x+sx,y+sy,z*sz,  7.1,5,   7.25,5.3,    7.28,5.7,   6.9, 5.5,'white',1);//right arm
            drawShape('qua',x+sx,y+sy,z*sz,  2.9,5,   2.75,5.3,    2.72,5.7,   3.1, 5.5,'white',1);//right arm


        sx =-.6391*z;
        sy = -.6*z;
        sz = 1.13;
      
        drawShape('qua',x+sx,y+sy,z*sz, 7.5,5.6, 7.8,5.8, 7.4,6, 7.25,5.5,'rgb(185,122,87)',1);//left forearm
        drawShape('tri',x+sx,y+sy,z*sz, 7.45,5.93, 7.4,5.85, 7.5,5.875, 7.5,5.6,'rgb(165,102,67)',1);//left forearm
        drawShape('qua',x+sx,y+sy,z*sz, 2.5,5.6, 2.2,5.8, 2.6,6, 2.75,5.5,'rgb(185,122,87)',1);//left forearm
        drawShape('tri',x+sx,y+sy,z*sz, 2.55,5.93, 2.6,5.85, 2.5,5.875, 2.5,5.6,'rgb(165,102,67)',1);//left forearm
        sx =-.6391*z;
        sy = -1.3691*z;
        sz = 1.13;
        drawShape('tri',x+sx,y+sy,z*sz, 5,2.5, 5.15,2.85, 5,2.85, 0,0,'rgba(0,0,0,.25)',1);//nose
        drawShape('tri',x+sx,y+sy,z*sz, 4.8,3, 5.2,3, 5,2.95, 0,0,'rgba(255,0,0,.25)',1);//mouth
        drawShape('tri',x+sx,y+sy,z*sz, 4.6,2.55, 4.9,2.55, 4.75,2.58, 0,0,'rgba(0,0,0,.25)',1);//left eye
        drawShape('tri',x+sx,y+sy,z*sz, 5.4,2.55, 5.1,2.55, 5.25,2.58, 0,0,'rgba(0,0,0,.25)',1);//left eye
        sx =-.6391*z;
        sy = -1.2*z;
        sz = 1.13;
        drawShape('ell',x+sx,y+sy,z*sz,4.61,1.5, .4,.25,1,0,6,0,'white',1);//infinity symbol 
        drawShape('ell',x+sx,y+sy,z*sz,5.39,1.5, .4,.25,1,0,6,0,'white',1);
        drawShape('ell',x+sx,y+sy,z*sz,4.61,1.5, .38,.23,1,0,6,0,'rgba(0,6,13)',1);
        drawShape('ell',x+sx,y+sy,z*sz,5.39,1.5, .38,.23,1,0,6,0,'(rgba(0,6,13)',1);
        sx =8.5*z;
        sy = 6.5*z;
        sz = .13;
        
        break;
    case 2.1://High Priestess Head Only
      
      drawShape('tri',x,y,z, 3,0, 4,1, 5,1, 0,0,'lightblue',1);//veil top
      drawShape('tri',x,y,z, 7,0, 6,1, 5,1, 0,0,'lightblue',1);//veil top
      drawShape('rec',x,y,z, 4.2,1, 1.6,2.1, 0,0,0,0,'black',1);//face
      drawShape('qua',x,y,z, 4.5,3, 5,2.5, 5.5,3, 5,3.5,'rgb(174,111,77)',1);//neck
      drawShape('rec',x,y,z, 4.2,1, 1.6,1, 0,0,0,0,'rgb(185,122,87)',1);//face
      drawShape('tri',x,y,z, 4.23,1.9, 5.78,1.9, 5,3, 0,0,'rgb(185,122,87)',1);//face bottom
      drawShape('rec',x,y,z, 4,1, .2,2.2, 0,0,0,0,'lightblue',1);//veil l
      drawShape('rec',x,y,z, 4,1, .2,2.2, 0,0,0,0,'rgba(0,0,0,.1)',1);//veil l
      drawShape('rec',x,y,z, 5.8,1, .2,2.2, 0,0,0,0,'lightblue',1);//veil r
      drawShape('rec',x,y,z, 5.8,1, .2,2.2, 0,0,0,0,'rgba(0,0,0,.1)',1);//veil r
      drawShape('rec',x,y,z, 4,1, 2,.75, 0,0,0,0,'lightblue',1);//veil m
      drawShape('rec',x,y,z, 4,1, 2,.75, 0,0,0,0,'rgba(0,0,0,.1)',1);//veil m
      drawShape('tri',x,y,z, 5,1.75, 5.15,2.25, 5,2.25, 0,0,'rgba(0,0,0,.25)',1);//nose
      drawShape('tri',x,y,z, 4.7,2.5, 5.3,2.5, 5,2.59, 0,0,'rgba(255,0,0,.525)',1);//mouth
      drawShape('tri',x,y,z, 4.5,1.8, 4.9,1.8, 4.75,1.83, 0,0,'rgba(0,0,0,.25)',1);//left eye
      drawShape('tri',x,y,z, 5.5,1.8, 5.1,1.8, 5.25,1.83, 0,0,'rgba(0,0,0,.25)',1);//r eye
      drawShape('arc',x,y,z,5,    .85, .8,0,6,0,0,0,'lightblue',1);//bag
      drawShape('arc',x,y,z,4.95,.80,.75,0,6,0,0,0,'rgba(255,255,255,.25)',1);//bag
      drawShape('arc',x,y,z,4.9,  .85, .7,0,6,0,0,0,'rgba(255,255,255,.25)',1);//bag
      drawShape('arc',x,y,z,4.85, .85, .65,0,6,0,0,0,'rgba(255,255,255,.25)',1);//bag
      drawShape('arc',x,y,z,4.8,  .85, .6,0,6,0,0,0,'rgba(255,255,255,.25)',1);//bag

    break;
    case 9.1: //Hermit No mountain
      drawShape('ell',x,y,z,4.59,.8,.65,.5,1,0,6,0,'gray',1);
      drawShape('qua',x,y,z,5.3,1, 6,2.5, 5.5,2.5, 5,1,'gray',1);//hair back
			
      sx = .15*z;
      sy = .49*z;
      sz=.95;
			drawShape('qua',x,y,z,4.4,8.5,/*tr*/4.75,9.5,/*br*/ 3,9.5,/*l*/4,9,/*tl*/'darkgray',1);//l-foot
			drawShape('qua',x+sx,y+sy,z*sz,4.5,9.5,/*br*/ 4.5,7.7,/*tr*/ 3.3,7.3,/*tl*/ 4.3,9,/*bl*/'darkgray',1);//l-calf
			//drawShape('qua',x+sx,y+sy,z*sz,4.5,9.5,/*br*/ 4.5,7.7,/*tr*/ 3.3,7.3,/*tl*/ 3.9,9,/*b*/'gray',0);//l-calf
			drawShape('qua',x+sx,y+sy,z*sz,4.7,2,5.5,1.5,6,2.5,4.25,2.5,'gray',1);//neck
			drawShape('qua',x+sx,y+sy,z*sz,5.5,7,/*tl*/6.25,7.25,/*tm*/6.75,7.2,/*tr*/ 6.25,9.5,/*b*/'darkgray',1);//r-calf
			//drawShape('qua',x,y,z,6.25,9,/*tl*/6.55,9.5,/*bl*/4.5,9.75,/*bm*/ 6,9,/*br*/'darkgray',1);//r-foot
			drawShape('qua',x,y,z,5.9,8.5,/*tr*/6.25,9.5,/*br*/ 4.8,9.6,/*l*/6,9,/*tl*/'darkgray',1);//l-foot
			drawShape('qua',x,y,z,/*tr*/ 4,2.5, /*tl*/3,1.5, /*bl*/2.5,5, 4,8,'gray',1);//l-arm
		  drawShape('qua',x,y,z,/*tr*/ 4,2.5, /*tl*/3,1.5, /*bl*/2.5,5, 4,8,'rgba(0,0,0,0.15)',1);//l-arm
			drawShape('tri',x+sx,y+sy,z*sz,/*tl*/ 5.55,3.55, /*tr*/6.3,2.5, /*br*/7.7,4, 0,0,'lightgray',1);//r-arm
			drawShape('tri',x+sx,y+sy,z*sz,/*tl*/ 5.6,3.5, /*tr*/6.3,2.5, /*br*/7.7,4, 0,0,'gray',0);//r-arm
			drawShape('arc',x+sx,y+sy,z*sz,6.2,5.75,.4,0,3,0,0,0,'darkgray',1);//r-hand
      drawShape('qua',x+sx,y+sy,z*sz,4,2, 4,4, 3,8, 7.25,7.25,'gray',1);//robeLShoulder
      drawShape('qua',x+sx,y+sy,z*sz,6,2.1, 7.5,3.5, 7.25,7.25, 4,2,'gray',1);//robeLShoulder
      drawShape('qua',x,y,z,7,9, 3,8.5, 3,8.1, 6,7.5,'gray',1);//robeLShoulder
      drawShape('tri',x+sx,y+sy,z*sz,/*br*/ 7.9,3.9, /*tr*/7.3,3.3, /*l*/6.5,5.5, 0,0,'lightgray',1);//r-forearm
			drawShape('tri',x+sx,y+sy,z*sz,/*br*/ 7.9,3.9, /*tr*/7.3,3.3, /*l*/6.5,5.5, 0,0,'gray',0);//r-forearm
      drawShape('qua',x,y,z,/*bl*/ 3,2.5, /*tl*/2.25,1.5, /*tr*/2.5,1, /*br*/ 3.5,2,'lightgray',1);//l-forearm
      drawShape('qua',x,y,z,2.5,1, 1.5,1, 2,1.5, 2.5,1.4,'rgb(185,122,87)',1);//hand left
      //drawShape('arc',x,y,z,2,2.75, .39,0, 3,0, 0,0,'gold',1);////gold orb
      drawShape('arc',x,y,z,2,2.75, .5,0, 3,0, 0,0,'rgba(255,255,0,.05)',1);////gold orb
      sx = 1.62*z;
      sy = 2.35*z;
      sz=.075;
      drawShape('tri',x+sx,y+sy,z*sz,5,0,.5,7.5,9.5,7.5,0,0,'black',0);
      drawShape('tri',x+sx,y+sy,z*sz,5,10,.5,2.5,9.5,2.5,0,0,'black',0);
      drawShape('tri',x+sx,y+sy,z*sz,5,0,.5,7.5,9.5,7.5,0,0,'gold',1);
      drawShape('tri',x+sx,y+sy,z*sz,5,10,.5,2.5,9.5,2.5,0,0,'gold',1);
      sx = 1.25*z;
      sy = 2*z;
      sz=.15;
      drawShape('tri',x+sx,y+sy,z*sz,5,0,.5,7.5,9.5,7.5,0,0,'rgba(255,255,0,.25)',1);
      drawShape('tri',x+sx,y+sy,z*sz,5,10,.5,2.5,9.5,2.5,0,0,'rgba(255,255,0,.25)',1);
      sx = 1.5*z;
      sy = 2.25*z;
      sz=.1;
      drawShape('tri',x+sx,y+sy,z*sz,5,0,.5,7.5,9.5,7.5,0,0,'rgba(255,255,0,.25)',1);
      drawShape('tri',x+sx,y+sy,z*sz,5,10,.5,2.5,9.5,2.5,0,0,'rgba(255,255,0,.25)',1);
      sx = .15*z;
      sy = .49*z;
      sz=.95;
      drawShape('arc',x,y,z,2,2.2, .6,1, 0,1, 1,0,'brown',1);//lantern top
      drawShape('rec',x,y,z,1.5,3.25, 1,.1, 0,1, 1,0,'brown',1);////lantern bottom
      drawShape('rec',x,y,z,1.5,1.99, .1,1.27, 0,1, 1,0,'brown',1);////lantern bottom
      drawShape('rec',x,y,z,1.95,1.99, .1,1.27, 0,1, 1,0,'brown',1);////lantern bottom
      drawShape('rec',x,y,z,2.4,1.99, .1,1.27, 0,1, 1,0,'brown',1);////lantern bottom
      drawShape('ell',x,y,z,2,2.17, .6,.1, 1,1, 0,6,'brown',0);//lantern top
      drawShape('ell',x,y,z,2,2.17, .6,.1, 1,1, 0,6,'rgba(255,255,0,.25)',1);//lantern top
      drawShape('ell',x,y,z,2,3.3, .5,.1, 1,1, 0,6,'brown',1);//lantern top
      drawShape('rec',x,y,z,1.975,1, .05,.6, 0,1, 1,0,'gray',1);////lantern bottom
      drawShape('arc',x,y,z,2,1.55, .1,0, 3,0, 0,0,'brown',1);////gold orb
      drawShape('qua',x,y,z,2.5,1, 1.7,1.1, 2,1.15, 2.5,1.4,'rgb(185,122,87)',1);//hand left
     	drawShape('arc',x+sx,y+sy,z*sz,6,3, .63,0, 3,0, 0,0,'rgba(0,0,0,0.025)',1);//r-shoulder
      drawShape('qua',x+sx,y+sy,z*sz,6,2.1, 7.5,3.5, 7.25,7.25, 4,2,'rgba(0,0,0,0.1)',1);//robeLShoulder
      drawShape('qua',x,y,z,2.5,1, 3,3.5, 7,9, 7,5.5,'gray',1);//crown
      drawShape('qua',x+sx,y+sy,z*sz,7,5, 6,4.75, 6.3,5.5, 6.5,5.5,'rgb(185,122,87)',1);//hand right
      drawShape('rec',x+sx,y+sy,z*sz,6.3,1, .19,8.9, 6.3,3, 0,0,'brown',1);//ankh
      drawShape('rec',x+sx,y+sy,z*sz,6.3,1, .19,8.9, 6.3,3, 0,0,'rgb(0,6,13)',0);//ankh
      drawShape('arc',x+sx,y+sy,z*sz,6.4,1, .25,0, 3,0, 0,0,'brown',1);//ankh circle outer
      drawShape('arc',x+sx,y+sy,z*sz,6.4,1, .25,0, 3,0, 0,0,'rgb(0,6,13)',0);//ankh circle outer
      drawShape('qua',x+sx,y+sy,z*sz,7,5, 6,5, 6.3,5.5, 6.5,5.5,'rgb(185,122,87)',1);//hand right
      drawShape('qua',x+sx,y+sy,z*sz,4.7,5.5,/*tr*/ 3.5,7.5,/*br*/ 4.4,7.7,/*bl*/ 5,6.5,'rgba(0,0,0,.05)',1);//l-thigh shadow
      drawShape('arc',x+sx,y+sy,z*sz,4.25,2.65, .63,0, 3,0, 0,0,'rgba(0,0,0,.025)',1);//l-shoulder
			drawShape('ell',x+sx,y+sy,z*sz,5.15,3.6,1.15,1.75,0,0,6,0,'rgba(0,0,0,.025)',1);//torso
			drawShape('qua',x+sx,y+sy,z*sz,4.5,5.5,/*tl*/6,4.5,/*tr*/ 6.5,7.7,/*br*/ 5.8,8,/*bl*/ 'rgba(0,0,0,.04)',1);//r-thigh
			drawShape('qua',x+sx,y+sy,z*sz,6.2,4.3,7.25,7.25,5.1,6.3,4.75,5.25,'rgba(0,0,0,.05)',1);//hip armor
		  drawShape('qua',x+sx,y+sy,z*sz,3,8, 3,2, 5.5,5.5, 7,7.3,'rgba(0,0,0,.05)',1);//groin armor
      drawShape('qua',x+sx,y+sy,z*sz,4,2, 3.5,2.5, 6.5,7.2, 4.2,5,'rbga(0,0,0,.05)',1);//robeLShoulder
      drawShape('qua',x+sx,y+sy,z*sz,4,2, 6.5,2.5, 3.5,7.2, 6.5,5,'rgba(0,0,0,.05)',1);//robeLShoulder
      drawShape('qua',x,y,z,5,1, 4.5,2, 4.75,2.5, 4.5,3,'rgba(255,255,255,.9)',1);//beard l
      drawShape('qua',x,y,z,4.75,2.5, 5.5,2, 5.25,.75, 4,1,'rgb(185,122,87)',1);//head
      drawShape('qua',x,y,z,4.75,2.5, 4.5,2, 4.5,3, 4.5,3,'rgba(255,255,255,.9)',1);//beard l
      drawShape('qua',x,y,z,4.5,2, 5,1.8, 5,1.9, 4.5,2.11,'rgba(255,255,255,.9)',1);//beard l
      drawShape('qua',x,y,z,5.3,1, 5.5,2, 5,3, 4.5,3,'rgba(255,255,255,.9)',1);//beard
      drawShape('tri',x,y,z,5,1.8, 4.5,2, 4.75,2.5, 4.75,2.5,'rgba(255,255,255,.9)',1);//beard
      drawShape('tri',x,y,z,4.5,1, 5.8,2.5, 5.3,1, 4.5,3,'gray',1);//beard
      drawShape('qua',x,y,z,4.1,1.3, 5.3,1, 5.25,.75, 3.9,.75,'gray',1);//crown
      drawShape('qua',x,y,z,4.5,1.5, 4.5,2, 4.7,2, 4.5,1.5,'rgba(0,0,0,.25)',1);//nose
      drawShape('qua',x,y,z,4.5,1.5, 4.9,1.45, 4.75,1.45, 4.7,1.45,'rgba(0,0,0,.25)',1);//eyesr
      drawShape('qua',x,y,z,4.5,1.5, 4.25,1.44, 4.3,1.5, 4.5,1.5,'rgba(0,0,0,.25)',1);//eyesl
      drawShape('qua',x,y,z,4.5,2, 4.7,2.2, 4.8,2, 4.6,2.1,'rgba(255,255,255,.25)',1);//mouth'
      drawShape('arc',x,y,z,4.25,1,.1,0,6,0,0,0,'gray',1);
      drawShape('arc',x,y,z,4.75,.9,.1,0,6,0,0,0,'gray',1);
      drawShape('arc',x,y,z,5.1,.87,.1,0,6,0,0,0,'gray',1);
      drawShape('qua',x,y,z,4.1,1.275, 4.75,1.1, 5.5,2.2, 4.6,1.25,'white',1);//hair back
      break;
      
    case 21.1://Serpent monster
      
      let sery = 1.5*z
      /////////////////////////////////////
      for (let i=0;i<60;i++){
        //drawShape('ell',x,y,z,5,9,3-i*.01,.75-i*.01, 0,1,2,0,`rgba(${0},${64-i},${0},1)`,0)
        drawShape('ell',x,y+sery,z,5,8,3-i*.01,.75-i*.01, 0,1,2,0,`rgba(${0},${64-i},${0},1)`,0)
        drawShape('ell',x,y+sery,z,5,7.5,3-i*.01,.75-i*.01, 0,1,2,0,`rgba(${0},${64-i},${0},1)`,0)
       drawShape('ell',x,y+sery,z,5,8.5,3.9-i*.01,.75-i*.01, 0,1,2,0,`rgba(${0},${64-i},${0},1)`,0)
        drawShape('ell',x,y+sery,z,5,6.9,2.5-i*.01,.75-i*.01, 0,1,1.7,0,`rgba(${0},${64-i},${0},1)`,0)
      }
      /////////////////////////////////////
      
      //////////////////////////////
 
      /////////////////////////////
      sx = 1.1*z;
      sy = -.6*z;
      sy = sy + sery;
      sz = .5; 
     drawShape('pol',x,y+sy,z,5,6, 2,8, 0,9, 10,9,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},${Math.random()*.5})`,1,10,9);
      drawShape('pol',x,y+sy,z,5,6, 2,8, 0,9, 10,9,`rgba(${255},${255},${0},.75)`,1,10,9);
          sx = 3*z;
       sy = 6.5*z;
       sy = sy + sery;
       sz = .1; 
    drawShape('arc',x+sx,y+sy,z*sz,4.8,5,4.5,0,6,0,0,0,'rgba(40,20,0,1)',1);
      drawShape('arc',x+sx,y+sy,z*sz,5,5,4.5,0,6,0,0,0,'rgba(85,43,0,1)',1);
      drawShape('rec',x+sx,y+sy,z*sz,0.5,5,9,.11,0,0,0,0,'rgba(0,0,0,.35)',1)
      drawShape('rec',x+sx,y+sy,z*sz,.95,3,8.1,.11,0,0,0,0,'rgba(0,0,0,.35)',1)
      drawShape('rec',x+sx,y+sy,z*sz,1,7,8,.11,0,0,0,0,'rgba(0,0,0,.35)',1)
      drawShape('qua',x+sx,y+sy,z*sz,5,4,6,5,5,6,4,5,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,3,1, 7,1.1, 2.8,1.2, 8,2,'rgba(0,0,0,.35)',1);
      drawShape('qua',x+sx,y+sy,z*sz,3-1,1+1, 7-1,1.1+1, 2.8-1,1.2+1, 8-1,2+1,'rgba(0,0,0,.35)',1);
      drawShape('qua',x+sx,y+sy,z*sz,1+3,1+2, 1+7,1.1+2, 1+2.8,1.2+2, 1+8,2+2,'rgba(0,0,0,.35)',1);
      drawShape('qua',x+sx,y+sy,z*sz,1+3,1+5, 1+7,1.1+5, 1+2.8,1.2+5, 1+8,2+5,'rgba(0,0,0,.35)',1);
      drawShape('qua',x+sx,y+sy,z*sz,3,1+6, 7,1.1+6, 2.8,1.2+6, 8,2+6,'rgba(0,0,0,.35)',1);
      drawShape('qua',x+sx,y+sy,z*sz,3-1,1+7, 7-1,1.1+7, 2.8-1,1.2+7, 8-1,2+7,'rgba(0,0,0,.35)',1);
     
      
      
        sx = 5.5*z;
      sy = 6.25*z;
      sy = sy + sery;
      sz = .1;
			drawShape('tri',x+sx,y+sy,z*sz,0,8.6, 1.4,10, 0,10 ,0,0,'rgb(252,165,3)',1);
			drawShape('qua',x+sx,y+sy,z*sz,0,9, 2,7, 3,8, 1,10,'rgb(252,165,3)',1);
			drawShape('qua',x+sx,y+sy,z*sz,0,5, 1,5 ,5,9 ,5,10,'rgb(252,165,3)',1);
       drawShape('tri',x+sx,y+sy,z*sz,0,10, 1.4,10, 0,8.6 ,0,10,'darkgray',1);//pommel

			drawShape('qua',x+sx,y+sy,z*sz,2,6, 8,1, 8,2, 4,6,'gray',1);//
			drawShape('qua',x+sx,y+sy,z*sz,4,8, 9,2, 8,2 ,4,6,'gray',1);
			drawShape('tri',x+sx,y+sy,z*sz,2,6, 4,6, 4,8, 0,0,'gray',1);
			drawShape('qua',x+sx,y+sy,z*sz,8,1, 8,2, 9,2, 10,0,'gray',1);
      	drawShape('qua',x+sx,y+sy,z*sz,2,6, 8,1, 8,2, 4,6,'rgba(0,0,0,.25)',1);//
			drawShape('qua',x+sx,y+sy,z*sz,4,8, 9,2, 8,2 ,4,6,'rgba(0,0,0,.25)',1);
			drawShape('tri',x+sx,y+sy,z*sz,2,6, 4,6, 4,8, 0,0,'rgba(0,0,0,.25)',1);
			drawShape('qua',x+sx,y+sy,z*sz,8,1, 8,2, 9,2, 10,0,'rgba(0,0,0,.25)',1);
			drawShape('qua',x+sx,y+sy,z*sz,0,5, 1,5, 5,9 ,5,10,'rgb(252,165,3)',0);
			drawShape('arc',x+sx,y+sy,z*sz,3,7, .5,0, 6,0 ,0,0,'red',1);//pommel gem
			drawShape('arc',x+sx,y+sy,z*sz,3,7 ,.5,0, 6,0, 0,0,'brown',0);
      sx = 4.75*z;
      sy = 6.25*z;
      sy = sy + sery;
      sz = .05;
     drawShape('qua',x+sx,y+sy,z*sz,1,9,9,9,1,1,9,1,'white',1);//body
      drawShape('rec',x+sx,y+sy,z*sz,1,.75,8,.25,0,0,0,0,'blue',1);
      drawShape('rec',x+sx,y+sy,z*sz,1,9,8,.25,0,0,0,0,'blue',1);

      drawShape('tri',x+sx,y+sy,z*sz,2.5,9,7.5,9,5,8.5,0,0,'blue',1);//bottom sand
      drawShape('tri',x+sx,y+sy,z*sz,5,5,2.5,2.5,7.5,2.5,0,0,'blue',1);//top sand
      drawShape('qua',x+sx,y+sy,z*sz,5,5, 4.9,6, 5.1,7, 4.9,8.5,'blue',1);//drip sand
      sx = 7*z;
      sy = 7*z;
      sy = sy + sery;
      sz = .05;
       drawShape('qua',x+sx,y+sy,z*sz,0.2,9.5, 6.21,0, 10,3.77, .2,9.9,'rgba(85,43,0,1)',1);//handle
      drawShape('qua',x+sx,y+sy,z*sz,0.2,9.5, 6.21,.1, 7,.8, .2,9.6,'rgba(0,0,0,.5)',1);//handle
      drawShape('qua',x+sx,y+sy,z*sz,0.2,9.9, 6.5,4.5, 6.52,4.5, .2,9.9,'rgba(0,0,0,.5)',1);//handle
      //drawShape('tri',x,y,z,10,0, 6.21,0, 10,3.77, 0,0,'rgb(109,39,19)',1);//GFR
      drawShape('tri',x+sx,y+sy,z*sz,10,0, 6.21,0, 8.2,2, 0,0,'rgba(255,0,0,.2)',1);//gfl
      drawShape('tri',x+sx,y+sy,z*sz,10,0, 6.21,0, 10,3.77, 0,0,'rgba(209,70,47,.2)',1);//GFR
      //drawShape('tri',x,y,z,10,0, 6.21,0, 8.2,2, 0,0,'rgb(109,39,19)',1);//gfl
      drawShape('tri',x+sx,y+sy,z*sz,6.21,0, 10,3.77, 9,1, 0,0,'rgba(255,0,0,.25)',1);//handle
      drawShape('tri',x+sx,y+sy,z*sz,10,0, 6.21,0, 10,3.77, 0,0,'rgba(255,0,0,.3)',1);//gem mask
      
      ////////////////////////
      for (let i=0;i<60;i++){
        drawShape('ell',x,y+sery,z,5,8,2.7-i*.01,.75-i*.01, 0,1.9,1.1,0,`rgba(${0},${64+i},${0},1)`,0) 
      }
      ///////////////////////////////
 
      
   
      for (let i=0;i<60;i++){
       // drawShape('ell',x,y,z,5,9,3-i*.01,.75-i*.01, 0,2,1,0,`rgba(${0},${64+i},${0},1)`,0)
        drawShape('ell',x,y+sery,z,5,7.45,3-i*.01,.75-i*.01, 0,2,1,0,`rgba(${0},${64+i},${0},1)`,0)
        drawShape('ell',x,y+sery,z,5,6.9,2.5-i*.01,.75-i*.01, 0,2.7,1,0,`rgba(${0},${64+i},${0},1)`,0)
        // drawShape('ell',x,y,z,1.8,6.95,2.5-i*.01,.75-i*.01, 0,0,.25,0,`rgba(${0},${64+i},${0},1)`,0)
        // drawShape('ell',x,y,z,1.8,6.95,2.5-i*.01,.75-i*.01, 0,0,.23,0,`rgba(${0},${64+i},${0},1)`,0)
        drawShape('ell',x,y+sery,z*.8,5,7.8,2.3-i*.01,1.6-i*.01, 0,1.7,.6,0,`rgba(${0},${64+i},${0},1)`,0)
        //BOAT from above/Leaf? drawShape('ell',x,y,z,    1+i*.001, 6+i*.001,        2-i*.01,   0+i*.01,  0,    0,   2,    0,   `rgba(${0},${64+i},${0},1)`,0)
        drawShape('ell',x,y+sery,z,    4.4+i*.001, 5.69+i*.001,        0+i*.001,   0+i*.002,  0,    .75,   1.5,    0,   `rgba(${255},${255},${255},1)`,0)
        drawShape('ell',x,y+sery,z,    4.67+i*.000005, 5.680+i*.001,        0+i*.001,   0+i*.002,  0,    1.5,   .2,    0,   `rgba(${255},${255},${255},1)`,0)
        //head
        drawShape('ell',x,y+sery,z,    4.5+i*.001, 5.25+i*.001,        0.2+i*.005,   0+i*.005,  0,    0,   2,    0,   `rgba(${0},${64+i},${0},1)`,0)
        //upper jaw
        drawShape('ell',x,y+sery,z,    4.5+i*.001, 5.5+i*.001,        .5-i*.005,   0+i*.005,  0,    1,   2,    0,   `rgba(${0},${128-i},${0},1)`,0)
        //bottom jaw     
        drawShape('ell',x,y+sery,z,    4.51+i*.001, 5.4+i*.001,        .49-i*.005,   0+i*.01,  0,    2,   1,    0,   `rgba(${0},${64+i},${0},1)`,0)
      }
      drawShape('pol',x,y+sery,z,    4.55, 5.6,   4.5, 6.3,   4.4,6.4,   4.55,6.3,   `rgba(${128},${0},${0},1)`,1, 4.6,6.5)
      drawShape('ell',x,y+sery,z,    4.8, 5.25,   .2, .15,   0,   1.6,  .5,   0,   `rgba(${255},${255},${0},1)`,1, 4.6,6.5)
      drawShape('ell',x,y+sery,z,    4.3, 5.25,   .2, .15,   0,   .5,  1.4,   0,   `rgba(${255},${255},${0},1)`,1, 4.6,6.5)
      drawShape('ell',x,y+sery,z,    4.86, 5.26,   .05, .12,   0,   -.45,  .25,   0,   `rgba(${0},${0},${0},1)`,1, 4.6,6.5)
      drawShape('ell',x,y+sery,z,    4.21, 5.26,   .05, .12,   0,   .75,  -.5,   0,   `rgba(${0},${0},${0},1)`,1, 4.6,6.5)
      ///jormungandr head
    
      break;
    
    case 23.1://Wisp monster2
    sx = 2.5*z;
    sy = 2.5*z;
    sz = .5;
			drawShape('arc',x+sx,y+sy,z*sz,5,5,5,0,6,0,0,0,'rgba(128,0,0,.25)',1);//glow
			drawShape('arc',x+sx,y+sy,z*sz,5,5,3,0,6,0,0,0,'rgba(255,0,0,.45)',1);//glow
			drawShape('tri',x+sx,y+sy,z*sz,2.3,3.5,1.9,4.5,3,5.3,0,0,'black',1);//glow
			drawShape('tri',x+sx,y+sy,z*sz,3,5.3,5,4.2,5,5.9,0,0,'black',1);//glow
			drawShape('tri',x+sx,y+sy,z*sz,2,5.9,2.9,7,4,6.5,0,0,'black',1);//glow
		break;
    case 32.1://Apprentice
          drawShape('qua',x,y,z, 7,3.5, 6.25,4, 7.5,6, 7.6,5.5,'rgba(64,0,0,1)',1);//upper arm R

      drawShape('qua',x,y,z, 6.5,8.5, .75,9.5, 6,4, 6.5,7.5,'rgb(64,0,0)',1);//Cape Back
      drawShape('qua',x,y,z, 6.5,8.5, .75,9.5, 6,4, 6.5,7.5,'rgba(0,0,0,1)',1);//Cape Back
      drawShape('qua',x,y,z, 2.75,7.5, 1.5,9.5, 1,9.5, 3.5,5.5,'rgb(0,0,0,1)',1);//left calf
      drawShape('qua',x,y,z, 5,5, 4,6, 5.5,8, 6.5,8,'rgba(0,0,0,1)',1);//right thigh
      //drawShape('qua',x,y,z,3.5,3.5,4.5,3,5,3,6,3.6,'rgb(41,121,205)',1);//neck
      drawShape('qua',x,y,z,3.5,3.5,4.5,3,5,3,6,3.6,'rgb(64,0,0,)',1);//neck
      drawShape('tri',x,y,z,4.5,3.5, 5,3.5, 5,3.1,6,3.6,'rgb(185,122,87)',1);//neck

      drawShape('qua',x,y,z, 3,3.4, 7,3.6, 1.2,9.3, .75,9.5,'rgba(64,0,0,.4)',1);//Cape Front
      drawShape('qua',x,y,z, 3,3.4, 7,3.6, 1.2,9.3, .75,9.5,'rgba(0,0,0,1)',1);//body/left leg/cape?
      drawShape('pol',x,y,z, 3,3.6, 7,3.4, 6,5.5, 7,9.5,'rgba(64,0,0,1)',1,.75,9.5);//body/left leg/cape?

      drawShape('qua',x,y,z, 9,5.5, 9,6.5, 8.5,8, 8.5,6,'rgba(64,0,0,.9)',1,8.5,6);//upper arm L
      drawShape('qua',x,y,z, 9,5.5, 9,6.5, 8.5,8, 8.5,6,'rgba(0,0,0,.6)',1,8.5,6);//upper arm L

      drawShape('qua',x,y,z, 9.1,5.7, 9.5,6, 9.25,6.25, 8.8,6,'rgb(185,122,87)',1);//rHand1
      drawShape('qua',x,y,z, 7.5,5.5, 7.5,6, 9,6, 9.1,5.7,'rgb(185,122,87)',1);//Forearm R
      drawShape('qua',x,y,z, 9.1,5.7, 9.5,6, 9.25,6.25, 8.8,6,'rgb(185,122,87)',1);//rHand2
      drawShape('tri',x,y,z,2.75,1.25, 2.65,1, 3,1.25,0,0,'darkred',1);//knot
      drawShape('tri',x,y,z,2.75,1.25, 2.75,.8, 2.9,1.25,0,0,'darkred',1);//knot
      drawShape('qua',x,y,z,5,1.4, 5,3.5, 5.5,3.5, 7,2,'rgb(64,0,0,4)',1);//head

      drawShape('qua',x,y,z,5,.9, 3.5,1, 4.5,3.5, 7,2,'rgb(185,122,87)',1);//Head
      drawShape('tri',x,y,z,4.39,3.2, 5.2,3.1, 4.5,3.5,0,0,'rgba(0,0,0,.45)',1);//neck shadow

      drawShape('tri',x,y,z,5.25,2, 5.75,2.5, 5.5,2.5, 0,0,'rgba(0,0,0,.45)',1);//Nose
      drawShape('tri',x,y,z,4.75,2.75, 5.25,2.95, 5.3,2.87, 0,0,'rgba(255,0,0,.25)',1);//mouth

      //drawShape('tri',x,y,z,5.4,2.051, 5.4,2.0515, 5.6,2, 0,0,'rgba(0,0,0,.45)',1);//eye
      drawShape('tri',x,y,z,4.6,1.8, 5.1,2, 5.05,1.92, 0,0,'rgba(0,0,0,.45)',1);//eye
      drawShape('tri',x,y,z,6.16,1.85, 5.5,2.05, 5.45,1.97, 0,0,'rgba(0,0,0,.45)',1);//eye

      drawShape('tri',x,y,z,3.5,1, 3.6,2, 5,1.4,0,0,'rgba(64,0,0,1)',1);//head
      drawShape('qua',x,y,z,3.5,1, 3.5,3.5, 4.5,3.5, 5,1.4,'rgba(64,0,0,1)',1);//head
          drawShape('pol',x,y,z,5,.9, 2,.5, 1.75,.75, 2,.69,'rgba(64,0,0,1)',1,4,3);//head
            drawShape('tri',x,y,z,2,.7, 3.5,2.5, 3.5,1.5,0,0,'rgba(0,0,0,.2)',1);//head

      drawShape('qua',x,y,z,5,1.4, 7,2, 5.5,3.5,6,2,'rgba(0,0,0,.15)',1);//head
       drawShape('tri',x,y,z,3.5,1, 3.6,2, 5,1.4,0,0,'rgba(0,0,0,.15)',1);//head
      drawShape('qua',x,y,z,3.5,1, 3.5,3.5, 4.5,3.5, 5,1.4,'rgba(0,0,0,.15)',1);//head
          drawShape('pol',x,y,z,5,.9, 2,.5, 1.75,.75, 2,.69,'rgba(0,0,0,.15)',1,4,3);//head

      drawShape('qua',x,y,z,5,1.4, 7,2, 5.5,3.5,6,2,'rgba(64,0,0,1)',1);//head
      drawShape('tri',x,y,z,3.5,1, 7,2, 5,.9,0,0,'rgb(64,0,0,)',1);//hat
      drawShape('tri',x,y,z,3.5,1, 7,2, 5,.9,0,0,'rgba(0,0,0,.05)',1);//hat
      drawShape('qua',x,y,z,5,1.4, 7,2, 5.5,3.5,6,2,'rgba(0,0,0,.2)',1);//head
      drawShape('tri',x,y,z,3.5,1, 7,2, 5,.9,0,0,'rgba(0,0,0,.2)',1);//hat
      drawShape('tri',x,y,z,3.5,1, 7,2, 5,.9,0,0,'rgba(0,0,0,.05)',1);//hat
      //drawShape('qua',x,y,z*1.4, 4.5,1.25, 5.5,.75, 5,1.25, 4.6,1.17,'darkred',1);//feather

      drawShape('qua',x,y,z, 6.5,8, 5,9.5, 4.5,9.5, 5.5,8,'rgb(0,0,0,.15)',1);//right calf
            

      drawShape('qua',x,y,z, 1.5,7, 1.25,7.25, 1.5,7.5, 2.25,7.25,'rgb(128,0,255)',1);//right calf

      drawShape('qua',x,y,z, 3,3.42, 2.8,4.8, 1.75,6, 1.5,5.5,'rgba(64,0,0,1)',1);//upper arm L

      drawShape('qua',x,y,z, 1.5,5.5, 1.4,7.1, 1.7,6.9, 2,5.5,'rgb(185,122,87)',1);//Forearm L
      drawShape('qua',x,y,z, 1.4,7.1, 1.4,7.5, 2,7, 1.7,6.8,'rgb(185,122,87)',1);//handL
      drawShape('qua',x,y,z, 1.4,7.5, 2,7.5, 2,7, 1.7,6.8,'rgb(185,122,87)',1);//handL
      drawShape('qua',x,y,z,4.5,9.5, 4.25,9.9, 7,9.9, 5,9.5,'rgb(64,0,0)',1);//rFoot
      drawShape('qua',x,y,z,1,9.5, .75,9.9, 3,9.9,1.5,9.5,'rgb(64,0,0)',1);//lfoot
      drawShape('qua',x,y,z, 2,7, 1.75,7.25, 2,7.5, 4,7.25,'rgb(0,0,0)',1);//right calf
      
      drawShape('pol',x,y,z, 3,3.42, 1.5,5.5, 1.25,7, 2,6.75,'rgba(64,0,0,.9)',1,2.8,4.75);//upper arm L
            drawShape('pol',x,y,z, 3,3.42, 1.5,5.5, 1.25,7, 2,6.75,'rgba(0,0,0,.13)',1,2.8,4.75);//upper arm L
      drawShape('qua',x,y,z, 9,5.5, 8.5,6, 8.5,8, 8.8,6,'rgba(64,0,0,.9)',1,8.5,6);//upper arm L
      drawShape('qua',x,y,z, 8.5,8, 7,6.5, 6,4.5, 6.5,4,'rgba(64,0,0,.9)',1,8.5,6);//upper arm L
      drawShape('qua',x,y,z, 7,3.4, 7.5,5.5, 9,5.5, 8.5,6,'rgba(64,0,0,.9)',1,8.5,8);//upper arm L
      drawShape('qua',x,y,z, 8.25,5.5, 8.5,6, 8.5,8, 7.5,6,'rgba(64,0,0,.9)',1,7.5,5.5);//upper arm L
      drawShape('tri',x,y,z, 8.25,5.5, 7.5,6, 7,3.5, 7.5,6,'rgba(64,0,0,.9)',1,7.5,5.5);//upper arm L
      drawShape('tri',x,y,z, 7,3.4, 6.6,4.25, 7.5,6, 7.5,6,'rgba(64,0,0,.9)',1,7.5,5.5);//upper arm L
      drawShape('tri',x,y,z, 7,3.4, 6.6,4.25, 7.5,6, 7.5,6,'rgba(0,0,0,.2)',1,7.5,5.5);//upper arm L

      drawShape('qua',x,y,z, 9,5.5, 8.5,6, 8.5,8, 8.8,6,'rgba(0,0,0,.1)',1,8.5,6);//upper arm L
      drawShape('qua',x,y,z, 8.5,8, 7,6.5, 6,4.5, 6.5,4,'rgba(0,0,0,.3)',1,8.5,6);//upper arm L
      drawShape('qua',x,y,z, 7,3.4, 7.5,5.5, 9,5.5, 8.5,6,'rgba(0,0,0,.2)',1,8.5,8);//upper arm L
      drawShape('qua',x,y,z, 8.25,5.5, 8.5,6, 8.5,8, 7.5,6,'rgba(0,0,0,.2)',1,7.5,5.5);//upper arm L
      drawShape('tri',x,y,z, 8.25,5.5, 7.5,6, 7,3.5, 7.5,6,'rgba(0,0,0,.2)',1,7.5,5.5);//upper arm L


      
      break;
    case 33.1://Salamander
    let lizy = 1.45 *z
      sx = .75*z;
      sy = -1*z;
      sy = sy + lizy
      //rear right arm 2 claws right
      drawShape('pol',x+sx,y+sy,z, 7.25,7.5, 7.5,7.5, 8,8, 7.25,7.75,'rgba(244,69,11,.5)',1,7.2,7.6);//Cape Back
      sx = 5*z;
      sy = -1*z;
      sy = sy + lizy
      drawShape('pol',x+sx,y+sy,z, 2.75,7.5, 2.5,7.75, 2.5,8.5, 2.8,7.75,'rgb(244,69,11,.5)',1,2.8,7.6);//Cape Back
      //rear right arm 2 claws left
      sx = 5.25*z;
      sy = -1*z;
      sy = sy + lizy
    //drawShape('pol',x+sx,y+sy,z, 2.75,7.5, 2.5,7.5, 2,8, 2.75,7.75,'rgba(244,69,11,.5)',1,2.8,7.6);//Cape Back
     drawShape('pol',x+sx,y+sy,z, 2.75,7.5, 2.5,7.75, 2.5,8.5, 2.8,7.75,'rgb(244,69,11,.5)',1,2.8,7.6);//Cape Back

      //front l
      sx = 0.2*z;
      sy = -7.25*z;
      sz = 1.5;
      sy = sy + lizy
      drawShape('pol',x+sx,y+sy,z*sz, 2.5,8.75, 1.5,9.2, 1.75,9.95, 1.9,9.3,'rgb(244,69,11)',1,2.5,9.2);//Cape Back
      //left arm 2 claws left
      drawShape('pol',x,y+lizy,z, 2.75,7.5, 2.5,7.5, 2,8, 2.75,7.75,'rgba(244,69,11,.5)',1,2.8,7.6);//Cape Back
      drawShape('pol',x,y+lizy,z, 2.75,7.5, 2.5,7.75, 2.5,8.5, 2.8,7.75,'rgb(244,69,11,.5)',1,2.8,7.6);//Cape Back
      //right arm 2 claws right
      drawShape('pol',x,y+lizy,z, 7.25,7.5, 7.5,7.5, 8,8, 7.25,7.75,'rgba(244,69,11,.5)',1,7.2,7.6);//Cape Back
      drawShape('pol',x,y+lizy,z, 2.75,7.5, 2.5,7.75, 2.5,8.5, 2.8,7.75,'rgb(244,69,11,.5)',1,2.8,7.6);//Cape Back
      
      //left arm 2 claws left
      sx = -4.6*z;
      sy = 0*z;
      sy = sy + lizy
     drawShape('pol',x+sx,y+sy,z, 7.25,7.5, 7.5,7.5, 8,8, 7.25,7.75,'rgba(244,69,11,.5)',1,7.2,7.6);//Cape Back
     // drawShape('pol',x+sx,y+sy,z, 2.75,7.5, 2.5,7.75, 2.5,8.5, 2.8,7.75,'rgb(244,69,11,.5)',1,2.8,7.6);//Cape Back
      
      //back l
      sx = 1.75*z;
      sy = -8.5*z;
      sz = 1.5;
      sy = sy + lizy
      drawShape('pol',x+sx,y+sy,z*sz, 2.5,8.75, 1.5,9.2, 1.75,9.95, 1.9,9.3,'rgb(244,69,11)',1,2.5,9.2);//Cape Back
      
      //front r
      sx = -.5*z;
      sy = -7.1*z;
      sz = 1.5;
      sy = sy + lizy
      drawShape('pol',x+sx,y+sy,z*sz, 4.5,8.7, 5.5,9.2, 5.25,9.95, 5.1,9.3,'rgb(244,69,11)',1,4.5,9.2);//Cape Back
      
      //right arm 2 claws left
      sx = 4.6*z;
      sy = 0*z;
      sy = sy + lizy
      drawShape('pol',x+sx,y+sy,z, 2.75,7.5, 2.5,7.5, 2,8, 2.75,7.75,'rgba(244,69,11,.5)',1,2.8,7.6);//Cape Back
      drawShape('pol',x+sx,y+sy,z, 2.75,7.5, 2.5,7.75, 2.5,8.5, 2.8,7.75,'rgb(244,69,11,.5)',1,2.8,7.6);//Cape Back

      //back r
      sx = 0*z;
      sy = -8*z;
      sz = 1.5;
      sy = sy + lizy
      drawShape('pol',x+sx,y+sy,z*sz, 4.5,8.7, 5.5,9.2, 5.25,9.95, 5.1,9.3,'rgb(244,69,11)',1,4.5,9.2);//Cape Back
      //main body and head
      sx = -8.7*z;
      sy = -9.6*z;
      sz = 3;
      sy = sy + lizy
      for (let i=0;i<60;i++){
        ////////////////////////////
        //floating island top
        // drawShape('ell',x+sx,y+sy,z*sz,    4.5+i*.001, 4.5+i*.001,        .5-i*.005,   0+i*.005,  0,    1,   2,    0,   `rgba(${255},${69-i},${11},1)`,0)
        //floating island botn     
        // drawShape('ell',x+sx,y+sy,z*sz,    4.51+i*.001, 4.4+i*.001,        .49-i*.005,   0+i*.01,  0,    2,   1,    0,   `rgba(${255},${69+i},${11},1)`,0)
        //eclipse
        //drawShape('ell',x+sx,y+sy,z*sz,    4.5+i*.001, 4.75+i*.001,        .2+i*.0025,   0.2+i*.0025,  0,    0,   2,    0,   `rgba(${244},${69+i},${11},1)`,0)
        ///////////////
        //teeth
        drawShape('ell',x+sx,y+sy,z*sz,    4.4+i*.001, 5.69+i*.001,        0+i*.001,   0+i*.002,  0,    .75,   1.5,    0,   `rgba(${255},${255},${255},1)`,0)
        drawShape('ell',x+sx,y+sy,z*sz,    4.67+i*.000005, 5.680+i*.001,        0+i*.001,   0+i*.002,  0,    1.5,   .2,    0,   `rgba(${255},${255},${255},1)`,0)
        //head
        drawShape('ell',x+sx,y+sy,z*sz,    4.75+i*.001, 5+i*.001,        0.2+i*.005,   0+i*.007,  0,    1,   .4,    0,   `rgba(${244},${69+i},${11},1)`,0)
        //body
        drawShape('ell',x+sx,y+sy,z*sz,    4.5+i*.001, 5.25+i*.001,        0.2+i*.005,   0+i*.005,  0,    0,   2,    0,   `rgba(${244},${69+i},${11},1)`,0)
        //upper jaw
        drawShape('ell',x+sx,y+sy,z*sz,    4.5+i*.001, 5.5+i*.001,        .5-i*.005,   0+i*.005,  0,    1,   2,    0,   `rgba(${255},${69-i},${11},1)`,0)
        //bottom jaw     
        drawShape('ell',x+sx,y+sy,z*sz,    4.51+i*.001, 5.4+i*.001,        .49-i*.005,   0+i*.01,  0,    2,   1,    0,   `rgba(${255},${69+i},${11},1)`,0)
        //tail
        drawShape('ell',x+sx-27.75*z,y+sy-27.5*z,z*sz*3,    4.5+i*.001, 4.5+i*.001,        .2+i*.0025,   0.2+i*.003,  0,    1,   .4,    0,   `rgba(${244},${69+i},${11},1)`,0)
      }
      sx = -4.2*z;
      sy = -4.6*z;
      sz = 2;
      sy = sy + lizy

      drawShape('pol',x+sx,y+sy,z*sz,    4.55, 5.9,   4.5, 6.3,   4.4,6.4,   4.55,6.3,   `rgba(${128},${0},${0},1)`,1, 4.6,6.5)
      sx = -8.7*z;
      sy = -9.6*z;
      sz = 3;
      sy = sy + lizy
      drawShape('ell',x+sx,y+sy,z*sz,    4.8, 5.25,   .2, .15,   0,   1.6,  .5,   0,   `rgba(${255},${0},${0},1)`,1, 4.6,6.5)
      drawShape('ell',x+sx,y+sy,z*sz,    4.3, 5.25,   .2, .15,   0,   .5,  1.4,   0,   `rgba(${255},${0},${0},1)`,1, 4.6,6.5)
      drawShape('ell',x+sx,y+sy,z*sz,    4.86, 5.26,   .05, .12,   0,   -.45,  .25,   0,   `rgba(${0},${0},${0},1)`,1, 4.6,6.5)
      drawShape('ell',x+sx,y+sy,z*sz,    4.21, 5.26,   .05, .12,   0,   .75,  -.5,   0,   `rgba(${0},${0},${0},1)`,1, 4.6,6.5)
      //left arm

      break;
    case 34.1://Witch Queen
      sx = 7*z;
      sy = 1.5*z
      sz = .1;
       drawShape('arc',x+sx,y+sy,z*sz,5,6.5,3.5,0,2,0,0,0,'rgba(176,9,0,.75)',1);//CRA
			drawShape('tri',x+sx,y+sy,z*sz,1.5,6.5,2,0,8,5,0,0,'rgba(176,9,0,.65)',1);//LRT
			drawShape('tri',x+sx,y+sy,z*sz,10-1.5,6.5,5,0,10-8,5,0,0,'rgba(176,9,0,.65)',1);//CRT
			drawShape('tri',x+sx,y+sy,z*sz,10-1.5,6.5,10-2,0,10-8,5,0,0,'rgba(176,9,0,.65)',1);//RRT
			drawShape('tri',x+sx,y+sy,z*sz,2.5,7.5,2.5,1,7,6,0,0,'rgba(232,220,0,.65)',1);//LYT
			drawShape('tri',x+sx,y+sy,z*sz,10-2.5,7.5,5,1,10-7,6,0,0,'rgba(232,220,0,.65)',1);//CYT
			drawShape('tri',x+sx,y+sy,z*sz,10-2.5,7.5,10-2.5,1,10-7,6,0,0,'rgba(232,220,0,.65)',1);//RYT
			drawShape('arc',x+sx,y+sy,z*sz,5,7.5,2.5,0,2,0,0,0,'rgba(232,220,0,1)',1);//CYA
      	drawShape('arc',x+sx,y+sy,z*sz,5,6.5,3.5,0,2,0,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.25)`,1);//CRA

      drawShape('tri',x+sx,y+sy,z*sz,1.5,6.5,2,0,8,5,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.1)`,1);//LRT
			drawShape('tri',x+sx,y+sy,z*sz,10-1.5,6.5,5,0,10-8,5,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.1)`,1);//CRT
			drawShape('tri',x+sx,y+sy,z*sz,10-1.5,6.5,10-2,0,10-8,5,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.1)`,1);//RRT
			drawShape('tri',x+sx,y+sy,z*sz,2.5,7.5,2.5,1,7,6,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.1)`,1);//LYT
			drawShape('tri',x+sx,y+sy,z*sz,10-2.5,7.5,5,1,10-7,6,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.1)`,1);//CYT
			drawShape('tri',x+sx,y+sy,z*sz,10-2.5,7.5,10-2.5,1,10-7,6,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.1)`,1);//RYT
      			drawShape('arc',x+sx,y+sy,z*sz,5,7.5,2.5,0,2,0,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.1)`,1);//CYA

//legs red boots
      sx = -.5*z; 
      sy = -.1*z;
      sz = 1.1;
      drawShape('qua',x+sx,y+sy,z*sz, 5.5,7, 5.8,8.5, 6,8, 6,6.5,'rgba(136,0,21,.65)',1);
      drawShape('qua',x+sx,y+sy,z*sz, 4,7, 4,8.5, 4.25,8.3, 4.5,7,'rgba(136,0,21,.65)',1);
      drawShape('qua',x+sx,y+sy,z*sz, 4,8.25, 3.6,9, 4,8.8, 4.35,8.23,'rgba(230,0,0,.65)',1);
      drawShape('qua',x+sx,y+sy,z*sz, 6,8, 6.3,9, 6,9, 5.7,8.5,'rgba(230,0,0,.65)',1);
      //Empress upper
      sz = .8;
      sx = 1*z;
      sy = .0*z;
      drawShape('qua',x+sx,y+sy,z*sz, 5.25,3, 5.5,3.5, 5,4, 4.5,2.5,'rgb(135,82,47)',1);//neck
      drawShape('qua',x+sx,y+sy,z*sz, 4.5,2.5, 5.5,3.5, 5,4, 4.5,2.5,'rgb(165,102,67)',1);//neckL

      drawShape('qua',x+sx,y+sy,z*sz,4,1.8, 3.9,3, 4.25,3.25, 4.25,1.75,'rgba(64,0,0,1)',1);//bangs left
      drawShape('qua',x+sx,y+sy,z*sz, 5.25,3.5, 4.15,2.25, 5,1.3, 6,2.5,'rgb(185,122,87)',1);//face
      //nose
      sz = .8;
      sx = .8*z;
      sy = .0*z;
      drawShape('tri',x+sx,y+sy,z*sz, 5.45,2.2, 5.4,2.8, 5.6,2.9, 0,0,'rgba(0,0,0,.2)',1);//nose
      //eyes
      sz = .8;
      sx = .8*z;
      sy = .0*z;
      drawShape('tri',x+sx,y+sy,z*sz, 5,2.2, 5.4,2.15, 5.2,2.3, 0,0,'rgba(0,0,0,.25)',1);//eye
      drawShape('tri',x+sx,y+sy,z*sz, 5.5,2.15, 5.9,2, 5.7,2.3, 0,0,'rgba(0,0,0,.25)',1);//eye
      //mouth 
      sz = .8;
      sx = .8*z;
      sy = .0*z;
      drawShape('tri',x+sx,y+sy,z*sz, 5.25,3, 5.6,2.95, 5.4,3.075, 0,0,'rgba(255,0,0,.25)',1);//mouth
      //hair
      sz = .8;
      sx = 1*z;
      sy = .0*z;
      drawShape('qua',x+sx,y+sy,z*sz,5,1.3, 4.2,1.75, 4,2.2, 5,1.85,'rgba(64,0,0,1)',1);//hair
      drawShape('qua',x+sx,y+sy,z*sz,5,1.3, 5.8,1.75, 6,2, 5,1.85,'rgba(64,0,0,1)',1);
       
      drawShape('qua',x+sx,y+sy,z*sz,5.55,1.9, 6,2.5, 5.8,3.4, 6,3.5,'rgba(64,0,0,1)',1);
      drawShape('qua',x+sx,y+sy,z*sz,5.55,1.9, 6,2.5, 5.8,3.4, 6,2,'rgba(64,0,0,1)',1);
      //drawShape('qua',x,y,z,4.25,1.9, 3.8,2.5, 4,3.4, 3.8,3.5,'gold',1);
      drawShape('qua',x+sx,y+sy,z*sz,5,1.8, 4.28,2.07, 4.8,3.4, 4.5,3.5,'rgba(64,0,0,1)',1);
      drawShape('qua',x+sx,y+sy,z*sz,4.28,2.07, 3.85,2.5, 4.05,3.4, 3.85,3.5,'rgba(0,0,0,.25)',1);
      //larm
       sz = .8;
      sx = 1.25*z;
      sy = 1*z;
      drawShape('qua',x+sx,y+sy,z*sz, 3.9,4, 3,6, 3.5,6, 4,5,'rgba(136,0,21,.65)',1);//dress left forearm
        
      drawShape('qua',x+sx,y+sy,z*sz, 3,6, 3.5,6, 3.4,6.3, 3,6.5,'rgb(185,122,87)',1);//left hand
      drawShape('qua',x+sx,y+sy,z*sz, 3.4,6, 2.7,8, 2.4,8, 3.2,5.9,'red',1);//scepter
      drawShape('qua',x+sx,y+sy,z*sz, 3.4,6, 2.7,8, 2.4,8, 3.2,5.9,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.3)`,1);//scepter

       sz = .7;
      sx = 1.7*z;
      sy = 3.45*z;
      drawShape('qua',x+sx,y+sy,z*sz, 3,4, 2.6,3.4, 3,3.5, 3.5,3.4,'rgb(165,102,67)',1);//left hand
         sz = .8;
      sx = 1.36*z;
      sy = .8*z;
      drawShape('tri',x+sx,y+sy,z*sz, 2.6,6.6, 3.5,6.6, 3,6.5, 2.75,9,'rgb(160,100,70)',1);//left fingers
      drawShape('qua',x+sx,y+sy,z*sz, 3.4,6.55, 3.25,6.5, 3.25,6.45, 3.4,6.3,'rgb(170,110,70)',1);//left thumb
      sz = .8;
      sx = 1.25*z;
      sy = 1*z;
      drawShape('qua',x+sx,y+sy,z*sz, 4.5,6, 4.5,4.5, 3.9,4, 4,6,'rgba(136,0,21,.65)',1);//dress left arm
      drawShape('qua',x+sx,y+sy,z*sz, 5,6, 5.5,3, 4.5,4.5, 4.5,6,'rgba(136,0,21,.65)',1);//dress left mid
      //
       sz = .8;
      sx = 1*z;
      sy = .0*z;
      drawShape('qua',x+sx,y+sy,z*sz, 5.5,3.5, 6,3.5, 6.5,3.75, 7.5,5,'rgba(136,0,21,.75)',1);//dress right shoulder n tricep
      drawShape('qua',x+sx,y+sy,z*sz, 6.5,5, 6,6, 7,9.5, 3,9.5,'rgba(136,0,21,1)',1);//dress bottom right n forearm
      drawShape('qua',x+sx,y+sy,z*sz, 7.5,5, 6,6, 7,9.5, 3,9.5,'rgba(0,0,0,.25)',1);//dress bottom right n forearm
      drawShape('qua',x+sx,y+sy,z*sz, 5.5,3.5, 5,4, 5,7.5, 7.5,5,'rgba(136,0,21,.75)',1);//dress collarR
      drawShape('qua',x+sx,y+sy,z*sz, 5,4, 4.8,3.4, 4.5,3.5, 4,4,'rgba(136,0,21,.75)',1);//dress collarL
      drawShape('qua',x+sx,y+sy,z*sz, 4.5,4, 4.25,4.5, 4.25,5, 5,5.75,'rgba(136,0,21,.65)',1);//bl
      drawShape('qua',x+sx,y+sy,z*sz, 5.5,4, 5.75,4.5, 5.75,5, 5,5.75,'rgba(136,0,21,,.65)',1);//br
      drawShape('qua',x+sx,y+sy,z*sz, 5.5,4, 5.05,4.5, 5.05,5, 5.8,5.75,'rgba(136,0,21,,.65)',1);//brmain
           
      //
      sz = .8;
      sx = 2*z;
      sy = .0*z;
      drawShape('qua',x+sx,y+sy,z*sz, 6.1,6, 7,4, 6.5,4, 6,5,'rgba(136,0,21,.65)',1);//dress left forearm
        
      drawShape('qua',x+sx,y+sy,z*sz, 7,4, 6.5,4, 6.6,3.7, 7,3.5,'rgb(185,122,87)',1);//left hand

      drawShape('qua',x+sx,y+sy,z*sz, 7,4, 7.4,3.4, 7,3.5, 6.5,3.4,'rgb(165,102,67)',1);//left hand
        
      drawShape('tri',x+sx,y+sy,z*sz, 7.4,3.4, 6.5,3.4, 7,3.5, 7.25,1,'rgb(160,100,70)',1);//left fingers
      drawShape('qua',x+sx,y+sy,z*sz, 6.6,3.45, 6.75,3.5, 6.75,3.55, 6.6,3.7,'rgb(170,110,70)',1);//left thumb

      drawShape('qua',x+sx,y+sy,z*sz, 5.5,4, 5.5,5.5, 6.1,6, 6,4,'rgba(136,0,21,.65)',1);//dress left arm
      drawShape('qua',x+sx,y+sy,z*sz, 5,4, 4.5,7, 5.5,5.5, 5.5,4,'rgba(136,0,21,.65)',1);//dress left mid
     //////
      drawShape('pol',x,y,z, 4.25,3.2, 4.4,4.25, 4.25,6.5, 6,6,'rgba(136,0,21,,.65)',1,5,3);//brmain
      //hat
        drawShape('pol',x,y,z, 3.75,1.5, 5.1,1.65, 6.5,1.6, 5,1.25,'rgba(136,0,21,,.65)',1,4.25,1.25);//brmain
        drawShape('pol',x,y,z, 5.5,1.5, 5.25,1, 5,0, 4.5,1,'rgba(136,0,21,,.65)',1,4.25,1.3);//brmain
        drawShape('qua',x,y,z, 5,.9, 4.8,1.1, 5,1.3, 5.1,1.1,'rgba(255,255,255,1)',1,4.25,1.3);//brmain
        drawShape('qua',x,y,z, 5,.9, 4.8,1.1, 5,1.3, 5.1,1.1,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.3)`,1,4.25,1.3);//brmain

    break;
    case 35.1://Djinn


      //ribs+spine
			drawShape('ell',x,y,z,5,5,1,1,0,0.1,.9,0,'rgba(128,0,0,.2)',1);//rib5
			drawShape('ell',x,y,z,5,5,.75,.7,0,0.1,.9,0,'black',1);//rib5-shadow
			drawShape('ell',x,y,z,5,4.5,1.5,1,0,0.1,.9,0,'rgba(128,0,0,.2)',1);//rib4
			drawShape('ell',x,y,z,5,4.5,1,.7,0,0.1,.9,0,'black',1);//rib4-shadow
			drawShape('ell',x,y,z,5,4,1.5,1,0,0.1,.9,0,'rgba(128,0,0,.2)',1);//rib3
			drawShape('ell',x,y,z,5,4,1,.7,0,0.1,.9,0,'black',1);//rib3-shadow
			drawShape('ell',x,y,z,5,3.5,1.5,1,0,0.1,.9,0,'rgba(128,0,0,.2)',1);//rib2
			drawShape('ell',x,y,z,5,3.5,1,.7,0,0.1,.9,0,'black',1);//rib2-shadow
			drawShape('ell',x,y,z,5,3,1.5,1,0,0.1,.9,0,'rgba(128,0,0,.2)',1);//rib1
			drawShape('ell',x,y,z,5,3,1,.7,0,0.1,.9,0,'black',1);//rib1-shadow
			drawShape('lin',x,y,z,5,3.5,5,6,0,0,0,0,'rgba(128,0,0,.2)',0);//spine
      	//arms
			drawShape('arc',x,y,z,3.5,3.5,.5,0,6,0,0,0,'rgba(128,0,0,.2)',1);//l-shoulder
			drawShape('arc',x,y,z,6.5,3.5,.5,0,6,0,0,0,'rgba(128,0,0,.2)',1);//r-shoulder
			drawShape('arc',x,y,z,3.5,3.5,.5,0,6,0,0,0,'black',0);//l-shoulder-shadow
			drawShape('arc',x,y,z,6.5,3.5,.5,0,6,0,0,0,'black',0);//r-shoulder-shadow
			drawShape('tri',x,y,z,3,3.5,3.5,4,2,5,0,0,'rgba(128,0,0,.2)',1);//l-arm
			drawShape('tri',x,y,z,7,3.5,6.5,4,8,5,0,0,'rgba(128,0,0,.2)',1);//r-arm
			drawShape('tri',x,y,z,2,5,1.5,6.5,2.4,4.9,0,0,'rgba(128,0,0,.2)',1);//l-forearm
			drawShape('tri',x,y,z,7.8,4.8,8.5,6.3,7.5,4.8,0,0,'rgba(128,0,0,.2)',1);//r-forearm
			drawShape('arc',x,y,z,1.7,6.3,.35,0,6,0,0,0,'rgba(128,0,0,.2)',1);//l-hand
			drawShape('arc',x,y,z,8.3,6.25,.35,0,6,0,0,0,'rgba(128,0,0,.2)',1);//r-hand
			//lower body
			drawShape('ell',x,y,z,5,6.5,1,.5,0,0,6,0,'rgba(128,0,0,.2)',1);//hip
			drawShape('arc',x,y,z,5.75,6.5,.5,0,6,0,0,0,'rgba(128,0,0,.2)',1);//hip
			drawShape('arc',x,y,z,4.25,6.5,.5,0,6,0,0,0,'rgba(128,0,0,.2)',1);//hip
			
      
      //left upper arm upper
      drawShape('pol',x,y,z, 2,5, 2.5,4, 3.2,3, 3.5,3.5,'rgba(41,121,205,.35)',1,3.5,4);//upper arm R
      //left upper arm lower
      drawShape('qua',x,y,z, 2,5, 2.25,5, 3,4.5, 3.5,4,'rgba(41,121,205,.55)',1);//upper arm R
      //left upper arm upper
      drawShape('pol',x,y,z, 2,5, 1.9,5, 1.6,5.5, 1.5,6.5,'rgba(41,121,205,.35)',1,2,5.5);//upper arm R
      //left upper arm lower
      drawShape('pol',x,y,z, 2,5, 2.5,4.8, 2,6, 1.5,6.5,'rgba(41,121,205,.55)',1,1.75,5.5);//upper arm R
      //r upper arm upper
      drawShape('pol',x,y,z, 8,5, 7.5,4, 6.8,3, 6.5,3.5,'rgba(41,121,205,.35)',1,6.5,4);//upper arm R
      //r upper arm lower
      drawShape('qua',x,y,z, 8,5, 7.75,5, 7,4.5, 6.5,4,'rgba(41,121,205,.55)',1);//upper arm R
      //r upper arm upper
      drawShape('pol',x,y,z, 8,5, 8.1,5, 8.4,5.5, 8.5,6.5,'rgba(41,121,205,.35)',1,8.2,5.5);//upper arm R
      //r upper arm lower
      drawShape('pol',x,y,z, 8,5, 7.5,4.8, 8,6, 8.5,6.5,'rgba(41,121,205,.55)',1,8.25,5.5);//upper arm R
      //shoulders
      drawShape('pol',x,y,z, 3.2,3, 6.8,3, 6.5,4, 5,3,'rgba(41,121,205,.55)',1,3.5,4);//upper arm R
      //left torso
      drawShape('pol',x,y,z, 3.5,4, 3.53,5, 3.75,5.5, 4,6,'rgba(41,121,205,.55)',1,5,3);//upper arm R
      //r torso
      drawShape('pol',x,y,z, 6.5,4, 6.47,5, 6.25,5.5, 6,6,'rgba(41,121,205,.55)',1,5,3);//upper arm R
      //mid torso
      drawShape('tri',x,y,z, 5,3, 4,6, 6,6, 6,6,'rgba(41,121,205,.55)',1,5,3);//upper arm R
      
      //l chest
      drawShape('pol',x,y,z, 5,4, 4.8,4.5, 4.25,4.5, 3.5,4,'rgba(41,121,205,.55)',1,3.5,3.25);//upper arm R
      //r chest
      drawShape('pol',x,y,z, 5,4, 5.2,4.5, 5.75,4.5, 6.5,4,'rgba(41,121,205,.55)',1,6.5,3.25);//upper arm R
      //shorts l
      drawShape('pol',x,y,z, 4,6, 3.7,6.2, 3.6,6.5, 3.7,6.8,'rgba(128,0,0,.55)',1,4.5,7);//upper arm R
      //shorts r
      drawShape('pol',x,y,z, 6,6, 6.3,6.2, 6.4,6.5, 6.3,6.8,'rgba(128,0,0,.55)',1,5.5,7);//upper arm R
      drawShape('pol',x,y,z, 4,6, 4.5,7, 5.5,7, 6,6,'rgba(128,0,0,.55)',1,5,5.95);//upper arm R
      //turban circle
      drawShape('arc',x,y,z,5,1.5,1.5,0,6,0,0,0,'rgba(128,0,0,.4)',1);//head
   

      //smoke
        drawShape('pol',x,y,z, 3.6,9.3, 4,9.2, 4.5,9, 5,8.5,'rgba(255,255,255,.55)',1, 3.6,9.4);//upper arm R
        drawShape('pol',x,y,z, 4.5,9, 5.5,8.5, 4.5,9, 6,7.5,'rgba(255,255,255,.55)',1, 6.25,6.75);//upper arm R
        drawShape('pol',x,y,z, 3.69,6.75, 4,7.5, 4.5,8, 4.25,9,'rgba(255,255,255,.55)',1, 6,8);//upper arm R
        drawShape('pol',x,y,z, 6,8, 6,7.5, 6.3,6.75, 5,7,'rgba(255,255,255,.75)',1, 3.69,6.75);//upper arm R
      //lhand
      drawShape('pol',x,y,z, 8.5,6, 8.75,6.25, 8.75,6.5, 8.25,6.75,'rgba(41,121,205,.55)',1,8,6.5);//upper arm R
      drawShape('pol',x,y,z, 8,6, 8,6.5, 8.75,6.5, 8.5,6,'rgba(41,121,205,.55)',1,8,6);//upper arm R
//rhand
      drawShape('pol',x,y,z, 1.5,6, 1.25,6.25, 1.25,6.5, 1.75,6.75,'rgba(41,121,205,.55)',1,2,6.5);//upper arm R
      drawShape('pol',x,y,z, 2,6, 2,6.5, 1.25,6.5, 1.5,6,'rgba(41,121,205,.55)',1,2,6);//upper arm R

      sx = 2*z;
      sy = 0*z
      sz = 1;
			drawShape('tri',x+sx,y+sy,z*sz,3,2,3,4,5,2,0,0,'rgba(41,121,205,.55)',1);//H-head
			drawShape('tri',x+sx,y+sy,z*sz,3,2,2.25,3.25,3,3,0,0,'rgba(128,0,0,.2)',1);//H-nose
			//drawShape('tri',x+sx,y+sy,z*sz,3,2.25,3,2.75,3.75,2.75,0,0,'red',1);//H-eye(sad)
      sx = 2.5*z;
      sy = 0*z
      sz = 1;
			drawShape('tri',x+sx,y+sy,z*sz,3,2.25,3,2.75,3.75,2.1,0,0,'blue',1);//H-eye(mad)
			//drawShape('tri',x+sx,y+sy,z*sz,3,2.25,3,2.75,3.75,2.25,0,0,'red',1);//H-eye(neutral)
			sx = 2*z;
      sy = 0*z
      sz = 1;
      drawShape('tri',x+sx,y+sy,z*sz,4,2.25,4,2.75,4.75,1.75,0,0,'rgba(64,0,0,.2)',1);//H-ear
      sx = -2*z;
      sy = 0*z
      sz = 1;
			drawShape('tri',x+sx,y+sy,z*sz,7,2, 7,4, 5,2, 0,0,'rgba(41,121,205,.55)',1);//H-head
			drawShape('tri',x+sx,y+sy,z*sz,7,2, 7.75,3.25, 7,3, 0,0,'rgba(128,0,0,.2)',1);//H-nose
			sx = -2.5*z;
      sy = 0*z
      sz = 1;
      //drawShape('tri',x+sx,y+sy,z*sz,3,2.25,3,2.75,3.75,2.75,0,0,'red',1);//H-eye(sad)
			drawShape('tri',x+sx,y+sy,z*sz,7,2.25, 7,2.75, 6.25,2.1, 0,0,'blue',1);//H-eye(mad)
			//drawShape('tri',x+sx,y+sy,z*sz,3,2.25,3,2.75,3.75,2.25,0,0,'red',1);//H-eye(neutral)
			sx = -2*z;
      sy = 0*z
      sz = 1;
      drawShape('tri',x+sx,y+sy,z*sz,6,2.25, 6,2.75, 5.25,1.75, 0,0,'rgba(64,0,0,.2)',1);//H-ear
			drawShape('arc',x+sx,y+sy,z*sz,7.3,3.2, .25,1.25, 2,0, 0,0,'black',1);//H-nostril
			drawShape('arc',x+sx,y+sy,z*sz,6.7,3.2, .25,1, 1.75,0, 0,0,'black',1);//H-nostril
      drawShape('tri',x+sx,y+sy,z*sz,5,0, 7,2, 5,2, 0,0,'tan',1);//H-hat
      sx = 2*z;
      sy = 0*z
      sz = 1;
      drawShape('tri',x+sx,y+sy,z*sz,5,0,3,2,5,2,0,0,'tan',1);//H-hat
    	                
      break;
    
    case 37.1://Siren 2  

      //front l
      sx = 1.3*z;
      sy = -6.25*z;
      sz = 1.5;
      drawShape('pol',x+sx,y+sy,z*sz, 2.5,8.75, 1.5,9.2, 1.75,9.95, 1.9,9.3,'rgb(244,69,11)',1,2.5,9.2);//Cape Back
      sx = 1.2*z;
      sy = 1*z;
      //left arm 2 claws left
      drawShape('pol',x+sx,y+sy,z, 2.75,7.5, 2.5,7.5, 2,8, 2.75,7.75,'rgba(244,69,11,.5)',1,2.8,7.6);//Cape Back
      drawShape('pol',x+sx,y+sy,z, 2.75,7.5, 2.5,7.75, 2.5,8.5, 2.8,7.75,'rgb(244,69,11,.5)',1,2.8,7.6);//Cape Back
      sx = -1.4*z;
      sy = 1*z;
      //right arm 2 claws right
      drawShape('pol',x+sx,y+sy,z, 7.25,7.5, 7.5,7.5, 8,8, 7.25,7.75,'rgba(244,69,11,.5)',1,7.2,7.6);//Cape Back
      
      //left arm 2 claws left
      sx = -3.3*z;
      sy = 1*z;
      drawShape('pol',x+sx,y+sy,z, 7.25,7.5, 7.5,7.5, 8,8, 7.25,7.75,'rgba(244,69,11,.5)',1,7.2,7.6);//Cape Back
      
    
      //front r
      sx = -2*z;
      sy = -6.3*z;
      sz = 1.5;
      drawShape('pol',x+sx,y+sy,z*sz, 4.5,8.7, 5.5,9.2, 5.25,9.95, 5.1,9.3,'rgb(244,69,11)',1,4.5,9.2);//Cape Back
      
      //right arm 2 claws left
      sx = 3.2*z;
      sy = 1*z;
      drawShape('pol',x+sx,y+sy,z, 2.75,7.5, 2.5,7.5, 2,8, 2.75,7.75,'rgba(244,69,11,.5)',1,2.8,7.6);//Cape Back
      drawShape('pol',x+sx,y+sy,z, 2.75,7.5, 2.5,7.75, 2.5,8.5, 2.8,7.75,'rgb(244,69,11,.5)',1,2.8,7.6);//Cape Back

    
      //wind special effect
     // for (let i=0;i<120;i++){
      //drawShape('ell',x+sx-27.75*z,y+sy-27.5*z,z*sz*3,    4.5+i*.001, 4.5+i*.001,        .2+i*.0025,   0.2+i*.003,  0,    1,   .4,    0,   `rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.3)`,0)
        
       // drawShape('ell',x,y,z,    1.9+i*.001, 3.6+i*.001,        1.9-i*.01,   0+i*.02,  0,    i*.03,   2,    0,   `rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.3)`,0)
      //}//
      //wings
      ///////////////////////////////////////////////
      //////////////////////////////////////
       
      drawShape('qua',x,y,z, 4.5,3, 3.75,3.3, 3,7, 6,9.9,'lightblue',1);//robe left
      drawShape('qua',x,y,z, 4.5,3, 3.75,3.3, 3,7, 6,9.9,'rgba(0,0,0,.1)',1);//robe left
      drawShape('qua',x,y,z, 5.5,3, 6.25,3.3, 7,7, 4,9.3,'lightblue',1);//robe left
      drawShape('qua',x,y,z, 5.5,3, 6.25,3.3, 7,7, 4,9.3,'rgba(0,0,0,.15)',1);//robe left
      
      
      
        ////////////////////////////////////
       ////////////////////////////////////
      drawShape('qua',x,y,z, 4.5,3, 3.75,3.3, 3,7, 6,9.9,'rgba(0,0,0,.1)',1);//robe left
      drawShape('qua',x,y,z, 5.5,3, 6.25,3.3, 7,7, 4,9.3,'rgba(0,0,0,.15)',1);//robe left
      drawShape('qua',x,y,z, 4.3,1.5, 4,3.5, 4.5,4.5, 4.55,2,'rgba(128,128,128,.75)',1);//neck
      drawShape('qua',x,y,z, 5.7,1.5, 6,3.5, 5.5,4.5, 5.45,2,'rgba(128,128,128,.75)',1);//neck

      drawShape('qua',x,y,z, 4.5,3, 5,2.5, 5.5,3, 5,3.5,'rgb(174,111,77)',1);//neck
      drawShape('arc',x,y,z,5,1.69,.7,0,2,0,0,0,'rgb(185,122,87)',1);
      drawShape('tri',x,y,z, 4.23,1.9, 5.78,1.9, 5,3, 0,0,'rgb(185,122,87)',1);//face bottom
      drawShape('tri',x,y,z, 5,1.75, 5.15,2.25, 5,2.25, 0,0,'rgba(0,0,0,.25)',1);//nose
      drawShape('tri',x,y,z, 4.7,2.5, 5.3,2.5, 5,2.59, 0,0,'rgba(255,0,0,.525)',1);//mouth
      drawShape('tri',x,y,z, 4.5,1.8, 4.9,1.8, 4.75,1.83, 0,0,'rgba(0,0,0,.25)',1);//left eye
      drawShape('tri',x,y,z, 5.5,1.8, 5.1,1.8, 5.25,1.83, 0,0,'rgba(0,0,0,.25)',1);//r eye
      
      drawShape('qua',x,y,z, 5,1, 4.5,1, 4.25,1.5, 4,2,'rgba(128,128,128,.75)',1);//neck
      drawShape('qua',x,y,z, 5,1, 4.5,.5, 4.5,1, 5,1.5,'rgba(128,128,128,.75)',1);//neck
      drawShape('qua',x,y,z, 5,1, 5.5,1, 5.75,1.5, 6,2,'rgba(128,128,128,.75)',1);//neck
      drawShape('qua',x,y,z, 5,1, 5.5,.5, 5.5,1, 5,1.5,'rgba(128,128,128,.75)',1);//neck
      
      drawShape('qua',x,y,z, 4.5,1, 4.5,2.5, 4.15,2, 4.5,1,'rgba(128,128,128,.75)',1);//neck
      drawShape('qua',x,y,z, 5.5,1, 5.5,2.5, 5.85,2, 5.5,1,'rgba(128,128,128,.75)',1);//neck
       

      drawShape('qua',x,y,z, 4.5,3, 4.98,5.2, 5.5,3, 5,3.5,'rgba(239,228,176,.5)',1);//neck
      break;
    case 46.1://Sea Serpent
    let aniwalk2 = Date.now();
    if (portraitani == 1){

    if (aniwalk2 - lastanitime> 550){portraitani = 0;lastanitime = Date.now();}
     
    }
    if (portraitani == 0){

    if (aniwalk2 - lastanitime> 550){portraitani = 1;lastanitime = Date.now();}
     
   }

      let ssery = 1*z
      let sserx = 0*z
      //tail
      drawShape('pol',x,y+ssery+(2*z),z,3.5,6.1, 5.5,6.5, 8,5, 6,3,'rgb(0,128,128)',1,7,5);
      //tail shadow
      drawShape('pol',x,y+ssery+(2*z),z,3.5,6.1, 5.5,6.5, 8,5, 6,3,'rgba(0,0,0,.2)',1,7,5);
      drawShape('pol',x,y+ssery+(2*z),z,5,6, 8,5, 7,4, 7.5,5,'rgb(0,128,128)',1,6.5,5.5);
      drawShape('qua',x,y+ssery+(2*z),z,4,6, 7,5, 6,3, 7.5,5,'rgb(0,128,128)',1,5,6);
      //back glow



      //Head and mouth gap offsets
      sx = 3.75*z;
      sy = (-6*z);
      sz = 1.25;
      if (portraitani == 0){
      //main head 
      drawShape('qua',x+sx+sserx,y+sy+ssery+(2*z),z*sz,1,8, 3,9.5, 4,8, 2.5,7.5,'rgb(0,128,128)',1);
      //mouth gap
      drawShape('qua',x+sx+sserx,y+sy+ssery+(2*z),z*sz,3,9.51, 4.005,8, 2,8, 2.25,8.75,'rgba(0,0,0,.9)',1);
			//throat
      drawShape('tri',x+sserx,y+ssery+(2*z),z,5,5, 5,6, 5.75,4.75, 2,6,'rgb(0,128,128)',1);
      drawShape('tri',x+sserx,y+ssery+(2*z),z,5,4, 5,5, 5.75,4.75, 2,6,'rgb(0,128,128)',1);
			drawShape('tri',x+sserx,y+ssery+(2*z),z,5,4, 5.8,4.6, 5.75,4.75, 2,6,'rgb(0,128,128)',1);

      //inside mouth
      drawShape('pol',x+sserx,y+ssery+(2*z),z,6.5,4, 7,4.5, 7.5,5.5, 7.5,6,'rgba(0,128,128,.2)',1,5,4);
      drawShape('pol',x+sserx,y+ssery+(2*z),z,8.75,4, 8.2,4.35, 7.5,4.5, 6.5,4.5,'rgba(0,128,128,.2)',1,6.5,4);
      //throat
      drawShape('tri',x+sserx,y+ssery+(2*z),z,5,4, 5.8,4.6, 5.75,4.75, 2,6,'rgba(0,0,0,.7)',1);

      //eye
      drawShape('arc',x+sserx,y+ssery+(2*z),z,7,3.5,.15,0,2,0,0,0,'rgba(0,0,0,.9)',1);
      //drawShape('pol',x+sserx,y+ssery+(2*z),z,5.5,6.5, 4.5,7, 4,8, 3,9,'rgb(0,128,128)',1,4,6);
        drawShape('pol',x+sserx,y+ssery+(2*z),z,5.5,6.5, 4.5,7, 4,8, 3,9,'rgba(0,0,0,.2)',1,4,6);

   // drawShape('pol',x,y,z,6,0, 2.5,3, 4,4, 5,4,'rgba(0,0,0,.2)',1,8,0);

      //body upper
    
      //drawShape('qua',x,y,z,5.5,6.5, 4.5,7, 7,9, 8.5,10,'rgba(0,0,0,.75)',1,8,10);
      //drawShape('qua',x,y,z,5.5,6.5, 4.5,7, 7,9, 8.5,10,'rgba(0,0,0,.75)',1,8,10);
        drawShape('qua',x+sserx,y+ssery+(2*z),z,3,6.5, 5,4, 5,6.5, 4,7,'rgb(0,128,128)',1);

    }
      
      if (portraitani == 1){
drawShape('qua',x+sx-10*z,y+sy+ssery+(2*z),z*sz,9,8, 7,9.5, 6,8, 7.5,7.5,'rgb(0,128,128)',1);
      drawShape('qua',x+sx-10*z,y+sy+ssery+(2*z),z*sz,7,9.51, 5.995,8, 8,8, 7.75,8.75,'rgba(0,0,0,.9)',1);

      //main head 
      //mouth gap
			//throat
      drawShape('tri',x+sserx,y+ssery+(2*z),z,5,5, 5,6, 4.25,4.75, 8,6,'rgb(0,128,128)',1);
      drawShape('tri',x+sserx,y+ssery+(2*z),z,5,4, 5,5, 4.25,4.75, 8,6,'rgb(0,128,128)',1);
			drawShape('tri',x+sserx,y+ssery+(2*z),z,5,4, 4.2,4.6, 4.25,4.75, 8,6,'rgb(0,128,128)',1);

      //inside mouth
      drawShape('pol',x+sserx,y+ssery+(2*z),z,3.5,4, 3,4.5, 2.5,5.5, 2.5,6,'rgba(0,128,128,.2)',1,5,4);
      drawShape('pol',x+sserx,y+ssery+(2*z),z,1.25,4, 1.8,4.35, 2.5,4.5, 3.5,4.5,'rgba(0,128,128,.2)',1,3.5,4);
      //throat
      drawShape('tri',x+sserx,y+ssery+(2*z),z,5,4, 4.2,4.6, 4.25,4.75, 8,6,'rgba(0,0,0,.7)',1);

      //eye
      drawShape('arc',x+sserx,y+ssery+(2*z),z,3,3.5,.15,0,2,0,0,0,'rgba(0,0,0,.9)',1);
     // drawShape('pol',x+sserx,y+ssery+(2*z),z,4.5,6.5, 5.5,7, 6,8, 7,9,'rgb(0,128,128)',1,6,6);
        drawShape('pol',x+sserx,y+ssery+(2*z),z,4.5,6.5, 5.5,7, 6,8, 7,9,'rgba(0,0,0,.2)',1,6,6);

   // drawShape('pol',x,y,z,6,0, 2.5,3, 4,4, 5,4,'rgba(0,0,0,.2)',1,8,0);

      //body upper
    
      //drawShape('qua',x,y,z,5.5,6.5, 4.5,7, 7,9, 8.5,10,'rgba(0,0,0,.75)',1,8,10);
      //drawShape('qua',x,y,z,5.5,6.5, 4.5,7, 7,9, 8.5,10,'rgba(0,0,0,.75)',1,8,10);
      //drawShape('qua',x+sserx,y+ssery+(2*z),z,8,6.5, 8,6, 8,5, 8,4,'rgb(0,128,128)',1);
      drawShape('qua',x+sserx,y+ssery+(2*z),z,7,6.5, 5,4, 5,6.5, 6,7,'rgb(0,128,128)',1);
    
      }
      break;
    case 47.1://Undine 
    undineY = 1*z;
    sy = (-1*z)+undineY;
      //ribs bone
			drawShape('ell',x,y+sy,z,5,4.5, .9,1,0,0.1,.9,0,'rgba(41,121,205,.05)',1);//rib5
			drawShape('ell',x,y+sy,z,5,4.5, .5,.7,0,0.1,.9,0,'rgba(41,121,205,.05)',1);//rib5-shadow
			drawShape('ell',x,y+sy,z,5,4, .9,1,0,0.1,.9,0,'rgba(41,121,205,.05)',1);//rib4
			drawShape('ell',x,y+sy,z,5,4, 1,.7,0,0.1,.9,0,'rgba(41,121,205,.05)',1);//rib4-shadow
			drawShape('ell',x,y+sy,z,5,3.5, 1,1,0,0.1,.9,0,'rgba(41,121,205,.05)',1);//rib3
			drawShape('ell',x,y+sy,z,5,3.5, 1,.7,0,0.1,.9,0,'rgba(41,121,205,.05)',1);//rib3-shadow
			drawShape('ell',x,y+sy,z,5,3, 1.3,1,0,0.1,.9,0,'rgba(41,121,205,.05)',1);//rib2
			drawShape('ell',x,y+sy,z,5,3, 1,.7,0,0.1,.9,0,'rgba(41,121,205,.05)',1);//rib2-shadow
			drawShape('ell',x,y+sy,z,5,2.9, .9,1,0,0.1,.9,0,'rgba(41,121,205,.35)',1);//rib1
			//lower body bone
			drawShape('ell',x,y+sy,z,5,6,1,.5,0,0,6,0,'rgba(41,121,205,.05)',1);//hip
			drawShape('arc',x,y+sy,z,5.75,6,.5,0,6,0,0,0,'rgba(41,121,205,.05)',1);//hip
			drawShape('arc',x,y+sy,z,4.25,6,.5,0,6,0,0,0,'rgba(41,121,205,.05)',1);//hip
      
      //upper body
      drawShape('pol',x,y+sy,z,4,3.5, 4.1,4.6, 4.25,5.25, 4.5,5.5,'rgba(41,121,205,.35)',1,5,4.5);//lower arm R
      drawShape('pol',x,y+sy,z,6,3.5, 5.9,4.6, 5.75,5.25, 5.5,5.5,'rgba(41,121,205,.35)',1,5,4.5);//lower arm R
      drawShape('qua',x,y+sy,z,4,3.5, 6,3.5, 4.5,5.5, 5.5,5.5,'rgba(41,121,205,.35)',1,6,3.5);//lower arm R
      drawShape('tri',x,y+sy,z,5,4.5, 4.5,5.5, 5.5,5.5, 5.5,5.5,'rgba(41,121,205,.35)',1,6,3.5);//lower arm R
      //hips
     // drawShape('arc',x,y+sy,z,4.5,6,.75,0,6,0,0,0,'rgba(41,121,205,.35)',1);//r-hand
     // drawShape('arc',x,y+sy,z,5.5,6,.75,0,6,0,0,0,'rgba(41,121,205,.35)',1);//r-hand
      //thighs
      drawShape('pol',x,y+sy,z,3.75,6, 3.5,7.5, 4,8, 5,7,'rgba(41,121,205,.35)',1,5,4.5);//lower arm R
      drawShape('pol',x,y+sy,z,6.25,6, 6.5,7.5, 6,8, 5,7,'rgba(41,121,205,.15)',1,5,4.5);//lower arm R
      drawShape('qua',x,y+undineY,z,6,4.5, 5.5,4.25, 5,4.6, 6,6,'rgba(41,121,205,.35)',1,4,5);//lower arm R

      //feet
      drawShape('pol',x,y+undineY,z,4,8, 3.5,8.5, 4,9, 4.5,8.5,'rgba(41,121,205,.1)',1,4.1,8);//lower arm R
      drawShape('qua',x,y+undineY,z,6,7.5, 6,8, 7,8.5, 6.5,8,'rgba(41,121,205,.1)',1,4.1,8);//lower arm R
      //shoulders
      drawShape('qua',x,y+undineY,z,3.25,2, 4.2,2.25, 4.5,2.5, 4,3,'rgba(41,121,205,.35)',1,4.1,8);//lower arm R
      drawShape('qua',x,y+undineY,z,6.75,2, 5.8,2.25, 5.5,2.5, 6,3,'rgba(41,121,205,.35)',1,4.1,8);//lower arm R
      //weapon
      sy = (1.5*z)+undineY;
      sx = -1*z;
      drawShape('pol',x+sx,y+sy,z,4,4.5, 7,2.5, 8.25,1.75, 1.5,6,'rgba(41,121,205,.35)',1,3.5,4.5);//lower arm R
      
        drawShape('pol',x+sx,y+sy,z,4,4.5, 7,2.5, 8.25,1.75, 1.5,6,'rgba(41,121,205,.35)',1,4,5);//lower arm R
           
        drawShape('pol',x+sx,y+sy,z,4,4.5, 7,2.5, 8.25,1.75, 1.5,6,`rgba(41,121,205,1`,1,3.5,4.5);//lower arm R
      
        drawShape('pol',x+sx,y+sy,z,4,4.5, 7,2.5, 8.25,1.75, 1.5,6,'rgba(41,121,205,1)',1,4,5);//lower arm R
       
        //hands
        drawShape('qua',x,y+undineY,z,6,4.5, 5.5,4.25, 5,4.8, 5.75,4.7,'rgba(41,121,205,.8)',1,4,5);//lower arm R
        drawShape('qua',x,y+undineY,z,3.5,5, 4,5.25, 4,5.5, 3.5,5.75,'rgba(41,121,205,.8)',1,3.4,5.5);//lower arm R
        drawShape('qua',x,y+undineY,z,3,6.1, 7.75,3, 7.5,3, 3,6,'rgba(41,121,205,.3)',1,4,5);//lower arm R
        drawShape('tri',x,y+undineY,z,3.5,5, 3,4, 3.5,5.5, 3.5,5.5,'rgba(41,121,205,.2)',1,3.4,5.5);//lower arm R
        drawShape('qua',x,y+undineY,z,3.5,5.5, 3.4,5.4, 3,4.5, 4,5.5,'rgba(41,121,205,.2)',1,3.4,5.5);//lower arm R
        drawShape('tri',x,y+undineY,z,4,5.2, 3.25,4.5, 3.5,5.5, 3.5,5.5,'rgba(41,121,205,.2)',1,3.4,5.5);//lower arm R

        sy = (-1*z)+undineY;
      sx = .25*z;
			//arms
      drawShape('tri',x+sx,y+sy,z,3.25,3.5, 3.63,3.63, 2, 5,0,0,'rgba(41,121,205,.05)',1);//l-arm
			drawShape('arc',x+sx,y+sy,z,3.5,3.5,.25,0,6,0,0,0,'rgba(41,121,205,.05)',1);//l-shoulder
      drawShape('tri',x+sx,y+sy,z,2,5, 2.75,3.5, 2.3,5,0,0,'rgba(41,121,205,.05)',1);//l-forearm
      //upper arm l
      drawShape('pol',x+sx,y+sy,z, 2,5, 2.5,4.25, 3.5,3, 3.5,3.5,'rgba(41,121,205,.35)',1,3.5,4);//upper arm l
      //lower arm l
      drawShape('pol',x,y+undineY,z, 2.25,4, 2.5,3.5, 3.5,5, 3.5,5.5,'rgba(41,121,205,.35)',1,3.55,5.5);//lower arm l
      drawShape('arc',x+sx,y+sy,z,3.5,3.5,.35,0,6,0,0,0,'rgba(41,121,205,.35)',1);//r-hand
      sx = -.25*z;
			drawShape('arc',x+sx,y+sy,z,6.5,3.5,.25,0,6,0,0,0,'rgba(41,121,205,.05)',1);//r-shoulder
			drawShape('tri',x+sx,y+sy,z,6.75,3.5,6.25,3.5,8,5,0,0,'rgba(41,121,205,.05)',1);//r-arm
			drawShape('tri',x+sx,y+sy,z,7.8,4.8,8,5,5.5,5.75,0,0,'rgba(41,121,205,.05)',1);//r-forearm
			//upper arm r
      drawShape('pol',x+sx,y+sy,z, 8,5, 7.5,4.25, 6.5,3, 6.5,3.5,'rgba(41,121,205,.35)',1,6.5,4);//upper arm R
      //lower arm r
      drawShape('pol',x+sx,y+sy,z, 8,5, 6.5,5.5, 6,5.5, 7,5,'rgba(41,121,205,.35)',1,7.5,4.6);//lower arm R
      drawShape('arc',x+sx,y+sy,z,6.5,3.5,.35,0,6,0,0,0,'rgba(41,121,205,.35)',1);//r-hand
      sz= 1.5;
      let xoffset2 = -2.5*z;
      let yoffset2 = -1*z
      //hair
      sy = .5*z+yoffset2
      sx = .5*z+xoffset2
        drawShape('pol',x+sx,y+sy+undineY,z*sz, 5,1, 4.5,1.5, 4.75,2.3, 4.5,1.4,'rgba(41,121,205,.2)',1,7.5,1.6);//lower arm 
      sy = .25*z+yoffset2
      sx = .25*z+xoffset2
      drawShape('pol',x+sx,y+sy+undineY,z*sz, 5,1, 4.5,1.5, 4.75,2.3, 4.5,1.4,'rgba(41,121,205,.2)',1,7.5,1.6);//lower arm R
      sx = 0*z+xoffset2
      sy = 0*z+yoffset2
      drawShape('qua',x+sx,y+sy+undineY,z*sz, 5,1, 5.5,1.5, 5.25,2.3, 5,1.5,'rgba(41,121,205,.2)',1,7.5,1.6);//lower arm R
      drawShape('pol',x+sx,y+sy+undineY,z*sz, 5,1, 4.5,1.5, 4.75,2.3, 4.5,1.4,'rgba(41,121,205,.2)',1,7.5,1.6);//lower arm R
      sx = -.25*z+xoffset2
      drawShape('qua',x+sx,y+sy+undineY,z*sz, 5,1, 4.5,1.5, 4.75,2.3, 5,1.5,'rgba(41,121,205,.2)',1,7.5,1.6);//lower arm R
      drawShape('qua',x+sx,y+sy+undineY,z*sz, 5,1, 5.5,1.5, 5.25,2.3, 5,1.5,'rgba(41,121,205,.2)',1,7.5,1.6);//lower arm R
      sy = 0*z+yoffset2
      sx = 0*z+xoffset2
      //head
      drawShape('qua',x+sx,y+sy+undineY,z*sz, 5.1,1.3, 4.5,1.8, 5,2.3, 5.5,1.8,'rgba(41,121,205,.45)',1,7.5,4.6);//lower arm R
      
      //hair
      drawShape('qua',x+sx,y+sy+undineY,z*sz, 5,1, 4.5,1.5, 4.75,2.3, 5,1.5,'rgba(41,121,205,.2)',1,7.5,1.6);//lower arm R
      drawShape('pol',x+sx,y+sy+undineY,z*sz, 5,1, 4.5,1.5, 4.75,2.3, 4.5,1.4,'rgba(41,121,205,.2)',1,7.5,1.6);//lower arm R


      
      //left calf
      sx = -6.3*z;
      sy = (-2.3*z)+undineY;
      sz = 2.25;
      for (let i=0;i<60;i++){
        ////////////////////////////
        //floating island topMath.random()*8
        drawShape('ell',x+sx,y+sy,z*sz,    4.5+i*.001, 4+i*.001,        .5-i*.005,   0+i*.005,  0,    1,   2,    0,   `rgba(41,121,205,.15)`,0)
        //floating island botn     
        drawShape('ell',x+sx,y+sy,z*sz,    4.51+i*.001, 4+i*.001,        .49-i*.005,   0+i*.01,  0,    2,   1,    0,   `rgba(41,121,205,.15)`,0)
       
      }
      //right calf 
      sx = -3*z;
      sy = (-1.5*z)+undineY;
      sz = 2;
      for (let i=0;i<60;i++){
       //floating island topMath.random()*8
        drawShape('ell',x+sx,y+sy,z*sz,    4.5+i*.001, 4+i*.001,        .5-i*.005,   0+i*.005,  0,    1,   2,    0,   `rgba(41,121,205,.15)`,0)
        //floating island botn     
        drawShape('ell',x+sx,y+sy,z*sz,    4.51+i*.001, 4+i*.001,        .49-i*.005,   0+i*.01,  0,    2,   1,    0,   `rgba(41,121,205,.15)`,0)
        

       
      }

			break;
    case 48.1://Ice Queen - Queen
       //right calf 
      sx = -3*z;
      sy = -1.5*z;
      sz = 2;
    
       

       
            drawShape('arc',x,y,z,4.8,4.9,.05,0,6,0,0,0,'rgba(41,121,205,.25)',1);//r-hand

          drawShape('arc',x,y,z,7.5,2,.75,0,6,0,0,0,'rgba(41,121,205,.075)',1);//r-hand
        drawShape('pol',x,y,z,7,4, 5,9, 4,5, 4.5,4,'rgba(41,121,205,.25)',1,5,2.5);

    // aniDice.setColor(0,0, .7)
    // aniDice.setGlow(Math.floor(Math.random()*255))
     // aniDice.animate(x+7.55*z,y+2*z,1*z,.25,globalDt);

        drawShape('qua',x,y,z,4.25,2, 4.5,3, 5,2.5, 4.55,1.5,'rgba(41,121,205,.45)',1);
        drawShape('pol',x,y,z,4.45,5.5, 4,7.5, 4.5,7.5, 4.5,7,'rgba(41,121,205,.45)',1,5.25,5.5);
        drawShape('pol',x,y,z,5.6,5, 6,6.5, 6,7, 5.6,7.5,'rgba(41,121,205,.45)',1,5.6,6.5);
        drawShape('tri',x,y,z,5.75,7, 5,5.5, 5.6,5, 5.5,7.5,'rgba(41,121,205,.45)',1,5.6,6.5);
        drawShape('pol',x,y,z,5.5,5, 5.4,4.5, 5.5,3.5, 6.9,4.8,'rgba(41,121,205,.45)',1,5.5,3);

      //legs red boots
      sx = -.5*z; 
      sy = -.1*z;
      sz = 1.1;
      drawShape('qua',x+sx,y+sy,z*sz, 5.5,7, 5.8,8.5, 6,8, 6,6.5,'rgba(41,121,205,.35)',1);
      drawShape('qua',x+sx,y+sy,z*sz, 4,7, 4,8.5, 4.25,8.3, 4.5,7,'rgba(41,121,205,.35)',1);
      drawShape('qua',x+sx,y+sy,z*sz, 4,8.25, 3.6,9, 4,8.8, 4.35,8.23,'rgba(41,121,205,.35)',1);
      drawShape('qua',x+sx,y+sy,z*sz, 6,8, 6.3,9, 6,9, 5.7,8.5,'rgba(41,121,205,.35)',1);
      //Empress upper
      sz = .8;
      sx = 1*z;
      sy = .0*z;
      //drawShape('qua',x+sx,y+sy,z*sz, 5.25,3, 5.5,3.5, 5,4, 4.5,2.5,'rgba(41,121,205,.35)',1);//neck
      drawShape('qua',x+sx,y+sy,z*sz, 4.5,2.5, 5.5,3.5, 5,4, 4.5,2.5,'rgba(41,121,205,.35)',1);//neckL

      drawShape('qua',x+sx,y+sy,z*sz,4,1.8, 3.9,3, 4.25,3.25, 4.25,1.75,'rgba(41,121,205,.35)',1);//bangs left
      drawShape('qua',x+sx,y+sy,z*sz, 5.25,3.5, 4.15,2.25, 5,1.3, 6,2.5,'rgba(41,121,205,.35)',1);//face
      //nose
      sz = .8;
      sx = .8*z;
      sy = .0*z;
      drawShape('tri',x+sx,y+sy,z*sz, 5.45,2.2, 5.4,2.8, 5.6,2.9, 0,0,'rgba(41,121,205,.35)',1);//nose
      //eyes
      sz = .8;
      sx = .8*z;
      sy = .0*z;
      drawShape('tri',x+sx,y+sy,z*sz, 5,2.2, 5.4,2.15, 5.2,2.3, 0,0,'rgba(41,121,205,.35)',1);//eye
      drawShape('tri',x+sx,y+sy,z*sz, 5.5,2.15, 5.9,2, 5.7,2.3, 0,0,'rgba(41,121,205,.35)',1);//eye
      //mouth 
      sz = .8;
      sx = .8*z;
      sy = .0*z;
      drawShape('tri',x+sx,y+sy,z*sz, 5.25,3, 5.6,2.95, 5.4,3.075, 0,0,'rgba(41,121,205,.35)',1);//mouth
      //hair
      sz = .8;
      sx = 1*z;
      sy = .0*z;
      drawShape('qua',x+sx,y+sy,z*sz,5,1.3, 4.2,1.75, 4,2.2, 5,1.85,'rgba(41,121,205,.35)',1);//hair
      drawShape('qua',x+sx,y+sy,z*sz,5,1.3, 5.8,1.75, 6,2, 5,1.85,'rgba(41,121,205,.35)',1);
       
      drawShape('qua',x+sx,y+sy,z*sz,5.55,1.9, 6,2.5, 5.8,3.4, 6,3.5,'rgba(41,121,205,.35)',1);
      drawShape('qua',x+sx,y+sy,z*sz,5.55,1.9, 6,2.5, 5.8,3.4, 6,2,'rgba(41,121,205,.35)',1);
      //drawShape('qua',x,y,z,4.25,1.9, 3.8,2.5, 4,3.4, 3.8,3.5,'gold',1);
      drawShape('qua',x+sx,y+sy,z*sz,5,1.8, 4.28,2.07, 4.8,3.4, 4.5,3.5,'rgba(41,121,205,.35)',1);
      drawShape('qua',x+sx,y+sy,z*sz,4.28,2.07, 3.85,2.5, 4.05,3.4, 3.85,3.5,'rgba(41,121,205,.35)',1);
      //larm
       sz = .8;
      sx = 1.25*z;
      sy = 1*z;
      drawShape('qua',x+sx,y+sy,z*sz, 3.9,4, 3,6, 3.5,6, 4,5,'rgba(41,121,205,.35)',1);//dress left forearm
        
      drawShape('qua',x+sx,y+sy,z*sz, 3,6, 3.5,6, 3.4,6.3, 3,6.5,'rgba(41,121,205,.35)',1);//left hand
 drawShape('qua',x+sx,y+sy,z*sz, 3.4,6, 2.7,8, 2.4,8, 3.2,5.9,'blue',1);//scepter
      drawShape('qua',x+sx,y+sy,z*sz, 3.4,6, 2.7,8, 2.4,8, 3.2,5.9,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.3)`,1);//scepter

    
       sz = .7;
      sx = 1.7*z;
      sy = 3.45*z;
      drawShape('qua',x+sx,y+sy,z*sz, 2.8,4, 2.75,3.4, 3,3.6, 3.4,3.9,'rgba(41,121,205,.35)',1);//left hand
         sz = .8;
      sx = 1.36*z;
      sy = .8*z;
     drawShape('tri',x+sx,y+sy,z*sz, 3,6.6, 3.5,6.6, 3,6.5, 2.75,9,'rgba(41,121,205,.35)',1);//left fingers
     drawShape('qua',x+sx,y+sy,z*sz, 3.4,6.55, 3.25,6.5, 3.25,6.45, 3.3,6.3,'rgba(41,121,205,.35)',1);//left thumb
      sz = .8;
      sx = 1.25*z;
      sy = 1*z;
     // drawShape('qua',x+sx,y+sy,z*sz, 4.5,6, 4.5,4.5, 3.9,4, 4,6,'rgba(41,121,205,.35)',1);//dress left arm
     // drawShape('qua',x+sx,y+sy,z*sz, 5,6, 5.5,3, 4.5,4.5, 4.5,6,'rgba(41,121,205,.35)',1);//dress left mid
      //
       sz = .8;
      sx = 1*z;
      sy = .0*z;
      //drawShape('qua',x+sx,y+sy,z*sz, 5.5,3.5, 6,3.5, 6.5,3.75, 7.5,5,'rgba(41,121,205,.35)',1);//dress right shoulder n tricep
      //drawShape('qua',x+sx,y+sy,z*sz, 6.5,5, 6,6, 7,9.5, 3,9.5,'rgba(41,121,205,.35)',1);//dress bottom right n forearm
      //drawShape('qua',x+sx,y+sy,z*sz, 7.5,5, 6,6, 7,9.5, 3,9.5,'rgba(41,121,205,.35)',1);//dress bottom right n forearm
      drawShape('qua',x+sx,y+sy,z*sz, 5.5,3.5, 5,4, 5,7.5, 7.5,5,'rgba(41,121,205,.35)',1);//dress collarR
      drawShape('qua',x+sx,y+sy,z*sz, 5,4, 4.8,3.4, 4.5,3.5, 4,4,'rgba(41,121,205,.35)',1);//dress collarL
           sz = .8;
      sx = .83*z;
      sy = .0*z;
       drawShape('qua',x+sx,y+sy,z*sz, 4.5,4, 4,4.5, 4.45,5, 5,4.9,'rgba(41,121,205,.25)',1);//bl
        sx = .5*z;
        sy = .0*z;
       drawShape('qua',x+sx,y+sy,z*sz, 5.5,4, 4.8,4.5, 5.25,5, 5.8,4.9,'rgba(41,121,205,.15)',1);//brmain

      //
      sz = .8;
      sx = 2*z;
      sy = .0*z;
      drawShape('qua',x+sx,y+sy,z*sz, 6.1,6, 7,4, 6.5,4, 6,5,'rgba(41,121,205,.35)',1);//dress left forearm
        
      drawShape('qua',x+sx,y+sy,z*sz, 7,4, 6.5,4, 6.6,3.7, 7,3.5,'rgba(41,121,205,.35)',1);//left hand

      drawShape('qua',x+sx,y+sy,z*sz, 7,4, 7.4,3.4, 7,3.5, 6.5,3.4,'rgba(41,121,205,.35)',1);//left hand
        
      drawShape('tri',x+sx,y+sy,z*sz, 7.4,3.4, 6.5,3.4, 7,3.5, 7.25,1,'rgba(41,121,205,.35)',1);//left fingers
      drawShape('qua',x+sx,y+sy,z*sz, 6.6,3.45, 6.75,3.5, 6.75,3.55, 6.6,3.7,'rgba(41,121,205,.35)',1);//left thumb

     // drawShape('qua',x+sx,y+sy,z*sz, 5.5,4, 5.5,5.5, 6.1,6, 6,4,'rgba(41,121,205,.35)',1);//dress left arm
     // drawShape('qua',x+sx,y+sy,z*sz, 5,4, 4.5,7, 5.5,5.5, 5.5,4,'rgba(41,121,205,.35)',1);//dress left mid
     //////
      drawShape('pol',x,y,z, 4.5,3.2, 4.4,4.25, 4.5,6.5, 5,6,'rgba(41,121,205,.35)',1,5,3);//brmain
           
      drawShape('pol',x,y,z, 4.25,1.5, 4,1, 4.5,1.75, 4.5,1,'rgba(41,121,205,.35)',1,5,1.5);//brmain
      drawShape('pol',x,y,z, 5.75,1.5, 6,1, 5.5,1.75, 5.5,1,'rgba(41,121,205,.35)',1,5,1.5);//brmain
      drawShape('pol',x,y,z, 4.25,1.5, 4,1, 4.5,1.75, 4.5,1,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.5)`,1,5,1.5);//brmain
      drawShape('pol',x,y,z, 5.75,1.5, 6,1, 5.5,1.75, 5.5,1,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.5)`,1,5,1.5);//brmain
    break;
    
      case 49.1://Kraken King  
        let krakeny = 2*z;
         // drawShape('ell',x,y,z,5, 7, 4, 4,  0,    1,   2,    0,   `rgba(${255},${201},${14},.25)`,1)
            drawShape('pol',x,y+krakeny,z, .5,5.9, .5,6.5, 1,6.5, 1,6,'rgba(41,200,205,.65)',1,.9,5.6);//face
       drawShape('pol',x,y+krakeny,z, 8.35,4.6, 8.5,5, 8.5,5.5, 7.75,5.5,'rgba(41,180,205,.34)',1,8.1,4.9);//face

         //tail
      sx = 9.3*z;
      sy = krakeny+12.9*z;
      sz = 1.5;
      for (let i=0;i<60;i++){
        drawShape('ell',x+sx-27.75*z,y+sy-27.5*z,z*sz*3,    4.5+i*.001, 4.5+i*.001,        .2+i*.0025,   0.2+i*.003,  0,    1,   .1,    0,   `rgba(${0},${128+i},${128},1)`,0)        

      }
      //tail
      sx = 15.1*z;
      sy = krakeny+13.69*z;
      sz = 1.5;
      for (let i=0;i<60;i++){
        drawShape('ell',x+sx-27.75*z,y+sy-27.5*z,z*sz*3,    4.5+i*.00021, 4.5+i*.00031,        .2+i*.00125,   0.4+i*.0023,  0,   1,   1.7,    0,   `rgba(${0},${128+i},${128},1)`,0)        

      }
      sx = -17.7*z;
      sy = (-19*z)+krakeny;
      sz = 5;
      for (let i=0;i<60;i++){
        //fin
        drawShape('ell',x+sx,y+sy,z*sz,    4.48+i*.001, 4.4+i*.001,        .49-i*.007,   0+i*.01,  0,    1,   2,    0,   `rgba(${0},${64+i},${128},1)`,0)
      }
      sx = -8.7*z;
      sy = (-10*z)+krakeny;
      sz = 3;
      for (let i=0;i<60;i++){
        //body
        drawShape('ell',x+sx,y+sy,z*sz,4.5+i*.001, 5.5+i*.0001, 0.2+i*.005, 0+i*.02,  0,    1,   2,    0,   `rgba(${0},${64+i},${128},1)`,0)
        drawShape('ell',x+sx,y+sy,z*sz,4.5+i*.001, 5.51+i*.0001, 0.2+i*.005, 0+i*.02,  0,    1,   2,    0,   `rgba(${0},${64+i},${128},1)`,0)

      }
      sx = -8.7*z;
      sy = (-10*z)+krakeny;
      sz = 3;
      for (let i=0;i<60;i++){
        //body
        drawShape('ell',x+sx,y+sy,z*sz,4.5+i*.001, 5.5+i*.0001, 0.2+i*.005, 0+i*.00512,  0,    2,   1,    0,   `rgba(${0},${64+i},${128},1)`,0)
        drawShape('ell',x+sx,y+sy,z*sz,4.5+i*.001, 5.51+i*.001, 0.2+i*.005, 0+i*.00512,  0,    2,   1,    0,   `rgba(${0},${64+i},${128},1)`,0)

      }
      //tail
      sx = 9.3*z;
      sy = (13.9*z)+krakeny;
      sz = 1.5;
      for (let i=0;i<60;i++){
        drawShape('ell',x+sx-27.75*z,y+sy-27.5*z,z*sz*3,    4.5+i*.001, 4.5+i*.001,        .2+i*.0025,   0.2+i*.003,  0,    1,   0,    0,   `rgba(${0},${128+i},${128},1)`,0)        

      }
      
       //tail
      sx = 9*z;
      sy = (15*z)+krakeny;
      sz = 1.5;
      for (let i=0;i<60;i++){
        drawShape('ell',x+sx-27.75*z,y+sy-27.5*z,z*sz*3,    4.5+i*.001, 4.5+i*.001,        .015+i*.0015,   0.3+i*.00123,  0,   1.2,   2,    0,   `rgba(${0},${128+i},${128},1)`,0)        

      }
    
      //tail
      sx = 16*z;
      sy = (13.75*z)+krakeny;
      sz = 1.5;
      for (let i=0;i<60;i++){
        drawShape('ell',x+sx-27.75*z,y+sy-27.5*z,z*sz*3,    4.5+i*.0001, 4.5+i*.0001,        .3+i*.0025,   0.2+i*.0023,  0,   1,   1.7,    0,   `rgba(${0},${128+i},${128},1)`,0)        

      }
      sx = 5.25*z;
      sy = (7.5*z)+krakeny;
      sz = .39;
    

    
     
      drawShape('pol',x,y+krakeny,z, .5,6.9, .5,7.5, 1,8, 1,7,'rgba(41,180,205,.65)',1,.9,6.6);//face
       //drawShape('pol',x,y,z, 2.5,8.1, 2.5,7.5, 3,7, 3,7.5,'rgba(41,180,205,.75)',1,3,8.2);//face
       drawShape('pol',x,y+krakeny,z, 9.7,5.25, 10,5.75, 9.9,7, 9.5,6.5,'rgba(41,180,205,.34)',1,9.25,5.75);//face
       drawShape('qua',x,y+krakeny,z, 7.2,6.5, 7,7, 6.2,7.2, 6.5,6.5,'rgba(41,180,205,.34)',1,9.25,5.75);//face
       //drawShape('pol',x,y,z, 6,7, 6.05,7.75, 7,8.1, 7,7,'rgba(41,180,205,.34)',1,6.5,6.5);//face
       drawShape('qua',x,y+krakeny,z, 1.4,7, 1.5,7.25, 1.75,7.1, 1.6,6.4,'rgba(41,180,205,.54)',1,6.5,6.5);//face
       drawShape('qua',x,y+krakeny,z, 5,6.36, 4.5,7, 5,7.25,5.5,7,'rgba(254,203,1,.84)',1,6.5,6.5);//face
      drawShape('qua',x,y+krakeny,z, 5,6.36, 4.5,7, 5,7.25,5.5,7,'rgba(255,128,0,.95)',0,6.5,6.5);//face

       drawShape('qua',x,y+krakeny,z, 5,6.36, 4.975,7, 5,7.25,5.025,7,'rgba(128,64,0,.94)',1,6.5,6.5);//face
       drawShape('qua',x,y+krakeny,z, 4.5,7, 5,7.025, 5.5,7, 5,6.975,'rgba(128,64,0,.94)',1,6.5,6.5);//face
       sz = .12;
      sx = 4.4*z;
      sy = krakeny+5.1*z;

      drawShape('ell',x+sx,y+sy,z*sz,    5.1, 5,        4.1,   2.1,  0,    2,  0,    0,   `rgba(${255},${255},${255},1)`,1)
      //drawShape('ell',x+sx,y+sy,z*sz,    4.8, 5.7,        2,   2,  0,    .77,  .23,    0,   `rgba(${185},${122},${87},1)`,1)
      //drawShape('ell',x+sx,y+sy,z*sz,    4.5, 5.97,        .5,   .5,  0,    2,  0,    0,   `rgba(${0},${0},${0},1)`,1)

       sx = 4.5*z;
      sy = krakeny+2.5*z;
      sz = .5;
      for (let i = 0;i<64;i++){
        drawShape('ell',x+sx,y+sy,z*sz,    1+i*.001, 6+i*.001,        2-i*.01,   .5+i*.01,  0,    0,   2,    0,   `rgba(41,180,205,.0024)`,1)
        drawShape('ell',x+sx,y+sy,z*sz,    1+i*.001, 6+i*.001,        2-i*.01,   .5+i*.01,  0,    1.1,   -.1,    0,   `rgba(41,180,205,.0024)`,1)
        drawShape('ell',x+sx,y+sy,z*sz,    1+i*.001, 6+i*.001,        2-i*.01,   .5+i*.01,  0,    .1,  .9,    0,   `rgba(41,180,205,.0024)`,1)
        drawShape('ell',x+sx,y+sy,z*sz,    1+i*.001, 6+i*.001,        2-i*.01,   .5+i*.01,  0,    1.1,   -.1,    0,   `rgba(41,180,205,.0024)`,1)
        drawShape('ell',x+sx,y+sy,z*sz,    1+i*.001, 6+i*.001,        2-i*.01,   .5+i*.01,  0,    .1,  .9,    0,   `rgba(41,180,205,.0024)`,1)
      }
       sz = .12;
      sx = 4.4*z;
      sy = krakeny+5.1*z;
            drawShape('ell',x+sx,y+sy,z*sz,    4.8, 5.7,        2,   2,  0,    .77,  .23,    0,   `rgba(${185},${122},${87},.95)`,1)
                        drawShape('ell',x+sx,y+sy,z*sz,    4.8, 5.7,        2,   2,  0,    .77,  .23,    0,   `rgba(${0},${0},${0},.55)`,1)

      drawShape('ell',x+sx,y+sy,z*sz,    4.8, 5.97,        .5,   .5,  0,    2,  0,    0,   `rgba(${0},${0},${0},1)`,1)

      drawShape('pol',x,y+krakeny,z, 5,0.25, 4.85,.5, 4.725,1, 4.55,3.25,'rgba(41,180,205,.34)',1,5,3.5);//face
      drawShape('pol',x,y+krakeny,z, 5,0.25, 5.1,.5, 5.25,1, 5.45,3.25,'rgba(41,180,205,.34)',1,5,3.5);//face
      drawShape('qua',x,y+krakeny,z, 5,0.25, 5.15,3.25, 5,5, 4.85,3.25,'rgba(41,180,205,.34)',1,5,3.5);//face

    break;
  
    case 56.1://Imp 7
   
        sx =  -2.5*z;
       sy = -.65*z
       sz = 1.5;
            drawShape('pol',x+sx,y+sy,z*sz,5,1, 4.25,.5 ,4.5,2 ,5,2.5,'rgba(64,0,0,.75)',1,5.5,1);
            drawShape('pol',x+sx,y+sy,z*sz,5,1, 5.75,.5 ,5.5,2 ,5,2.5,'rgba(64,0,0,.75)',1,4.5,1);
            drawShape('qua',x+sx,y+sy,z*sz,5,2, 4,2.5 ,4.5,4 ,5,5,'rgba(64,0,0,1)',1,5.5,1);
            drawShape('qua',x+sx,y+sy,z*sz,5,2, 6,2.5 ,5.5,4 ,5,5,'rgba(64,0,0,1)',1,5.5,1);

            drawShape('pol',x+sx,y+sy,z*sz,4.5,4, 4,5 ,4,6 ,4.5,5.25,'rgba(64,0,0,.75)',1,5,5);
            drawShape('pol',x+sx,y+sy,z*sz,5.5,4, 6,5 ,6,6 ,5.5,5.25,'rgba(64,0,0,.75)',1,5,5);

            drawShape('pol',x+sx,y+sy,z*sz,4,2.5, 3.5,3 ,3,4 ,3.5,3.5,'rgba(64,0,0,1)',1,4.5,3);
            drawShape('pol',x+sx,y+sy,z*sz,6,2.5, 6.5,3 ,7,4 ,6.5,3.5,'rgba(64,0,0,1)',1,5.5,3);
            drawShape('qua',x+sx,y+sy,z*sz,4,5.5, 4,7 ,4.5,6 ,4.5,5.5,'rgba(64,0,0,.75)',1,5.5,3);
            drawShape('qua',x+sx,y+sy,z*sz,6,5.5, 6,7 ,5.5,6 ,5.5,5.5,'rgba(64,0,0,.75)',1,4.5,3);
            drawShape('tri',x+sx,y+sy,z*sz,5,1.5, 4.6,1.25 ,4.6,1.45 ,5.5,5.5,'rgba(0,0,255,1)',1,4.5,3);
            drawShape('tri',x+sx,y+sy,z*sz,5,1.5, 5.4,1.25 ,5.4,1.45 ,5.5,5.5,'rgba(0,0,255,1)',1,4.5,3);

            drawShape('qua',x+sx,y+sy,z*sz,3.25,3.6, 2.75,3.75 ,3.25,3.75 ,3.5,4,'rgba(64,0,0,1)',1,4.5,3);
            drawShape('qua',x+sx,y+sy,z*sz,6.75,3.6, 7.25,3.75 ,6.75,3.75 ,6.5,4,'rgba(64,0,0,1)',1,4.5,3);

            drawShape('pol',x+sx,y+sy,z*sz,4.6,1.7, 4.9,2.2 ,5.1,2.2 ,5.4,1.7,'rgba(0,0,0,1)',1,5.4,1.7);
            drawShape('tri',x+sx,y+sy,z*sz,4.9,2, 5.1,2 ,5,3 ,5,3,'rgba(0,0,255,1)',1,5.4,1.7);
            drawShape('tri',x+sx,y+sy,z*sz,4.6,1.7, 4.7,1.7 ,4.6,1.9 ,5,3,'rgba(255,255,255,1)',1,5.4,1.7);
            drawShape('tri',x+sx,y+sy,z*sz,5.4,1.7, 5.3,1.7 ,5.4,1.9 ,5,3,'rgba(255,255,255,1)',1,5.4,1.7);
            drawShape('pol',x+sx,y+sy,z*sz,4.9,5, 5.1,5 ,5.1,6 ,5.3,7,'rgba(64,0,0,1)',1,5.1,6.3);

    break;
    case 57.1: //Spider 8
    sz = .69
    sx = 1.55*z
    sy = 3*z
			//back legs
			drawShape('ell',x+sx,y+sy,z*sz,6.5,5,5.5,.6,1.5,0,6,0,'darkgreen',1);//r-leg-rear-base
			drawShape('ell',x+sx,y+sy,z*sz,10.2,2.6,2.4,.3,.73,0,6,0,'darkgreen',1);//r-leg-rear-mid
			drawShape('ell',x+sx,y+sy,z*sz,11.3,4.4,.5,.15,1.5,0,6,0,'darkgreen',1);//r-leg-rear-tip
			drawShape('ell',x+sx,y+sy,z*sz,8,5,5,.5,1.38,0,6,0,'green',1);//r-leg-mrear-base
			drawShape('ell',x+sx,y+sy,z*sz,11,3.1,2,.2,2,0,6,0,'green',1);//r-leg-mrear-mid
			drawShape('ell',x+sx,y+sy,z*sz,11.3,5,.5,.15,0,0,6,0,'green',1);//r-leg-mrear-tip
			drawShape('ell',x+sx,y+sy,z*sz,3.5,5,5.5,.6,-1.5,0,6,0,'darkgreen',1);//l-leg-rear-base
			drawShape('ell',x+sx,y+sy,z*sz,-.2,2.6,2.4,.3,-.73,0,6,0,'darkgreen',1);//l-leg-rear-mid
			drawShape('ell',x+sx,y+sy,z*sz,-1.3,4.4,.5,.15,-1.5,0,6,0,'darkgreen',1);//l-leg-rear-tip
			drawShape('ell',x+sx,y+sy,z*sz,2,5,5,.5,-1.38,0,6,0,'green',1);//l-leg-mrear-base
			drawShape('ell',x+sx,y+sy,z*sz,-1,3.1,2,.2,2,0,6,0,'green',1);//l-leg-mrear-mid
			drawShape('ell',x+sx,y+sy,z*sz,-1.3,5,.5,.15,0,0,6,0,'green',1);//l-leg-mrear-tip
			//body
			drawShape('ell',x+sx,y+sy,z*sz,5,5,5,4,0,0,6,0,'darkgreen',1);//body
			drawShape('ell',x+sx,y+sy,z*sz,5,5,5,4,0,.05,.95,0,'rgba(0,0,0,.45)',1);//body shadow
			drawShape('ell',x+sx,y+sy,z*sz,5,3,6.13,4,0,.2,.8,0,'darkgreen',1);//body shadowcurve
			drawShape('qua',x+sx,y+sy,z*sz,2,1.73,9.5,5.5,0.5,5.5,8,1.73,'red',1);//hourglass
			//front legs
			drawShape('ell',x+sx,y+sy,z*sz,2,7,4,.4,-1.25,0,6,0,'green',1);//l-leg-mfront-base
			drawShape('ell',x+sx,y+sy,z*sz,-.9,6.7,2,.3,2,0,6,0,'green',1);//l-leg-mfront-mid
			drawShape('ell',x+sx,y+sy,z*sz,-1.1,9,.7,.2,1.5,0,6,0,'green',1);//l-leg-mfront-tip
			drawShape('ell',x+sx,y+sy,z*sz,8,7,4,.4,1.25,0,6,0,'green',1);//r-leg-mfront-base
			drawShape('ell',x+sx,y+sy,z*sz,10.9,6.7,2,.3,2,0,6,0,'green',1);//r-leg-mfront-mid
			drawShape('ell',x+sx,y+sy,z*sz,11.1,9,.7,.2,-1.5,0,6,0,'green',1);//r-leg-mfront-tip
			drawShape('ell',x+sx,y+sy,z*sz,7.5,5,5,.5,1.5,0,6,0,'green',1);//r-leg-front-base
			drawShape('ell',x+sx,y+sy,z*sz,10,5,4,.4,2,0,6,0,'green',1);//r-leg-front1-mid
			drawShape('ell',x+sx,y+sy,z*sz,10,5,4,.4,2,0,6,0,'darkgreen',0);//r-leg-front1-mid
			drawShape('ell',x+sx,y+sy,z*sz,9.6,9,1,.3,1.5,0,6,0,'green',1);//r-leg-front-tip
			drawShape('ell',x+sx,y+sy,z*sz,2.5,5,5,.5,-1.5,0,6,0,'green',1);//l-leg-front-base
			drawShape('ell',x+sx,y+sy,z*sz,0,5,4,.4,2,0,6,0,'green',1);//l-leg-front-mid
			drawShape('ell',x+sx,y+sy,z*sz,0,5,4,.4,2,0,6,0,'darkgreen',0);//l-leg-front-mid
			drawShape('ell',x+sx,y+sy,z*sz,.4,9,1,.3,-1.5,0,6,0,'green',1);//l-leg-front-tip
			//head
      sy = 2.9*z
			drawShape('ell',x+sx,y+sy,z*sz,5,8,2.3,2,0,0,6,0,'green',1);//head
			drawShape('ell',x+sx,y+sy,z*sz,5,8,2.3,2,0,0,6,0,'darkgreen',0);//head
			drawShape('ell',x+sx,y+sy,z*sz,5,8,2.3,2,0,.05,.95,0,'rgba(0,0,0,.45)',1);//head shadow
			drawShape('ell',x+sx,y+sy,z*sz,5,7,2.8,2,0,.2,.8,0,'green',1);//head shadowcurve
			drawShape('arc',x+sx,y+sy,z*sz,4.5,8,.5,0,6,0,0,0,'black',1);//l-eye1
			drawShape('arc',x+sx,y+sy,z*sz,5.5,8,.5,0,6,0,0,0,'black',1);//r-eye1
			drawShape('arc',x+sx,y+sy,z*sz,3.73,7,.2,0,6,0,0,0,'black',1);//l-eyebot
			drawShape('arc',x+sx,y+sy,z*sz,4.23,7.2,.2,0,6,0,0,0,'black',1);//l-eyemid
			drawShape('arc',x+sx,y+sy,z*sz,4.7,7.35,.2,0,6,0,0,0,'black',1);//l-eyetop
			drawShape('arc',x+sx,y+sy,z*sz,6.26,7,.2,0,6,0,0,0,'black',1);//r-eyebot
			drawShape('arc',x+sx,y+sy,z*sz,5.77,7.2,.2,0,6,0,0,0,'black',1);//r-eyemid
			drawShape('arc',x+sx,y+sy,z*sz,5.3,7.35,.2,0,6,0,0,0,'black',1);//r-eyebot
			drawShape('ell',x+sx,y+sy,z*sz,5,9.3,1.5,.5,0,.65,2.35,0,'black',1);//mouth
			drawShape('ell',x+sx,y+sy,z*sz,5.2,9.5,.8,.5,1.9,1.1,1.9,0,'white',1);//r-fang
			drawShape('ell',x+sx,y+sy,z*sz,4.8,9.5,.8,.5,-1.9,1.1,1.9,0,'white',1);//l-fang
			drawShape('ell',x+sx,y+sy,z*sz,6.8,8.4,1,.8,1.1,1.1,1.9,0,'green',1);//r-fang
			drawShape('ell',x+sx,y+sy,z*sz,6.8,8,1,.8,1.1,1.1,1.9,0,'darkgreen',0);//r-fang
			drawShape('ell',x+sx,y+sy,z*sz,3.3,8.4,1,.8,-1.1,1.1,1.9,0,'green',1);//l-fang
			drawShape('ell',x+sx,y+sy,z*sz,3.3,8,1,.8,-1.1,1.1,1.9,0,'darkgreen',0);//l-fang
			
		 
    break;
    case 60.1: //pixie
 
         sx = .5*z;
      sy = .5*z;
      sz = .9;
      drawShape('qua',x+sx,y+sy,z*sz,5.5,9, 5,8, 4.9,8.1, 5.1,8.75,'gold',1);//rfoottop
      drawShape('tri',x+sx,y+sy,z*sz,5.5,9, 5.5,8.5, 5,8, 5.1,8.75,'gold',1);//rfootbot

       sx = .5*z;
      sy = .5*z
      //drawShape('pol',x,y+sy,z,6.25,6.5, 6,6.4, 3.5,6.5, 4.5,6,'brown',1, 6.01,6.1);//llegcalf
      //drawShape('pol',x,y+sy,z,6.5,3.5, 6.6,3.75, 6.25,5, 5.75,4.5,'brown',1,6,4);//llegthigh
        //drawShape('ell',x,y+sy,z,4.1,6.34, .6,.39, .48,0, 1,1,'brown',1);

      drawShape('qua',x+sx,y+sy,z*sz,5.2,8.4, 5.2,8, 4.9,7, 4.95,8.1,'brown',1);//rlegleft
      drawShape('pol',x+sx,y+sy,z*sz,5.2,8, 4.9,7, 4.75,5.8, 5.5,5.25,'brown',1, 5.3,7);//rlegright
      sx = 0*z;
      sy = 0*z
      drawShape('qua',x+sx,y+sy,z*sz,4.5,9, 5,8, 5.1,8.1, 4.9,8.75,'gold',1);//rfoottop
      drawShape('tri',x+sx,y+sy,z*sz,4.5,9, 4.5,8.5, 5,8, 4.9,8.75,'gold',1);//rfootbot

      drawShape('qua',x+sx,y+sy,z*sz,4.8,8.4, 4.8,8, 5.1,7, 5.05,8.1,'brown',1);//rlegleft
      drawShape('pol',x+sx,y+sy,z*sz,4.8,8, 5.1,7, 5.25,5.8, 4.5,5.25,'brown',1, 4.7,7);//rlegright
      sx = .5*z;
      sy = .5*z
      drawShape('pol',x+sx,y+sy,z*sz,4.25,5.5, 3.75,5, 3.7,5.2, 3.5,4.8,'cyan',1, 4.3,4);//hipclothesleft
      drawShape('pol',x+sx,y+sy,z*sz,4.25,5.5, 3.75,5, 3.7,5.2, 3.5,4.8,'rgba(0,0,0,.4)',1, 4.3,4);//hipclothesleft
      drawShape('pol',x+sx,y+sy,z*sz,4.25,5.5, 4.5,5.25, 4.75,5.8, 5.5,5.25,'cyan',1, 5.8,4.5);//hipclothesright
      drawShape('pol',x+sx,y+sy,z*sz,4.25,5.5, 4.5,5.25, 4.75,5.8, 5.5,5.25,'rgba(0,0,0,.2)',1, 5.8,4.5);//hipclothesright

      drawShape('pol',x+sx,y+sy,z*sz,4.25,5.5, 5.8,4.5, 5.5,4, 4.75,4.2,'cyan',1, 4.3,4);//hipclothesmid
      drawShape('qua',x+sx,y+sy,z*sz,4.8,3.2, 2.6,2.5-Math.random(), 5,0.9, 7.4,2.5-Math.random(),'rgba(255,255,255,.05)',1);//arms
      drawShape('qua',x+sx,y+sy,z*sz,4.8,3.2, 2.6,2.5-Math.random(), 5,.9, 7.4,2.5-Math.random(),'rgba(255,255,255,.05)',1);//arms
      drawShape('qua',x+sx,y+sy,z*sz,4.8,3, 3.5,2.5-Math.random(), 4.8,2, 6.5,2.5-Math.random(),'rgba(255,255,255,.45)',1);//arms
     sy = -3.5*z
  drawShape('qua',x+sx,y+sy,z*sz,4.8,6.8, 2.6,7.5+Math.random(), 5,9.1, 7.4,7.5+Math.random(),'rgba(255,255,255,.05)',1);//arms
      drawShape('qua',x+sx,y+sy,z*sz,4.8,6.8, 2.6,7.5+Math.random(), 5,9.1, 7.4,7.5+Math.random(),'rgba(255,255,255,.05)',1);//arms
      drawShape('qua',x+sx,y+sy,z*sz,4.8,7, 3.5,7.5+Math.random(), 4.8,8, 6.5,7.5+Math.random(),'rgba(255,255,255,.45)',1);//arms
      sy = .5*z

      drawShape('pol',x+sx,y+sy,z*sz,4.3,4, 4,2.5, 4.1,1.5, 5.85,1.5,'cyan',1, 5.8,2);//tunicl
            drawShape('pol',x+sx,y+sy,z*sz,4.3,4, 4,2.5, 4.1,1.5, 5.85,1.5,'rgba(0,0,0,.2)',1, 5.8,2);//tunicl

      drawShape('qua',x+sx,y+sy,z*sz,5.8,2, 5.5,4, 4.75,4.25, 4.3,4,'cyan',1);//tunicr
            drawShape('qua',x+sx,y+sy,z*sz,5.8,2, 5.5,4, 4.75,4.25, 4.3,4,'rgba(0,0,0,.1)',1);//tunicr


      drawShape('pol',x+sx,y+sy,z*sz,4.5,1.5, 4.5,1.6, 5,1.75, 5.5,1.6,'rgb(255,179,102)',1, 5.5,1.5);//collar

      drawShape('pol',x+sx,y,z*sz,4.55,1.5, 4.35,0.7, 5,0, 5.6,0.7,'gold',1, 5.4,1.6);//hair
      sy = .5*z
      drawShape('pol',x+sx,y+sy,z*sz,4.55,1.5, 4.8,1.1, 5.25,1.25, 5.3,1.4,'rgb(255,179,102)',1, 5.5,1.5);//neck
      drawShape('pol',x+sx,y+sy,z*sz,4.6,1.25, 4.5,0.25, 5,0.275, 5.5,0.3,'rgb(245,169,92)',1, 5.3,1.5);//neck
       sx = .5*z;
      sy = .2*z
            drawShape('tri',x+sx,y+sy,z*sz,4.55,1, 4.8,0.95, 4.95,1, 0,0,'rgba(0,0,0,.7)',1, 5.4,8.4);//hair
            drawShape('tri',x+sx,y+sy,z*sz,5.45,1, 5.2,0.95, 5.05,1, 0,0,'rgba(0,0,0,.7)',1, 5.4,8.4);//hair
            drawShape('pol',x+sx,y+sy,z*sz,5,1.4, 4.9,1.35, 5,1.2, 5,1.35,'rgba(0,0,0,.7)',1, 5.1,1.35);//hair
            drawShape('tri',x+sx,y+sy,z*sz,4.75,1.5, 5,1.55, 5.25,1.5, 0,0,'rgba(255,0,0,.55)',1, 5.4,8.4);//hair
     
      drawShape('qua',x,y,z,4,4, 3.5,5, 3.4,4.9, 3.5,3.75,'rgba(255,128,64,1)',1, 4.3,4);//hipclothesleft
      drawShape('qua',x,y,z,6,4, 6.5,5, 6.6,4.9, 6.5,3.75,'rgba(255,128,64,1)',1, 4.3,4);//hipclothesleft
      
      drawShape('qua',x,y,z,3.4,5.1, 3.5,5.5, 3.25,6, 3.2,5.4,'gold',1, 3.4,4.9);//hipclothesleft

      drawShape('pol',x,y,z,3.5,5, 3.5,5.5, 3.4,5.1, 3.2,5.4,'rgba(255,128,64,1)',1, 3.4,4.9);//hipclothesleft
      drawShape('pol',x,y,z,3.4,5.4, 2.5,5, 1,4.6, 2.25,5.25,'silver',1, 3.3252,5.7);//hipclothesleft
      drawShape('pol',x,y,z,3.5,5.5, 3.8,5.75, 3.7,5.75, 3.5,5.75,'gold',1, 3.4,4.9);//hipclothesleft


      drawShape('qua',x,y,z,4.2,1.9, 3.5,3.75, 4,4.25, 4.2,3.25,'cyan',1, 4.3,4);//hipclothesleft
      drawShape('qua',x,y,z,4.2,1.9, 3.5,3.75, 4,4.25, 4.2,3.25,'rgba(0,0,0,.5)',1, 4.3,4);//hipclothesleft

      drawShape('qua',x,y,z,5.69,1.9, 6.5,3.75, 6,4.25, 5.63,2.8,'cyan',1, 4.3,4);//hipclothesleft
      drawShape('qua',x,y,z,5.69,1.9, 6.5,3.75, 6,4.25, 5.63,2.8,'rgba(0,0,0,.15)',1, 4.3,4);//hipclothesleft
      drawShape('tri',x,y,z,3.5,5.5, 3.5,5.8, 3.4,5.7, 3.5,3.75,'rgba(255,128,64,1)',1, 4.3,4);//hipclothesleft

      drawShape('qua',x,y,z,6.6,5.1, 6.5,5.5, 6.75,6, 6.8,5.4,'gold',1, 3.4,4.9);//hipclothesleft

      drawShape('pol',x,y,z,6.5,5, 6.5,5.5, 6.6,5.1, 6.8,5.4,'rgba(255,128,64,1)',1, 6.6,4.9);//hipclothesleft
      drawShape('pol',x,y,z,6.4,5.4, 7.5,5, 9,4.6, 7.75,5.25,'silver',1, 6.6848,5.7);//hipclothesleft
      drawShape('pol',x,y,z,6.5,5.5, 6.2,5.75, 6.2,5.75, 6.5,5.75,'gold',1, 6.6,4.9);//hipclothesleft


      drawShape('qua',x,y,z,5.8,1.9, 6.5,3.75, 6,4.25, 5.8,3.25,'cyan',1, 4.3,4);//hipclothesleft
      drawShape('qua',x,y,z,5.8,1.9, 6.5,3.75, 6,4.25, 5.8,3.25,'rgba(0,0,0,.5)',1, 4.3,4);//hipclothesleft

      drawShape('qua',x,y,z,4.31,1.9, 4.5,3.75, 4,4.25, 4.47,2.8,'cyan',1, 4.3,4);//hipclothesleft
      drawShape('qua',x,y,z,4.31,1.9, 4.5,3.75, 4,4.25, 4.47,2.8,'rgba(0,0,0,.15)',1, 4.3,4);//hipclothesleft
      drawShape('tri',x,y,z,6.5,5.5, 6.5,5.8, 6.6,5.7, 6.5,3.75,'rgba(255,128,64,1)',1, 4.3,4);//hipclothesleft

    break;
    case 61.1://Sylph Knight


    		drawShape('qua',x,y,z,5.5,3, 6,1.5 ,7.5,1, 7.5,2.5,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},${0+Math.random()*.5})`,1);//neck
    			drawShape('qua',x,y,z,5.5,2.75, 7,3 ,8,5.25, 6.5,4.75,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},${0+Math.random()*.5})`,1);//neck
          drawShape('qua',x,y,z,4.5,3, 4,1.5 ,2.5,1, 2.5,2.5,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},${0+Math.random()*.5})`,1);//neck
    			drawShape('qua',x,y,z,4.5,2.75, 3,3 ,2,5.25, 3.5,4.75,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},${0+Math.random()*.5})`,1);//neck
       
       sx=.5*z;
       sy=1*z; 
       sz=.9;
          		drawShape('tri',x+sx,y+sy,z*sz,/*tl*/ 4.45,3.55, /*tr*/3.7,2.5, /*br*/2.3,4, 0,0,'rgba(255,255,255,1)',1);//r-arm
			drawShape('tri',x+sx,y+sy,z*sz,/*tl*/ 4.4,3.5, /*tr*/3.7,2.5, /*br*/2.3,4, 0,0,'rgba(0,0,0,.4)',1);//r-arm
         drawShape('tri',x+sx,y+sy,z*sz,/*br*/ 2.1,3.9, /*tr*/2.7,3.3, /*l*/3.5,5.5, 0,0,'rgba(255,255,255,1)',1);//r-forearm
			drawShape('tri',x+sx,y+sy,z*sz,/*br*/ 2.1,3.9, /*tr*/2.7,3.3, /*l*/3.5,5.5, 0,0,'rgba(0,0,0,.4)',0);//r-forearm
     
    sx=.5*z;
      sy=1*z; 
      sz=.9;

			drawShape('arc',x+sx,y+sy,z*sz,4.25,2.65, .63,0, 3,0, 0,0,'rgba(255,255,255,1)',1);//l-shoulder
			drawShape('arc',x+sx,y+sy,z*sz,4.25,2.65, .63,0, 3,0, 0,0,'rgba(0,0,0,.2)',1);//l-shoulder
      drawShape('arc',x+sx,y+sy,z*sz,4.25,2.65, .63,0, 3,0, 0,0,'rgba(255,255,255,.5)',0);//l-shoulder-shadow
			drawShape('ell',x+sx,y+sy,z*sz,5.15,3.6,1.15,1.75,0,0,6,0,'rgba(255,255,255,1)',1);//torso
      			drawShape('ell',x+sx,y+sy,z*sz,5.15,3.6,1.15,1.75,0,0,6,0,'rgba(0,0,0,.3)',1);//torso

			drawShape('qua',x+sx,y+sy,z*sz,4.7,1.5, 5.5,1.5 ,6,2.5, 4.3,2.5,'rgba(255,255,255,1)',1);//neck
      			drawShape('qua',x+sx,y+sy,z*sz,4.7,1.5, 5.5,1.5 ,6,2.5, 4.3,2.5,'rgba(0,0,0,.33)',1);//neck

			drawShape('arc',x+sx,y+sy,z*sz,5,1,.9,0,2,0,0,0,'rgba(255,255,255,1)',1);//head
      			drawShape('arc',x+sx,y+sy,z*sz,5,1,.9,0,2,0,0,0,'rgba(0,0,0,.3)',1);//head


      //drawShape('tri',x+sx,y+sy,z*sz,4.1,.9, 5.6,.4, 4,-.3,0,0,'lightgray',1);//helm nose

     drawShape('arc',x+sx,y+sy,z*sz,4.95,1.1,1,0,2,0,0,0,'rgba(255,255,255,.5)',1);//head
			drawShape('arc',x+sx,y+sy,z*sz,5,1.1,.9,0,.7,0,0,0,'rgba(255,255,255,.1)',1);//head
			drawShape('arc',x+sx,y+sy,z*sz,4.9,.9,.9,0,.7,0,0,0,'rgba(255,255,255,1)',1);//head
      			drawShape('arc',x+sx,y+sy,z*sz,4.9,.9,.9,0,.7,0,0,0,'rgba(0,0,0,.2)',1);//head
			drawShape('arc',x+sx,y+sy,z*sz,5,1,.8,.7,0,0,0,0,'rgba(0,0,0,.2)',1);//head

			drawShape('arc',x+sx,y+sy,z*sz,5,1,.8,.7,0,0,0,0,'rgba(255,255,255,1)',1);//head
      			drawShape('arc',x+sx,y+sy,z*sz,5,1,.8,.7,0,0,0,0,'rgba(0,0,0,.3)',1);//head

      			drawShape('arc',x+sx,y+sy,z*sz,4.9,.9,.9,0,.7,0,0,0,'rgba(0,0,0,.1)',1);//head

      drawShape('tri',x+sx,y+sy,z*sz,3.5,1.5, 4.3,.75, 4.9,1.5,0,0,'rgba(255,255,255,1)',1);//helm nose
			      drawShape('tri',x+sx,y+sy,z*sz,3.5,1.5, 4.3,.75, 4.9,1.5,0,0,'rgba(0,0,0,.3)',1);//helm nose

      
      drawShape('tri',x+sx,y+sy,z*sz,3.5,1.5,4.8,1.5,4.9,2,0,0,'rgba(255,255,255,1)',1);//helm nose
			drawShape('tri',x+sx,y+sy,z*sz,3.5,1.5,4.8,1.5,4.9,2,0,0,'rgba(0,0,0,.2)',1);//helm nose
  
      drawShape('qua',x,y,z,5,6.5, 4-Math.random()*.25,7.5, 5,9+Math.random(), 6+Math.random()*.25,7.5,`rgba(255,255,255,${1-Math.random()})`,1);//FLOATING THING
  drawShape('qua',x,y,z,5,6.5, 4-Math.random()*.25,7.5, 5,9+Math.random(), 6+Math.random()*.25,7.5,`rgba(0,0,0,${0+Math.random()*.5})`,1);//FLOATING THING
			drawShape('qua',x+sx,y+sy,z*sz,6.2,4.3,7.25,7.25,5.1,6.3,4.75,5.25,'rgba(255,255,255,.5)',1);//hip armor
     drawShape('qua',x+sx,y+sy,z*sz,6.2,4.3,7.25,7.25,5.1,6.3,4.75,5.25,'rgba(0,0,0,.25)',1);//hip armor

			drawShape('qua',x+sx,y+sy,z*sz,4.2,4.3,2.75,7.25,4.9,6.3,5.25,5.25,'rgba(255,255,255,.5)',1);//hip armor
      drawShape('qua',x+sx,y+sy,z*sz,4.2,4.3,2.75,7.25,4.9,6.3,5.25,5.25,'rgba(0,0,0,.25)',1);//hip armor
			drawShape('qua',x+sx,y+sy,z*sz,4.75,7, 5.45,5, 4.75,5.2, 4.4,5,'rgba(255,255,255,1)',1);//groin armor
			drawShape('qua',x+sx,y+sy,z*sz,4.75,7, 5.45,5, 4.75,5.2, 4.4,5,'rgba(0,0,0,.3)',1);//groin armor

		
      sx=-.5*z;
		  drawShape('qua',x+sx,y+sy,z*sz,2.75,1.75, 4.5,2.75, 4.5,5.8, 2.75,4.8,'rgba(255,255,255,1)',1);//shield top
			drawShape('tri',x+sx,y+sy,z*sz,2.75,4.8,4.5,5.8,3.5,7.5,0,0,'rgba(255,255,255,1)',1);//shield bot
			 drawShape('qua',x+sx,y+sy,z*sz,2.75,1.75, 4.5,2.75, 4.5,5.8, 2.75,4.8,'rgba(0,0,0,.5)',1);//shield top
			drawShape('tri',x+sx,y+sy,z*sz,2.75,4.8,4.5,5.8,3.5,7.5,0,0,'rgba(0,0,0,.5)',1);//shield bot
      drawShape('lin',x+sx,y+sy,z*sz,3.5,7.6,3.45,2.1,0,0,0,0,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.2)`,0);//shield cross |
			drawShape('lin',x+sx,y+sy,z*sz,2.75,4,4.5,5,0,0,0,0,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.2)`,0);//shield cross--
sx=.5*z;
			drawShape('tri',x+sx,y+sy,z*sz,/*tl*/ 5.55,3.5, /*tr*/6.3,2.5, /*br*/7.7,4, 0,0,'rgba(255,255,255,1)',1);//r-arm
			drawShape('tri',x+sx,y+sy,z*sz,/*tl*/ 5.6,3.5, /*tr*/6.3,2.5, /*br*/7.7,4, 0,0,'rgba(0,0,0,.4)',1);//r-arm
	
      sx=.5*z;

			drawShape('qua',x+sx,y+sy,z*sz,5.9,5, 5.9,5.3, 7.2,5.7, 7.2,5.3,'gold',1);//sword-hilt
			drawShape('tri',x+sx,y+sy,z*sz,1,4.1, 5.9,4.85, 6.1,5.65,0,0,'white',1);//sword-blade
      			drawShape('tri',x+sx,y+sy,z*sz,1,4.1, 5.9,4.85, 6.1,5.65,0,0,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},1)`,1);//sword-blade

			drawShape('qua',x+sx,y+sy,z*sz,6,4, 5.6,5.2, 6,6.3, 6.1,5.5,'gold',1);//sword-crossguard
      sx=.5*z;

			drawShape('arc',x+sx,y+sy,z*sz,6,3, .63,0, 3,0, 0,0,'rgba(255,255,255,1)',1);//r-shoulder
			drawShape('arc',x+sx,y+sy,z*sz,6,3, .63,0, 3,0, 0,0,'rgba(0,0,0,.1)',1);//r-shoulder
			//drawShape('tri',x+sx,y+sy,z*sz,5.3,1.3, 4.95,.05, 5.4,.17, 5.4,.3,'black',1);//helmet visor
      drawShape('qua',x+sx,y+sy,z*sz,5.8,.7, 4.2,.8, 4.05,.5, 4.15,.6,'rgba(0,0,0,1)',1);//helmet visor

      drawShape('tri',x+sx,y+sy,z*sz,/*br*/ 7.9,3.9, /*tr*/7.3,3.3, /*l*/6.5,5.5, 0,0,'rgba(255,255,255,1)',1);//r-forearm
			drawShape('tri',x+sx,y+sy,z*sz,/*br*/ 7.9,3.9, /*tr*/7.3,3.3, /*l*/6.5,5.5, 0,0,'rgba(0,0,0,.4)',1);//r-forearm
      drawShape('qua',x+sx,y+sy,z*sz,6.9,4.9, 6.1,5.1, 6.4,5.5, 6.7,5.6,'rgba(255,255,255,1)',1);//hand right
            drawShape('qua',x+sx,y+sy,z*sz,6.9,4.9, 6.1,5.1, 6.4,5.5, 6.7,5.6,'rgba(0,0,0,.4)',1);//hand right


            

    break;
    case 61.2://Dark Sylph
    	drawShape('qua',x,y,z,5.5,3, 6,1.5 ,7.5,1, 7.5,2.5,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},${0+Math.random()*.5})`,1);//neck
    	drawShape('qua',x,y,z,5.5,2.75, 7,3 ,8,5.25, 6.5,4.75,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},${0+Math.random()*.5})`,1);//neck
      drawShape('qua',x,y,z,4.5,3, 4,1.5 ,2.5,1, 2.5,2.5,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},${0+Math.random()*.5})`,1);//neck
    	drawShape('qua',x,y,z,4.5,2.75, 3,3 ,2,5.25, 3.5,4.75,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},${0+Math.random()*.5})`,1);//neck
       sx=.5*z;
       sy=1*z; 
       sz=.9;
      drawShape('tri',x+sx,y+sy,z*sz,/*tl*/ 4.45,3.55, /*tr*/3.7,2.5, /*br*/2.3,4, 0,0,'rgba(0,0,0,1)',1);//r-arm
			drawShape('tri',x+sx,y+sy,z*sz,/*tl*/ 4.4,3.5, /*tr*/3.7,2.5, /*br*/2.3,4, 0,0,'rgba(255,255,255,.24)',1);//r-arm
      drawShape('tri',x+sx,y+sy,z*sz,/*br*/ 2.1,3.9, /*tr*/2.7,3.3, /*l*/3.5,5.5, 0,0,'rgba(0,0,0,1)',1);//r-forearm
			drawShape('tri',x+sx,y+sy,z*sz,/*br*/ 2.1,3.9, /*tr*/2.7,3.3, /*l*/3.5,5.5, 0,0,'rgba(255,255,255,.24)',0);//r-forearm
     
      sx=.5*z;
      sy=1*z; 
      sz=.9;
			drawShape('arc',x+sx,y+sy,z*sz,4.25,2.65, .63,0, 3,0, 0,0,'rgba(0,0,0,1)',1);//l-shoulder
			drawShape('arc',x+sx,y+sy,z*sz,4.25,2.65, .63,0, 3,0, 0,0,'rgba(255,255,255,.2)',1);//l-shoulder
      drawShape('arc',x+sx,y+sy,z*sz,4.25,2.65, .63,0, 3,0, 0,0,'rgba(0,0,0,.5)',0);//l-shoulder-shadow
			drawShape('ell',x+sx,y+sy,z*sz,5.15,3.6,1.15,1.75,0,0,6,0,'rgba(0,0,0,1)',1);//torso
      drawShape('ell',x+sx,y+sy,z*sz,5.15,3.6,1.15,1.75,0,0,6,0,'rgba(255,255,255,.3)',1);//torso

			drawShape('qua',x+sx,y+sy,z*sz,4.7,1.5, 5.5,1.5 ,6,2.5, 4.3,2.5,'rgba(0,0,0,1)',1);//neck
      drawShape('qua',x+sx,y+sy,z*sz,4.7,1.5, 5.5,1.5 ,6,2.5, 4.3,2.5,'rgba(255,255,255,.33)',1);//neck

			drawShape('arc',x+sx,y+sy,z*sz,5,1,.9,0,2,0,0,0,'rgba(0,0,0,1)',1);//head
      drawShape('arc',x+sx,y+sy,z*sz,5,1,.9,0,2,0,0,0,'rgba(255,255,255,.3)',1);//head


      //drawShape('tri',x+sx,y+sy,z*sz,4.1,.9, 5.6,.4, 4,-.3,0,0,'lightgray',1);//helm nose

      drawShape('arc',x+sx,y+sy,z*sz,4.95,1.1,1,0,2,0,0,0,'rgba(0,0,0,.5)',1);//head
			drawShape('arc',x+sx,y+sy,z*sz,5,1.1,.9,0,.7,0,0,0,'rgba(0,0,0,.1)',1);//head
			drawShape('arc',x+sx,y+sy,z*sz,4.9,.9,.9,0,.7,0,0,0,'rgba(0,0,0,1)',1);//head
      drawShape('arc',x+sx,y+sy,z*sz,4.9,.9,.9,0,.7,0,0,0,'rgba(255,255,255,.2)',1);//head
			drawShape('arc',x+sx,y+sy,z*sz,5,1,.8,.7,0,0,0,0,'rgba(255,255,255,.2)',1);//head

			drawShape('arc',x+sx,y+sy,z*sz,5,1,.8,.7,0,0,0,0,'rgba(0,0,0,1)',1);//head
      drawShape('arc',x+sx,y+sy,z*sz,5,1,.8,.7,0,0,0,0,'rgba(255,255,255,.3)',1);//head

      drawShape('arc',x+sx,y+sy,z*sz,4.9,.9,.9,0,.7,0,0,0,'rgba(255,255,255,.1)',1);//head

      drawShape('tri',x+sx,y+sy,z*sz,3.5,1.5, 4.3,.75, 4.9,1.5,0,0,'rgba(0,0,0,1)',1);//helm nose
			drawShape('tri',x+sx,y+sy,z*sz,3.5,1.5, 4.3,.75, 4.9,1.5,0,0,'rgba(255,255,255,.3)',1);//helm nose

      drawShape('tri',x+sx,y+sy,z*sz,3.5,1.5,4.8,1.5,4.9,2,0,0,'rgba(0,0,0,1)',1);//helm nose
			drawShape('tri',x+sx,y+sy,z*sz,3.5,1.5,4.8,1.5,4.9,2,0,0,'rgba(255,255,255,.2)',1);//helm nose
  
      drawShape('qua',x,y,z,5,6.5, 4-Math.random()*.25,7.5, 5,9+Math.random(), 6+Math.random()*.25,7.5,`rgba(0,0,0,${1-Math.random()})`,1);//FLOATING THING
      drawShape('qua',x,y,z,5,6.5, 4-Math.random()*.25,7.5, 5,9+Math.random(), 6+Math.random()*.25,7.5,`rgba(255,255,255,${0+Math.random()*.5})`,1);//FLOATING THING
			drawShape('qua',x+sx,y+sy,z*sz,6.2,4.3,7.25,7.25,5.1,6.3,4.75,5.25,'rgba(0,0,0,.5)',1);//hip armor
      drawShape('qua',x+sx,y+sy,z*sz,6.2,4.3,7.25,7.25,5.1,6.3,4.75,5.25,'rgba(255,255,255,.25)',1);//hip armor

			drawShape('qua',x+sx,y+sy,z*sz,4.2,4.3,2.75,7.25,4.9,6.3,5.25,5.25,'rgba(0,0,0,.5)',1);//hip armor
      drawShape('qua',x+sx,y+sy,z*sz,4.2,4.3,2.75,7.25,4.9,6.3,5.25,5.25,'rgba(255,255,255,.25)',1);//hip armor
			drawShape('qua',x+sx,y+sy,z*sz,4.75,7, 5.45,5, 4.75,5.2, 4.4,5,'rgba(0,0,0,1)',1);//groin armor
			drawShape('qua',x+sx,y+sy,z*sz,4.75,7, 5.45,5, 4.75,5.2, 4.4,5,'rgba(255,255,255,.3)',1);//groin armor

		
      sx=-.5*z;
		  drawShape('qua',x+sx,y+sy,z*sz,2.75,1.75, 4.5,2.75, 4.5,5.8, 2.75,4.8,'rgba(0,0,0,1)',1);//shield top
			drawShape('tri',x+sx,y+sy,z*sz,2.75,4.8,4.5,5.8,3.5,7.5,0,0,'rgba(0,0,0,1)',1);//shield bot
			drawShape('qua',x+sx,y+sy,z*sz,2.75,1.75, 4.5,2.75, 4.5,5.8, 2.75,4.8,'rgba(255,255,255,.25)',1);//shield top
			drawShape('tri',x+sx,y+sy,z*sz,2.75,4.8,4.5,5.8,3.5,7.5,0,0,'rgba(255,255,255,.25)',1);//shield bot
      drawShape('lin',x+sx,y+sy,z*sz,3.5,7.6,3.45,2.1,0,0,0,0,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.2)`,0);//shield cross |
			drawShape('lin',x+sx,y+sy,z*sz,2.75,4,4.5,5,0,0,0,0,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.2)`,0);//shield cross--
      sx=.5*z;
			drawShape('tri',x+sx,y+sy,z*sz,/*tl*/ 5.55,3.5, /*tr*/6.3,2.5, /*br*/7.7,4, 0,0,'rgba(0,0,0,1)',1);//r-arm
			drawShape('tri',x+sx,y+sy,z*sz,/*tl*/ 5.6,3.5, /*tr*/6.3,2.5, /*br*/7.7,4, 0,0,'rgba(255,255,255,.24)',1);//r-arm
	
      sx=.5*z;

			drawShape('qua',x+sx,y+sy,z*sz,5.9,5, 5.9,5.3, 7.2,5.7, 7.2,5.3,'rgba(32,32,0,1)',1);//sword-hilt
			drawShape('tri',x+sx,y+sy,z*sz,1,4.1, 5.9,4.85, 6.1,5.65,0,0,'black',1);//sword-blade
      drawShape('tri',x+sx,y+sy,z*sz,1,4.1, 5.9,4.85, 6.1,5.65,0,0,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},1)`,1);//sword-blade

			drawShape('qua',x+sx,y+sy,z*sz,6,4, 5.6,5.2, 6,6.3, 6.1,5.5,'rgba(32,32,0,1)',1);//sword-crossguard
      sx=.5*z;

			drawShape('arc',x+sx,y+sy,z*sz,6,3, .63,0, 3,0, 0,0,'rgba(0,0,0,1)',1);//r-shoulder
			drawShape('arc',x+sx,y+sy,z*sz,6,3, .63,0, 3,0, 0,0,'rgba(255,255,255,.1)',1);//r-shoulder
			//drawShape('tri',x+sx,y+sy,z*sz,5.3,1.3, 4.95,.05, 5.4,.17, 5.4,.3,'black',1);//helmet visor
      drawShape('qua',x+sx,y+sy,z*sz,5.8,.7, 4.2,.8, 4.05,.5, 4.15,.6,'rgba(255,0,0,1)',1);//helmet visor

      drawShape('tri',x+sx,y+sy,z*sz,/*br*/ 7.9,3.9, /*tr*/7.3,3.3, /*l*/6.5,5.5, 0,0,'rgba(0,0,0,1)',1);//r-forearm
			drawShape('tri',x+sx,y+sy,z*sz,/*br*/ 7.9,3.9, /*tr*/7.3,3.3, /*l*/6.5,5.5, 0,0,'rgba(255,255,255,.24)',1);//r-forearm
      drawShape('qua',x+sx,y+sy,z*sz,6.9,4.9, 6.1,5.1, 6.4,5.5, 6.7,5.6,'rgba(0,0,0,1)',1);//hand right
      drawShape('qua',x+sx,y+sy,z*sz,6.9,4.9, 6.1,5.1, 6.4,5.5, 6.7,5.6,'rgba(255,255,255,.24)',1);//hand right


            

    break;
    case 62.1: //Fairy Queen
     
    
       
    //right calf 
    sy= .25*z
  	drawShape('qua',x,y+sy,z,5.5,3, 6,1.5 ,7.5,1, 7.5,2.5,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},${0+Math.random()*.5})`,1);//neck
    			drawShape('qua',x,y+sy,z,5.5,2.75, 7,3 ,8,5.25, 6.5,4.75,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},${0+Math.random()*.5})`,1);//neck
          drawShape('qua',x,y+sy,z,4.5,3, 4,1.5 ,2.5,1, 2.5,2.5,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},${0+Math.random()*.5})`,1);//neck
    			drawShape('qua',x,y+sy,z,4.5,2.75, 3,3 ,2,5.25, 3.5,4.75,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},${0+Math.random()*.5})`,1);//neck
       
       
            drawShape('arc',x,y,z,4.8,4.9,.05,0,6,0,0,0,'rgba(128,128,0,.25)',1);//r-hand

          drawShape('arc',x,y,z,7.5,2,.75,0,6,0,0,0,'rgba(128,128,0,.075)',1);//r-hand
        drawShape('pol',x,y,z,7,4, 5,9, 4,5, 4.5,4,'rgba(128,128,0,.25)',1,5,2.5);

    // aniDice.setColor(1,1, 0)
      //aniDice.setGlow(Math.random())
      //aniDice.animate(x+7.55*z,y+2*z,1*z,.25,globalDt);

        drawShape('qua',x,y,z,4.25,2, 4.5,3, 5,2.5, 4.55,1.5,'rgba(0,0,0,1)',1);
        drawShape('pol',x,y,z,4.45,5.5, 4,7.5, 4.5,7.5, 4.5,7,'rgba(128,128,0,.5)',1,5.25,5.5);
        drawShape('pol',x,y,z,5.6,5, 6,6.5, 6,7, 5.6,7.5,'rgba(128,128,0,.5)',1,5.6,6.5);
        drawShape('tri',x,y,z,5.75,7, 5,5.5, 5.6,5, 5.5,7.5,'rgba(128,128,0,.5)',1,5.6,6.5);
        drawShape('pol',x,y,z,5.5,5, 5.4,4.5, 5.5,3.5, 6.9,4.8,'rgba(128,128,0,.5)',1,5.5,3);

      //legs red boots
      sx = -.5*z; 
      sy = -.1*z;
      sz = 1.1;
      drawShape('qua',x+sx,y+sy,z*sz, 5.5,7, 5.8,8.5, 6,8, 6,6.5,'rgba(128,128,0,.5)',1);
      drawShape('qua',x+sx,y+sy,z*sz, 4,7, 4,8.5, 4.25,8.3, 4.5,7,'rgba(128,128,0,.5)',1);
      drawShape('qua',x+sx,y+sy,z*sz, 4,8.25, 3.6,9, 4,8.8, 4.35,8.23,'rgba(128,128,0,1)',1);
      drawShape('qua',x+sx,y+sy,z*sz, 6,8, 6.3,9, 6,9, 5.7,8.5,'rgba(128,128,0,1)',1);
      //Empress upper
      sz = .8;
      sx = 1*z;
      sy = .0*z;
      //drawShape('qua',x+sx,y+sy,z*sz, 5.25,3, 5.5,3.5, 5,4, 4.5,2.5,'rgba(128,128,0,1)',1);//neck
      drawShape('qua',x+sx,y+sy,z*sz, 4.5,2.5, 5.5,3.5, 5,4, 4.5,2.5,'rgba(255,196,168,.9)',1);//neckL

      drawShape('qua',x+sx,y+sy,z*sz,4,1.8, 3.9,3, 4.25,3.25, 4.25,1.75,'rgba(0,0,0,.75)',1);//bangs left
      drawShape('qua',x+sx,y+sy,z*sz, 5.25,3.5, 4.15,2.25, 5,1.3, 6,2.5,'rgba(255,196,168,1)',1);//face
      //nose
      sz = .8;
      sx = .8*z;
      sy = .0*z;
      drawShape('tri',x+sx,y+sy,z*sz, 5.45,2.2, 5.4,2.8, 5.6,2.9, 0,0,'rgba(0,0,0,.2)',1);//nose
      //eyes
      sz = .8;
      sx = .8*z;
      sy = .0*z;
      drawShape('tri',x+sx,y+sy,z*sz, 5,2.2, 5.4,2.15, 5.2,2.3, 0,0,'rgba(0,0,0,.3)',1);//eye
      drawShape('tri',x+sx,y+sy,z*sz, 5.5,2.15, 5.9,2.1, 5.7,2.3, 0,0,'rgba(0,0,0,.3)',1);//eye
      //mouth 
      sz = .8;
      sx = .8*z;
      sy = .0*z;
      drawShape('tri',x+sx,y+sy,z*sz, 5.25,3, 5.6,2.95, 5.4,3.075, 0,0,'rgba(64,0,0,.4)',1);//mouth
      //hair
      sz = .8;
      sx = 1*z;
      sy = .0*z;
      drawShape('qua',x+sx,y+sy,z*sz,5,1.3, 4.2,1.75, 4,2.2, 5,1.85,'rgba(0,0,0,1)',1);//hair
      drawShape('qua',x+sx,y+sy,z*sz,5,1.3, 5.8,1.75, 6,2, 5,1.85,'rgba(0,0,0,1)',1);
       
      drawShape('qua',x+sx,y+sy,z*sz,5.55,1.9, 6,2.5, 5.8,3.4, 6,3.5,'rgba(0,0,0,1)',1);
      drawShape('qua',x+sx,y+sy,z*sz,5.55,1.9, 6,2.5, 5.8,3.4, 6,2,'rgba(0,0,0,.75)',1);
      //drawShape('qua',x,y,z,4.25,1.9, 3.8,2.5, 4,3.4, 3.8,3.5,'gold',1);
      drawShape('qua',x+sx,y+sy,z*sz,5,1.8, 4.28,2.07, 4.8,3.4, 4.5,3.5,'rgba(0,0,0,1)',1);
      drawShape('qua',x+sx,y+sy,z*sz,4.28,2.07, 3.85,2.5, 4.05,3.4, 3.85,3.5,'rgba(0,0,0,.75)',1);
      //larm
       sz = .8;
      sx = 1.25*z;
      sy = 1*z;
      drawShape('qua',x+sx,y+sy,z*sz, 3.9,4, 3,6, 3.5,6, 4,5,'rgba(128,128,0,.5)',1);//dress left forearm
        
 drawShape('qua',x+sx,y+sy,z*sz, 3.4,6, 2.5,9, 2.4,8, 3.2,5.9,'gold',1);//scepter
      drawShape('qua',x+sx,y+sy,z*sz, 3.4,6, 2.7,8, 2.4,8, 3.2,5.9,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.3)`,1);//scepter

          drawShape('qua',x+sx,y+sy,z*sz, 3,6, 3.5,6, 3.4,6.3, 3,6.5,'rgba(128,128,0,1)',1);//left hand

       sz = .7;
      sx = 1.7*z;
      sy = 3.45*z;
      drawShape('qua',x+sx,y+sy,z*sz, 2.8,4, 2.75,3.4, 3,3.6, 3.4,3.9,'rgba(128,128,0,1)',1);//left hand
         sz = .8;
      sx = 1.36*z;
      sy = .8*z;

     drawShape('qua',x+sx,y+sy,z*sz, 3.4,6.55, 3.2,6.5, 3.25,6.45, 3.2,6.3,'rgba(128,128,0,1)',1);//left thumb
      sz = .8;
      sx = 1.25*z;
      sy = 1*z;
     // drawShape('qua',x+sx,y+sy,z*sz, 4.5,6, 4.5,4.5, 3.9,4, 4,6,'rgba(128,128,0,1)',1);//dress left arm
     // drawShape('qua',x+sx,y+sy,z*sz, 5,6, 5.5,3, 4.5,4.5, 4.5,6,'rgba(128,128,0,1)',1);//dress left mid
      //
       sz = .8;
      sx = 1*z;
      sy = .0*z;
      //drawShape('qua',x+sx,y+sy,z*sz, 5.5,3.5, 6,3.5, 6.5,3.75, 7.5,5,'rgba(128,128,0,1)',1);//dress right shoulder n tricep
      //drawShape('qua',x+sx,y+sy,z*sz, 6.5,5, 6,6, 7,9.5, 3,9.5,'rgba(128,128,0,1)',1);//dress bottom right n forearm
      //drawShape('qua',x+sx,y+sy,z*sz, 7.5,5, 6,6, 7,9.5, 3,9.5,'rgba(128,128,0,1)',1);//dress bottom right n forearm
      drawShape('qua',x+sx,y+sy,z*sz, 5.5,3.5, 5,4, 5,7.5, 7.5,5,'rgba(128,128,0,.5)',1);//dress collarR
      drawShape('qua',x+sx,y+sy,z*sz, 5,4, 4.8,3.4, 4.5,3.5, 4,4,'rgba(128,128,0,.5)',1);//dress collarL
           sz = .8;
      sx = .83*z;
      sy = .0*z;
       drawShape('qua',x+sx,y+sy,z*sz, 4.5,4, 4,4.5, 4.45,5, 5,4.9,'rgba(128,128,0,.25)',1);//bl
        sx = .5*z;
        sy = .0*z;
       drawShape('qua',x+sx,y+sy,z*sz, 5.5,4, 4.8,4.5, 5.25,5, 5.8,4.9,'rgba(128,128,0,.5)',1);//brmain

      //
      sz = .8;
      sx = 2*z;
      sy = .0*z;
      drawShape('qua',x+sx,y+sy,z*sz, 6.1,6, 7,4, 6.5,4, 6,5,'rgba(128,128,0,.5)',1);//dress left forearm
        
      drawShape('qua',x+sx,y+sy,z*sz, 7,4, 6.5,4, 6.6,3.7, 7,3.5,'rgba(128,128,0,1)',1);//left hand

      drawShape('qua',x+sx,y+sy,z*sz, 7,4, 7.4,3.4, 7,3.5, 6.5,3.4,'rgba(128,128,0,1)',1);//left hand
        
      drawShape('tri',x+sx,y+sy,z*sz, 7.4,3.4, 6.5,3.4, 7,3.5, 7.25,1,'rgba(128,128,0,1)',1);//left fingers
      drawShape('qua',x+sx,y+sy,z*sz, 6.6,3.45, 6.75,3.5, 6.75,3.55, 6.6,3.7,'rgba(128,128,0,1)',1);//left thumb

     // drawShape('qua',x+sx,y+sy,z*sz, 5.5,4, 5.5,5.5, 6.1,6, 6,4,'rgba(128,128,0,1)',1);//dress left arm
     // drawShape('qua',x+sx,y+sy,z*sz, 5,4, 4.5,7, 5.5,5.5, 5.5,4,'rgba(128,128,0,1)',1);//dress left mid
     //////
      drawShape('pol',x,y,z, 4.5,3.2, 4.4,4.25, 4.5,6.5, 5,6,'rgba(128,128,0,1)',1,5,3);//brmain
           
      drawShape('pol',x,y,z, 4.25,1.5, 4,1, 4.5,1.75, 4.5,1,'rgba(128,128,0,1)',1,5,1.5);//brmain
      drawShape('pol',x,y,z, 5.75,1.5, 6,1, 5.5,1.75, 5.5,1,'rgba(128,128,0,1)',1,5,1.5);//brmain
      drawShape('pol',x,y,z, 4.25,1.5, 4,1, 4.5,1.75, 4.5,1,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.5)`,1,5,1.5);//brmain
      drawShape('pol',x,y,z, 5.75,1.5, 6,1, 5.5,1.75, 5.5,1,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.5)`,1,5,1.5);//brmain
   
    break;
    
    case 63.1: //Dragon
    let anifly = Date.now();
    
      
    if (anifly - lastanitime> 250){
      dragY = (Math.random()*1)*z;
      lastanitime = Date.now();
    }
     
    
      
      sx = 0*z;
      sy = dragY +4*z;
      sz = .6;
      drawShape('pol',x+sx,y+sy,z*sz,10,0, 8,.5 ,2,5 ,0,8,'rgba(0,32,0,1)',1,0,10);
      drawShape('tri',x+sx,y+sy,z*sz,10,0, 10,5 ,5.5,2 ,0,10,'rgba(0,32,0,1)',1,9,9);
      drawShape('pol',x+sx,y+sy,z*sz,10,5, 8.5,2 ,4,4.45 ,0,10,'rgba(255,255,128,1)',1,9,9);
      drawShape('tri',x+sx,y+sy,z*sz,10,5, 10,7 ,9.5,6 ,0,10,'rgba(255,255,128,1)',1,9,9);
      drawShape('pol',x+sx,y+sy,z*sz,9,9, 10,7 ,9.75,6.25 ,8.75,7.25,'rgba(16,8,4,1)',1,8.75,8.25);
      drawShape('pol',x+sx,y+sy,z*sz,9,9.1, 4.5,9.6 ,5,8.5 ,6,8.25,'rgba(16,8,4,1)',1,8,8.5);
      drawShape('pol',x+sx,y+sy,z*sz,0,10, 4.5,9.7 ,4,9 ,3,8.75,'rgba(16,8,3,1)',1,2,9);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 4.5,5 ,8.5,2 ,5,5,'rgba(0,0,0,.25)',1,2,9);
      drawShape('qua',x+sx,y+sy,z*sz,4.5,9, 5,6 ,8.5,2 ,5.5,6,'rgba(0,0,0,.25)',1,2,9);
      drawShape('qua',x+sx,y+sy,z*sz,9,9, 7.55,6 ,8.5,2 ,8,6,'rgba(0,0,0,.25)',1,2,9);
      drawShape('qua',x+sx,y+sy,z*sz,10,7, 9.5,5 ,8.5,2 ,9.3,5,'rgba(0,0,0,.25)',1,2,9);
      drawShape('tri',x+sx,y+sy,z*sz,0,9.75, 2.25,5 ,0,7 ,6,8.25,'rgba(10,6,3,1)',1,8,8.5);
      //tail
      drawShape('pol',x,y+dragY ,z,3.6,5.8, 3.6,7.5 ,4,7.5 ,4.25,7.25,'rgba(0,32,0,1)',1,3.9,6.9);
      drawShape('pol',x,y+dragY ,z,6,7.5, 6,8 ,6.5,9 ,5.5,8.5,'rgba(0,32,0,1)',1,5,7);
      sx = -3*z;
      sy = (-6.6*z)+dragY ;
      sz = 2.75;
      for (let i=0;i<60;i++){
        drawShape('ell',x+sx-27.75*z,y+sy-27.4*z,z*sz*3,    4.5+i*.001, 4.5+i*.001,        .2+i*.0025,   0.2+i*.003,  0,    1,   .4,    0,   `rgba(${0},${64+i},${0},1)`,0)
        drawShape('ell',x+sx-27.75*z,y+sy-27.37*z,z*sz*3,    4.5+i*.001, 4.5+i*.001,        .2+i*.0025,   0.2+i*.003,  0,    1,   .4,    0,   `rgba(${0},${64+i},${0},1)`,0)
        drawShape('ell',x+sx-28.75*z,y+sy-26.5*z,z*sz*3,    4.5+i*.001, 4.5+i*.001,        .2+i*.0025,   0.2+i*.003,  0,    .1,   .8,    0,   `rgba(${0},${64+i},${0},1)`,0)
        drawShape('ell',x+sx-28.75*z,y+sy-26.51*z,z*sz*3,    4.5+i*.001, 4.5+i*.001,        .2+i*.0025,   0.2+i*.003,  0,    .1,   .8,    0,   `rgba(${0},${64+i},${0},1)`,0)
      }
 
      sx = -13*z;
      sy = (-13.3*z)+dragY ;
      sz = 3.5;
      for (let i=0;i<60;i++){
       drawShape('ell',x+sx-30.75*z,y+sy-25.5*z,z*sz*3,    4.5+i*.001, 4.5+i*.001,        .2+i*.0025,   0.2+i*.003,  0,    1.2,   -.49,    0,   `rgba(${0},${64+i},${0},1)`,0)
      }
      sx =6*z;
      sy = dragY +4*z;
      sz = .4;
      drawShape('pol',x+sx,y+sy,z*sz,0,0, 2,.5 ,8,5 ,10,8,'rgba(0,64,0,.75)',1,10,10);
      drawShape('tri',x+sx,y+sy,z*sz,0,0, 0,5 ,4.5,2 ,10,10,'rgba(0,64,0,.75)',1,1,9);

      drawShape('pol',x+sx,y+sy,z*sz,0,5, 1.5,2 ,6,4.45 ,10,10,'rgba(0,64,0,.75)',1,1,9);
      drawShape('tri',x+sx,y+sy,z*sz,0,5, 0,7 ,0.5,6 ,10,10,'rgba(0,64,0,.75)',1,1,9);
      drawShape('pol',x+sx,y+sy,z*sz,1,9, 0,7 ,0.25,6.25 ,1.25,7.25,'rgba(0,64,0,.75)',1,1.25,8.25);
      drawShape('pol',x+sx,y+sy,z*sz,1,9.1, 5.5,9.6 ,5,8.5 ,4,8.25,'rgba(0,64,0,.75)',1,2,8.5);
      drawShape('pol',x+sx,y+sy,z*sz,10,10, 5.5,9.7 ,6,9 ,7,8.75,'rgba(0,64,0,.75)',1,8,9);
      drawShape('qua',x+sx,y+sy,z*sz,10,10, 5.5,5 ,1.5,2 ,5,5,'rgba(0,64,0,.75)',1,8,9);
      drawShape('qua',x+sx,y+sy,z*sz,5.5,9, 5,6 ,1.5,2 ,4.5,6,'rgba(0,64,0,.75)',1,8,9);
      drawShape('qua',x+sx,y+sy,z*sz,1,9, 2.45,6 ,1.5,2 ,2,6,'rgba(0,64,0,.75)',1,8,9);
      drawShape('qua',x+sx,y+sy,z*sz,0,7, 0.5,5 ,1.5,2 ,0.7,5,'rgba(0,64,0,.75)',1,8,9);
      drawShape('tri',x+sx,y+sy,z*sz,10,9.75, 7.75,5 ,10,7 ,4,8.25,'rgba(0,64,13,.75)',1,2,8.5);
      sx = -7.5*z;
      sy = (-3.6*z)+dragY ;
      sz = 2;
      for (let i=0;i<60;i++){
        //teeth
        drawShape('ell',x+sx,y+sy,z*sz,    4.4+i*.001, 5.69+i*.001,        0+i*.001,   0+i*.002,  0,    .75,   1.5,    0,   `rgba(${255},${255},${255},1)`,0)
        drawShape('ell',x+sx,y+sy,z*sz,    4.67+i*.000005, 5.680+i*.001,        0+i*.001,   0+i*.002,  0,    1.5,   .2,    0,   `rgba(${255},${255},${255},1)`,0)
        //head
        //body
        drawShape('ell',x+sx,y+sy,z*sz,    4.5+i*.001, 5.25+i*.001,        0.2+i*.005,   0+i*.005,  0,    0,   2,    0,   `rgba(${0},${64+i},${0},1)`,0)
        //upper jaw
        drawShape('ell',x+sx,y+sy,z*sz,    4.5+i*.001, 5.5+i*.001,        .5-i*.005,   0+i*.005,  0,    1,   2,    0,   `rgba(${0},${64-i},${0},1)`,0)
        //bottom jaw     
        drawShape('ell',x+sx,y+sy,z*sz,    4.51+i*.001, 5.4+i*.001,        .49-i*.005,   0+i*.01,  0,    2,   1,    0,   `rgba(${0},${64+i},${0},1)`,0)
        //tail
      }
      sx = -7.5*z;
      sy = (-3.6*z)+dragY ;
      sz = 2;
      drawShape('pol',x+sx,y+sy,z*sz,    4.55, 5.6,   4.5, 6.3,   4.4,6.4,   4.55,6.3,   `rgba(${128},${0},${0},1)`,1, 4.6,6.5)
      drawShape('ell',x+sx,y+sy,z*sz,    4.8, 5.25,   .2, .15,   0,   1.6,  .5,   0,   `rgba(${255},${255},${128},1)`,1, 4.6,6.5)
      drawShape('ell',x+sx,y+sy,z*sz,    4.3, 5.25,   .2, .15,   0,   .5,  1.4,   0,   `rgba(${255},${255},${128},1)`,1, 4.6,6.5)
      drawShape('ell',x+sx,y+sy,z*sz,    4.86, 5.26,   .05, .12,   0,   -.45,  .25,   0,   `rgba(${0},${0},${0},1)`,1, 4.6,6.5)
      drawShape('ell',x+sx,y+sy,z*sz,    4.21, 5.26,   .05, .12,   0,   .75,  -.5,   0,   `rgba(${0},${0},${0},1)`,1, 4.6,6.5)
      drawShape('qua',x,y+dragY,z,6,4, 4,5 ,4.5,5.5 ,6,6,'rgba(0,64,0,1)',1,0,10);
      drawShape('pol',x,y+dragY,z,4,5, 5,6 ,5.5,7 ,4.5,7.5,'rgba(0,32,0,1)',1,5,6.5);
      drawShape('tri',x,y+dragY,z,4,5, 4.5,6 ,5,6.5 ,4.75,8,'rgba(0,32,0,1)',1,5,7);
    
      drawShape('pol',x,y+dragY,z,7,7.5, 7,8 ,7.5,9 ,6.5,8.5,'rgba(0,32,0,1)',1,6,7);
      drawShape('qua',x,y+dragY,z,7.5,8.5, 6.5,9 ,7,9 ,7,9.5,'rgba(0,32,0,1)',1,6,7);
      drawShape('qua',x,y+dragY,z,6.5,8.5, 5.5,9 ,6,9 ,6,9.5,'rgba(0,32,0,1)',1,6,7);
      drawShape('qua',x,y+dragY,z,4.9,7, 4.5,7 ,4.75,7.25 ,5,7.5,'rgba(0,32,0,1)',1,6,7);
      drawShape('pol',x,y+dragY,z,4,7,3.9,6.5 ,4.1,6.9 ,4.3,7,'rgba(0,32,0,1)',1,4,7.5);
      drawShape('pol',x,y+dragY,z,1.6+Math.random()*.1,7.6,   1-Math.random()*.75,9+Math.random()*.4 ,       1.6, 10-Math.random()*.3 ,        2.5+Math.random(),9+Math.random()*.3,`rgba(${255},${Math.random()*100},${0},1)`,1,1.6+Math.random()*.3,8.5-Math.random()*.3);
      drawShape('pol',x,y+dragY,z,1,6.6, 1.5,6.5 ,1,6 ,.5,6,'rgba(255,255,128,1)',1,1.1,6.25);
      sx= -6.75*z
      drawShape('pol',x+sx,y+dragY ,z,9,6.6, 8.5,6.5 ,9,6 ,9.5,6,'rgba(255,255,128,1)',1,8.9,6.25);
      break;
    case 70.1://Cultivate 7  
      drawShape('arc',x,y+1*z,z,5,5,5-Math.random(),0,2,0,0,0,'rgba(0,64,0,.25)',1);
      sx = -5*z;
      sy = -0.5*z;
      sz = 2;
      //neck
      drawShape('qua',x+sx,y+sy,z*sz,5,2, 4.5,2.5, 4.5,3, 5,3.5,`rgba(${0},${128},${0},.5)`,1,10,7);
       drawShape('qua',x+sx,y+sy,z*sz,5,2, 5.5,2.5, 5.5,3, 5,3.5,`rgba(${0},${128},${0},.5)`,1,10,7);
      //shoulders
      drawShape('qua',x+sx,y+sy,z*sz,5,2.5, 4,2.5, 3.5,3, 5,3,`rgba(${0},${128},${0},.5)`,1,10,7);
      drawShape('qua',x+sx,y+sy,z*sz,5,2.5, 6,2.5, 6.5,3, 5,3,`rgba(${0},${128},${0},.5)`,1,10,7);
      //torso
      drawShape('qua',x+sx,y+sy,z*sz,4,3, 5,5, 6,3, 5,2.5,`rgba(${0},${128},${0},.5)`,1,10,7);
      //legs
      drawShape('qua',x+sx,y+sy,z*sz,5.5,4, 7,5, 6,5, 5,5,`rgba(${0},${128},${0},.5)`,1,10,7);
      drawShape('qua',x+sx,y+sy,z*sz,4.5,4, 3,5, 4,5, 5,5,`rgba(${0},${128},${0},.5)`,1,10,7);
            
      drawShape('qua',x+sx,y+sy,z*sz,3,5, 5.5,5.5, 4,4.8, 3.5,4.75,`rgba(${0},${128},${0},.5)`,1,10,7);
      drawShape('qua',x+sx,y+sy,z*sz,7,5, 4.5,5.5, 6,4.8, 6.5,4.75,`rgba(${0},${128},${0},.5)`,1,10,7);
      //arms
      drawShape('tri',x+sx,y+sy,z*sz,3.5,3, 4,4, 4,3, 3.5,4.75,`rgba(${0},${128},${0},.5)`,1,10,7);
      drawShape('tri',x+sx,y+sy,z*sz,6.5,3, 6,4, 6,3, 3.5,4.75,`rgba(${0},${128},${0},.5)`,1,10,7);

      drawShape('tri',x+sx,y+sy,z*sz,4,3.5, 4,4, 5,4.5, 3.5,4.75,`rgba(${0},${128},${0},.5)`,1,10,7);
      drawShape('tri',x+sx,y+sy,z*sz,6,3.5, 6,4, 5,4.5, 3.5,4.75,`rgba(${0},${128},${0},.5)`,1,10,7);
    sx = -1.25*z;
      sy = 1.5*z;
      sz = 1.25;
      //head l
      drawShape('qua',x+sx,y+sy,z*sz,5,.25, 4,1, 4.5,2, 5,2.5,`rgba(${0},${128},${0},1)`,1,10,7);
      //head r
      drawShape('qua',x+sx,y+sy,z*sz,5,.25, 6,1, 5.5,2, 5,2.5,`rgba(${0},${128},${0},1)`,1,10,7);
    //////////////////////////////////////////////////////////////////////
    sx = -5*z;
        sy = -0.5*z;
        sz = 2;
        //neck
      drawShape('qua',x+sx,y+sy,z*sz,5,2, 4.5,2.5, 4.5,3, 5,3.5,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.1)`,1,10,7);
       drawShape('qua',x+sx,y+sy,z*sz,5,2, 5.5,2.5, 5.5,3, 5,3.5,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.1)`,1,10,7);
     //shoulders
      drawShape('qua',x+sx,y+sy,z*sz,5,2.5, 4,2.5, 3.5,3, 5,3,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.1)`,1,10,7);
      drawShape('qua',x+sx,y+sy,z*sz,5,2.5, 6,2.5, 6.5,3, 5,3,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.1)`,1,10,7);
     
      //torso
            drawShape('qua',x+sx,y+sy,z*sz,4,3, 5,5, 6,3, 5,2.5,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.1)`,1,10,7);
      //legs
            drawShape('qua',x+sx,y+sy,z*sz,5.5,4, 7,5, 6,5, 5,5,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.1)`,1,10,7);
            drawShape('qua',x+sx,y+sy,z*sz,4.5,4, 3,5, 4,5, 5,5,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.1)`,1,10,7);
            
            drawShape('qua',x+sx,y+sy,z*sz,3,5, 5.5,5.5, 4,4.8, 3.5,4.75,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.1)`,1,10,7);
            drawShape('qua',x+sx,y+sy,z*sz,7,5, 4.5,5.5, 6,4.8, 6.5,4.75,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.1)`,1,10,7);
     //arms
        drawShape('tri',x+sx,y+sy,z*sz,3.5,3, 4,4, 4,3, 3.5,4.75,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.1)`,1,10,7);
        drawShape('tri',x+sx,y+sy,z*sz,6.5,3, 6,4, 6,3, 3.5,4.75,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.1)`,1,10,7);

        drawShape('tri',x+sx,y+sy,z*sz,4,3.5, 4,4, 5,4.5, 3.5,4.75,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.1)`,1,10,7);
        drawShape('tri',x+sx,y+sy,z*sz,6,3.5, 6,4, 5,4.5, 3.5,4.75,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.1)`,1,10,7);
        sx = -1.25*z;
    sy = 1.5*z;
    sz = 1.25;
    //head l
      drawShape('qua',x+sx,y+sy,z*sz,5,.25, 4,1, 4.5,2, 5,2.5,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.1)`,1,10,7);
      //head r
      drawShape('qua',x+sx,y+sy,z*sz,5,.25, 6,1, 5.5,2, 5,2.5,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.1)`,1,10,7);

      break;
    
    case 74.1://Gargoyle  
    let anifly2 = Date.now();
    
      
    if (anifly2 - lastanitime> 250){
      dragY = (Math.random()*1)*z;
      lastanitime = Date.now();
    }
         

           sx =  0.4*z;
       sy = dragY+1*z
       sz = .36;
    drawShape('pol',x+sx,y+sy,z*sz,10,0, 8,.5 ,2,5 ,0,8,'rgba(0,6,13,1)',1,0,10);
      drawShape('tri',x+sx,y+sy,z*sz,10,0, 10,5 ,5.5,2 ,0,10,'rgba(0,6,13,1)',1,9,9);
    
      drawShape('qua',x,dragY+y,z,5,2.75, 4,2,3.45,1.6 ,4.5,3.5,'rgba(255,255,255,.5)',1,5.1,7);
      drawShape('tri',x,dragY+y,z,3.5,1.75, 3.5,1.55, 1.8,2.6 ,4.5,3.5,'rgba(255,255,255,.5)',1,5.1,7);
      drawShape('tri',x,dragY+y,z,.5,4.55, 1.8,2.5, 2,2.5 ,4.5,4,'rgba(255,255,255,.5)',1,5.1,7);

      drawShape('pol',x+sx,y+sy,z*sz,10,5, 8.5,2 ,4,4.45 ,0,10,'rgba(255,255,255,.5)',1,9,9);
      drawShape('tri',x+sx,y+sy,z*sz,10,5, 10,7 ,9.5,6 ,0,10,'rgba(255,255,255,.5)',1,9,9);
      drawShape('pol',x+sx,y+sy,z*sz,9,9, 10,7 ,9.75,6.25 ,8.75,7.25,'rgba(255,255,255,.5)',1,8.75,8.25);
      drawShape('pol',x+sx,y+sy,z*sz,9,9.1, 4.5,9.6 ,5,8.5 ,6,8.25,'rgba(255,255,255,.5)',1,8,8.5);
      drawShape('pol',x+sx,y+sy,z*sz,0,10, 4.5,9.7 ,4,9 ,3,8.75,'rgba(255,255,255,.5)',1,2,9);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 4.5,5 ,8.5,2 ,5,5,'rgba(255,255,255,.5)',1,2,9);
      drawShape('qua',x+sx,y+sy,z*sz,4.5,9, 5,6 ,8.5,2 ,5.5,6,'rgba(255,255,255,.5)',1,2,9);
      drawShape('qua',x+sx,y+sy,z*sz,9,9, 7.55,6 ,8.5,2 ,8,6,'rgba(255,255,255,.5)',1,2,9);
      drawShape('qua',x+sx,y+sy,z*sz,10,7, 9.5,5 ,8.5,2 ,9.3,5,'rgba(255,255,255,.5)',1,2,9);
      drawShape('tri',x+sx,y+sy,z*sz,0,9.75, 2.25,5 ,0,7 ,6,8.25,'rgba(0,6,13,1)',1,8,8.5);

      sx =  6*z;
       sy = dragY+1*z
       sz = .36;
       drawShape('pol',x+sx,y+sy,z*sz,0,0, 2,.5 ,8,5 ,10,8,'rgba(0,6,13,1)',1,10,10);
      drawShape('tri',x+sx,y+sy,z*sz,0,0, 0,5 ,4.5,2 ,0,10,'rgba(0,6,13,1)',1,9,9);

      drawShape('pol',x+sx,y+sy,z*sz,0,5, 1.5,2 ,6,4.45 ,10,10,'rgba(255,255,255,.5)',1,1,9);
      drawShape('tri',x+sx,y+sy,z*sz,0,5, 0,7 ,0.5,6 ,10,10,'rgba(255,255,255,.5)',1,1,9);
      drawShape('pol',x+sx,y+sy,z*sz,1,9, 0,7 ,0.75,6.25 ,1.25,7.25,'rgba(255,255,255,.5)',1,1.25,8.25);
      drawShape('pol',x+sx,y+sy,z*sz,1,9.1, 5.5,9.6 ,5,8.5 ,4,8.25,'rgba(255,255,255,.5)',1,2,8.5);
      drawShape('pol',x+sx,y+sy,z*sz,10,10, 5.5,9.7 ,6,9 ,7,8.75,'rgba(255,255,255,.5)',1,8,9);
      drawShape('qua',x+sx,y+sy,z*sz,10,10, 5.5,5 ,1.5,2 ,5,5,'rgba(255,255,255,.5)',1,8,9);
      drawShape('qua',x+sx,y+sy,z*sz,5.5,9, 5,6 ,1.5,2 ,4.5,6,'rgba(255,255,255,.5)',1,8,9);
      drawShape('qua',x+sx,y+sy,z*sz,1,9, 2.45,6 ,1.5,2 ,2,6,'rgba(255,255,255,.5)',1,8,9);
      drawShape('qua',x+sx,y+sy,z*sz,0,7, 0.5,5 ,1.5,2 ,0.7,5,'rgba(255,255,255,.5)',1,8,9);
      drawShape('tri',x+sx,y+sy,z*sz,10,9.75, 7.75,5 ,10,7 ,4,8.25,'rgba(0,6,13,1)',1,2,8.5);
            drawShape('qua',x,dragY+y,z,5,2.75, 6,2,6.55,1.7 ,5.5,3.5,'rgba(255,255,255,.5)',1,5.1,7);
      drawShape('tri',x,dragY+y,z,6.5,1.75, 6.5,1.6, 8.2,2.6 ,4.5,3.5,'rgba(255,255,255,.5)',1,5.1,7);
      drawShape('tri',x,dragY+y,z,9.55,4.55, 8.2,2.5, 8,2.5 ,4.5,3.5,'rgba(255,255,255,.5)',1,5.1,7);

            drawShape('pol',x,dragY+y,z,5,1, 4.25,.5 ,4.5,2 ,5,2.5,'rgba(255,255,255,.5)',1,5.5,1);
            drawShape('pol',x,dragY+y,z,5,1, 5.75,.5 ,5.5,2 ,5,2.5,'rgba(255,255,255,.5)',1,4.5,1);
            drawShape('qua',x,dragY+y,z,5,2, 4,2.5 ,4.5,4 ,5,5,'rgba(255,255,255,.5)',1,5.5,1);
            drawShape('qua',x,dragY+y,z,5,2, 6,2.5 ,5.5,4 ,5,5,'rgba(255,255,255,.5)',1,5.5,1);

            drawShape('pol',x,dragY+y,z,4.5,4, 4,5 ,4,6 ,4.5,5.25,'rgba(255,255,255,.5)',1,5,5);
            drawShape('pol',x,dragY+y,z,5.5,4, 6,5 ,6,6 ,5.5,5.25,'rgba(255,255,255,.5)',1,5,5);

            drawShape('pol',x,dragY+y,z,4,2.5, 3.5,3 ,3,4 ,3.5,3.5,'rgba(255,255,255,.5)',1,4.5,3);
            drawShape('pol',x,dragY+y,z,6,2.5, 6.5,3 ,7,4 ,6.5,3.5,'rgba(255,255,255,.5)',1,5.5,3);
            drawShape('qua',x,dragY+y,z,4,5.5, 4,7 ,4.5,6 ,4.5,5.5,'rgba(255,255,255,.5)',1,5.5,3);
            drawShape('qua',x,dragY+y,z,6,5.5, 6,7 ,5.5,6 ,5.5,5.5,'rgba(255,255,255,.5)',1,4.5,3);
            drawShape('tri',x,dragY+y,z,5,1.5, 4.6,1.25 ,4.6,1.45 ,5.5,5.5,'rgba(0,0,0,1)',1,4.5,3);
            drawShape('tri',x,dragY+y,z,5,1.5, 5.4,1.25 ,5.4,1.45 ,5.5,5.5,'rgba(0,0,0,1)',1,4.5,3);

            drawShape('qua',x,dragY+y,z,3.25,3.6, 2.75,3.75 ,3.25,3.75 ,3.5,4,'rgba(255,255,255,.5)',1,4.5,3);
            drawShape('qua',x,dragY+y,z,6.75,3.6, 7.25,3.75 ,6.75,3.75 ,6.5,4,'rgba(255,255,255,.5)',1,4.5,3);

            drawShape('pol',x,dragY+y,z,4.6,1.7, 4.9,2.2 ,5.1,2.2 ,5.4,1.7,'rgba(0,0,0,1)',1,5.4,1.7);
            drawShape('tri',x,dragY+y,z,4.9,2, 5.1,2 ,5,3 ,5,3,'rgba(255,255,255,.5)',1,5.4,1.7);
            drawShape('tri',x,dragY+y,z,4.6,1.7, 4.7,1.7 ,4.6,1.9 ,5,3,'rgba(255,255,255,1)',1,5.4,1.7);
            drawShape('tri',x,dragY+y,z,5.4,1.7, 5.3,1.7 ,5.4,1.9 ,5,3,'rgba(255,255,255,1)',1,5.4,1.7);
            drawShape('pol',x,dragY+y,z,4.9,5, 5.1,5 ,5.1,6 ,5.3,7.5,'rgba(255,255,255,.5)',1,5.1,7);

    break;
    
    case 75.1://Gnome KN  
     
      sx = -3.75*z;
      sy = -1*z;
      sz = 1.75;
      //neck
      drawShape('qua',x+sx,y+sy,z*sz,5,2, 4.5,2.5, 4.5,3, 5,3.5,`rgba(${64},${32},${0},.5)`,1,10,7);
       drawShape('qua',x+sx,y+sy,z*sz,5,2, 5.5,2.5, 5.5,3, 5,3.5,`rgba(${64},${32},${0},.5)`,1,10,7);
      //shoulders
      drawShape('qua',x+sx,y+sy,z*sz,5,2.5, 4,2.5, 3.5,3, 5,3,`rgba(${0},${0},${0},1)`,1,10,7);
      drawShape('qua',x+sx,y+sy,z*sz,5,2.5, 6,2.5, 6.5,3, 5,3,`rgba(${0},${0},${0},1)`,1,10,7);
            drawShape('qua',x+sx,y+sy,z*sz,5,2.5, 4,2.5, 3.5,3, 5,3,`rgba(${64},${32},${0},.5)`,1,10,7);
      drawShape('qua',x+sx,y+sy,z*sz,5,2.5, 6,2.5, 6.5,3, 5,3,`rgba(${64},${32},${0},.5)`,1,10,7);
      //torso
            drawShape('qua',x+sx,y+sy,z*sz,4,3, 5,5, 6,3, 5,2.5,`rgba(${0},${0},${0},1)`,1,10,7);

      drawShape('qua',x+sx,y+sy,z*sz,4,3, 5,5, 6,3, 5,2.5,`rgba(${64},${32},${0},.5)`,1,10,7);
      //legs
    sx = -1.25*z;
      sy = .8*z;
      sz = 1.25;
      //head l
      drawShape('qua',x+sx,y+sy,z*sz,5,.25, 4,1, 4.5,2, 5,2.5,`rgba(${64},${32},${0},1)`,1,10,7);
      //head r
      drawShape('qua',x+sx,y+sy,z*sz,5,.25, 6,1, 5.5,2, 5,2.5,`rgba(${64},${32},${0},1)`,1,10,7);
         
      drawShape('qua',x+sx,y+sy,z*sz,5,.25, 6,1, 5.5,2, 5,2.5,`rgba(${64},${32},${0},1)`,1,10,7);
      
      
      sx = .5*z;
      sy = 3.75*z;
      sz = .4;
			drawShape('rec',x+sx,y+sy,z*sz,1,1,8,5,0,0,0,0,'rgba(64,32,0,1)',1);
			drawShape('tri',x+sx,y+sy,z*sz,1,6,5.1,9,9,6,0,0,'rgba(64,32,0,1)',1);
      drawShape('rec',x+sx,y+sy,z*sz,1,1,8,5,0,0,0,0,`rgba(${0},${Math.random()*255},${0},.1)`,1);
			drawShape('tri',x+sx,y+sy,z*sz,1,6,5.1,9,9,6,0,0,`rgba(${0},${Math.random()*255},${0},.1)`,1);
sy = 1*z;
      drawShape('tri',x,y+sy,z,6,5, 7,7, 5,6, 5,2.5,`rgba(${64},${32},${0},.8)`,1,10,7);
      drawShape('tri',x,y+sy,z,4,5, 3,7, 5,6, 5,2.5,`rgba(${64},${32},${0},.8)`,1,10,7);
      drawShape('qua',x,y+sy,z,4,5.5, 2.5,8, 4,8, 5,6,`rgba(${64},${32},${0},.7)`,1,10,7);
      drawShape('qua',x,y+sy,z,6,5.5, 7.5,8, 6,8, 5,6,`rgba(${64},${32},${0},.7)`,1,10,7);
      drawShape('pol',x,y+sy,z,7.5,3.2, 8,4, 7.5,5, 7.5,4,`rgba(${64},${32},${0},1)`,1,6.5,3);
      drawShape('qua',x,y+sy,z,7,4.5, 7.55,4.75, 7.75,5.3, 7.25,5,`rgba(${64},${32},${0},1)`,1,6.5,3);
      drawShape('tri',x,y+sy,z,7.25,4.75, 7.6,5.1, 5,7.5, 7.25,5,`rgba(${0},${64+Math.random()*100},${0},1)`,1,6.5,3);
      drawShape('qua',x,y+sy,z,4,8, 4,9, 1,9, 3.1,6.9,`rgba(${32},${16},${0},1)`,1,6.5,3);
      drawShape('qua',x,y+sy,z,6,8, 6,9, 9,9, 6.9,6.9,`rgba(${32},${16},${0},1)`,1,6.5,3);


    break;
    case 76.1://Elf Queen      
         
    
       
    //drawShape('qua',x,y,z,0,5, 5,Math.random()*.2, 10,5, 5,10,'rgba(0,255,0,.15)',1,2,10);//lower arm R
    //right calf 
    
       
            drawShape('arc',x,y,z,4.8,4.9,.05,0,6,0,0,0,'rgba(0,128,0,.25)',1);//r-hand

          drawShape('arc',x,y,z,7.5,2,.75,0,6,0,0,0,'rgba(0,128,0,.075)',1);//r-hand
        drawShape('pol',x,y,z,7,4, 5,9, 4,5, 4.5,4,'rgba(0,128,0,.25)',1,5,2.5);

    // aniDice2.setColor(0,1, 0)
     // aniDice2.setGlow(Math.random())
     // aniDice2.animate(x+7.55*z,y+2*z,1*z,.25,globalDt);

        drawShape('qua',x,y,z,4.25,2, 4.5,3, 5,2.5, 4.55,1.5,'rgba(64,32,0,1)',1);
        drawShape('pol',x,y,z,4.45,5.5, 4,7.5, 4.5,7.5, 4.5,7,'rgba(0,128,0,.5)',1,5.25,5.5);
        drawShape('pol',x,y,z,5.6,5, 6,6.5, 6,7, 5.6,7.5,'rgba(0,128,0,.5)',1,5.6,6.5);
        drawShape('tri',x,y,z,5.75,7, 5,5.5, 5.6,5, 5.5,7.5,'rgba(0,128,0,.5)',1,5.6,6.5);
        drawShape('pol',x,y,z,5.5,5, 5.4,4.5, 5.5,3.5, 6.9,4.8,'rgba(0,128,0,.5)',1,5.5,3);

      //legs red boots
      sx = -.5*z; 
      sy = -.1*z;
      sz = 1.1;
      drawShape('qua',x+sx,y+sy,z*sz, 5.5,7, 5.8,8.5, 6,8, 6,6.5,'rgba(0,128,0,.5)',1);
      drawShape('qua',x+sx,y+sy,z*sz, 4,7, 4,8.5, 4.25,8.3, 4.5,7,'rgba(0,128,0,.5)',1);
      drawShape('qua',x+sx,y+sy,z*sz, 4,8.25, 3.6,9, 4,8.8, 4.35,8.23,'rgba(0,128,0,1)',1);
      drawShape('qua',x+sx,y+sy,z*sz, 6,8, 6.3,9, 6,9, 5.7,8.5,'rgba(0,128,0,1)',1);
      //Empress upper
      sz = .8;
      sx = 1*z;
      sy = .0*z;
      //drawShape('qua',x+sx,y+sy,z*sz, 5.25,3, 5.5,3.5, 5,4, 4.5,2.5,'rgba(0,128,0,1)',1);//neck
      drawShape('qua',x+sx,y+sy,z*sz, 4.5,2.5, 5.5,3.5, 5,4, 4.5,2.5,'rgba(255,196,168,.9)',1);//neckL

      drawShape('qua',x+sx,y+sy,z*sz,4,1.8, 3.9,3, 4.25,3.25, 4.25,1.75,'rgba(64,32,0,.75)',1);//bangs left
      drawShape('qua',x+sx,y+sy,z*sz, 5.25,3.5, 4,2.2, 5,1.3, 6,2.5,'rgba(255,196,168,1)',1);//face
      //nose
      sz = .8;
      sx = .8*z;
      sy = .0*z;
      drawShape('tri',x+sx,y+sy,z*sz, 5.45,2.2, 5.4,2.8, 5.6,2.9, 0,0,'rgba(0,0,0,.2)',1);//nose
      //eyes
      sz = .8;
      sx = .8*z;
      sy = .0*z;
      drawShape('tri',x+sx,y+sy,z*sz, 5,2.2, 5.4,2.15, 5.2,2.3, 0,0,'rgba(0,0,0,.3)',1);//eye
      drawShape('tri',x+sx,y+sy,z*sz, 5.5,2.15, 5.9,2.1, 5.7,2.3, 0,0,'rgba(0,0,0,.3)',1);//eye
      //mouth 
      sz = .8;
      sx = .8*z;
      sy = .0*z;
      drawShape('tri',x+sx,y+sy,z*sz, 5.25,3, 5.6,2.95, 5.4,3.075, 0,0,'rgba(64,0,0,.4)',1);//mouth
      //hair
      sz = .8;
      sx = 1*z;
      sy = .0*z;
      drawShape('qua',x+sx,y+sy,z*sz,5,1.3, 4.2,1.75, 4,2.2, 5,1.85,'rgba(64,32,0,1)',1);//hair
      drawShape('qua',x+sx,y+sy,z*sz,5,1.3, 5.8,1.75, 6,2, 5,1.85,'rgba(64,32,0,1)',1);
       
      drawShape('qua',x+sx,y+sy,z*sz,5.55,1.9, 6,2.5, 5.8,3.4, 6,3.5,'rgba(64,32,0,1)',1);
      drawShape('qua',x+sx,y+sy,z*sz,5.55,1.9, 6,2.5, 5.8,3.4, 6,2,'rgba(64,32,0,.75)',1);
      //drawShape('qua',x,y,z,4.25,1.9, 3.8,2.5, 4,3.4, 3.8,3.5,'gold',1);
      drawShape('qua',x+sx,y+sy,z*sz,5,1.8, 4.28,2.07, 4.8,3.4, 4.5,3.5,'rgba(64,32,0,1)',1);
      drawShape('qua',x+sx,y+sy,z*sz,4.28,2.07, 3.85,2.5, 4.05,3.4, 3.85,3.5,'rgba(64,32,0,.75)',1);
      //larm
       sz = .8;
      sx = 1.25*z;
      sy = 1*z;
      drawShape('qua',x+sx,y+sy,z*sz, 3.9,4, 3,6, 3.5,6, 4,5,'rgba(0,128,0,.5)',1);//dress left forearm
        
 drawShape('qua',x+sx,y+sy,z*sz, 3.4,6, 2.5,9, 2.4,8, 3.2,5.9,'green',1);//scepter
      drawShape('qua',x+sx,y+sy,z*sz, 3.4,6, 2.7,8, 2.4,8, 3.2,5.9,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.3)`,1);//scepter

          drawShape('qua',x+sx,y+sy,z*sz, 3,6, 3.5,6, 3.4,6.3, 3,6.5,'rgba(0,128,0,1)',1);//left hand

       sz = .7;
      sx = 1.7*z;
      sy = 3.45*z;
      drawShape('qua',x+sx,y+sy,z*sz, 2.8,4, 2.75,3.4, 3,3.6, 3.4,3.9,'rgba(0,128,0,1)',1);//left hand
         sz = .8;
      sx = 1.36*z;
      sy = .8*z;

     drawShape('qua',x+sx,y+sy,z*sz, 3.4,6.55, 3.2,6.5, 3.25,6.45, 3.2,6.3,'rgba(0,128,0,1)',1);//left thumb
      sz = .8;
      sx = 1.25*z;
      sy = 1*z;
     // drawShape('qua',x+sx,y+sy,z*sz, 4.5,6, 4.5,4.5, 3.9,4, 4,6,'rgba(0,128,0,1)',1);//dress left arm
     // drawShape('qua',x+sx,y+sy,z*sz, 5,6, 5.5,3, 4.5,4.5, 4.5,6,'rgba(0,128,0,1)',1);//dress left mid
      //
       sz = .8;
      sx = 1*z;
      sy = .0*z;
      //drawShape('qua',x+sx,y+sy,z*sz, 5.5,3.5, 6,3.5, 6.5,3.75, 7.5,5,'rgba(0,128,0,1)',1);//dress right shoulder n tricep
      //drawShape('qua',x+sx,y+sy,z*sz, 6.5,5, 6,6, 7,9.5, 3,9.5,'rgba(0,128,0,1)',1);//dress bottom right n forearm
      //drawShape('qua',x+sx,y+sy,z*sz, 7.5,5, 6,6, 7,9.5, 3,9.5,'rgba(0,128,0,1)',1);//dress bottom right n forearm
      drawShape('qua',x+sx,y+sy,z*sz, 5.5,3.5, 5,4, 5,7.5, 7.5,5,'rgba(0,128,0,.5)',1);//dress collarR
      drawShape('qua',x+sx,y+sy,z*sz, 5,4, 4.8,3.4, 4.5,3.5, 4,4,'rgba(0,128,0,.5)',1);//dress collarL
           sz = .8;
      sx = .83*z;
      sy = .0*z;
       drawShape('qua',x+sx,y+sy,z*sz, 4.5,4, 4,4.5, 4.45,5, 5,4.9,'rgba(0,128,0,.25)',1);//bl
        sx = .5*z;
        sy = .0*z;
       drawShape('qua',x+sx,y+sy,z*sz, 5.5,4, 4.8,4.5, 5.25,5, 5.8,4.9,'rgba(0,128,0,.5)',1);//brmain

      //
      sz = .8;
      sx = 2*z;
      sy = .0*z;
      drawShape('qua',x+sx,y+sy,z*sz, 6.1,6, 7,4, 6.5,4, 6,5,'rgba(0,128,0,.5)',1);//dress left forearm
        
      drawShape('qua',x+sx,y+sy,z*sz, 7,4, 6.5,4, 6.6,3.7, 7,3.5,'rgba(0,128,0,1)',1);//left hand

      drawShape('qua',x+sx,y+sy,z*sz, 7,4, 7.4,3.4, 7,3.5, 6.5,3.4,'rgba(0,128,0,1)',1);//left hand
        
      drawShape('tri',x+sx,y+sy,z*sz, 7.4,3.4, 6.5,3.4, 7,3.5, 7.25,1,'rgba(0,128,0,1)',1);//left fingers
      drawShape('qua',x+sx,y+sy,z*sz, 6.6,3.45, 6.75,3.5, 6.75,3.55, 6.6,3.7,'rgba(0,128,0,1)',1);//left thumb

     // drawShape('qua',x+sx,y+sy,z*sz, 5.5,4, 5.5,5.5, 6.1,6, 6,4,'rgba(0,128,0,1)',1);//dress left arm
     // drawShape('qua',x+sx,y+sy,z*sz, 5,4, 4.5,7, 5.5,5.5, 5.5,4,'rgba(0,128,0,1)',1);//dress left mid
     //////
      drawShape('pol',x,y,z, 4.5,3.2, 4.4,4.25, 4.5,6.5, 5,6,'rgba(0,128,0,1)',1,5,3);//brmain
           
      drawShape('pol',x,y,z, 4.25,1.5, 4,1, 4.5,1.75, 4.5,1,'rgba(0,128,0,1)',1,5,1.5);//brmain
      drawShape('pol',x,y,z, 5.75,1.5, 6,1, 5.5,1.75, 5.5,1,'rgba(0,128,0,1)',1,5,1.5);//brmain
      drawShape('pol',x,y,z, 4.25,1.5, 4,1, 4.5,1.75, 4.5,1,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.5)`,1,5,1.5);//brmain
      drawShape('pol',x,y,z, 5.75,1.5, 6,1, 5.5,1.75, 5.5,1,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.5)`,1,5,1.5);//brmain
   
        break;
    
    case 77.1://Giant  
      sx = 1*z;
      sy = 0*z;
      sz = 1;
      drawShape('qua',x+sx,y+sy,z*sz,3,4, 2.5,5, 2,4.5, 2,3,'rgba(255,174,94,.75)',1,6.5,7);//lower arm R
      drawShape('pol',x+sx,y+sy,z*sz,2.5,5, 1.5,4.5, .75,3.5, 1,3,'rgba(255,174,94,.75)',1,2,4);//lower arm R
      drawShape('pol',x+sx,y+sy,z*sz,.25,3.75, 5,1.5, 5.25,.75, 4.75,.25,'rgba(53,32,13,1)',1,.1,3.45);//lower arm R
      drawShape('pol',x+sx,y+sy,z*sz,1,3, 1,2.75, .5,2.9, .9,3,'rgba(255,174,94,.75)',1,1,3.5);//lower arm R
      drawShape('tri',x+sx,y+sy,z*sz,1,2.75, 1.5,3.5, 1,3.5, .9,3,'rgba(255,174,94,.75)',1,1,3.5);//lower arm R
      drawShape('tri',x+sx,y+sy,z*sz,.5,2.9, 1,3, .5,3.5, .9,3,'rgba(255,174,94,.75)',1,1,3.5);//lower arm R
      drawShape('pol',x+sx,y+sy,z*sz,3.5,1.5, 6,2.5, 3.5,4, 2,3,'rgba(255,174,94,.9)',1,2.5,2);//lower arm R
      drawShape('pol',x+sx,y+sy,z*sz,2,3, 3.5,5, 6,4.5, 5.5,2.5,'rgba(255,174,94,.75)',1,3.5,4);//lower arm R
      drawShape('pol',x+sx,y+sy,z*sz,4,4.5, 5,7, 6,8, 6.5,7,'rgba(255,174,94,.75)',1,6,4.5);//lower arm R
      drawShape('pol',x+sx,y+sy,z*sz,5.5,7.5, 5.75,8.5, 7,9.5, 7,8,'rgba(255,174,94,.75)',1,6.5,7);//lower arm R
      drawShape('pol',x+sx,y+sy,z*sz,1,6.5, 1.5,9, 2.,9, 2.5,7.5,'rgba(255,174,94,.75)',1,2,7);//lower arm R
      drawShape('tri',x+sx,y+sy,z*sz,2,7, 5.5,5.8, 4,5.5, 4,6,'rgba(255,174,94,1)',1,5,5);//lower arm R
      drawShape('pol',x+sx,y+sy,z*sz,3.5,5, 1,6.5, 2,7, 4,6,'rgba(255,174,94,1)',1,5,5);//lower arm R
      drawShape('pol',x+sx,y+sy,z*sz,2,9, 2,10, 0,10, 1.5,9.5,'rgba(255,174,94,1)',1,1.5,9);//lower arm R
      drawShape('pol',x+sx,y+sy,z*sz,5.9,8.6, 6.5,9.5, 6.5,10, 8.25,10,'rgba(255,174,94,1)',1,7.25,9.5);//lower arm R
      drawShape('pol',x+sx,y+sy,z*sz,3.5,5, 3.5,6.25, 5.5,6, 6.5,6,'rgba(0,64,0,1)',1,6,4);//lower arm R
      drawShape('pol',x+sx,y+sy,z*sz,6,4, 4,2.5, 2.25,2.5, 2,3,'rgba(0,64,0,1)',1,3.5,5);//lower arm R
      drawShape('qua',x+sx,y+sy,z*sz,2.25,2.5, 3,3, 6,2.5, 3,1,'rgba(0,128,0,.75)',1,3.5,5);//lower arm R
      drawShape('pol',x+sx,y+sy,z*sz,6,2.5, 6.5,4, 5,6, 5.25,4,'rgba(255,174,94,1)',1,4.4,2.8);//lower arm R
      drawShape('pol',x+sx,y+sy,z*sz,2,1, 3,.5, 4,1, 3,2.5,'rgba(255,174,94,1)',1,2.25,1.75);//lower arm R
      drawShape('tri',x+sx,y+sy,z*sz,2.5,1.5, 2.5,1, 2.25,1.5, 3,1,'rgba(0,0,0,.5)',1,3.5,5);//lower arm R
      drawShape('tri',x+sx,y+sy,z*sz,2.5,1.1, 2,1, 2.25,1.25, 3,1,'rgba(0,0,0,.5)',1,3.5,5);//lower arm R
      drawShape('tri',x+sx,y+sy,z*sz,2.5,1.1, 3,1, 2.75,1.25, 3,1,'rgba(0,0,0,.5)',1,3.5,5);//lower arm R
      drawShape('tri',x+sx,y+sy,z*sz,2.5,2, 3,2, 2.75,1.9, 3,1,'rgba(0,0,0,.5)',1,3.5,5);//lower arm R
      sx = 2.75*z;
      sy = 3*z;
      sz = .4;
      drawShape('arc',x+sx,y+sy,z*sz,4.8,5,4.5,0,6,0,0,0,'rgba(40,20,0,1)',1);
      drawShape('arc',x+sx,y+sy,z*sz,5,5,4.5,0,6,0,0,0,'rgba(85,43,0,1)',1);
      drawShape('rec',x+sx,y+sy,z*sz,0.5,5,9,.11,0,0,0,0,'rgba(0,0,0,.35)',1)
      drawShape('rec',x+sx,y+sy,z*sz,.95,3,8.1,.11,0,0,0,0,'rgba(0,0,0,.35)',1)
      drawShape('rec',x+sx,y+sy,z*sz,1,7,8,.11,0,0,0,0,'rgba(0,0,0,.35)',1)
      drawShape('qua',x+sx,y+sy,z*sz,5,4,6,5,5,6,4,5,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,3,1, 7,1.1, 2.8,1.2, 8,2,'rgba(0,0,0,.35)',1);
      drawShape('qua',x+sx,y+sy,z*sz,3-1,1+1, 7-1,1.1+1, 2.8-1,1.2+1, 8-1,2+1,'rgba(0,0,0,.35)',1);
      drawShape('qua',x+sx,y+sy,z*sz,1+3,1+2, 1+7,1.1+2, 1+2.8,1.2+2, 1+8,2+2,'rgba(0,0,0,.35)',1);
      drawShape('qua',x+sx,y+sy,z*sz,1+3,1+5, 1+7,1.1+5, 1+2.8,1.2+5, 1+8,2+5,'rgba(0,0,0,.35)',1);
      drawShape('qua',x+sx,y+sy,z*sz,3,1+6, 7,1.1+6, 2.8,1.2+6, 8,2+6,'rgba(0,0,0,.35)',1);
      drawShape('qua',x+sx,y+sy,z*sz,3-1,1+7, 7-1,1.1+7, 2.8-1,1.2+7, 8-1,2+7,'rgba(0,0,0,.35)',1);
      break;
    case 77.2://Giant  
          drawShape('qua',x,y,z,4,.5, 3,.75, 3,2.5, 3.5,2,'rgba(255,255,0,1)',1,6.4,5.5);//lower arm R

      sx = 1*z;
      sy = 0*z;
      sz = 1;
      drawShape('qua',x+sx,y+sy,z*sz,3,4, 2.5,5, 2,4.5, 2,3,'rgba(255,174,94,.75)',1,6.5,7);//lower arm R
      drawShape('pol',x+sx,y+sy,z*sz,2.5,5, 1.5,4.5, .75,3.5, 1,3,'rgba(255,174,94,.75)',1,2,4);//lower arm R
      drawShape('pol',x+sx,y+sy,z*sz,1,3, 1,2.75, .5,2.9, .9,3,'rgba(255,174,94,.75)',1,1,3.5);//lower arm R
      drawShape('tri',x+sx,y+sy,z*sz,1,2.75, 1.5,3.5, 1,3.5, .9,3,'rgba(255,174,94,.75)',1,1,3.5);//lower arm R
      drawShape('tri',x+sx,y+sy,z*sz,.5,2.9, 1,3, .5,3.5, .9,3,'rgba(255,174,94,.75)',1,1,3.5);//lower arm R
      drawShape('pol',x+sx,y+sy,z*sz,3.5,1.5, 6,2.5, 3.5,4, 2,3,'rgba(255,174,94,.9)',1,2.5,2);//lower arm R
      drawShape('pol',x+sx,y+sy,z*sz,2,3, 3.5,5, 6,4.5, 5.5,2.5,'rgba(255,174,94,.75)',1,3.5,4);//lower arm R
      drawShape('pol',x+sx,y+sy,z*sz,4,4.5, 5,7, 6,8, 6.5,7,'rgba(255,174,94,.75)',1,6,4.5);//lower arm R
      drawShape('pol',x+sx,y+sy,z*sz,5.5,7.5, 5.75,8.5, 7,9.5, 7,8,'rgba(255,174,94,.75)',1,6.5,7);//lower arm R
      drawShape('pol',x+sx,y+sy,z*sz,1,6.5, 1.5,9, 2.,9, 2.5,7.5,'rgba(255,174,94,.75)',1,2,7);//lower arm R
      drawShape('tri',x+sx,y+sy,z*sz,2,7, 5.5,5.8, 4,5.5, 4,6,'rgba(255,174,94,1)',1,5,5);//lower arm R
      drawShape('pol',x+sx,y+sy,z*sz,3.5,5, 1,6.5, 2,7, 4,6,'rgba(255,174,94,1)',1,5,5);//lower arm R
      drawShape('pol',x+sx,y+sy,z*sz,2,9, 2,10, 0,10, 1.5,9.5,'rgba(255,174,94,1)',1,1.5,9);//lower arm R
      drawShape('pol',x+sx,y+sy,z*sz,5.9,8.6, 6.5,9.5, 6.5,10, 8.25,10,'rgba(255,174,94,1)',1,7.25,9.5);//lower arm R
      drawShape('pol',x+sx,y+sy,z*sz,3.5,5, 3.5,6.25, 5.5,6, 6.5,6,'rgba(0,64,0,1)',1,6,4);//lower arm R
      drawShape('pol',x+sx,y+sy,z*sz,6,4, 4,2.5, 2.25,2.5, 2,3,'rgba(0,64,0,1)',1,3.5,5);//lower arm R
      drawShape('qua',x+sx,y+sy,z*sz,2.25,2.5, 3,3, 6,2.5, 3,1,'rgba(0,128,0,.75)',1,3.5,5);//lower arm R
      drawShape('pol',x+sx,y+sy,z*sz,6,2.5, 6.5,4, 5,6, 5.25,4,'rgba(255,174,94,1)',1,4.4,2.8);//lower arm R
      drawShape('pol',x+sx,y+sy,z*sz,2,1, 3,.5, 4,1, 3,2.5,'rgba(255,174,94,1)',1,2.25,1.75);//lower arm R
      drawShape('tri',x+sx,y+sy,z*sz,2.5,1.5, 2.5,1, 2.25,1.5, 3,1,'rgba(0,0,0,.5)',1,3.5,5);//lower arm R
      drawShape('tri',x+sx,y+sy,z*sz,2.5,1.1, 2,1, 2.25,1.25, 3,1,'rgba(0,0,0,.5)',1,3.5,5);//lower arm R
      drawShape('tri',x+sx,y+sy,z*sz,2.5,1.1, 3,1, 2.75,1.25, 3,1,'rgba(0,0,0,.5)',1,3.5,5);//lower arm R
      drawShape('tri',x+sx,y+sy,z*sz,2.5,2, 3,2, 2.75,2.1, 3,1,'rgba(0,0,0,.5)',1,3.5,5);//lower arm R
            
      drawShape('pol',x,y,z,6,6, 5.5,6.25, 5.75,5.75, 6,5.5,'rgba(255,174,94,1)',1,6.4,5.5);//lower arm R
      drawShape('qua',x,y,z,6.5,5.5, 5.75,5.5, 5.25,6, 5.5,6.5,'rgba(255,174,94,.75)',1,6.4,5.5);//lower arm R
      drawShape('qua',x,y,z,4,.5, 4.5,2.5, 5,3, 5,1,'rgba(255,255,0,1)',1,4.5,.5);//lower arm R
      drawShape('qua',x,y,z,4,.5, 4.25,1, 3,1, 3.25,.75,'rgba(190,190,0,1)',1,4.5,.5);//lower arm R

      
      break;
        
    case 80: //Wyrm

      sx = 0*z;
      sy = 4*z;
      sz = .5;
      drawShape('pol',x+sx,y+sy,z*sz,10,4.2, 8.5,2 ,2,5 ,0,8,'rgba(133,255,255,1)',1,0,10);
      drawShape('tri',x+sx,y+sy,z*sz,10,4.2, 10,5 ,5.5,4 ,0,10,'rgba(133,255,255,1)',1,9,9);

      drawShape('pol',x+sx,y+sy,z*sz,10,5, 8.5,2.5 ,4,4.45 ,0,10,'rgba(64,128,128,1)',1,9,9);
      drawShape('tri',x+sx,y+sy,z*sz,10,5, 10,7 ,9.5,6 ,0,10,'rgba(64,128,128,1)',1,9,9);
      drawShape('pol',x+sx,y+sy,z*sz,9,9, 10,7 ,9.75,6.25 ,8.75,7.25,'rgba(0,0,0,1)',1,8.75,8.25);
      drawShape('pol',x+sx,y+sy,z*sz,9,9.1, 4.5,9.6 ,5,8.5 ,6,8.25,'rgba(0,0,0,1)',1,8,8.5);
      drawShape('pol',x+sx,y+sy,z*sz,0,10, 4.5,9.7 ,4,9 ,3,8.75,'rgba(0,0,0,1)',1,2,9);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 4.5,5 ,8.5,2 ,5,5,'rgba(0,0,0,.25)',1,2,9);
      drawShape('qua',x+sx,y+sy,z*sz,4.5,9, 5,6 ,8.5,2 ,5.5,6,'rgba(0,0,0,.25)',1,2,9);
      drawShape('qua',x+sx,y+sy,z*sz,9,9, 7.55,6 ,8.5,2 ,8,6,'rgba(0,0,0,.25)',1,2,9);
      drawShape('qua',x+sx,y+sy,z*sz,10,7, 9.5,5 ,8.5,2 ,9.3,5,'rgba(0,0,0,.25)',1,2,9);
      drawShape('tri',x+sx,y+sy,z*sz,0,9.75, 2.25,5 ,0,7 ,6,8.25,'rgba(0,6,13,1)',1,8,8.5);
      //tail
        //drawShape('pol',x,y,z,3.6,5.8, 3.6,7.5 ,4,7.5 ,4.25,7.25,'rgba(0,32,0,1)',1,3.9,6.9);
        //drawShape('pol',x,y,z,6,7.5, 6,8 ,6.5,9 ,5.5,8.5,'rgba(0,32,0,1)',1,5,7);

      sx = -3*z;
      sy = -6.6*z;
      sz = 2.75;
      for (let i=0;i<60;i++){
        drawShape('ell',x+sx-27.75*z,y+sy-27.4*z,z*sz*3,    4.5+i*.001, 4.5+i*.001,        .2+i*.0025,   0.2+i*.003,  0,    1,   .4,    0,   `rgba(${63+i},${191+i},${191+i},1)`,0)
        drawShape('ell',x+sx-27.75*z,y+sy-27.37*z,z*sz*3,    4.5+i*.001, 4.5+i*.001,        .2+i*.0025,   0.2+i*.003,  0,    1,   .4,    0,   `rgba(${63+i},${191+i},${191+i},1)`,0)

        drawShape('ell',x+sx-28.75*z,y+sy-26.5*z,z*sz*3,    4.5+i*.001, 4.5+i*.001,        .2+i*.0025,   0.2+i*.003,  0,    .1,   .8,    0,   `rgba(${63+i},${191+i},${191+i},1)`,0)
        drawShape('ell',x+sx-28.75*z,y+sy-26.51*z,z*sz*3,    4.5+i*.001, 4.5+i*.001,        .2+i*.0025,   0.2+i*.003,  0,    .1,   .8,    0,   `rgba(${63+i},${191+i},${191+i},1)`,0)

        
      }
 //neck
      sx = -13*z;
          sy = -13.3*z;
          sz = 3.5;
          for (let i=0;i<60;i++){
          drawShape('ell',x+sx-30.75*z,y+sy-25.5*z,z*sz*3,    4.5+i*.001, 4.5+i*.001,        .2+i*.0025,   0.2+i*.003,  0,    1.2,   -.49,    0,   `rgba(${63+i},${191+i},${191+i},1)`,0)

          }
    sx =6*z;
    sy = 4*z;
    sz = .4;
    drawShape('pol',x+sx,y+sy,z*sz,0,4, 2,1 ,8,5 ,10,8,'rgba(133,255,255,.75)',1,10,10);
      drawShape('tri',x+sx,y+sy,z*sz,0,4, 0,5 ,4.5,2 ,10,10,'rgba(133,255,255,.75)',1,1,9);

      drawShape('pol',x+sx,y+sy,z*sz,0,5, 1.5,2 ,6,4.45 ,10,10,'rgba(133,255,255,.75)',1,1,9);
      drawShape('tri',x+sx,y+sy,z*sz,0,5, 0,7 ,0.5,6 ,10,10,'rgba(133,255,255,.75)',1,1,9);
      drawShape('pol',x+sx,y+sy,z*sz,1,9, 0,7 ,0.25,6.25 ,1.25,7.25,'rgba(133,255,255,.75)',1,1.25,8.25);
      drawShape('pol',x+sx,y+sy,z*sz,1,9.1, 5.5,9.6 ,5,8.5 ,4,8.25,'rgba(133,255,255,.75)',1,2,8.5);
      drawShape('pol',x+sx,y+sy,z*sz,10,10, 5.5,9.7 ,6,9 ,7,8.75,'rgba(133,255,255,.75)',1,8,9);
      drawShape('qua',x+sx,y+sy,z*sz,10,10, 5.5,5 ,1.5,2 ,5,5,'rgba(133,255,255,.75)',1,8,9);
      drawShape('qua',x+sx,y+sy,z*sz,5.5,9, 5,6 ,1.5,2 ,4.5,6,'rgba(133,255,255,.75)',1,8,9);
      drawShape('qua',x+sx,y+sy,z*sz,1,9, 2.45,6 ,1.5,2 ,2,6,'rgba(133,255,255,.75)',1,8,9);
      drawShape('qua',x+sx,y+sy,z*sz,0,7, 0.5,5 ,1.5,2 ,0.7,5,'rgba(133,255,255,.75)',1,8,9);
      drawShape('tri',x+sx,y+sy,z*sz,10,9.75, 7.75,5 ,10,7 ,4,8.25,'rgba(133,255,255,.75)',1,2,8.5);
      sx = -7.5*z;
      sy = -3.6*z;
      sz = 2;
      for (let i=0;i<60;i++){
        ////////////////////////////
        //floating island top
        // drawShape('ell',x+sx,y+sy,z*sz,    4.5+i*.001, 4.5+i*.001,        .5-i*.005,   0+i*.005,  0,    1,   2,    0,   `rgba(${255},${69-i},${11},1)`,0)
        //floating island botn     
        // drawShape('ell',x+sx,y+sy,z*sz,    4.51+i*.001, 4.4+i*.001,        .49-i*.005,   0+i*.01,  0,    2,   1,    0,   `rgba(${255},${69+i},${11},1)`,0)
        //eclipse
        //drawShape('ell',x+sx,y+sy,z*sz,    4.5+i*.001, 4.75+i*.001,        .2+i*.0025,   0.2+i*.0025,  0,    0,   2,    0,   `rgba(${244},${69+i},${11},1)`,0)
        ///////////////
        //teeth
        drawShape('ell',x+sx,y+sy,z*sz,    4.35+i*.002, 5.63+i*.001,        0+i*.0005,   0+i*.002,  0,    .75,   1.3,    0,   `rgba(${255},${255},${255},1)`,0)
        drawShape('ell',x+sx,y+sy,z*sz,    4.63+i*.001, 5.640+i*.001,        0+i*.0005,   0+i*.002,  0,    1.5,   .2,    0,   `rgba(${255},${255},${255},1)`,0)
        //head
        //body
        drawShape('ell',x+sx,y+sy,z*sz,    4.5+i*.001, 5.25+i*.001,        0.2+i*.005,   0+i*.005,  0,    0,   2,    0,   `rgba(${63+i},${191+i},${191+i},1)`,0)
        //upper jaw
        drawShape('ell',x+sx,y+sy,z*sz,    4.5+i*.001, 5.5+i*.001,        .5-i*.005,   0+i*.005,  0,    1,   2,    0,   `rgba(${63+i},${191+i},${191+i},1)`,0)
        //bottom jaw     
        drawShape('ell',x+sx,y+sy,z*sz,    4.51+i*.001, 5.4+i*.001,        .49-i*.005,   0+i*.01,  0,    2,   1,    0,   `rgba(${63+i},${191+i},${191+i},1)`,0)
        //tail
      }
      sx = -7.5*z;
      sy = -3.6*z;
      sz = 2;
      drawShape('pol',x+sx,y+sy,z*sz,    4.55, 5.6,   4.5, 6.3,   4.4,6.4,   4.55,6.3,   `rgba(${64},${128},${128},1)`,1, 4.6,6.5)
      drawShape('ell',x+sx,y+sy,z*sz,    4.8, 5.25,   .2, .15,   0,   1.6,  .5,   0,   `rgba(${64},${128},${128},1)`,1, 4.6,6.5)
      drawShape('ell',x+sx,y+sy,z*sz,    4.3, 5.25,   .2, .15,   0,   .5,  1.4,   0,   `rgba(${64},${128},${128},1)`,1, 4.6,6.5)
      drawShape('ell',x+sx,y+sy,z*sz,    4.86, 5.26,   .05, .12,   0,   -.45,  .25,   0,   `rgba(${0},${0},${0},1)`,1, 4.6,6.5)
      drawShape('ell',x+sx,y+sy,z*sz,    4.21, 5.26,   .05, .12,   0,   .75,  -.5,   0,   `rgba(${0},${0},${0},1)`,1, 4.6,6.5)
   
       //drawShape('qua',x,y,z,6,4, 4,5 ,4.5,5.5 ,6,6,'rgba(133,255,255,1)',1,0,10);
      // drawShape('pol',x,y,z,4,5, 5,6 ,5.5,7 ,4.5,7.5,'rgba(0,32,0,1)',1,5,6.5);
        //drawShape('tri',x,y,z,4,5, 4.5,6 ,5,6.5 ,4.75,8,'rgba(0,32,0,1)',1,5,7);
        
        
       // drawShape('pol',x,y,z,7,7.5, 7,8 ,7.5,9 ,6.5,8.5,'rgba(0,32,0,1)',1,6,7);
        //drawShape('qua',x,y,z,7.5,8.5, 6.5,9 ,7,9 ,7,9.5,'rgba(0,32,0,1)',1,6,7);
        //drawShape('qua',x,y,z,6.5,8.5, 5.5,9 ,6,9 ,6,9.5,'rgba(0,32,0,1)',1,6,7);
       // drawShape('qua',x,y,z,4.9,7, 4.5,7 ,4.75,7.25 ,5,7.5,'rgba(0,32,0,1)',1,6,7);
        //drawShape('pol',x,y,z,4,7,3.9,6.5 ,4.1,6.9 ,4.3,7,'rgba(0,32,0,1)',1,4,7.5);
        drawShape('pol',x,y,z,1,6.6, 1.5,6.5 ,1,6 ,.5,6,'rgba(64,128,128,1)',1,1.1,6.25);
        sx= -6.75*z
        drawShape('pol',x+sx,y,z,9,6.6, 8.5,6.5 ,9,6 ,9.5,6,'rgba(64,128,128,1)',1,8.9,6.25);



      break;
    case 81://Gnome KN  
     
      sx = -3.75*z;
      sy = -2*z;
      sz = 1.75;
      //neck
      drawShape('qua',x+sx,y+sy,z*sz,5,2, 4.5,2.5, 4.5,3, 5,3.5,`rgba(${0},${63},${190},1)`,1,10,7);
       drawShape('qua',x+sx,y+sy,z*sz,5,2, 5.5,2.5, 5.5,3, 5,3.5,`rgba(${0},${63},${190},1)`,1,10,7);
      //shoulders
      drawShape('qua',x+sx,y+sy,z*sz,5,2.5, 4,2.5, 3.5,3, 5,3,`rgba(${0},${0},${0},1)`,1,10,7);
      drawShape('qua',x+sx,y+sy,z*sz,5,2.5, 6,2.5, 6.5,3, 5,3,`rgba(${0},${0},${0},1)`,1,10,7);
            drawShape('qua',x+sx,y+sy,z*sz,5,2.5, 4,2.5, 3.5,3, 5,3,`rgba(${0},${63},${190},1)`,1,10,7);
      drawShape('qua',x+sx,y+sy,z*sz,5,2.5, 6,2.5, 6.5,3, 5,3,`rgba(${0},${63},${190},1)`,1,10,7);
      //torso
            drawShape('qua',x+sx,y+sy,z*sz,4,3, 5,5, 6,3, 5,2.5,`rgba(${0},${0},${0},1)`,1,10,7);

      drawShape('qua',x+sx,y+sy,z*sz,4,3, 5,5, 6,3, 5,2.5,`rgba(${0},${63},${190},1)`,1,10,7);
      //legs
    sx = -1.25*z;
      sy = -.2*z;
      sz = 1.25;
      //head l
      drawShape('qua',x+sx,y+sy,z*sz,5,.25, 4,1, 4.5,2, 5,2.5,`rgba(${0},${40},${160},1)`,1,10,7);
      //head r
      drawShape('qua',x+sx,y+sy,z*sz,5,.25, 6,1, 5.5,2, 5,2.5,`rgba(${0},${40},${160},1)`,1,10,7);
         
      drawShape('qua',x+sx,y+sy,z*sz,5,.25, 6,1, 5.5,2, 5,2.5,`rgba(${0},${40},${160},1)`,1,10,7);
      
      
      sx = .5*z;
      sy = 2.75*z;
      sz = .4;
			drawShape('rec',x+sx,y+sy,z*sz,1,1,8,5,0,0,0,0,'rgba(0,50,128,1)',1);
			drawShape('tri',x+sx,y+sy,z*sz,1,6,5.1,9,9,6,0,0,'rgba(0,50,128,1)',1);
      
      drawShape('tri',x,y,z,6,5, 7,7, 5,6, 5,2.5,`rgba(${0},${40},${160},.8)`,1,10,7);
      drawShape('tri',x,y,z,4,5, 3,7, 5,6, 5,2.5,`rgba(${0},${40},${160},.8)`,1,10,7);
      drawShape('qua',x,y,z,4,5.5, 2.5,8, 4,8, 5,6,`rgba(${0},${40},${160},.7)`,1,10,7);
      drawShape('qua',x,y,z,6,5.5, 7.5,8, 6,8, 5,6,`rgba(${0},${40},${160},.7)`,1,10,7);
      drawShape('pol',x,y,z,7.5,3.2, 8,4, 7.5,5, 7.5,4,`rgba(${0},${40},${160},1)`,1,6.5,3);
      drawShape('qua',x,y,z,7,4.5, 7.55,4.75, 7.75,5.3, 7.25,5,`rgba(${0},${40},${160},1)`,1,6.5,3);
      drawShape('tri',x,y,z,7.25,4.75, 7.6,5.1, 5,7.5, 7.25,5,`rgba(${0},${255},${255},.5)`,1,6.5,3);
      drawShape('qua',x,y,z,4,8, 4,9, 1,9, 3.1,6.9,`rgba(${0},${63},${190}1)`,1,6.5,3);
      drawShape('qua',x,y,z,6,8, 6,9, 9,9, 6.9,6.9,`rgba(${0},${63},${190}1)`,1,6.5,3);


    break;
    
    case 82://SKELETON
    
    
    let aniwalk = Date.now();
    if (portraitani == 1){

    if (aniwalk - lastanitime> 250){portraitani = 0;lastanitime = Date.now();}
     
    }
    if (portraitani == 0){

    if (aniwalk - lastanitime> 250){portraitani = 1;lastanitime = Date.now();}
     
    }
   
			//ribs+spine
			drawShape('ell',x,y,z,5,5,1,1,0,0.1,.9,0,'lightgray',1);//rib5
			drawShape('ell',x,y,z,5,5,.75,.7,0,0.1,.9,0,'black',1);//rib5-shadow
			drawShape('ell',x,y,z,5,4.5,1.5,1,0,0.1,.9,0,'lightgray',1);//rib4
			drawShape('ell',x,y,z,5,4.5,1,.7,0,0.1,.9,0,'black',1);//rib4-shadow
			drawShape('ell',x,y,z,5,4,1.5,1,0,0.1,.9,0,'lightgray',1);//rib3
			drawShape('ell',x,y,z,5,4,1,.7,0,0.1,.9,0,'black',1);//rib3-shadow
			drawShape('ell',x,y,z,5,3.5,1.5,1,0,0.1,.9,0,'lightgray',1);//rib2
			drawShape('ell',x,y,z,5,3.5,1,.7,0,0.1,.9,0,'black',1);//rib2-shadow
			drawShape('ell',x,y,z,5,3,1.5,1,0,0.1,.9,0,'lightgray',1);//rib1
			drawShape('ell',x,y,z,5,3,1,.7,0,0.1,.9,0,'black',1);//rib1-shadow
			drawShape('lin',x,y,z,5,3.5,5,6,0,0,0,0,'gray',0);//spine
			//head
			drawShape('arc',x,y,z,5,1.5,1.5,0,6,0,0,0,'lightgray',1);//head
			drawShape('arc',x,y,z,5.5,1.5,.5,0,6,0,0,0,'black',1);//r-eye
			drawShape('arc',x,y,z,4.5,1.5,.5,0,6,0,0,0,'black',1);//l-eye
			drawShape('lin',x,y,z,5.1,1.3,3.9,.75,0,0,0,0,'black',0);//l-eyebrow
			drawShape('lin',x,y,z,4.9,1.3,6.1,.75,0,0,0,0,'black',0);//l-eyebrow
			drawShape('tri',x,y,z,5,2,4.5,2.5,5.5,2.5,0,0,'black',1);//nose
			drawShape('lin',x,y,z,5,2,5,2.4,0,0,0,0,'lightgray',0);//nostrils
			drawShape('ell',x,y,z,5,3,1,.5,0,0,6,0,'lightgray',1);//jaw
			drawShape('lin',x,y,z,4,3,6,3,0,0,0,0,'black',0);//mouth
			//arms
			drawShape('arc',x,y,z,3.5,3.5,.5,0,6,0,0,0,'lightgray',1);//l-shoulder
			drawShape('arc',x,y,z,6.5,3.5,.5,0,6,0,0,0,'lightgray',1);//r-shoulder
			drawShape('arc',x,y,z,3.5,3.5,.5,0,6,0,0,0,'black',0);//l-shoulder-shadow
			drawShape('arc',x,y,z,6.5,3.5,.5,0,6,0,0,0,'black',0);//r-shoulder-shadow
			drawShape('tri',x,y,z,3,3.5,3.5,4,2,5,0,0,'lightgray',1);//l-arm
			drawShape('tri',x,y,z,7,3.5,6.5,4,8,5,0,0,'lightgray',1);//r-arm
			drawShape('tri',x,y,z,2,5,1.5,6.5,2.4,4.9,0,0,'lightgray',1);//l-forearm
			drawShape('tri',x,y,z,7.8,4.8,8.5,6.3,7.5,4.8,0,0,'lightgray',1);//r-forearm
			drawShape('arc',x,y,z,1.7,6.3,.35,0,6,0,0,0,'lightgray',1);//l-hand
			drawShape('arc',x,y,z,8.1,6.1,.35,0,6,0,0,0,'lightgray',1);//r-hand
			//lower body
			drawShape('ell',x,y,z,5,6.5,1,.5,0,0,6,0,'lightgray',1);//hip
			drawShape('arc',x,y,z,5.75,6.5,.5,0,6,0,0,0,'gray',1);//hip
			drawShape('arc',x,y,z,4.25,6.5,.5,0,6,0,0,0,'gray',1);//hip
if(portraitani == 1){
			drawShape('tri',x,y,z,6.15,6.4, 5.4,6.75, 8,8, 0,0,'lightgray',1);//r-leg
			drawShape('tri',x,y,z,3.85,6.4, 4.6,6.75, 2,8, 0,0,'lightgray',1);//l-leg
			drawShape('tri',x,y,z,2,8, 2.5,7.5, 4,10, 0,0,'lightgray',1);//l-shin
			drawShape('tri',x,y,z,8,8, 7.5,7.5, 6,9, 0,0,'lightgray',1);//r-shin
			drawShape('tri',x,y,z,4,10, 1.75,10, 3.5,9.3, 0,0,'lightgray',1);//l-foot
			drawShape('tri',x,y,z,6.8,8.3, 8,10, 6,9, 0,0,'lightgray',1);//r-foot
}else{
      drawShape('tri',x,y,z,3.85,6.4, 4.6,6.75, 2,8, 0,0,'lightgray',1);//r-leg
			drawShape('tri',x,y,z,6.15,6.4, 5.4,6.75, 8,8, 0,0,'lightgray',1);//l-leg
			drawShape('tri',x,y,z,8,8, 7.5,7.5, 6,10, 0,0,'lightgray',1);//l-shin
			drawShape('tri',x,y,z,2,8, 2.5,7.5, 4,9, 0,0,'lightgray',1);//r-shin
			drawShape('tri',x,y,z,6,10, 8.25,10, 6.5,9.3, 0,0,'lightgray',1);//l-foot
			drawShape('tri',x,y,z,3.2,8.3, 2,10, 4,9, 0,0,'lightgray',1);//r-foot
}
      drawShape('tri',x,y,z,5.75,3, 4.25,3, 5,2.9,0,0,'black',1);//nose

      break;
    case 83://Tentacle

      for (let i=0;i<60;i++){
       drawShape('ell',x,y,z,    5+i*.001, 8.45+i*.001,     0+i*.02,   5-i*.01,     0,    .9,   2.1,    0,   `rgba(${0},${128+i},${255},1)`,0)
      }

      drawShape('ell',x,y,z,    5.06, 11.28,     .5,   6,     0,    1.07,   1.93,    0,   `rgba(${255},${255},${255},.4)`,1)

    break;
    case -15.2: //Excalibur
      drawShape('qua',x,y,z,0,5, 5,Math.random()*.2, 10,5, 5,10,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.15)`,1,2,10);//lower arm R
			drawShape('tri',x,y,z,0,8.6, 1.4,10, 0,10 ,0,0,'rgb(252,165,3)',1);
			drawShape('qua',x,y,z,0,9, 2,7, 3,8, 1,10,'rgb(252,165,3)',1);
			drawShape('qua',x,y,z,0,5, 1,5 ,5,9 ,5,10,'rgb(252,165,3)',1);
			drawShape('qua',x,y,z,2,6, 8,1, 8,2, 4,6,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},1)`,1);//
			drawShape('qua',x,y,z,4,8, 9,2, 8,2 ,4,6,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},1)`,1);
			drawShape('tri',x,y,z,2,6, 4,6, 4,8, 0,0,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},1)`,1);
			drawShape('qua',x,y,z,8,1, 8,2, 9,2, 10,0,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},1)`,1);
			drawShape('qua',x,y,z,0,5, 1,5, 5,9 ,5,10,'rgb(252,165,3)',0);
			drawShape('arc',x,y,z,3,7, .5,0, 6,0 ,0,0,'red',1);//pommel gem
			drawShape('arc',x,y,z,3,7 ,.5,0, 6,0, 0,0,'brown',0);
			break;
      
    
    case 0://Fool monster 
      drawShape('qua',x,y,z, 6.5,8.5, .75,9.5, 6,4, 6.5,7.5,'cyan',1);//Cape Back
      drawShape('qua',x,y,z, 6.5,8.5, .75,9.5, 6,4, 6.5,7.5,'rgba(0,0,0,.8)',1);//Cape Back
      drawShape('qua',x,y,z, 2.75,7.5, 1.5,9.5, 1,9.5, 3.5,5.5,'rgb(185,122,87)',1);//left calf
      drawShape('qua',x,y,z, 5,5, 4,6, 5.5,8, 6.5,8,'gold',1);//right thigh
      //drawShape('qua',x,y,z,3.5,3.5,4.5,3,5,3,6,3.6,'darkblue',1);//head
      drawShape('qua',x,y,z,3.5,3.5,4.5,3,5,3,6,3.6,'white',1);//neck
      drawShape('qua',x,y,z,3.5,3.5,4.5,3,5,3,6,3.6,'white',1);//neck
      drawShape('qua',x,y,z, 3,3.4, 7,3.6, 1.2,9.3, .75,9.5,'cyan',1);//Cape Front
      drawShape('qua',x,y,z, 3,3.4, 7,3.6, 1.2,9.3, .75,9.5,'rgba(0,0,0,.7)',1);//body/left leg/cape?
      drawShape('qua',x,y,z, 7,3.6, 6.25,4, 7.5,6, 7.6,5.5,'white',1);//upper arm R
      //drawShape('qua',x,y,z, 7,3.6, 6.25,4, 7.5,6, 7.6,5.5,'rgba(0,0,0,.7)',1);//upper arm R
      //bag
      drawShape('arc',x,y,z,2.8,2,.8,0,6,0,0,0,'darkred',1);//bag
      drawShape('arc',x,y,z,2.8,1.95,.75,0,6,0,0,0,'rgba(255,255,255,.15)',1);//bag
      //sun
      drawShape('arc',x,y,z,9,1,.8,0,6,0,0,0,'gold',1);//bag
      drawShape('arc',x,y,z,8.95,.95,.75,0,6,0,0,0,'rgba(255,255,255,.15)',1);//bag
      drawShape('arc',x,y,z,8.9,1,.7,0,6,0,0,0,'rgba(255,255,255,.15)',1);//bag
      drawShape('arc',x,y,z,8.85,1,.65,0,6,0,0,0,'rgba(255,255,255,.15)',1);//bag
      drawShape('arc',x,y,z,8.8,1,.6,0,6,0,0,0,'rgba(255,255,255,.15)',1);//bag
      drawShape('qua',x,y,z, 9.1,5.7, 9.5,6, 9.25,6.25, 8.8,6,'rgb(185,122,87)',1);//rHand1
      drawShape('qua',x,y,z, 7.5,5.5, 7.5,6, 9,6, 9.1,5.7,'rgb(185,122,87)',1);//Forearm R
      drawShape('qua',x,y,z, 9.5,6.5, 2.5,1, 2.5,0.9, 9.5,6.4,'brown',1);////stick
      drawShape('qua',x,y,z, 9.5,6.5, 2.5,1, 2.5,0.9, 9.5,6.4,'rgba(0,0,0,.45)',1);////stick
      drawShape('qua',x,y,z, 9.1,5.7, 9.5,6, 9.25,6.25, 8.8,6,'rgb(185,122,87)',1);//rHand2
      drawShape('tri',x,y,z,2.75,1.25, 2.65,1, 3,1.25,0,0,'darkred',1);//knot
      drawShape('tri',x,y,z,2.75,1.25, 2.75,.8, 2.9,1.25,0,0,'darkred',1);//knot

      drawShape('qua',x,y,z,5,.9,3.5,1,4.5,3.5,7,2,'rgb(185,122,87)',1);//Head
      drawShape('tri',x,y,z,4.39,3.2, 5.2,3.1, 4.5,3.5,0,0,'rgba(0,0,0,.45)',1);//neck shadow

      drawShape('tri',x,y,z,4.75,2, 4.25,2.5, 4.5,2.5, 0,0,'rgba(0,0,0,.45)',1);//Nose
      drawShape('tri',x,y,z,4.25,2.75, 4.75,2.95, 4.8,2.87, 0,0,'rgba(255,0,0,.25)',1);//mouth
      drawShape('tri',x,y,z,5,2, 5.5,2.2, 5.45,2.12, 0,0,'rgba(0,0,0,.45)',1);//eye
      drawShape('tri',x,y,z,4,1.7, 4.5,1.9, 4.45,1.82, 0,0,'rgba(0,0,0,.45)',1);//eye
      drawShape('tri',x,y,z,3.5,1, 3.6,2, 5,1.4,0,0,'gold',1);//head
      drawShape('tri',x,y,z,5,1.4, 6.1,2.5, 7,2,0,0,'gold',1);//head
      drawShape('tri',x,y,z,3.5,1, 7,2, 5,.9,0,0,'cyan',1);//hat
      drawShape('tri',x,y,z,3.5,1, 7,2, 5,.9,0,0,'rgba(0,0,0,.7)',1);//hat
      drawShape('qua',x,y,z*1.4, 4.5,1.25, 5.5,.75, 5,1.25, 4.6,1.17,'darkred',1);//feather

      drawShape('qua',x,y,z, 6.5,8, 5,9.5, 4.5,9.5, 5.5,8,'rgb(185,122,87)',1);//right calf


      drawShape('qua',x,y,z, 3,3.42, 2.8,4.8, 1.75,6, 1.5,5.5,'white',1);//upper arm L

      drawShape('qua',x,y,z, 1.5,5.5, 1.4,7.1, 1.7,6.9, 2,5.5,'rgb(185,122,87)',1);//Forearm L
      drawShape('qua',x,y,z, 1.4,7.1, 1.4,7.5, 2,7, 1.7,6.8,'rgb(185,122,87)',1);//handL
      drawShape('qua',x,y,z, 1.4,7.5, 2,7.5, 2,7, 1.7,6.8,'rgb(185,122,87)',1);//handL
      drawShape('qua',x,y,z,4.5,9.5, 4.25,9.9, 7,9.9, 5,9.5,'gold',1);//rFoot
      drawShape('qua',x,y,z,1,9.5, .75,9.9, 3,9.9,1.5,9.5,'gold',1);//lfoot

      break;
    case 1://Magician monster
      sx =-.6391*z;
      sy = -.30691*z;
      sz = 1.13;
      drawShape('qua',x+sx,y+sy,z*sz,  5.2,8.4,   5.1,8.8,    6.25,9,   5.75, 8.75,'white',1);//right foot
      drawShape('qua',x+sx,y+sy,z*sz,  4.8,8.4,   4.9,8.8,    3.75,9,   4.25, 8.75,'white',1);//left foot
      drawShape('qua',x+sx,y+sy,z*sz,  6,5.51,   6.1,8.5,    3.9,8.5,   4, 5.51,'white',1);//robe botto,
      let scaly = 0;
      let scalx = 1.26;
      let scalxt = 3.339;
      let scalxs = scalx;

      let scalz = .8;
      let scalzt = .6;
      let scalzs = scalz;
      let zratio = scalzt/scalzs;
      let xratio = (scalxt-scalxs)*zratio
      let scaly2 = 0;
      let scalx2 = 1.069*xratio
      let scalz2 = 1 * zratio;
      scalz = scalzt;
      scalx = scalxt;
      sx =-.6391*z;
      sy = -.30691*z;
      sz = 1.13;
      drawShape('qua',x+sx,y+sy,z*scalz*sz, 4.5+scalx,3.5+scaly, 4.5+scalx,4+scaly, 4.25+scalx,4+scaly,5+scalx,4.5+scaly,'rgb(185,122,87)',1);//neck left
      drawShape('qua',x+sx,y+sy,z*scalz*sz, 5.5+scalx,3.5+scaly, 5.5+scalx,4+scaly, 5.75+scalx,4+scaly,5+scalx,4.5+scaly,'rgb(185,122,87)',1);//neck right
      drawShape('qua',x+sx,y+sy,z*scalz*sz, 4.35+scalx,3.2+scaly, 5+scalx,3.9+scaly, 5.65+scalx,3.2+scaly, 5+scalx,4.52+scaly,'rgb(185,122,87)',1);//neck middle
      drawShape('qua',x+sx,y+sy,z*scalz*sz, 4.35+scalx,3.2+scaly, 5+scalx,3.9+scaly, 5.65+scalx,3.2+scaly, 5.02+scalx,4.52+scaly,'rgba(0,0,0,.2)',1);//neck middle
      drawShape('qua',x+sx,y+sy,z*scalz*sz, 5.02+scalx,2+scaly, 4.1+scalx,2.5+scaly, 4.25+scalx,3.25+scaly,5.02+scalx,3.9+scaly,'rgb(185,122,87)',1);//face left
      drawShape('qua',x+sx,y+sy,z*scalz*sz, 5.02+scalx,2+scaly, 5.9+scalx,2.5+scaly, 5.75+scalx,3.25+scaly,5+scalx,3.9+scaly,'rgb(185,122,87)',1);//face right

      drawShape('rec',x+sx,y+sy,z*scalz*sz, 4+scalx,2+scaly,2,.25,0,0,0,0,'white',1);//headband
      drawShape('qua',x+sx,y+sy,z*scalz*sz, 5+scalx,1.63+scaly, 4.3+scalx,1.75+scaly, 4+scalx,2+scaly,5+scalx,2+scaly,'rgb(0,0,0)',1);//top head
      drawShape('qua',x+sx,y+sy,z*scalz*sz, 5+scalx,1.63+scaly, 5.7+scalx,1.75+scaly, 6+scalx,2+scaly,5+scalx,2+scaly,'rgb(0,0,0)',1);//top head
      //DONOTDELETEdrawShape('qua',x,y,z,4,2.25, 3.9,3.5, 4.25,3,4.25,4.25,'rgb(119,43,79)',1);//lightning bolt

      drawShape('qua',x+sx,y+sy,z*scalz*sz, 4+scalx,2.25+scaly, 5+scalx,2.25+scaly, 4.25+scalx,2.5+scaly,4.25+scalx,4+scaly,'rgb(0,0,0)',1);//bangs left
      drawShape('qua',x+sx,y+sy,z*scalz*sz, 6+scalx,2.25+scaly, 5+scalx,2.25+scaly, 5.75+scalx,2.5+scaly,5.75+scalx,4+scaly,'rgb(0,0,0)',1);//bangs left

      drawShape('qua',x+sx,y+sy,z*scalz2*sz, 5.6+scalx2,3.2+scaly2,    5+scalx2,   3.6+scaly2,    6+scalx2,    6+scaly2, 5.75+scalx2, 3.2+scaly2,'white',1);//shirt right
      drawShape('qua',x+sx,y+sy,z*scalz2*sz,   5+scalx2, 3.6+scaly2,  4.5+scalx2,  3.25+scaly2, 4.25+scalx2,    6+scaly2,    6+scalx2,   6+scaly2,'white',1);//shirt left
      drawShape('qua',x+sx,y+sy,z*scalz2*sz, 5.6+scalx2,3.2+scaly2, 5.75+scalx2, 3.19+scaly2,    6+scalx2,  3.2+scaly2,  6.5+scalx2, 3.5+scaly2,'darkred',1);//right shoulder
      drawShape('rec',x+sx,y+sy,z*sz,4,4.65,2,.3,0,0,0,0,'rgba(0,0,0,.75)',0);

      drawShape('rec',x,y,z, 4,4.75, 2,.125, 0,0,0,0,'rgba(255,255,255,.75)',1);//belt/midsection
      drawShape('rec',x,y,z, 4,4.75, 2,.2499, 0,0,0,0,'rgba(255,255,255,.75)',1);//belt/midsection
      drawShape('rec',x,y,z, 4,4.875, 2,.2499, 0,0,0,0,'rgba(255,255,255,.75)',1);//belt/midsection
      drawShape('rec',x,y,z, 4,5, 2,.2499, 0,0,0,0,'rgba(255,255,255,.75)',1);//belt/midsection
      drawShape('rec',x,y,z, 4,5.125, 2,.2499, 0,0,0,0,'rgba(255,255,255,.75)',1);//belt/midsection
      drawShape('rec',x,y,z, 4,5.25, 2,.2499, 0,0,0,0,'rgba(255,255,255,.75)',1);//belt/midsection
      drawShape('rec',x,y,z, 4,5.375, 2,.2499, 0,0,0,0,'rgba(255,255,255,.75)',1);//belt/midsection
      drawShape('rec',x,y,z, 4,5.5, 2,.2499, 0,0,0,0,'rgba(255,255,255,.75)',1);//belt/midsection
      drawShape('rec',x,y,z, 4,5.625, 2,.2499, 0,0,0,0,'rgba(255,255,255,.75)',1);//belt/midsection
      drawShape('rec',x,y,z, 4,5.75, 2,.2499, 0,0,0,0,'rgba(255,255,255,.75)',1);//belt/midsection
      drawShape('rec',x,y,z, 4,5.875, 2,.2499, 0,0,0,0,'rgba(255,255,255,.75)',1);//belt/midsection
        
      drawShape('qua',x+sx,y+sy,z*scalz2*sz, 6.5+scalx2,3.5+scaly2,  6.9+scalx2,    4+scaly2,    8+scalx2,   5.5+scaly2,    8+scalx2,   9+scaly2,'darkred',1);//robeR Right
      drawShape('tri',x,y,z, 7.14,5.6,  7.5, 7.25,    7.44,   5,    8,   9,'rgba(0,0,0,.35)',1);//robeR Right

      drawShape('qua',x+sx,y+sy,z*scalz2*sz,5.75+scalx2,3.2+scaly2, 6.25+scalx2,    9+scaly2,    8+scalx2,    9+scaly2,  6.5+scalx2, 3.5+scaly2,'darkred',1);//robeR LEft
      drawShape('qua',x+sx,y+sy,z*sz, 4.65, 2.4,   4.5, 6.75,    3.5, 6.75,    3.5, 1.6,'darkred',1);//robeL LEft
      drawShape('qua',x,y,z,  4,2,   3.25,2,    3.33,7.2 ,  3.9, 3.9,'rgba(0,0,0,.5)',1);
      sx =-.6391*z;
      sy = -.6*z;
      sz = 1.13;
      drawShape('qua',x+sx,y+sy,z*sz,  3.99,2.3,   3.3,1.6,    3.16,1.9,   3.99, 3.66,'white',1);//left arm
      drawShape('qua',x+sx,y+sy,z*sz,  7.1,5,   7.25,5.3,    7.28,5.7,   6.9, 5.5,'white',1);//right arm
      drawShape('qua',x+sx,y+sy,z*sz, 3.3,1.61, 3,1.1, 2.9,1.2, 3.16,1.9,'rgb(185,122,87)',1);//left forearm
      drawShape('qua',x+sx,y+sy,z*sz, 3,1.15, 2.9,.95, 2.5,.95, 2.6,1.25,'rgb(185,122,87)',1);//left hand
      //wand
      sx = -.08 *z;
      drawShape('qua',x+sx,y,z,2.5,1.05, 2.3,0.25, 2.5,0, 2.7,.25,'rgba(85,43,0,1)',1);//handle
      drawShape('tri',x+sx,y,z,2.3,.25, 2.5,0, 2.7,.25, 0,0,'rgba(255,0,0,.2)',1);//gfl

      sx =-.6391*z;
      sy = -.6*z;
      sz = 1.13;
      drawShape('qua',x+sx,y+sy,z*sz, 2.5,.95, 2.6,1.25, 2.75,1.2, 2.75,1,'rgb(160,100,70)',1);//left fingers
      drawShape('qua',x+sx,y+sy,z*sz, 2.9,.95, 2.5,1, 2.75,1.05, 3,1.15,'rgb(170,110,70)',1);//left thumb
      drawShape('qua',x+sx,y+sy,z*sz, 7.25,5.3, 7.25,5.69, 8,6.22, 7.5,5.6,'rgb(185,122,87)',1);//left forearm
      drawShape('qua',x+sx,y+sy,z*sz, 7.5,5.6, 7.8,5.8, 7.4,6, 7.25,5.5,'rgb(185,122,87)',1);//left forearm
      drawShape('tri',x+sx,y+sy,z*sz, 7.45,5.93, 7.4,5.85, 7.5,5.875, 7.5,5.6,'rgb(165,102,67)',1);//left forearm
      sx =-.6391*z;
      sy = -1.3691*z;
      sz = 1.13;
      drawShape('tri',x+sx,y+sy,z*sz, 5,2.5, 5.15,2.85, 5,2.85, 0,0,'rgba(0,0,0,.25)',1);//nose
      drawShape('tri',x+sx,y+sy,z*sz, 4.8,3, 5.2,3, 5,3.05, 0,0,'rgba(255,0,0,.25)',1);//mouth
      drawShape('tri',x+sx,y+sy,z*sz, 4.6,2.55, 4.9,2.55, 4.75,2.58, 0,0,'rgba(0,0,0,.25)',1);//left eye
      drawShape('tri',x+sx,y+sy,z*sz, 5.4,2.55, 5.1,2.55, 5.25,2.58, 0,0,'rgba(0,0,0,.25)',1);//left eye
      sx =-.6391*z;
      sy = -1.2*z;
      sz = 1.13;
      drawShape('ell',x+sx,y+sy,z*sz,4.61,1.5, .4,.25,1,0,6,0,'white',1);//infinity symbol 
      drawShape('ell',x+sx,y+sy,z*sz,5.39,1.5, .4,.25,1,0,6,0,'white',1);
      drawShape('ell',x+sx,y+sy,z*sz,4.61,1.5, .38,.23,1,0,6,0,'rgba(0,6,13)',1);
      drawShape('ell',x+sx,y+sy,z*sz,5.39,1.5, .38,.23,1,0,6,0,'(rgba(0,6,13)',1);
      sx =8.5*z;
      sy = 6.5*z;
      sz = .13;
      //Stat symbols
      //sword
      drawShape('qua',x+sx,y+sy,z*sz,0,1, 2,3, 3,2, 1,0,'rgb(252,165,3)',1);//handle
      drawShape('qua',x+sx,y+sy,z*sz,0,1, 2,3, 3,2, 1,0,'rgb(252,165,3)',0);//handle
      drawShape('tri',x+sx,y+sy,z*sz,0,0, 1.4,0, 0,1.4 ,0,0,'darkgray',1);//pommel
      drawShape('tri',x+sx,y+sy,z*sz,0,0, 1.4,0, 0,1.4 ,0,0,'rgb(252,165,3)',0);//pommel
      drawShape('qua',x+sx,y+sy,z*sz,0,5, 1,5 ,5,1 ,5,0,'rgb(252,165,3)',1);//hilt guard
      drawShape('qua',x+sx,y+sy,z*sz,2,4, 8,9, 8,8, 4,4,'gray',1);//lhalf blade
      drawShape('qua',x+sx,y+sy,z*sz,4,2, 9,8, 8,8 ,4,4,'gray',1);//rhalf blade
      drawShape('tri',x+sx,y+sy,z*sz,4,4, 4,2, 2,4, 0,0,'gray',1);//near hilt center
      drawShape('qua',x+sx,y+sy,z*sz,9,8, 8,8, 8,9, 10,10,'gray',1);//sword tip
      drawShape('qua',x+sx,y+sy,z*sz,0,5, 1,5, 5,1 ,5,0,'rgb(252,165,3)',0);//hilt guard outline
      drawShape('arc',x+sx,y+sy,z*sz,3,3, .5,0, 6,0 ,0,0,'white',1);//hilt gem
      drawShape('arc',x+sx,y+sy,z*sz,3,3 ,.51,0, 6,0, 0,0,'white',0);
     //shield
      sx =4.7*z;
      sy = 3*z;
      sz = .06;
      drawShape('lin',x,y,z,5,3.1, 4.6,2.4, 0,0, 0,0,'gray',0);//string
      drawShape('lin',x,y,z,5,3.1, 5.41,2.4, 0,0, 0,0,'gray',0);//string
      drawShape('arc',x+sx,y+sy,z*sz,4.8,5,4.5,0,6,0,0,0,'rgba(40,20,0,1)',1);
      drawShape('arc',x+sx,y+sy,z*sz,5,5,4.5,0,6,0,0,0,'rgba(85,43,0,1)',1);
      drawShape('rec',x+sx,y+sy,z*sz,0.5,5,9,.11,0,0,0,0,'rgba(0,0,0,.35)',1)
      drawShape('rec',x+sx,y+sy,z*sz,.95,3,8.1,.11,0,0,0,0,'rgba(0,0,0,.35)',1)
      drawShape('rec',x+sx,y+sy,z*sz,1,7,8,.11,0,0,0,0,'rgba(0,0,0,.35)',1)
      drawShape('qua',x+sx,y+sy,z*sz,5,4,6,5,5,6,4,5,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,3,1, 7,1.1, 2.8,1.2, 8,2,'rgba(0,0,0,.35)',1);
      drawShape('qua',x+sx,y+sy,z*sz,3-1,1+1, 7-1,1.1+1, 2.8-1,1.2+1, 8-1,2+1,'rgba(0,0,0,.35)',1);
      drawShape('qua',x+sx,y+sy,z*sz,1+3,1+2, 1+7,1.1+2, 1+2.8,1.2+2, 1+8,2+2,'rgba(0,0,0,.35)',1);
      drawShape('qua',x+sx,y+sy,z*sz,1+3,1+5, 1+7,1.1+5, 1+2.8,1.2+5, 1+8,2+5,'rgba(0,0,0,.35)',1);
      drawShape('qua',x+sx,y+sy,z*sz,3,1+6, 7,1.1+6, 2.8,1.2+6, 8,2+6,'rgba(0,0,0,.35)',1);
      drawShape('qua',x+sx,y+sy,z*sz,3-1,1+7, 7-1,1.1+7, 2.8-1,1.2+7, 8-1,2+7,'rgba(0,0,0,.35)',1);
      //hourglass
      sx =4.875*z;
      sy = .75*z;
      sz = .025;
      drawShape('qua',x+sx,y+sy,z*sz,1,9,9,9,1,1,9,1,'white',1);//body
      drawShape('qua',x+sx,y+sy,z*sz,1,9,9,9,1,1,9,1,'black',0);//body
      drawShape('rec',x+sx,y+sy,z*sz,1,.75,8,.25,0,0,0,0,'rgb(128,64,0)',1);
      drawShape('rec',x+sx,y+sy,z*sz,1,9,8,.25,0,0,0,0,'rgb(128,64,0)',1);
      drawShape('tri',x+sx,y+sy,z*sz,2.5,9,7.5,9,5,8.5,0,0,'blue',1);//bottom sand
      drawShape('tri',x+sx,y+sy,z*sz,5,5,2.5,2.5,7.5,2.5,0,0,'blue',1);//top sand
      drawShape('qua',x+sx,y+sy,z*sz,5,5, 4.9,6, 5.1,7, 4.9,8.5,'blue',1);//drip sand
      break;
    case 2://High Priestess monster
      drawShape('arc',x,y,z*.5,5,    .85, .8,0,6,0,0,0,'silver',1);//bag
      drawShape('arc',x,y,z*.5,4.95,.80,.75,0,6,0,0,0,'rgba(0,0,0,.25)',1);//bag
      drawShape('arc',x,y,z*.5,4.9,  .85, .7,0,6,0,0,0,'rgba(0,0,0,.25)',1);//bag
      drawShape('arc',x,y,z*.5,4.85, .85, .65,0,6,0,0,0,'rgba(0,0,0,.25)',1);//bag
      drawShape('arc',x,y,z*.5,4.8,  .85, .6,0,6,0,0,0,'rgba(0,0,0,.25)',1);//bag

      drawShape('ell',x,y,z,5,4.5, 2.45,4.5,1,0,6,0,'gray',1);//chair back
      drawShape('rec',x,y,z, 3,5.5, 4,3, 0,0,0,0,'rgba(0,0,0,.35)',1);//seat
      drawShape('rec',x,y,z, 3,9, 4,1, 0,0,0,0,'gray',1);//bottom of chair
      drawShape('rec',x,y,z, 2,2, 1,8, 0,0,0,0,'black',1);//black column
      drawShape('rec',x,y,z, 2,2, 1,8, 0,0,0,0,'gray',0);//black column
      drawShape('rec',x,y,z, 1.99,1.99, 1.02,8.01, 0,0,0,0,'white',0);
      drawShape('tri',x,y,z, 8,1, 8,2, 7,2, 0,0,'black',1);//column top left
      drawShape('tri',x,y,z, 8,1, 8,2, 7,2, 0,0,'gray',0);//column top left
      drawShape('tri',x,y,z, 2,1, 2,2, 3,2, 0,0,'white',1);//column top left
      drawShape('rec',x,y,z, 7,2, 1,8, 0,0,0,0,'white',1);//column white

      drawShape('tri',x,y,z, 3,0, 4,1, 5,1, 0,0,'lightblue',1);//veil top

      drawShape('tri',x,y,z, 7,0, 6,1, 5,1, 0,0,'lightblue',1);//veil top


      drawShape('rec',x,y,z, 4.2,1, 1.6,2.1, 0,0,0,0,'black',1);//face
      drawShape('qua',x,y,z, 4.5,3, 5,2.5, 5.5,3, 5,3.5,'rgb(174,111,77)',1);//neck
      drawShape('rec',x,y,z, 4.2,1, 1.6,1, 0,0,0,0,'rgb(185,122,87)',1);//face
      drawShape('tri',x,y,z, 4.23,1.9, 5.78,1.9, 5,3, 0,0,'rgb(185,122,87)',1);//face bottom
      drawShape('rec',x,y,z, 4,1, .2,2.2, 0,0,0,0,'lightblue',1);//veil l
      drawShape('rec',x,y,z, 4,1, .2,2.2, 0,0,0,0,'rgba(0,0,0,.1)',1);//veil l
      drawShape('rec',x,y,z, 5.8,1, .2,2.2, 0,0,0,0,'lightblue',1);//veil r
      drawShape('rec',x,y,z, 5.8,1, .2,2.2, 0,0,0,0,'rgba(0,0,0,.1)',1);//veil r

      drawShape('rec',x,y,z, 4,1, 2,.75, 0,0,0,0,'lightblue',1);//veil m
      drawShape('rec',x,y,z, 4,1, 2,.75, 0,0,0,0,'rgba(0,0,0,.1)',1);//veil m
      drawShape('qua',x,y,z, 3.8,3.3, 6.2,3.3, 5.8,5.55, 4.2,5.55,'cyan',1);//body
      drawShape('qua',x,y,z, 3.8,3.3, 6.2,3.3, 5.8,5.55, 4.2,5.55,'rgba(255,255,255,.85)',1);//body
      drawShape('qua',x,y,z, 4.2,5.55, 3,7, 3,9.8, 5.8,5.55,'lightblue',1);//skirt left
      drawShape('qua',x,y,z, 5.8,5.55, 7,7, 7,9.8, 3,9.8,'lightblue',1);//skirt right
      drawShape('qua',x,y,z, 4.2,5.55, 3,7, 3,9.8, 5.8,5.55,'rgba(0,0,0,.15)',1);//skirt left
      drawShape('qua',x,y,z, 5.8,5.55, 7,7, 7,9.8, 3,9.8,'rgba(0,0,0,.15)',1);//skirt right
      //drawShape('qua',x,y,z, 3.8,3.3, 3.95,4, 2.9,5.5, 2.5,5.5,'cyan',1);//left arm
      //drawShape('qua',x,y,z, 2.5,5.5, 5,6, 5,5.9, 2.8,5.2,'rgb(185,122,87)',1);//left forearm
      drawShape('qua',x,y,z, 6.2,3.3, 6.05,4, 7.1,5.5, 7.5,5.5,'cyan',1);//right arm

      drawShape('arc',x,y,z,5,    .85, .8,0,6,0,0,0,'lightblue',1);//bag
      drawShape('arc',x,y,z,4.95,.80,.75,0,6,0,0,0,'rgba(255,255,255,.25)',1);//bag
      drawShape('arc',x,y,z,4.9,  .85, .7,0,6,0,0,0,'rgba(255,255,255,.25)',1);//bag
      drawShape('arc',x,y,z,4.85, .85, .65,0,6,0,0,0,'rgba(255,255,255,.25)',1);//bag
      drawShape('arc',x,y,z,4.8,  .85, .6,0,6,0,0,0,'rgba(255,255,255,.25)',1);//bag

      //drawShape('qua',x,y,z,  6.2-.5,9.4,   6.1-.5,9.8,    6.5-.5,10,   6.75-.5, 9.75,'lightblue',1);//right foot
      //drawShape('qua',x,y,z,  4.2,9.4,   4.9-.5,9.8,    4.75-.5,10,   4.25-.5, 9.75,'lightblue',1);//left foot
      drawShape('qua',x,y,z, 4.5,3, 3.75,3.3, 3,7, 6,9.9,'lightblue',1);//robe left
      drawShape('qua',x,y,z, 4.5,3, 3.75,3.3, 3,7, 6,9.9,'rgba(0,0,0,.1)',1);//robe left
      drawShape('qua',x,y,z, 5.5,3, 6.25,3.3, 7,7, 4,9.3,'lightblue',1);//robe left
      drawShape('qua',x,y,z, 5.5,3, 6.25,3.3, 7,7, 4,9.3,'rgba(0,0,0,.15)',1);//robe left
      drawShape('ell',x,y,z,5,4.5, 1.05,1.5,1,0,6,0,'cyan',1);//chair back
      drawShape('ell',x,y,z,5,4.5, 1.05,1.5,1,0,6,0,'rgba(255,255,255,.85)',1);//chair back
      drawShape('ell',x,y,z,5,3.1, .55,.2,1,0,6,0,'rgb(175,112,77)',1);//clavicle
      drawShape('qua',x,y,z, 6.2,3.3, 6.05,4, 7.1,5.5, 7.5,5.5,'rgba(255,255,255,.85)',1);//right arm
      sx = 3.78*z;
      sy = 5*z;
      sz = .2;
			drawShape('qua',x+sx,y+sy,z*sz,0,7.5,10,7.5,7.5,2.5,2.5,2.5,'rgba(128,64,0,.85)',1);
			drawShape('qua',x+sx,y+sy,z*sz,.2,7.1,9.8,7.1,7.5,2.5,2.5,2.5,'rgba(255,255,128,1)',1);
			drawShape('lin',x+sx,y+sy,z*sz,5,7.5,5,2.5,0,0,0,0,'rgba(128,64,0,.85)',1);
			drawShape('arc',x+sx,y+sy,z*sz,3.75,3.8,1.75,1.25,1.75,0,0,0,'rgba(255,255,128,1)',1);
			drawShape('arc',x+sx,y+sy,z*sz,6.25,3.8,1.75,1.25,1.75,0,0,0,'rgba(255,255,128,1)',1);
			drawShape('arc',x+sx,y+sy,z*sz,2.5,7.9,2.4,1.1,1.9,0,0,0,'rgba(248,179,16,.85)',1);
			drawShape('arc',x+sx,y+sy,z*sz,7.5,7.9,2.4,1.1,1.9,0,0,0,'rgba(248,179,16,.85)',1);

      drawShape('qua',x,y,z, 5.5,8, 6.5,7.3, 6.5,6, 4.5,7.5,'rgba(0,0,0,.09)',1);//right forearm
      drawShape('qua',x,y,z, 5,6, 5.5,5.5, 6.1,5.4, 6.13,5.6,'rgb(185,122,87)',1);//right forearm

      drawShape('qua',x,y,z, 4,4, 4.5,6, 5.6,8, 3,9.9,'lightblue',1);//robe left
      drawShape('qua',x,y,z, 5.5,5.5, 5.25,5.75, 5.5,6, 5.7,5.9,'rgb(185,122,87)',1);//right forearm
      drawShape('arc',x,y,z,5,6,1,0,6,0,0,0,'rgba(255,255,255,.25)',1);//book glow
      drawShape('qua',x,y,z, 4,4, 4.5,6, 5.6,8, 3,9.9,'lightblue',1);//robe left
      drawShape('qua',x,y,z, 6.21,3.28, 5.9,4, 6.5,8.5, 7.5,5.5,'lightblue',1);//robe left

      drawShape('tri',x,y,z, 5,1.75, 5.15,2.25, 5,2.25, 0,0,'rgba(0,0,0,.25)',1);//nose
      drawShape('tri',x,y,z, 4.7,2.5, 5.3,2.5, 5,2.59, 0,0,'rgba(255,0,0,.525)',1);//mouth
      drawShape('tri',x,y,z, 4.5,1.8, 4.9,1.8, 4.75,1.83, 0,0,'rgba(0,0,0,.25)',1);//left eye
      drawShape('tri',x,y,z, 5.5,1.8, 5.1,1.8, 5.25,1.83, 0,0,'rgba(0,0,0,.25)',1);//r eye
      drawShape('qua',x,y,z,  4.2,8.8,   4.4,9.1,    4.3,9.4,   3.4, 10,'lightblue',1);//left foot
            drawShape('qua',x,y,z,  6.2-.5,9.4,   6.1-.5,9.8,    6.5-.5,10,   6.75-.5, 9.75,'lightblue',1);//right foot

      break;
    case 3://Empress monster
      //legs red boots
      sx = -.5*z; 
      sy = -.1*z;
      sz = 1.1;
      drawShape('qua',x+sx,y+sy,z*sz, 5.5,7, 5.8,8.5, 6,8, 6,6.5,'rgba(255,0,0,.65)',1);
      drawShape('qua',x+sx,y+sy,z*sz, 4,7, 4,8.5, 4.25,8.3, 4.5,7,'rgba(255,0,0,.65)',1);
      drawShape('qua',x+sx,y+sy,z*sz, 4,8.25, 3.6,9, 4,8.8, 4.35,8.23,'rgba(230,0,0,.65)',1);
      drawShape('qua',x+sx,y+sy,z*sz, 6,8, 6.3,9, 6,9, 5.7,8.5,'rgba(230,0,0,.65)',1);
      //Empress upper
      sz = .8;
      sx = 1*z;
      sy = .0*z;
      drawShape('qua',x+sx,y+sy,z*sz, 5.25,3, 5.5,3.5, 5,4, 4.5,2.5,'rgb(135,82,47)',1);//neck
      drawShape('qua',x+sx,y+sy,z*sz, 4.5,2.5, 5.5,3.5, 5,4, 4.5,2.5,'rgb(165,102,67)',1);//neckL

      drawShape('qua',x+sx,y+sy,z*sz,4,1.8, 3.9,3, 4.25,3.25, 4.25,1.75,'gold',1);//bangs left
      drawShape('qua',x+sx,y+sy,z*sz, 5.25,3.5, 4.15,2.25, 5,1.3, 6,2.5,'rgb(185,122,87)',1);//face
      
      drawShape('tri',x+sx,y+sy,z*sz, 5.45,2.2, 5.4,2.8, 5.6,2.9, 0,0,'rgba(0,0,0,.2)',1);//nose
      drawShape('tri',x+sx,y+sy,z*sz, 5,2.2, 5.4,2.15, 5.2,2.3, 0,0,'rgba(0,0,0,.25)',1);//eye
      drawShape('tri',x+sx,y+sy,z*sz, 5.5,2.15, 5.9,2, 5.7,2.3, 0,0,'rgba(0,0,0,.25)',1);//eye
     
      drawShape('tri',x+sx,y+sy,z*sz, 5.25,3, 5.6,2.95, 5.4,3.075, 0,0,'rgba(255,0,0,.25)',1);//mouth
      drawShape('qua',x+sx,y+sy,z*sz,5,1.3, 4.2,1.75, 4,2.2, 5,1.85,'gold',1);//hair
      drawShape('qua',x+sx,y+sy,z*sz,5,1.3, 5.8,1.75, 6,2, 5,1.85,'gold',1);
       
      drawShape('qua',x+sx,y+sy,z*sz,5.55,1.9, 6,2.5, 5.8,3.4, 6,3.5,'gold',1);
      drawShape('qua',x+sx,y+sy,z*sz,5.55,1.9, 6,2.5, 5.8,3.4, 6,2,'gold',1);
      //drawShape('qua',x,y,z,4.25,1.9, 3.8,2.5, 4,3.4, 3.8,3.5,'gold',1);
      drawShape('qua',x+sx,y+sy,z*sz,5,1.8, 4.28,2.07, 4.8,3.4, 4.5,3.5,'gold',1);
      drawShape('qua',x+sx,y+sy,z*sz,4.28,2.07, 3.85,2.5, 4.05,3.4, 3.85,3.5,'rgba(0,0,0,.25)',1);
   
      drawShape('qua',x+sx,y+sy,z*sz, 3.9,6, 3,4, 3.5,4, 4,5,'rgba(255,255,255,.65)',1);//dress left forearm
        
      drawShape('qua',x+sx,y+sy,z*sz, 3,4, 3.5,4, 3.4,3.7, 3,3.5,'rgb(185,122,87)',1);//left hand
      drawShape('qua',x+sx,y+sy,z*sz, 3.4,4, 2.7,2, 2.4,2, 3.2,4.1,'yellow',1);//scepter
      drawShape('qua',x+sx,y+sy,z*sz, 3,4, 2.6,3.4, 3,3.5, 3.5,3.4,'rgb(165,102,67)',1);//left hand
        
      drawShape('tri',x+sx,y+sy,z*sz, 2.6,3.4, 3.5,3.4, 3,3.5, 2.75,1,'rgb(160,100,70)',1);//left fingers
      drawShape('qua',x+sx,y+sy,z*sz, 3.4,3.45, 3.25,3.5, 3.25,3.55, 3.4,3.7,'rgb(170,110,70)',1);//left thumb

      drawShape('qua',x+sx,y+sy,z*sz, 4.5,4, 4.5,5.5, 3.9,6, 4,4,'rgba(255,255,255,.65)',1);//dress left arm
      drawShape('qua',x+sx,y+sy,z*sz, 5,4, 5.5,7, 4.5,5.5, 4.5,4,'rgba(255,255,255,.65)',1);//dress left mid
      drawShape('qua',x+sx,y+sy,z*sz, 5.5,3.5, 6,3.5, 6.5,3.75, 7.5,5,'rgba(255,255,255,.75)',1);//dress right shoulder n tricep
      drawShape('qua',x+sx,y+sy,z*sz, 6.5,5, 6,6, 7,9.5, 3,9.5,'rgba(255,255,255,1)',1);//dress bottom right n forearm
      drawShape('qua',x+sx,y+sy,z*sz, 7.5,5, 6,6, 7,9.5, 3,9.5,'rgba(0,0,0,.25)',1);//dress bottom right n forearm
      drawShape('qua',x+sx,y+sy,z*sz, 5.5,3.5, 5,4, 5,7.5, 7.5,5,'rgba(255,255,255,.75)',1);//dress collarR
      drawShape('qua',x+sx,y+sy,z*sz, 5,4, 4.8,3.4, 4.5,3.5, 4,4,'rgba(255,255,255,.75)',1);//dress collarL
      drawShape('qua',x+sx,y+sy,z*sz, 4.5,4, 4.25,4.5, 4.25,5, 5,5.75,'rgba(255,255,255,.65)',1);//bl
      drawShape('qua',x+sx,y+sy,z*sz, 5.5,4, 5.75,4.5, 5.75,5, 5,5.75,'rgba(255,255,255,.65)',1);//br
      drawShape('qua',x+sx,y+sy,z*sz, 5.5,4, 5.05,4.5, 5.05,5, 5.8,5.75,'rgba(255,255,255,.65)',1);//brmain
      sx = -1.5*z;
      sy = 1*z;
      sz = .5;
      //sphere
      drawShape('arc',x+sx,y+sy,z*sz,9,1,.8,0,6,0,0,0,'gold',1);//bag
      drawShape('arc',x+sx,y+sy,z*sz,8.95,.95,.75,0,6,0,0,0,'rgba(255,255,255,.15)',1);//bag
      drawShape('arc',x+sx,y+sy,z*sz,8.9,1,.7,0,6,0,0,0,'rgba(255,255,255,.15)',1);//bag
      drawShape('arc',x+sx,y+sy,z*sz,8.85,1,.65,0,6,0,0,0,'rgba(255,255,255,.15)',1);//bag
      drawShape('arc',x+sx,y+sy,z*sz,8.8,1,.6,0,6,0,0,0,'rgba(255,255,255,.15)',1);//bag
      //heartshield
      sx = 3.7*z;
      sy = 3.8*z;
      sz = .25;
      drawShape('tri',x+sx,y+sy,z*sz,0,6.5, 12.6,12.6, 11.25,0, 0,0,'gray',1);
			drawShape('arc',x+sx,y+sy,z*sz,2.25,3.7,3.63,0,6,0,0,0,'gray',1);
			drawShape('arc',x+sx,y+sy,z*sz,7.75,1,3.63,0,6,0,0,0,'gray',1);
			drawShape('arc',x+sx,y+sy,z*sz,5,7,3,3,0,0,0,0,'gray',1);

      drawShape('arc',x,y,z,5,4.4,.4,0,6,0,0,0,'black',1);//circle in shield
      drawShape('arc',x,y,z,5,4.4,.36,0,6,0,0,0,'green',1);//circle in shield
      sx = 0;
      sy = 0;
      drawShape('qua',x+sx,y+sy,z,5.2,4.7, 5.28,4.69, 5.9,5.5, 5.8,5.5,'black',1);//////////cross
      drawShape('qua',x+sx,y+sy,z,5.23,5.5, 5.25,5.5, 6,5, 5.9,5,'black',1);//////////cross
            
      //star crown
      sz = .03;
      sx = 4.85*z;
      sy = 0.09*z;
      drawShape('tri',x+sx,y+sy,z*sz,5,0,.5,7.5,9.5,7.5,0,0,'white',1);//topmid
      drawShape('tri',x+sx,y+sy,z*sz,5,10,.5,2.5,9.5,2.5,0,0,'white',1);

      sx = 5.1*z;
      sy = 0.3*z;
      drawShape('tri',x+sx,y+sy,z*sz,5,0,.5,7.5,9.5,7.5,0,0,'white',1);//topr1
      drawShape('tri',x+sx,y+sy,z*sz,5,10,.5,2.5,9.5,2.5,0,0,'white',1);
        
      sx = 5.4*z;
      sy = 0.5*z;
      drawShape('tri',x+sx,y+sy,z*sz,5,0,.5,7.5,9.5,7.5,0,0,'white',1);//topr2
      drawShape('tri',x+sx,y+sy,z*sz,5,10,.5,2.5,9.5,2.5,0,0,'white',1);

      sx = 5.13*z;
      sy = 0.6*z;
      drawShape('tri',x+sx,y+sy,z*sz,5,0,.5,7.5,9.5,7.5,0,0,'white',1);//botr1
      drawShape('tri',x+sx,y+sy,z*sz,5,10,.5,2.5,9.5,2.5,0,0,'white',1);

      sx = 5.65*z;
      sy = 0.7*z;
      drawShape('tri',x+sx,y+sy,z*sz,5,0,.5,7.5,9.5,7.5,0,0,'white',1);//topr3
      drawShape('tri',x+sx,y+sy,z*sz,5,10,.5,2.5,9.5,2.5,0,0,'white',1);

      sx = 4.58*z;
      sy = 0.6*z;
      drawShape('tri',x+sx,y+sy,z*sz,5,0,.5,7.5,9.5,7.5,0,0,'white',1);//botl1
      drawShape('tri',x+sx,y+sy,z*sz,5,10,.5,2.5,9.5,2.5,0,0,'white',1);

      sx = 5.8*z;
      sy = 1*z;
      drawShape('tri',x+sx,y+sy,z*sz,5,0,.5,7.5,9.5,7.5,0,0,'white',1);//topr4
      drawShape('tri',x+sx,y+sy,z*sz,5,10,.5,2.5,9.5,2.5,0,0,'white',1);

      sx = 4*z;
      sy = 0.7*z;
      drawShape('tri',x+sx,y+sy,z*sz,5,0,.5,7.5,9.5,7.5,0,0,'white',1);//topl3
      drawShape('tri',x+sx,y+sy,z*sz,5,10,.5,2.5,9.5,2.5,0,0,'white',1);

      sx = 4.6*z;
      sy = 0.3*z;
      drawShape('tri',x+sx,y+sy,z*sz,5,0,.5,7.5,9.5,7.5,0,0,'white',1);//topl1
      drawShape('tri',x+sx,y+sy,z*sz,5,10,.5,2.5,9.5,2.5,0,0,'white',1);

      sx = 4.3*z;
      sy = 0.5*z;
      drawShape('tri',x+sx,y+sy,z*sz,5,0,.5,7.5,9.5,7.5,0,0,'white',1);//topl2
      drawShape('tri',x+sx,y+sy,z*sz,5,10,.5,2.5,9.5,2.5,0,0,'white',1);

      sx = 3.9*z;
      sy = 1*z;
      drawShape('tri',x+sx,y+sy,z*sz,5,0,.5,7.5,9.5,7.5,0,0,'white',1);//topl4
      drawShape('tri',x+sx,y+sy,z*sz,5,10,.5,2.5,9.5,2.5,0,0,'white',1);

      sx = 4.85*z;
      sy = 0.4*z;
      drawShape('tri',x+sx,y+sy,z*sz,5,0,.5,7.5,9.5,7.5,0,0,'white',1);//starmid
      drawShape('tri',x+sx,y+sy,z*sz,5,10,.5,2.5,9.5,2.5,0,0,'white',1);
          

      //leaf crown
      sz = 0.03;
      sx = 4.9*z;
      sy = .9*z;
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,10,0, 9,6, 6.5,8.5, 0,10,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'rgba(0,0,0,.45)',0);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 4,4, 5,3, 10,0,'rgba(0,0,0,.15)',1);
      sx = 5.2*z;
      sy = 1*z;
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,10,0, 9,6, 6.5,8.5, 0,10,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'rgba(0,0,0,.45)',0);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 4,4, 5,3, 10,0,'rgba(0,0,0,.15)',1);
      sx = 5.5*z;
      sy = 1.1*z;
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,10,0, 9,6, 6.5,8.5, 0,10,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'rgba(0,0,0,.45)',0);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 4,4, 5,3, 10,0,'rgba(0,0,0,.15)',1);
      sx = 5.7*z;
      sy = 1.3*z;
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,10,0, 9,6, 6.5,8.5, 0,10,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'rgba(0,0,0,.45)',0);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 4,4, 5,3, 10,0,'rgba(0,0,0,.15)',1);
      sx = 4.5*z;
      sy = 1*z;
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,10,0, 9,6, 6.5,8.5, 0,10,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'rgba(0,0,0,.45)',0);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 4,4, 5,3, 10,0,'rgba(0,0,0,.15)',1);
      sx = 4.2*z;
      sy = 1.2*z;
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,10,0, 9,6, 6.5,8.5, 0,10,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'rgba(0,0,0,.45)',0);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 4,4, 5,3, 10,0,'rgba(0,0,0,.15)',1);
      sx = 43.91*z;
      sy = 1.3*z;
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,10,0, 9,6, 6.5,8.5, 0,10,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'rgba(0,0,0,.45)',0);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 4,4, 5,3, 10,0,'rgba(0,0,0,.15)',1);
      //leaf crown bot
      sz = 0.03;
      sx = 4.8*z;
      sy = 1.1*z;
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,10,0, 9,6, 6.5,8.5, 0,10,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'rgba(0,0,0,.45)',0);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 4,4, 5,3, 10,0,'rgba(0,0,0,.15)',1);
      sx = 5*z;
      sy = 1.1*z;
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,10,0, 9,6, 6.5,8.5, 0,10,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'rgba(0,0,0,.45)',0);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 4,4, 5,3, 10,0,'rgba(0,0,0,.15)',1);

      sx = 5.3*z;
      sy = 1.1*z;
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,10,0, 9,6, 6.5,8.5, 0,10,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'rgba(0,0,0,.45)',0);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 4,4, 5,3, 10,0,'rgba(0,0,0,.15)',1);

      sx = 5.5*z;
      sy = 1.2*z;
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,10,0, 9,6, 6.5,8.5, 0,10,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'rgba(0,0,0,.45)',0);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 4,4, 5,3, 10,0,'rgba(0,0,0,.15)',1);

      sx = 4.7*z;
      sy = 1*z;
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,10,0, 9,6, 6.5,8.5, 0,10,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'rgba(0,0,0,.45)',0);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 4,4, 5,3, 10,0,'rgba(0,0,0,.15)',1);

      sx = 4.4*z;
      sy = 1.2*z;
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,10,0, 9,6, 6.5,8.5, 0,10,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'rgba(0,0,0,.45)',0);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 4,4, 5,3, 10,0,'rgba(0,0,0,.15)',1);

      sx = 4*z;
      sy = 1.3*z;
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,10,0, 9,6, 6.5,8.5, 0,10,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'rgba(0,0,0,.45)',0);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 4,4, 5,3, 10,0,'rgba(0,0,0,.15)',1);
      break;
    case 4://Emperor monster
    drawShape('ell',x,y,z,4.59,.8,.65,.5,1,0,6,0,'yellow',1);
    drawShape('arc',x,y,z,4,1,.1,0,6,0,0,0,'red',1);
    drawShape('arc',x,y,z,5.25,.85,.1,0,6,0,0,0,'red',1);
    drawShape('qua',x,y,z,5.3,1, 6,2.5, 5.5,2.5, 5,1,'rgba(255,255,255,.9)',1);//hair back
 
    sx = .15*z;
    sy = .49*z;
    sz=.95;
    drawShape('qua',x+sx,y+sy,z*sz,4.5,5.25,/*tr*/ 3.4,7.35,/*br*/ 4.4,7.7,/*bl*/ 5,6.5,'lightgray',1);//l-thigh
			drawShape('qua',x+sx,y+sy,z*sz,4.5,9.1,/*tr*/4.5,9.6,/*br*/ 2,9.6,/*l*/4.5,8.6,/*tl*/'darkgray',1);//l-foot
			drawShape('qua',x+sx,y+sy,z*sz,4.5,9.5,/*br*/ 4.5,7.7,/*tr*/ 3.3,7.3,/*tl*/ 3.9,9,/*bl*/'darkgray',1);//l-calf
			drawShape('qua',x+sx,y+sy,z*sz,4.5,9.5,/*br*/ 4.5,7.7,/*tr*/ 3.3,7.3,/*tl*/ 3.9,9,/*b*/'gray',0);//l-calf
			drawShape('arc',x+sx,y+sy,z*sz,4.25,2.65, .63,0, 3,0, 0,0,'darkgray',1);//l-shoulder
			drawShape('arc',x+sx,y+sy,z*sz,4.25,2.65, .63,0, 3,0, 0,0,'gray',0);//l-shoulder-shadow
			drawShape('ell',x+sx,y+sy,z*sz,5.15,3.6,.5,1.75,0,0,6,0,'lightgray',1);//torso
			drawShape('qua',x+sx,y+sy,z*sz,4.7,2,5.5,1.5,6,2.5,4.25,2.5,'darkgray',1);//neck
			//drawShape('arc',x+sx,y+sy,z*sz,5,1,1,0,6,0,0,0,'lightgray',1);//head
			//drawShape('tri',x+sx,y+sy,z*sz,3.5,1.5,4.3,.25,4.9,2,0,0,'lightgray',1);//helm nose
			drawShape('qua',x+sx,y+sy,z*sz,4.5,5.5,/*tl*/6,4.5,/*tr*/ 6.5,7.7,/*br*/ 5.8,8,/*bl*/ 'lightgray',1);//r-thigh
			drawShape('qua',x+sx,y+sy,z*sz,5.5,8,/*tl*/6.25,7.25,/*tm*/6.75,8,/*tr*/ 6.25,9.5,/*b*/'darkgray',1);//r-calf
			drawShape('qua',x+sx,y+sy,z*sz,5.5,8,/*tl*/6.25,7.25,/*tm*/6.75,8,/*tr*/ 6.25,9.5,/**/'gray',0);//r-calf
			drawShape('qua',x+sx,y+sy,z*sz,6.25,9,/*t*/5.6,9.6,/*bl*/6.25,10,/*bm*/ 6.9,9.6,/*br*/'darkgray',1);//r-foot
			//drawShape('tri',x+sx,y+sy,z*sz,6.25,9.5,/*t*/5.75,10,/*bl*/6.75,10,/*br*/ 0,0,'gray',1);//r-toe
			drawShape('qua',x+sx,y+sy,z*sz,6.2,4.3,7.25,7.25,5.1,6.3,4.75,5.25,'darkgray',1);//hip armor
			drawShape('qua',x+sx,y+sy,z*sz,6.2,4.3,7.25,7.25,5.1,6.3,4.75,5.25,'gray',0);//hip armor
			drawShape('qua',x+sx,y+sy,z*sz,4.5,7, 5.2,5, 4.5,5.2, 4.2,5,'darkgray',1);//groin armor
			drawShape('qua',x+sx,y+sy,z*sz,4.5,7, 5.2,5, 4.5,5.2, 4.2,5,'gray',0);//groin armor
			//drawShape('qua',x+sx,y+sy,z*sz,2.75,1.75, 4.5,2.75, 4.5,5.8, 2.75,4.8,'gray',1);//shield top
			//drawShape('tri',x+sx,y+sy,z*sz,2.75,4.8,4.5,5.8,3.5,7.5,0,0,'gray',1);//shield bot
			//drawShape('lin',x+sx,y+sy,z*sz,3.5,7.6,3.45,2.1,0,0,0,0,'blue',0);//shield cross |
			//drawShape('lin',x+sx,y+sy,z*sz,2.75,4,4.5,5,0,0,0,0,'blue',0);//shield cross--
			drawShape('tri',x+sx,y+sy,z*sz,/*tl*/ 4.45,3.55, /*tr*/3.7,2.5, /*br*/2.3,4, 0,0,'lightgray',1);//l-arm
		  

			drawShape('tri',x+sx,y+sy,z*sz,/*tl*/ 5.55,3.55, /*tr*/6.3,2.5, /*br*/7.7,4, 0,0,'lightgray',1);//r-arm
			drawShape('tri',x+sx,y+sy,z*sz,/*tl*/ 5.6,3.5, /*tr*/6.3,2.5, /*br*/7.7,4, 0,0,'gray',0);//r-arm

			drawShape('qua',x+sx,y+sy,z*sz,5.9,5.5, 5.9,5.7, 7.2,6.1, 7.2,5.7,'gold',1);//sword-hilt
			drawShape('arc',x+sx,y+sy,z*sz,6.2,5.75,.4,0,3,0,0,0,'darkgray',1);//r-hand
			//drawShape('tri',x+sx,y+sy,z*sz,1,4.6, 5.9,5.35, 6.1,6.15,0,0,'white',1);//sword-blade
			//drawShape('qua',x+sx,y+sy,z*sz,5.8,4.5,5.9,5.7,6.3,6.8,6.4,6,'gold',1);//sword-crossguard
			drawShape('arc',x+sx,y+sy,z*sz,6,3, .63,0, 3,0, 0,0,'darkgray',1);//r-shoulder
			drawShape('arc',x+sx,y+sy,z*sz,6,3, .63,0, 3,0, 0,0,'gray',0);//r-shoulder
			//drawShape('qua',x+sx,y+sy,z*sz,5.8,.7, 3.5,.8, 3.7,.5, 3.85,.6,'black',1);//helmet visor
            drawShape('qua',x+sx,y+sy,z*sz,4,2, 3.5,2.5, 6.5,7.2, 4.2,5,'rgba(255,0,0,.4)',1);//robeLShoulder
        drawShape('qua',x+sx,y+sy,z*sz,4,2, 6.5,2.5, 3.5,7.2, 6.5,5,'rgba(255,0,0,.4)',1);//robeLShoulder
              drawShape('qua',x+sx,y+sy,z*sz,4,2, 3.5,2.5, 6.5,7.2, 4.2,5,'rgba(255,0,0,.4)',1);//robeLShoulder
        drawShape('qua',x+sx,y+sy,z*sz,4,2, 4,4, 3,8, 7.25,7.25,'rgba(255,0,0,.8)',1);//robeLShoulder
              drawShape('qua',x+sx,y+sy,z*sz,4,2, 3.5,2.5, 6.5,7.2, 4.2,5,'rgba(255,0,0,.4)',1);//robeLShoulder
        drawShape('qua',x+sx,y+sy,z*sz,6,2.1, 7.5,3.5, 7.25,7.25, 4,2,'rgba(255,0,0,.7)',1);//robeLShoulder
      drawShape('qua',x+sx,y+sy,z*sz,6,2.1, 7.5,3.5, 7.25,7.25, 4,2,'rgba(255,0,0,.7)',1);//robeLShoulder
      			drawShape('tri',x+sx,y+sy,z*sz,/*br*/ 7.9,3.9, /*tr*/7.3,3.3, /*l*/6.5,5.5, 0,0,'lightgray',1);//r-forearm
			drawShape('tri',x+sx,y+sy,z*sz,/*br*/ 7.9,3.9, /*tr*/7.3,3.3, /*l*/6.5,5.5, 0,0,'gray',0);//r-forearm
      drawShape('tri',x+sx,y+sy,z*sz,/*br*/ 2.3,4, /*tr*/2.7,3.55, /*l*/4.5,4, 0,0,'gray',1);//l-forearm
      drawShape('qua',x+sx,y+sy,z*sz,4,4, 5,3.75, 4.7,4.4, 4.5,4.4,'rgb(185,122,87)',1);//hand left
      drawShape('arc',x+sx,y+sy,z*sz,4.5,4, .39,0, 3,0, 0,0,'gold',1);////gold orb
      drawShape('arc',x+sx,y+sy,z*sz,4.5,4, .5,0, 3,0, 0,0,'rgba(255,255,0,.25)',1);////gold orb

      drawShape('qua',x+sx,y+sy,z*sz,4,4, 5,4, 4.7,4.4, 4.3,4.4,'rgb(185,122,87)',1);//hand left
      drawShape('arc',x+sx,y+sy,z*sz,6.4,2.65, .25,0, 3,0, 0,0,'gold',1);//ankh circle outer
     
            drawShape('arc',x+sx,y+sy,z*sz,6.4,2.65, .13,0, 3,0, 0,0,'red',1);//ankh circle inner
            drawShape('arc',x+sx,y+sy,z*sz,6.4,2.65, .131,0, 3,0, 0,0,'rgba(0,6,13,1)',0);//ankh circle inner
      drawShape('qua',x+sx,y+sy,z*sz,7,5, 6,4.75, 6.3,5.5, 6.5,5.5,'rgb(185,122,87)',1);//hand right
      drawShape('rec',x+sx,y+sy,z*sz,6.3,3, .19,2.5, 6.3,3, 0,0,'gold',1);//ankh
      drawShape('rec',x+sx,y+sy,z*sz,6.3,3, .19,2.5, 6.3,3, 0,0,'rgb(0,6,13)',0);//ankh
      drawShape('rec',x+sx,y+sy,z*sz,5.9,2.89, 1,.15, 6.3,3, 0,0,'gold',1);//ankh cross
      drawShape('rec',x+sx,y+sy,z*sz,5.9,2.89, 1,.15, 6.3,3, 0,0,'rgb(0,6,13)',0);//ankh cross
       drawShape('arc',x+sx,y+sy,z*sz,6.4,2.65, .25,0, 3,0, 0,0,'rgb(0,6,13)',0);//ankh circle outer
             drawShape('qua',x+sx,y+sy,z*sz,7,5, 6,5, 6.3,5.5, 6.5,5.5,'rgb(185,122,87)',1);//hand right
     
    drawShape('qua',x,y,z,5,1, 4.5,2, 4.75,2.5, 4.5,3,'rgba(255,255,255,.9)',1);//beard l
    drawShape('qua',x,y,z,4.75,2.5, 5.5,2, 5.25,.75, 4,1,'rgb(185,122,87)',1);//head
    drawShape('qua',x,y,z,4.75,2.5, 4.5,2, 4.5,3, 4.5,3,'rgba(255,255,255,.9)',1);//beard l
    drawShape('qua',x,y,z,4.5,2, 5,1.8, 5,1.9, 4.5,2.11,'rgba(255,255,255,.9)',1);//beard l
    drawShape('qua',x,y,z,5.3,1, 5.5,2, 5,3, 4.5,3,'rgba(255,255,255,.9)',1);//beard
        drawShape('tri',x,y,z,5,1.8, 4.5,2, 4.75,2.5, 4.75,2.5,'rgba(255,255,255,.9)',1);//beard
            drawShape('tri',x,y,z,4.5,1, 5.8,2.5, 5.3,1, 4.5,3,'rgba(255,255,255,.9)',1);//beard


    
    drawShape('qua',x,y,z,4.1,1.3, 5.3,1, 5.25,.75, 3.9,.75,'gold',1);//crown
    drawShape('qua',x,y,z,4.5,1.5, 4.5,2, 4.7,2, 4.5,1.5,'rgba(0,0,0,.25)',1);//nose
          drawShape('qua',x,y,z,4.5,1.5, 4.9,1.45, 4.75,1.4, 4.7,1.4,'rgba(0,0,0,.25)',1);//eyesr
          drawShape('qua',x,y,z,4.5,1.5, 4.25,1.4, 4.3,1.5, 4.5,1.5,'rgba(0,0,0,.25)',1);//eyesl
          drawShape('qua',x,y,z,4.5,2, 4.7,2.2, 4.8,2, 4.6,2.1,'rgba(255,0,0,.25)',1);//mouth'
    drawShape('arc',x,y,z,4.25,1,.1,0,6,0,0,0,'white',1);
        drawShape('arc',x,y,z,4.75,.9,.1,0,6,0,0,0,'red',1);
                drawShape('arc',x,y,z,5.1,.87,.1,0,6,0,0,0,'white',1);







    break;
    case 5://Heirophant monster
      sx =-.6391*z;
      sy = -.30691*z;
      sz = 1.13;

      drawShape('qua',x+sx,y+sy,z*sz,  5.2,8.4,   5.1,8.8,    6.25,9,   5.75, 8.75,'blue',1);//right foot
      drawShape('qua',x+sx,y+sy,z*sz,  4.8,8.4,   4.9,8.8,    3.75,9,   4.25, 8.75,'blue',1);//left foot
      drawShape('qua',x+sx,y+sy,z*sz,  5.2,8.4,   5.1,8.8,    6.25,9,   5.75, 8.75,'rgba(255,255,255,.4)',1);//right foot
      drawShape('qua',x+sx,y+sy,z*sz,  4.8,8.4,   4.9,8.8,    3.75,9,   4.25, 8.75,'rgba(255,255,255,.4)',1);//left foot
      drawShape('qua',x+sx,y+sy,z*sz,  6,5.51,   6.1,8.5,    3.9,8.5,   4, 5.51,'lightblue',1);//robe bottom
  
    

      
      sx =1.25*z;
      sy = -.5*z;
      sz = .75;
        drawShape('qua',x,y,z, 4.4,1.9, 4.4,2.5, 5,2.9, 5,2,'lightblue',1);//neck left
        drawShape('qua',x,y,z, 5.6,1.9, 5.6,2.5, 5,2.9, 5,2,'lightblue',1);//neck left
        drawShape('qua',x+sx,y+sy,z*sz, 5.5,3.5, 5.5,4, 5.75,4,5,4.5,'lightblue',1);//neck right
        drawShape('qua',x+sx,y+sy,z*sz, 4.35,3.2, 5,3.9, 5.65,3.2, 5,4.52,'lightblue',1);//neck middle
        drawShape('qua',x+sx,y+sy,z*sz, 4.35,3.2, 5,3.9, 5.65,3.2, 5.02,4.52,'lightblue',1);//neck middle
        drawShape('qua',x+sx,y+sy,z*sz, 5.02,2, 4.1,2.5, 4.25,3.25,5.02,3.9,'rgb(185,122,87)',1);//face left
        drawShape('qua',x+sx,y+sy,z*sz, 5.02,2, 5.9,2.5, 5.75,3.25,5,3.9,'rgb(185,122,87)',1);//face right

        drawShape('rec',x+sx,y+sy,z*sz, 4,2,2,.28,0,0,0,0,'gold',1);//headband
        drawShape('qua',x+sx,y+sy,z*sz, 5,1.63, 4.3,1.75, 4,2, 5,2,'gold',1);//top head
        drawShape('qua',x+sx,y+sy,z*sz, 5,1.63, 5.7,1.75, 6,2, 5,2,'gold',1);//top head
        sy = -.75*z;
        drawShape('qua',x+sx,y+sy,z*sz, 5,1.63, 4.3,1.75, 4,2.3, 5,2,'gold',1);//top head
        drawShape('qua',x+sx,y+sy,z*sz, 5,1.63, 5.7,1.75, 6,2.3, 5,2,'gold',1);//top head
                sy = -1*z;
        drawShape('qua',x+sx,y+sy,z*sz, 5,1.63, 4.3,1.75, 4,2.6, 5,2,'gold',1);//top head
        drawShape('qua',x+sx,y+sy,z*sz, 5,1.63, 5.7,1.75, 6,2.6, 5,2,'gold',1);//top head
        //DONOTDELETEdrawShape('qua',x,y,z,4,2.25, 3.9,3.5, 4.25,3,4.25,4.25,'rgb(119,43,79)',1);//lightning bolt

      sx =0*z;
      sy = -.75*z;
      sz = 1;
      drawShape('qua',x+sx,y+sy,z*sz, 5.4,3.35,    5,3.6,    6,6,   5.4, 3.35,'white',1);//shirt right
      drawShape('qua',x+sx,y+sy,z*sz,   5, 3.6,  4.5,  3.25, 4.25,    6,    6,   6,'white',1);//shirt left
      drawShape('qua',x,y,z, 5.4,2.5, 5.55, 2.5,    6.1,  3,  6.5, 3.5,'darkred',1);//right shoulder
      drawShape('rec',x+sx,y+sy,z*sz,4,4.65,2,.3,0,0,0,0,'rgba(0,0,0,.75)',0);
 
      drawShape('rec',x,y,z,4.5,3, 1,6,0,0,0,0,'white',1);
      //drawShape('tri',x,y,z, 7.14,5.6,  7.5, 7.25,    7.44,   5,    8,   9,'rgba(0,0,0,.35)',1);//robeR Rightshadow
      sx =0*z;
      sy = 0*z;
      sz = 1;
      drawShape('qua',x+sx,y+sy,z*sz,  5.4,2.45,   5.25,9,    8,9,  6.5,3.5,'darkred',1);//robeR 
      drawShape('qua',x+sx,y+sy,z*sz,  4.6,2.5,   4.75,9,    2,9,  3.85,2,'darkred',1);//robeL
      sx =0*z;
      sy = 0*z;
      sz = 1;
      //drawShape('qua',x+sx,y+sy,z*sz, 4.65, 2.4,   4.5, 6.75,    3.5, 6.75,    3.5, 1.6,'darkred',1);//robeL LEft
      //drawShape('qua',x,y,z,  4,2,   3.25,2,    3.33,7.2 ,  3.9, 3.9,'rgba(0,0,0,.5)',1);
       sx =-.75*z;
      sy = -.8*z;
      sz = 1;
      drawShape('qua',x+sx,y+sy,z*sz, 6.5,3.5,  6.9, 4,    8,   5.5,    8, 9,'rgba(0,0,0,.2)',1);//robeR Right
      sx =.75*z;
      sy = -.8*z;
      sz = 1;
      drawShape('qua',x+sx,y+sy,z*sz, 3.5,3.5,  3.1, 4,    2,   5.5,    2, 9,'rgba(0,0,0,.2)',1);//robeR Right
      sx =1.25*z;
      sy = -.5*z;
      sz = .75;
      drawShape('qua',x+sx,y+sy,z*sz, 4,2.25, 5,2.25, 4.5,2.5, 4.25,6,'gold',1);//bangs left
      drawShape('qua',x+sx,y+sy,z*sz, 6,2.25, 5,2.25, 5.5,2.5, 5.75,6,'gold',1);//bangs left
      sx =-1*z;
      sy = -4*z;
      sz = 1.13;
      
      drawShape('qua',x+sx,y+sy,z*sz, 7.5,9.05, 7.4,8.75, 7.25,8.8, 7.25,9,'rgb(160,100,70)',1);//rightfingers

      drawShape('qua',x+sx,y+sy,z*sz, 6.7,8.39, 7,8.9, 7.1,8.8, 6.84,8.1,'rgb(185,122,87)',1);//right forearm
      drawShape('qua',x+sx,y+sy,z*sz, 7,8.85, 7.1,9.05, 7.5,9.05, 7.4,8.75,'rgb(185,122,87)',1);//right hand
      drawShape('rec',x,y,z,7.25,2, .1,6,0,0,0,0,'gold',1);
      drawShape('qua',x+sx,y+sy,z*sz, 7.1,9.05, 7.5,9, 7.25,8.95, 7,8.85,'rgb(170,110,70)',1);//rightthumb
      sx =-.6391*z;
      sy = -.6*z;
      sz = 1.13;
      drawShape('qua',x+sx,y+sy,z*sz,  3.99,2.3,   3.3,1.6,    3.16,1.9,   3.99, 3.66,'white',1);//left arm
      sx =-.16*z;
      sy = -3.87*z;
      drawShape('qua',x+sx,y+sy,z*sz,  2.9,5,   2.75,4.9,    2.72,4.3,   3.1, 4.8,'white',1);//left forearm white
      
      drawShape('qua',x+sx,y+sy,z*sz, 2.75,4.7, 2.75,4.31, 2,3.78, 2.5,4.4,'rgb(185,122,87)',1);//left finger/wrist
      drawShape('qua',x+sx,y+sy,z*sz, 2.75,4.7, 2.75,4.31, 2.2,3.6, 2.5,4.4,'rgb(185,122,87)',1);//left finger/wrist
      drawShape('qua',x+sx,y+sy,z*sz, 2.5,4.4, 2.2,4.2, 2.6,4, 2.75,4.5,'rgb(185,122,87)',1);//left hand
      drawShape('tri',x+sx,y+sy,z*sz, 2.55,4.07, 2.6,4.15, 2.3,4.2, 2.5,4.4,'rgb(165,102,67)',1);//left finger shadow
      
      sx =0*z;
      sy = -1*z;
      sz = 1;
      drawShape('tri',x+sx,y+sy,z*sz, 5,2.5, 5.15,2.85, 5,2.85, 0,0,'rgba(0,0,0,.25)',1);//nose
      drawShape('tri',x+sx,y+sy,z*sz, 4.8,3, 5.2,3, 5,3.05, 0,0,'rgba(255,0,0,.25)',1);//mouth
      drawShape('tri',x+sx,y+sy,z*sz, 4.6,2.55, 4.9,2.55, 4.75,2.58, 0,0,'rgba(0,0,0,.25)',1);//left eye
      drawShape('tri',x+sx,y+sy,z*sz, 5.4,2.55, 5.1,2.55, 5.25,2.58, 0,0,'rgba(0,0,0,.25)',1);//left eye

      drawShape('rec',x,y,z,4.97,3, .06,.6,0,0,0,0,'rgb(0,0,0)',1);
      drawShape('rec',x,y,z,4.85,3.2, .3,.06,0,0,0,0,'rgb(0,0,0)',1);

      drawShape('rec',x,y,z,4.97,4.5, .06,.6,0,0,0,0,'rgb(0,0,0)',1);
      drawShape('rec',x,y,z,4.85,4.7, .3,.06,0,0,0,0,'rgb(0,0,0)',1);

      drawShape('rec',x,y,z,4.97,6, .06,.6,0,0,0,0,'rgb(0,0,0)',1);
      drawShape('rec',x,y,z,4.85,6.2, .3,.06,0,0,0,0,'rgb(0,0,0)',1);
      drawShape('rec',x,y,z,6.75,2.5, 1.2,.1,0,0,0,0,'gold',1);
      drawShape('rec',x,y,z,6.5,2.75, 1.70,.1,0,0,0,0,'gold',1);           
      drawShape('rec',x,y,z,6.75,3, 1.2,.1,0,0,0,0,'gold',1);
    break;
    case 6://The Lovers spell
       //sx = 1.275*z;
       //sy = 1.275*z;
       //sz = .75;
			//drawShape('tri',x+sx,y+sy,z*sz,0,6.59,5,10,10,6.6,0,0,'rgb(255,72,72)',1);
			//drawShape('arc',x+sx,y+sy,z*sz,2.25,3.7,3.63,0,6,0,0,0,'rgb(255,72,72)',1);
			//drawShape('arc',x+sx,y+sy,z*sz,7.75,3.7,3.63,0,6,0,0,0,'rgb(255,72,72)',1);
			//drawShape('arc',x+sx,y+sy,z*sz,5,7,3,3,0,0,0,0,'rgb(255,72,72)',1);
      
      //wandfor (let i = 0; i < 20; i++){drawShape('ell',x,y,z, 4+i*.001, 5+i*.001, 6-i*.01, 0+i*.01, 4, 0, 2, 0, `rgba(${255},${195+i},${255},1)`,0)}
  drawShape('arc',x,y,z,5,5,5,0,2,0,0,0,'rgba(255,255,0,.25)',1);

  for (let i = 0; i < 25; i++){
      drawShape('ell',x,y,z, 5+i*.001, 5.5+i*.001, 4-i*.01, 0+i*.01, -4, 0, 2, 0, `rgba(${255},${235+i},${255},1)`,0)
  }
  for (let i = 0; i < 30; i++){
    //                                                                  CHANGE THIS 0 TO 4
    drawShape('ell',x,y,z, 5+i*.001, 5.5+i*.001, 6-i*.01, 0+i*.01, 4, 0, 2, 0, `rgba(${255},${225+i},${255},1)`,0)
        if (i == 30){drawShape('ell',x,y,z, 5+31*.001, 5.5+31*.001, 6-31*.01, 0+31*.01, 4, 0, 2, 0, `rgba(${0},${0},${0},1)`,1)
}
  }
      drawShape('pol',x,y,z,0.2,1, .25,.5, 1.9,2, 2.5,3,'rgb(252,165,3)',1,1.6,2.5);//handle
      drawShape('tri',x,y,z,0,.5, .7,.5, 0,1.2 ,0,0,'rgb(252,165,3)',1);//pommel
      drawShape('pol',x,y,z,2.5,1.5, 1,3 ,1,3.5 ,2,2.5,'rgb(252,165,3)',1,3,1.5);//hilt guard
      
      sx = 0.5*z;
       sy = 2*z;
       sz = .75;
      drawShape('pol',x+sx,y+sy,z*sz,10.8,0, 10.75,-.5, 8.1,2, 7.5,3,'rgb(252,165,3)',1,8.4,2.55);//handle
       sx = 1.25*z;
       sy = 1.25*z;
       sz = .75;     
      drawShape('tri',x+sx,y+sy,z*sz,10,.5, 9.3,.5, 10,1.2 ,0,0,'rgb(252,165,3)',1);//pommel
        sx = 1.4*z;
       sy = 1.6*z;
       sz = .75;    
      drawShape('pol',x+sx,y+sy,z*sz,7.5,1.5, 9,2 ,9,2.5 ,8,2.5,'rgb(252,165,3)',1,7,1.75);//hilt guard
      drawShape('pol',x+sx,y+sy,z*sz,8.5,2, 9,2 ,9,2.5 ,8,2.5,'rgba(0,0,0,.2)',1,8,2);//hilt guard

      break;
    case 7://The Chariot item (winged boot)
    			drawShape('qua',x,y,z,4.9,1, 5.1,.7, 5.22,.9, 3.4,6.4,'gray',1);
			drawShape('qua',x,y,z,4.75,2, 4.75,2, 5.5,4.2, 3.3,6.4,'rgba(128,64,0,1)',1);
			drawShape('qua',x,y,z,3.5,1, 5,9.45, 8.3,7.4, 8.5,1,'rgba(128,64,0,1)',1)
			drawShape('qua',x,y,z,3.75,1, 6,9.45, 4.5,7.4, 8,1,'rgba(0,0,0,.06)',1)
			drawShape('qua',x,y,z*1.1,7.8,1, 8,.7, 8.3,4.2, 6.3,6.4,'lightgray',1);
			drawShape('qua',x,y,z*1.1,7.8,1, 8,.7, 8.02,.9, 6.3,6.4,'gray',1);
			drawShape('ell',x,y,z,4,7.2, 2.9,2.4,1,0,6,0,'rgba(128,64,0,1)',1);
			drawShape('ell',x,y,z,4,7.2, 2.9,2.4,1,0,6,0,'rgba(0,0,0,.06)',1);
      break;
    case 8://Strength spell
        drawShape('arc',x,y,z,5,5,5,0,2,0,0,0,'rgba(255,255,0,.25)',1);


        drawShape('qua',x,y,z,10,3, 5,6, 3,10, 10,7,'rgb(255,187,119)',1);
                drawShape('qua',x,y,z,5,7, 2.5,2.5, 1,2, 3,10,'gray',1);
                drawShape('qua',x,y,z,1,2, 3,.5, 4,2, 2.5,2.5,'rgb(255,187,119)',1);
                drawShape('qua',x,y,z,3,.5, 4,2, 2,2, 2.25,1.25,'rgba(0,0,0,.25)',1);
        drawShape('ell',x,y,z,7.65,5.5, 2.8,2, 0,.65,-.19,.5,'rgb(255,187,119)',1);
        drawShape('ell',x,y,z,6.7,4.5, 2.8,2, 0,-.05,.5,.5,'rgba(0,0,0,.25)',1);
			


        break;
    case 9://Hermit monster
      drawShape('ell',x,y,z,4.59,.8,.65,.5,1,0,6,0,'gray',1);
      drawShape('qua',x,y,z,5.3,1, 6,2.5, 5.5,2.5, 5,1,'gray',1);//hair back
			drawShape('qua',x,y,z,2.5,10,   3,9.5,    5,9,   6.5,9.5,    'brown',1);//mountain
      drawShape('qua',x,y,z,2.5,10,   7,10,    6.5,9.5,   2.5,10,    'brown',1);//mountain
      sx = .15*z;
      sy = .49*z;
      sz=.95;
			drawShape('qua',x,y,z,4.4,8.5,/*tr*/4.75,9.5,/*br*/ 3,9.5,/*l*/4,9,/*tl*/'darkgray',1);//l-foot
			drawShape('qua',x+sx,y+sy,z*sz,4.5,9.5,/*br*/ 4.5,7.7,/*tr*/ 3.3,7.3,/*tl*/ 4.3,9,/*bl*/'darkgray',1);//l-calf
			//drawShape('qua',x+sx,y+sy,z*sz,4.5,9.5,/*br*/ 4.5,7.7,/*tr*/ 3.3,7.3,/*tl*/ 3.9,9,/*b*/'gray',0);//l-calf
			drawShape('qua',x+sx,y+sy,z*sz,4.7,2,5.5,1.5,6,2.5,4.25,2.5,'gray',1);//neck
			drawShape('qua',x+sx,y+sy,z*sz,5.5,7,/*tl*/6.25,7.25,/*tm*/6.75,7.2,/*tr*/ 6.25,9.5,/*b*/'darkgray',1);//r-calf
			//drawShape('qua',x,y,z,6.25,9,/*tl*/6.55,9.5,/*bl*/4.5,9.75,/*bm*/ 6,9,/*br*/'darkgray',1);//r-foot
			drawShape('qua',x,y,z,5.9,8.5,/*tr*/6.25,9.5,/*br*/ 4.8,9.6,/*l*/6,9,/*tl*/'darkgray',1);//l-foot
			drawShape('qua',x,y,z,/*tr*/ 4,2.5, /*tl*/3,1.5, /*bl*/2.5,5, 4,8,'gray',1);//l-arm
		  drawShape('qua',x,y,z,/*tr*/ 4,2.5, /*tl*/3,1.5, /*bl*/2.5,5, 4,8,'rgba(0,0,0,0.15)',1);//l-arm
			drawShape('tri',x+sx,y+sy,z*sz,/*tl*/ 5.55,3.55, /*tr*/6.3,2.5, /*br*/7.7,4, 0,0,'lightgray',1);//r-arm
			drawShape('tri',x+sx,y+sy,z*sz,/*tl*/ 5.6,3.5, /*tr*/6.3,2.5, /*br*/7.7,4, 0,0,'gray',0);//r-arm
			drawShape('arc',x+sx,y+sy,z*sz,6.2,5.75,.4,0,3,0,0,0,'darkgray',1);//r-hand
      drawShape('qua',x+sx,y+sy,z*sz,4,2, 4,4, 3,8, 7.25,7.25,'gray',1);//robeLShoulder
      drawShape('qua',x+sx,y+sy,z*sz,6,2.1, 7.5,3.5, 7.25,7.25, 4,2,'gray',1);//robeLShoulder
      drawShape('qua',x,y,z,7,9, 3,8.5, 3,8.1, 6,7.5,'gray',1);//robeLShoulder
      drawShape('tri',x+sx,y+sy,z*sz,/*br*/ 7.9,3.9, /*tr*/7.3,3.3, /*l*/6.5,5.5, 0,0,'lightgray',1);//r-forearm
			drawShape('tri',x+sx,y+sy,z*sz,/*br*/ 7.9,3.9, /*tr*/7.3,3.3, /*l*/6.5,5.5, 0,0,'gray',0);//r-forearm
      drawShape('qua',x,y,z,/*bl*/ 3,2.5, /*tl*/2.25,1.5, /*tr*/2.5,1, /*br*/ 3.5,2,'lightgray',1);//l-forearm
      drawShape('qua',x,y,z,2.5,1, 1.5,1, 2,1.5, 2.5,1.4,'rgb(185,122,87)',1);//hand left
      //drawShape('arc',x,y,z,2,2.75, .39,0, 3,0, 0,0,'gold',1);////gold orb
      drawShape('arc',x,y,z,2,2.75, .5,0, 3,0, 0,0,'rgba(255,255,0,.05)',1);////gold orb
      sx = 1.62*z;
      sy = 2.35*z;
      sz=.075;
      drawShape('tri',x+sx,y+sy,z*sz,5,0,.5,7.5,9.5,7.5,0,0,'black',0);
      drawShape('tri',x+sx,y+sy,z*sz,5,10,.5,2.5,9.5,2.5,0,0,'black',0);
      drawShape('tri',x+sx,y+sy,z*sz,5,0,.5,7.5,9.5,7.5,0,0,'gold',1);
      drawShape('tri',x+sx,y+sy,z*sz,5,10,.5,2.5,9.5,2.5,0,0,'gold',1);
      sx = 1.25*z;
      sy = 2*z;
      sz=.15;
      drawShape('tri',x+sx,y+sy,z*sz,5,0,.5,7.5,9.5,7.5,0,0,'rgba(255,255,0,.25)',1);
      drawShape('tri',x+sx,y+sy,z*sz,5,10,.5,2.5,9.5,2.5,0,0,'rgba(255,255,0,.25)',1);
      sx = 1.5*z;
      sy = 2.25*z;
      sz=.1;
      drawShape('tri',x+sx,y+sy,z*sz,5,0,.5,7.5,9.5,7.5,0,0,'rgba(255,255,0,.25)',1);
      drawShape('tri',x+sx,y+sy,z*sz,5,10,.5,2.5,9.5,2.5,0,0,'rgba(255,255,0,.25)',1);
      sx = .15*z;
      sy = .49*z;
      sz=.95;
      drawShape('arc',x,y,z,2,2.2, .6,1, 0,1, 1,0,'brown',1);//lantern top
      drawShape('rec',x,y,z,1.5,3.25, 1,.1, 0,1, 1,0,'brown',1);////lantern bottom
      drawShape('rec',x,y,z,1.5,1.99, .1,1.27, 0,1, 1,0,'brown',1);////lantern bottom
      drawShape('rec',x,y,z,1.95,1.99, .1,1.27, 0,1, 1,0,'brown',1);////lantern bottom
      drawShape('rec',x,y,z,2.4,1.99, .1,1.27, 0,1, 1,0,'brown',1);////lantern bottom
      drawShape('ell',x,y,z,2,2.17, .6,.1, 1,1, 0,6,'brown',0);//lantern top
      drawShape('ell',x,y,z,2,2.17, .6,.1, 1,1, 0,6,'rgba(255,255,0,.25)',1);//lantern top
      drawShape('ell',x,y,z,2,3.3, .5,.1, 1,1, 0,6,'brown',1);//lantern top
      drawShape('rec',x,y,z,1.975,1, .05,.6, 0,1, 1,0,'gray',1);////lantern bottom
      drawShape('arc',x,y,z,2,1.55, .1,0, 3,0, 0,0,'brown',1);////gold orb
      drawShape('qua',x,y,z,2.5,1, 1.7,1.1, 2,1.15, 2.5,1.4,'rgb(185,122,87)',1);//hand left
     	drawShape('arc',x+sx,y+sy,z*sz,6,3, .63,0, 3,0, 0,0,'rgba(0,0,0,0.025)',1);//r-shoulder
      drawShape('qua',x+sx,y+sy,z*sz,6,2.1, 7.5,3.5, 7.25,7.25, 4,2,'rgba(0,0,0,0.1)',1);//robeLShoulder
      drawShape('qua',x,y,z,2.5,1, 3,3.5, 7,9, 7,5.5,'gray',1);//crown
      drawShape('qua',x+sx,y+sy,z*sz,7,5, 6,4.75, 6.3,5.5, 6.5,5.5,'rgb(185,122,87)',1);//hand right
      drawShape('rec',x+sx,y+sy,z*sz,6.3,1, .19,8.9, 6.3,3, 0,0,'brown',1);//ankh
      drawShape('rec',x+sx,y+sy,z*sz,6.3,1, .19,8.9, 6.3,3, 0,0,'rgb(0,6,13)',0);//ankh
      drawShape('arc',x+sx,y+sy,z*sz,6.4,1, .25,0, 3,0, 0,0,'brown',1);//ankh circle outer
      drawShape('arc',x+sx,y+sy,z*sz,6.4,1, .25,0, 3,0, 0,0,'rgb(0,6,13)',0);//ankh circle outer
      drawShape('qua',x+sx,y+sy,z*sz,7,5, 6,5, 6.3,5.5, 6.5,5.5,'rgb(185,122,87)',1);//hand right
      drawShape('qua',x+sx,y+sy,z*sz,4.7,5.5,/*tr*/ 3.5,7.5,/*br*/ 4.4,7.7,/*bl*/ 5,6.5,'rgba(0,0,0,.05)',1);//l-thigh shadow
      drawShape('arc',x+sx,y+sy,z*sz,4.25,2.65, .63,0, 3,0, 0,0,'rgba(0,0,0,.025)',1);//l-shoulder
			drawShape('ell',x+sx,y+sy,z*sz,5.15,3.6,1.15,1.75,0,0,6,0,'rgba(0,0,0,.025)',1);//torso
			drawShape('qua',x+sx,y+sy,z*sz,4.5,5.5,/*tl*/6,4.5,/*tr*/ 6.5,7.7,/*br*/ 5.8,8,/*bl*/ 'rgba(0,0,0,.04)',1);//r-thigh
			drawShape('qua',x+sx,y+sy,z*sz,6.2,4.3,7.25,7.25,5.1,6.3,4.75,5.25,'rgba(0,0,0,.05)',1);//hip armor
		  drawShape('qua',x+sx,y+sy,z*sz,3,8, 3,2, 5.5,5.5, 7,7.3,'rgba(0,0,0,.05)',1);//groin armor
      drawShape('qua',x+sx,y+sy,z*sz,4,2, 3.5,2.5, 6.5,7.2, 4.2,5,'rbga(0,0,0,.05)',1);//robeLShoulder
      drawShape('qua',x+sx,y+sy,z*sz,4,2, 6.5,2.5, 3.5,7.2, 6.5,5,'rgba(0,0,0,.05)',1);//robeLShoulder
      drawShape('qua',x,y,z,5,1, 4.5,2, 4.75,2.5, 4.5,3,'rgba(255,255,255,.9)',1);//beard l
      drawShape('qua',x,y,z,4.75,2.5, 5.5,2, 5.25,.75, 4,1,'rgb(185,122,87)',1);//head
      drawShape('qua',x,y,z,4.75,2.5, 4.5,2, 4.5,3, 4.5,3,'rgba(255,255,255,.9)',1);//beard l
      drawShape('qua',x,y,z,4.5,2, 5,1.8, 5,1.9, 4.5,2.11,'rgba(255,255,255,.9)',1);//beard l
      drawShape('qua',x,y,z,5.3,1, 5.5,2, 5,3, 4.5,3,'rgba(255,255,255,.9)',1);//beard
      drawShape('tri',x,y,z,5,1.8, 4.5,2, 4.75,2.5, 4.75,2.5,'rgba(255,255,255,.9)',1);//beard
      drawShape('tri',x,y,z,4.5,1, 5.8,2.5, 5.3,1, 4.5,3,'gray',1);//beard
      drawShape('qua',x,y,z,4.1,1.3, 5.3,1, 5.25,.75, 3.9,.75,'gray',1);//crown
      drawShape('qua',x,y,z,4.5,1.5, 4.5,2, 4.7,2, 4.5,1.5,'rgba(0,0,0,.25)',1);//nose
      drawShape('qua',x,y,z,4.5,1.5, 4.9,1.45, 4.75,1.45, 4.7,1.45,'rgba(0,0,0,.25)',1);//eyesr
      drawShape('qua',x,y,z,4.5,1.5, 4.25,1.44, 4.3,1.5, 4.5,1.5,'rgba(0,0,0,.25)',1);//eyesl
      drawShape('qua',x,y,z,4.5,2, 4.7,2.2, 4.8,2, 4.6,2.1,'rgba(255,255,255,.25)',1);//mouth'
      drawShape('arc',x,y,z,4.25,1,.1,0,6,0,0,0,'gray',1);
      drawShape('arc',x,y,z,4.75,.9,.1,0,6,0,0,0,'gray',1);
      drawShape('arc',x,y,z,5.1,.87,.1,0,6,0,0,0,'gray',1);
      drawShape('qua',x,y,z,4.1,1.275, 4.75,1.1, 5.5,2.2, 4.6,1.25,'white',1);//hair back
      break;
    case 10://Wheel of Fortune item (CHEST)
    sx = .6*z;
    sy = .4*z;
    sz = .9;
			drawShape('rec',x+sx,y+sy,z*sz,7.93,1,1.85,9,0,0,0,0,'rgb(185,122,87)',1);
			drawShape('rec',x+sx,y+sy,z*sz,2,.3,6.613,9.7,0,0,0,0,'rgb(185,122,87)',1);
			drawShape('rec',x+sx,y+sy,z*sz,1,.3,1,1,0,0,0,0,'rgb(185,122,87)',1);
			drawShape('arc',x+sx,y+sy,z*sz,1,1.3,1,0,6,0,0,0,'rgb(119,43,79)',1);
			drawShape('arc',x+sx,y+sy,z*sz,8.8,1.3,1,0,6,0,0,0,'rgb(185,122,87)',1);
			drawShape('rec',x+sx,y+sy,z*sz,0,1,2,8,0,0,0,0,'rgb(119,43,79)',1);
			drawShape('tri',x+sx,y+sy,z*sz,0,9,2,10,2,9,0,0,'rgb(119,43,79)',1);
			drawShape('lin',x+sx,y+sy,z*sz,0,4,2,5,0,0,0,0,'black',0);
			drawShape('lin',x+sx,y+sy,z*sz,2,5,10,5,0,0,0,0,'black',0);
			drawShape('rec',x+sx,y+sy,z*sz,5,4,2,2,0,0,0,0,'gold',1);
			drawShape('rec',x+sx,y+sy,z*sz,5.8,4.7,.5,1,0,0,0,0,'black',1);
			break;
    case 11://Justice item
      drawShape('tri',x,y,z,4.5,9.5,5.5,9.5,5,0.5,0,0,'gray',1);
      drawShape('tri',x,y,z,5,9, 3,9.9, 7,9.9,0,0,'gray',1);
       drawShape('qua',x,y,z,8.5,.5, 1.5,1, 1.5,1.1,8.5,.6,'gray',1);
       drawShape('rec',x,y,z,2,1, .02,5, 0,0,0,0,'gray',1);
       drawShape('rec',x,y,z,8,.6, .02,5, 0,0,0,0,'gray',1);
       drawShape('ell',x,y,z,2,6, 1,.3, .5,0, 1,1,'gray',1);
        drawShape('ell',x,y,z,8,5.6, 1,.3, .5,0, 1,1,'gray',1);

    break;
    case 12://Bind spell (hanged man)
       sx = 0*z;
      sy = 0*z;
      drawShape('rec',x+sx,y+sy,z,4.5,1, 1,9, 0,0,0,0,'rgb(128,64,0)',1);
      drawShape('rec',x+sx,y+sy,z,0,.51, 10,.5, 0,0,0,0,'rgb(128,64,0)',1);
      drawShape('qua',x+sx,y+sy,z,0,.6, .5,.4, 1,1.5,0,3,'green',1);
      drawShape('qua',x+sx,y+sy,z,10,.6, 9.5,.4, 9,1.5,10,3,'green',1);
      drawShape('qua',x+sx,y+sy,z,7,.51, 6.75,.75, 7,1.5,7.5,.75,'green',1);
      drawShape('qua',x+sx,y+sy,z,3,.51, 3.25,.75, 3,1.5,2.5,.75,'green',1);
             sx = 0*z;
      sy = -.5*z;
      drawShape('qua',x+sx,y+sy,z,5.5,1, 5,2, 4.9,1.9, 5.1,1.25,'gold',1);//rfoottop
      drawShape('tri',x+sx,y+sy,z,5.5,1, 5.5,1.5, 5,2, 5.1,1.25,'gold',1);//rfootbot
      sx = 1*z;
      sy = 1.5*z;
         drawShape('qua',x+sx,y+sy,z,5.5,1, 5,2, 4.9,1.9, 5.2,1.25,'gold',1);
      drawShape('tri',x+sx,y+sy,z,5.5,1, 5.5,1.5, 5,2, 5.1,1.25,'gold',1);
       sx = 0*z;
      sy = -.5*z
      drawShape('pol',x,y+sy,z,6.25,3.5, 6,3.6, 3.5,3.5, 4.5,4,'brown',1, 6.01,3.9);//llegcalf
      drawShape('pol',x,y+sy,z,3.5,3.5, 3.4,3.75, 3.75,5, 4.25,4.5,'brown',1,4,4);//llegthigh
        drawShape('ell',x,y+sy,z,4.1,3.66, .6,.39, .48,0, 1,1,'brown',1);

      drawShape('qua',x+sx,y+sy,z,5.2,1.6, 5.2,2, 4.9,3, 4.95,1.9,'brown',1);//rlegleft
      drawShape('pol',x+sx,y+sy,z,5.2,2, 4.9,3, 4.75,4.2, 5.5,4.75,'brown',1, 5.3,3);//rlegright
      drawShape('pol',x+sx,y+sy,z,4.25,4.5, 3.75,5, 3.7,4.8, 3.5,5.2,'cyan',1, 4.3,6);//hipclothesleft
      drawShape('pol',x+sx,y+sy,z,4.25,4.5, 4.5,4.75, 4.75,4.2, 5.5,4.75,'cyan',1, 5.8,5.5);//hipclothesright
      drawShape('pol',x+sx,y+sy,z,4.25,4.5, 5.8,5.5, 5.5,6, 4.75,5.8,'cyan',1, 4.3,6);//hipclothesmid
      drawShape('qua',x+sx,y+sy,z,4.8,6.8, 2.6,7.5, 5,9.1, 7.4,7.5,'cyan',1);//arms
      drawShape('qua',x+sx,y+sy,z,4.8,6.8, 2.6,7.5, 5,9.1, 7.4,7.5,'rgba(0,0,0,.05)',1);//arms
      drawShape('qua',x+sx,y+sy,z,4.8,7, 3.5,7.5, 4.8,8, 6.5,7.5,'rgba(0,0,0,.45)',1);//arms
      drawShape('arc',x,y,z,5,8.75,1,0,3,0,0,0,'rgba(255,255,255,1)',1);//r-hand
      drawShape('arc',x,y,z,5,8.75,1.1,0,3,0,0,0,'rgba(255,255,0,.25)',1);//r-hand
      drawShape('arc',x,y,z,5,8.75,1.15,0,3,0,0,0,'rgba(255,255,0,.25)',1);//r-hand
      drawShape('arc',x,y,z,5,8.75,1.2,0,3,0,0,0,'rgba(255,255,0,.25)',1);//r-hand
      drawShape('arc',x,y,z,5,8.75,1.25,0,3,0,0,0,'rgba(255,255,0,.25)',1);//r-hand
      drawShape('arc',x,y,z,5,8.75,1.3,0,3,0,0,0,'rgba(255,255,0,.25)',1);//r-hand


      

      drawShape('pol',x+sx,y+sy,z,4.3,6, 4,7.5, 4.1,8.5, 5.85,8.5,'cyan',1, 5.8,8);//tunicl
      drawShape('qua',x+sx,y+sy,z,5.8,8, 5.5,6, 4.75,5.75, 4.3,6,'cyan',1);//tunicr

      drawShape('pol',x+sx,y+sy,z,4.5,8.5, 4.5,8.4, 5,8.25, 5.5,8.4,'rgb(255,179,102)',1, 5.5,8.5);//collar

      drawShape('pol',x,y,z,4.55,8.5, 4.35,9.3, 5,10, 5.6,9.3,'gold',1, 5.4,8.4);//hair

      drawShape('pol',x+sx,y+sy,z,4.55,8.5, 4.8,8.9, 5.25,8.75, 5.3,8.6,'rgb(255,179,102)',1, 5.5,8.5);//neck
      drawShape('pol',x+sx,y+sy,z,4.6,8.75, 4.5,9.75, 5,9.75, 5.5,9.7,'rgb(245,169,92)',1, 5.3,8.5);//neck
      drawShape('pol',x+sx,y+sy,z,4.6,8.75, 4.5,9.75, 5,9.75, 5.5,9.7,'rgb(245,169,92)',1, 5.3,8.5);//head
       sx = 0*z;
      sy = 0*z
            drawShape('tri',x,y,z,4.55,9, 4.8,9.05, 4.95,9, 0,0,'rgba(0,0,0,.7)',1, 5.4,8.4);//hair
            drawShape('tri',x,y,z,5.45,9, 5.2,9.05, 5.05,9, 0,0,'rgba(0,0,0,.7)',1, 5.4,8.4);//hair
            drawShape('pol',x,y,z,5,8.6, 4.9,8.65, 5,8.8, 5,8.65,'rgba(0,0,0,.7)',1, 5.1,8.65);//hair
            drawShape('tri',x,y,z,4.75,8.5, 5,8.45, 5.25,8.5, 0,0,'rgba(255,0,0,.55)',1, 5.4,8.4);//hair
      break;
    case 13://Death monster
      sz = .9;
      sx = .5*z;
      sy=.9*z;
			//arms
			drawShape('arc',x+sx,y+sy,z*sz,3.5,3.5,.5,0,6,0,0,0,'lightgray',1);//l-shoulder
			drawShape('arc',x+sx,y+sy,z*sz,6.5,3.5, .5,0, 6,0,0,0,'lightgray',1);//r-shoulder
			drawShape('arc',x+sx,y+sy,z*sz,3.5,3.5,.5,0,6,0,0,0,'black',0);//l-shoulder-shadow
			drawShape('arc',x+sx,y+sy,z*sz,6.5,3.5,.5,0,6,0,0,0,'black',0);//r-shoulder-shadow
			drawShape('tri',x+sx,y+sy,z*sz,3,3.5,3.5,4,2,5,0,0,'lightgray',1);//l-arm
			drawShape('tri',x+sx,y+sy,z*sz,7,3.5,6.5,4,8,5,0,0,'lightgray',1);//r-arm
			drawShape('tri',x,y,z,2.75,5.1, 2.3,5.4, 2,6.5,0,0,'lightgray',1);//l-forearm
      
      drawShape('tri',x,y,z,7.25,5.1, 7.7,5.4, 8,6.5,0,0,'lightgray',1);//l-forearm
      drawShape('pol',x,y,z,7.9,6.25, 7.88,6.3, 8.1,7, 8,6.5,'lightgray',1,8,6.75);//r-hand
			drawShape('pol',x,y,z,8,6.25, 7.8,6.3, 7.6,7, 8,6.5,'lightgray',1,8.25,6.75);//r-hand
			//lower body
			
      drawShape('pol',x,y,z,2,6, 1.9,6.8, 2.25,6.5, 2.2,6,'lightgray',1,2,6.75);//l-hand
			//drawShape('pol',x,y,z,2,6.25, 2.2,6.3, 2.4,7, 2,6.5,'lightgray',1,1.75,6.75);//l-hand
			//lower body
			drawShape('tri',x+sx,y+sy,z*sz,4,10,1.75,10,3.5,9.3, 0,0,'lightgray',1);//l-foot
			drawShape('tri',x+sx,y+sy,z*sz,6,10,8.25,10,6.5,9.3, 0,0,'lightgray',1);//l-foot
      sx =0*z;
      sy = -.25*z;
      sz = 1;
      drawShape('qua',x+sx,y+sy,z*sz, 5.4,3.35,    5,3.6,    6,6,   5.4, 3.35,'lightgray',1);//shirt right
      drawShape('qua',x+sx,y+sy,z*sz,   5, 3.6,  4.5,  3.25, 4.25,    6,    6,   6,'lightgray',1);//shirt left
      drawShape('rec',x+sx,y+sy,z*sz,4,4.65,2,.3,0,0,0,0,'rgba(0,0,0,.75)',0);
      drawShape('rec',x,y,z,4.5,3, 1,6,0,0,0,0,'lightgray',1);
      //drawShape('tri',x,y,z, 7.14,5.6,  7.5, 7.25,    7.44,   5,    8,   9,'rgba(0,0,0,.35)',1);//robeR Rightshadow
      sx =0*z;
      sy = .5*z;
      sz = 1;
      drawShape('qua',x+sx,y+sy,z*sz,  5,2.45,   5.2,9,    8,9,  6.5,3,'gray',1);//robeR 
      drawShape('qua',x+sx,y+sy,z*sz,  5,2.5,   4.75,9,    2,9,  3.5,3,'gray',1);//robeL
      sx =-.75*z;
      sy = -.3*z;
      sz = 1;
      drawShape('qua',x+sx,y+sy,z*sz, 6.5,3.5,  6.9, 4,    8,   5.5,    8, 9,'rgba(0,0,0,.2)',1);//robeR Right
      sx =.75*z;
      sy = -.3*z;
      sz = 1;
      drawShape('qua',x+sx,y+sy,z*sz, 3.5,3.5,  3.1, 4,    2,   5.5,    2, 9,'rgba(0,0,0,.2)',1);//robeR Right
      sy = .5*z;
      drawShape('qua',x,y+sy,z, 5.4,2.5, 5.55, 2.5,    6.1,  3,  6.5, 3.5,'gray',1);//right shoulder
      sz = 1.2;
      sx = -1*z;
      sy=0*z;
      drawShape('pol',x+sx,y+sy,z*sz,5,.5, 4,1, 3.5,2.5, 4,3.5,'gray',1,5,4);//hood
			drawShape('pol',x+sx,y+sy,z*sz,5,.5, 6,1, 6.5,2.5, 6,3.5,'gray',1,5,4);//hood
			drawShape('pol',x+sx,y+sy,z*sz,5,1.39, 5.9,1.2, 6.3,2.5, 5.8,3.3,'rgba(0,0,0,.45)',1,5,3.8);//hoodinner
			drawShape('pol',x+sx,y+sy,z*sz,5,1.39, 4.1,1.2, 3.7,2.5, 4.2,3.3,'rgba(0,0,0,.45)',1,5,3.8);//hoodinner
      sz = 1;
      sx = 0*z;
      sy=.4*z;
      drawShape('lin',x+sx,y+sy,z*sz,4.5,3.5, 5,4.5, 0,0, 0,0,'rgb(255,126,60)',0);//string
      drawShape('lin',x+sx,y+sy,z*sz,5.5,3.5, 5,4.5, 0,0, 0,0,'rgb(255,126,60)',0);//string
      drawShape('arc',x+sx,y+sy,z*sz,5,4.6,.13,0,6,0,0,0,'darkred',1);//amulet
      drawShape('arc',x+sx,y+sy,z*sz,5,4.6,.1,0,6,0,0,0,'red',1);//amulet
      sz = .9;
      sx = .5*z;
      sy=.9*z;
      //head
			drawShape('arc',x+sx,y+sy,z*sz,5,1.5,1.5,0,6,0,0,0,'lightgray',1);//head
      drawShape('pol',x,y,z,5,.6, 3.8,1.3, 4.5,1.6, 5,1.75,'gray',1,6.2,1.3);//hood

			drawShape('arc',x+sx,y+sy,z*sz,5.55,1.5,.5, -.2,1,0,0,0,'black',1);//r-eye
			drawShape('arc',x+sx,y+sy,z*sz,4.45,1.5,.5,0,1.2,0,0,0,'black',1);//l-eye
      drawShape('ell',x+sx,y+sy,z*sz, 5,   3,  .75,.5,0,0,6,0,'lightgray',1);//jaw
			drawShape('ell',x+sx,y+sy,z*sz,4.88,2.25,.1,.15,0,0,6,0,'black',1);//nose
			drawShape('ell',x+sx,y+sy,z*sz,5.1,2.25,.1,.15,0,0,6,0,'black',1);//nose
			drawShape('lin',x,y,z,4.5,3.7,5.5,3.7,0,0,0,0,'black',0);//mouth

      drawShape('rec',x,y,z,2,.5,.2,9.5,0,0,0,0,'rgb(200,80,40)',1);//scythehandle

			drawShape('tri',x,y,z,2.2,6.5, 2.2,6.3, 2,6.7, 2,6.5,'lightgray',1,1.75,6.75);//l-hand
			drawShape('tri',x,y,z,2,6.5, 2.2,6.7, 2,6.6, 2,6.5,'lightgray',1,1.75,6.75);//l-hand
			drawShape('tri',x,y,z,2,6.7, 2.2,6.9, 2,6.8, 2,6.5,'lightgray',1,1.75,6.75);//l-hand
			drawShape('tri',x,y,z,2,6.6, 2.2,6.8, 2,6.7, 2,6.5,'lightgray',1,1.75,6.75);//l-hand
      drawShape('pol',x,y,z,2,1, 2,.25, 5,.25, 6.7,.6,'lightgray',1,6,.5);//l-hand
			drawShape('ell',x,y,z,4.5,.75, 2.5,.5, .1,1.2,0,0,'lightgray',1);//nose		
      break;
    case 14://Temperance spell? item? (taiji)
    drawShape('arc',x,y,z,5,5,5,0.5,1.5,0,0,0,'white',1);//l-shoulder
    drawShape('arc',x,y,z,5,5,5,1.5,.5,0,0,0,'rgb(39,39,39)',1);//l-shoulder
    drawShape('arc',x,y,z,5,2.5,2.5,2,0,0,0,0,'rgb(39,39,39)',1);//l-shoulder
    drawShape('arc',x,y,z,5,7.5,2.5,2,0,0,0,0,'white',1);//l-shoulder
    drawShape('arc',x,y,z,5,2.5,1,2,0,0,0,0,'white',1);//l-shoulder
    drawShape('arc',x,y,z,5,7.5,1,2,0,0,0,0,'rgb(39,39,39)',1);//l-shoulder
    break;
    case 15://Goblin monster(...)
      drawShape('pol',x,y,z,0,7-Math.random()*.1, 5,Math.random()*.5, 10,7-Math.random()*.1, 8,10,'rgba(41,121,255,.15)',1,2,10);//lower arm R

      drawShape('qua',x,y,z,5,9,6,9,7,8,6,8,'darkgreen',1);//IL-foot
			drawShape('qua',x,y,z,6,8,7,8,4,6,4,7,'darkgreen',1);//IL-calf+knee
			drawShape('tri',x,y,z,4,6,7,5,5,7,0,0,'darkgreen',1);//IL-thigh
			drawShape('tri',x,y,z,7,5,8,5,8,6,0,0,'green',1);//OL-hip
			drawShape('qua',x,y,z,7,5,5,7,6,7,8,6,'green',1);//OL-thigh
			drawShape('qua',x,y,z,5,7,7,9,8,9,6,7,'green',1);//OL-calf+knee
			drawShape('qua',x,y,z,7,9,8,9,7,10,5.5,9.9,'green',1);//OL-foot
			drawShape('tri',x,y,z,3,3,5,5,4,2,0,0,'darkgreen',1);//Inner arm
			drawShape('tri',x,y,z,2.1,5.5,5,5,4.5,4.25,0,0,'darkgreen',1);//Inner forearm
			drawShape('arc',x,y,z,2.5,5.4,.4,0,6,0,0,0,'darkgreen',1);//Inner hand
			drawShape('arc',x,y,z,4.5,3.5,.75,0,6,0,0,0,'darkgreen',1);//T-Ishoulder
			drawShape('arc',x,y,z,5.8,4.4,2.5,1.4,2.25,0,0,0,'brown',1);//T-hump
			drawShape('qua',x,y,z,6,5.5,8,5,5,2,4,3,'brown',1);//T-torso
			drawShape('tri',x,y,z,4,3,5,2,5,3,0,0,'darkgreen',1);//T-neck
			drawShape('arc',x,y,z,5.5,2.5,.75,0,6,0,0,0,'darkgreen',1);//T-Oshoulder
			drawShape('qua',x,y,z,7,5,7,6,8,7,8,5,'brown',1);//T-hip armor
			drawShape('tri',x,y,z,5,3,7,5,6,2,0,0,'green',1);//Outer arm
			drawShape('qua',x,y,z,1,5,1,5.25,10,5.5,10,5.25,'brown',1);//T-spear
			drawShape('tri',x,y,z,4.1,5.5,7,5,6.5,4.25,0,0,'green',1);//Outer forearm
			drawShape('arc',x,y,z,4.5,5.4,.4,0,6,0,0,0,'green',1);//Inner hand
			drawShape('tri',x,y,z,5,0,3,2,5,2,0,0,'red',1);//H-hat
			drawShape('tri',x,y,z,3,2,3,4,5,2,0,0,'green',1);//H-head
			drawShape('tri',x,y,z,3,2,2.25,3.25,3,3,0,0,'green',1);//H-nose
			drawShape('tri',x,y,z,3,3, 3.5,3.25, 3,4,0,0,'black',1);//H-mouth
			drawShape('tri',x,y,z,3,2.5,3,2.75,3.75,2.75,0,0,'red',1);//H-eye(sad)
			//drawShape('tri',x,y,z,3,2.25,3,2.75,3.75,2.1,0,0,'red',1);//H-eye(mad)
			//drawShape('tri',x,y,z,3,2.25,3,2.75,3.75,2.25,0,0,'red',1);//H-eye(neutral)
			drawShape('tri',x,y,z,4,2.25,4,2.75,4.75,1.75,0,0,'darkgreen',1);//H-ear
			drawShape('arc',x,y,z,2.7,3.2,.25,1,1.75,0,0,0,'black',1);//H-nostril
			drawShape('tri',x,y,z,1,4.9,1,5.35,0,5.15,0,0,'lightgray',1);//H-ear
    break;
    case 16://Ruin item? spell? (tower)
      sx = 3.25*z;
      sy = .25*z;
      sz = .2;
      drawShape('arc',x+sx,y+sy,z*sz,5,6.5,3.5,0,2,0,0,0,'rgba(176,9,0,.75)',1);//CRA
			drawShape('tri',x+sx,y+sy,z*sz,1.5,6.5,2,0,8,5,0,0,'rgba(176,9,0,.65)',1);//LRT
			drawShape('tri',x+sx,y+sy,z*sz,10-1.5,6.5,5,0,10-8,5,0,0,'rgba(176,9,0,.65)',1);//CRT
			drawShape('tri',x+sx,y+sy,z*sz,10-1.5,6.5,10-2,0,10-8,5,0,0,'rgba(176,9,0,.65)',1);//RRT
			drawShape('tri',x+sx,y+sy,z*sz,2.5,7.5,2.5,1,7,6,0,0,'rgba(232,220,0,.65)',1);//LYT
			drawShape('tri',x+sx,y+sy,z*sz,10-2.5,7.5,5,1,10-7,6,0,0,'rgba(232,220,0,.65)',1);//CYT
			drawShape('tri',x+sx,y+sy,z*sz,10-2.5,7.5,10-2.5,1,10-7,6,0,0,'rgba(232,220,0,.65)',1);//RYT
			drawShape('arc',x+sx,y+sy,z*sz,5,7.5,2.5,0,2,0,0,0,'rgba(232,220,0,1)',1);//CYA
      
       sx = 6*z;
      sy = .75*z;
      sz = .12;
      drawShape('arc',x+sx,y+sy,z*sz,5,6.5,3.5,0,2,0,0,0,'rgba(176,9,0,.75)',1);//CRA
			drawShape('tri',x+sx,y+sy,z*sz,1.5,6.5,2,0,8,5,0,0,'rgba(176,9,0,.65)',1);//LRT
			drawShape('tri',x+sx,y+sy,z*sz,10-1.5,6.5,5,0,10-8,5,0,0,'rgba(176,9,0,.65)',1);//CRT
			drawShape('tri',x+sx,y+sy,z*sz,10-1.5,6.5,10-2,0,10-8,5,0,0,'rgba(176,9,0,.65)',1);//RRT
			drawShape('tri',x+sx,y+sy,z*sz,2.5,7.5,2.5,1,7,6,0,0,'rgba(232,220,0,.65)',1);//LYT
			drawShape('tri',x+sx,y+sy,z*sz,10-2.5,7.5,5,1,10-7,6,0,0,'rgba(232,220,0,.65)',1);//CYT
			drawShape('tri',x+sx,y+sy,z*sz,10-2.5,7.5,10-2.5,1,10-7,6,0,0,'rgba(232,220,0,.65)',1);//RYT
			drawShape('arc',x+sx,y+sy,z*sz,5,7.5,2.5,0,2,0,0,0,'rgba(232,220,0,1)',1);//CYA
      sx = 2.75*z;
      sy = .25*z;
      sz = .2;
      drawShape('arc',x+sx,y+sy,z*sz,5,6.5,3.5,0,2,0,0,0,'rgba(176,9,0,.75)',1);//CRA
			drawShape('tri',x+sx,y+sy,z*sz,1.5,6.5,2,0,8,5,0,0,'rgba(176,9,0,.65)',1);//LRT
			drawShape('tri',x+sx,y+sy,z*sz,10-1.5,6.5,5,0,10-8,5,0,0,'rgba(176,9,0,.65)',1);//CRT
			drawShape('tri',x+sx,y+sy,z*sz,10-1.5,6.5,10-2,0,10-8,5,0,0,'rgba(176,9,0,.65)',1);//RRT
			drawShape('tri',x+sx,y+sy,z*sz,2.5,7.5,2.5,1,7,6,0,0,'rgba(232,220,0,.65)',1);//LYT
			drawShape('tri',x+sx,y+sy,z*sz,10-2.5,7.5,5,1,10-7,6,0,0,'rgba(232,220,0,.65)',1);//CYT
			drawShape('tri',x+sx,y+sy,z*sz,10-2.5,7.5,10-2.5,1,10-7,6,0,0,'rgba(232,220,0,.65)',1);//RYT
			drawShape('arc',x+sx,y+sy,z*sz,5,7.5,2.5,0,2,0,0,0,'rgba(232,220,0,1)',1);//CYA
      
      
      drawShape('tri',x,y,z,2.5,10,7.5,10,5,8,0,0,'rgb(74,37,0)',1);//mountain
      sx = -1*z;
sy = -5*z;
sz = 3;

for (let i = 28; i > 0; i--) {
    // TOWER LOGIC: 
    // .2 is the width at the very top
    // i * 0.02 adds width for every layer down to the base
    let width = 0.3 + Math.abs(i - 14) * 0.02;

    // Use 'width' variable instead of fixed .5
    drawShape('ell',x+sx,y+sy,z*sz, 2, 2.1+i*.1, width, .15, 0, 2, 0, 0, 'rgba(255,255,255,.4)', 1);
    drawShape('ell',x+sx,y+sy,z*sz, 2, 2.1+i*.1, width, .15, 0, 2, 0, 0, 'rgba(255,255,255,.4)', 0);
    drawShape('ell',x+sx,y+sy,z*sz, 2, 2+i*.1,   width, .15, 0, 2, 0, 0, 'rgba(0,0,0,1)', 1);
}

      drawShape('rec',x,y,z,5.75,2,.5,1,0,0,0,0,'black',1);//door
        drawShape('rec',x,y,z,3.7,2,.5,1,0,0,0,0,'black',1);//door

      drawShape('rec',x,y,z,4.1,4,.5,1,0,0,0,0,'black',1);//window
      drawShape('rec',x,y,z,5,6,.5,1,0,0,0,0,'black',1);//window
      drawShape('rec',x,y,z,4.5,8.9,1,1,0,0,0,0,'black',1);//window

      sx = 5.5*z;
      sy = 7.5*z;
      sz = .2;
      drawShape('arc',x+sx,y+sy,z*sz,5,6.5,3.5,0,2,0,0,0,'rgba(176,9,0,.75)',1);//CRA
			drawShape('tri',x+sx,y+sy,z*sz,1.5,6.5,2,0,8,5,0,0,'rgba(176,9,0,.65)',1);//LRT
			drawShape('tri',x+sx,y+sy,z*sz,10-1.5,6.5,5,0,10-8,5,0,0,'rgba(176,9,0,.65)',1);//CRT
			drawShape('tri',x+sx,y+sy,z*sz,10-1.5,6.5,10-2,0,10-8,5,0,0,'rgba(176,9,0,.65)',1);//RRT
			drawShape('tri',x+sx,y+sy,z*sz,2.5,7.5,2.5,1,7,6,0,0,'rgba(232,220,0,.65)',1);//LYT
			drawShape('tri',x+sx,y+sy,z*sz,10-2.5,7.5,5,1,10-7,6,0,0,'rgba(232,220,0,.65)',1);//CYT
			drawShape('tri',x+sx,y+sy,z*sz,10-2.5,7.5,10-2.5,1,10-7,6,0,0,'rgba(232,220,0,.65)',1);//RYT
			drawShape('arc',x+sx,y+sy,z*sz,5,7.5,2.5,0,2,0,0,0,'rgba(232,220,0,1)',1);//CYA
      
      
    	sx = 3.25*z;
      sy = 5*z;
      sz = .15;
      drawShape('arc',x+sx,y+sy,z*sz,5,6.5,3.5,0,2,0,0,0,'rgba(176,9,0,.75)',1);//CRA
			drawShape('tri',x+sx,y+sy,z*sz,1.5,6.5,2,0,8,5,0,0,'rgba(176,9,0,.65)',1);//LRT
			drawShape('tri',x+sx,y+sy,z*sz,10-1.5,6.5,5,0,10-8,5,0,0,'rgba(176,9,0,.65)',1);//CRT
			drawShape('tri',x+sx,y+sy,z*sz,10-1.5,6.5,10-2,0,10-8,5,0,0,'rgba(176,9,0,.65)',1);//RRT
			drawShape('tri',x+sx,y+sy,z*sz,2.5,7.5,2.5,1,7,6,0,0,'rgba(232,220,0,.65)',1);//LYT
			drawShape('tri',x+sx,y+sy,z*sz,10-2.5,7.5,5,1,10-7,6,0,0,'rgba(232,220,0,.65)',1);//CYT
			drawShape('tri',x+sx,y+sy,z*sz,10-2.5,7.5,10-2.5,1,10-7,6,0,0,'rgba(232,220,0,.65)',1);//RYT
			drawShape('arc',x+sx,y+sy,z*sz,5,7.5,2.5,0,2,0,0,0,'rgba(232,220,0,1)',1);//CYA
      sx = 5*z;
      sy = 3.5*z;
      sz = .15;
      drawShape('arc',x+sx,y+sy,z*sz,5,6.5,3.5,0,2,0,0,0,'rgba(176,9,0,.75)',1);//CRA
			drawShape('tri',x+sx,y+sy,z*sz,1.5,6.5,2,0,8,5,0,0,'rgba(176,9,0,.65)',1);//LRT
			drawShape('tri',x+sx,y+sy,z*sz,10-1.5,6.5,5,0,10-8,5,0,0,'rgba(176,9,0,.65)',1);//CRT
			drawShape('tri',x+sx,y+sy,z*sz,10-1.5,6.5,10-2,0,10-8,5,0,0,'rgba(176,9,0,.65)',1);//RRT
			drawShape('tri',x+sx,y+sy,z*sz,2.5,7.5,2.5,1,7,6,0,0,'rgba(232,220,0,.65)',1);//LYT
			drawShape('tri',x+sx,y+sy,z*sz,10-2.5,7.5,5,1,10-7,6,0,0,'rgba(232,220,0,.65)',1);//CYT
			drawShape('tri',x+sx,y+sy,z*sz,10-2.5,7.5,10-2.5,1,10-7,6,0,0,'rgba(232,220,0,.65)',1);//RYT
			drawShape('arc',x+sx,y+sy,z*sz,5,7.5,2.5,0,2,0,0,0,'rgba(232,220,0,1)',1);//CYA
      
      sx = -6*z;
      sy = -4.5*z;
      sz = 2.1;
     //lightning bolt
      drawShape('qua',x+sx,y+sy,z*sz,4,2.25, 3.9,3.5, 4.25,3,4.25,4.25,'gold',1);//lightning bolt
      sx = -4*z;
      drawShape('qua',x+sx,y+sy,z*sz,6,2.25, 6.1,3.5, 5.75,3,5.75,4.25,'gold',1);//lightning bolt

     sx = -5*z;
      sy = .1*z;
      sz = 2;
     		drawShape('arc',x+sx,y+sy,z*sz,3.25,.5,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        drawShape('arc',x+sx,y+sy,z*sz,3.2,.6,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        drawShape('arc',x+sx,y+sy,z*sz,3.75,.5,.5,0,2,0,0,0,'rgba(255,255,255,.025)',1);//CYA
        
        drawShape('arc',x+sx,y+sy,z*sz,3.85,.55,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        drawShape('arc',x+sx,y+sy,z*sz,3,.5,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        
        drawShape('arc',x+sx,y+sy,z*sz,3.6,.63,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        drawShape('arc',x+sx,y+sy,z*sz,3.9,.53,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
       sy = .75*z;
        drawShape('arc',x+sx,y+sy,z*sz,4.1,.55,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        drawShape('arc',x+sx,y+sy,z*sz,4.4,.59,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        drawShape('arc',x+sx,y+sy,z*sz,4.7,.67,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        drawShape('arc',x+sx,y+sy,z*sz,5.1,.75,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        
        drawShape('arc',x+sx,y+sy,z*sz,5.2,.65,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        drawShape('arc',x+sx,y+sy,z*sz,5.6,.53,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        
        drawShape('arc',x+sx,y+sy,z*sz,6.1,.52,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        drawShape('arc',x+sx,y+sy,z*sz,6.3,.55,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        sy = 0.1*z;
        drawShape('arc',x+sx,y+sy,z*sz,4.4,.51,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        drawShape('arc',x+sx,y+sy,z*sz,4.7,.63,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        drawShape('arc',x+sx,y+sy,z*sz,5.1,.65,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        drawShape('arc',x+sx,y+sy,z*sz,5.2,.55,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        
        drawShape('arc',x+sx,y+sy,z*sz,5.6,.5,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        drawShape('arc',x+sx,y+sy,z*sz,5.9,.6,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        
        drawShape('arc',x+sx,y+sy,z*sz,6.1,.5,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        drawShape('arc',x+sx,y+sy,z*sz,6.3,.55,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
       
        drawShape('arc',x+sx,y+sy,z*sz,6.5,.55,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        
        drawShape('arc',x+sx,y+sy,z*sz,6.6,.5,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        drawShape('arc',x+sx,y+sy,z*sz,6.8,.6,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        
        drawShape('arc',x+sx,y+sy,z*sz,7,.5,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        drawShape('arc',x+sx,y+sy,z*sz,6.9,.55,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        break;
    case 17://star item
      for (let i=0;i<10;i++){
        drawShape('ell',x,y,z,5,2.65,3-i*.01,2.5-i*.01,0,2,0,0,'rgba(160,116,77,1)',0)
      }


      sx = 1.25*z;
      sy = 3.8*z;
      sz = .75;
      const cx = 5, cy = 5;      // center in your 10x10 local grid
      const R  = 3.2;            // outer radius (long points)
      const r  = 1.6;            // inner radius (between points)
      const N  = 8;
      const pts = [];

      // build 16 vertices (outer/inner alternating), start at top
      for (let k = 0; k < 2*N; k++) {
        const ang = -Math.PI/2 + k * (Math.PI / N);   // 22.5 steps
        const rad = (k % 2 === 0) ? R : r;
        pts.push([cx + rad * Math.cos(ang), cy + rad * Math.sin(ang)]);
      }

      // filled star (triangle fan from center)
      for (let k = 0; k < pts.length; k++) {
        const k2 = (k + 1) % pts.length;
        drawShape('tri', x+sx, y+sy, z*sz, cx, cy, pts[k][0], pts[k][1], pts[k2][0], pts[k2][1], 0, 0, 'gold', 1);
      }

      // outline (optional)
      for (let k = 0; k < pts.length; k++) {
        const k2 = (k + 1) % pts.length;
        drawShape('lin', x+sx, y+sy, z*sz, pts[k][0], pts[k][1], pts[k2][0], pts[k2][1], 0, 0, 0, 0, 'black', 0);
      }
      for (let i=0;i<5;i++){
      drawShape('ell',x,y,z,5,5.25,.1-i*.01,.1-i*.01,0,2,0,0,'lightgray',0)

     }
      for (let i=0;i<10;i++){
      drawShape('ell',x,y,z,5,5.1,.1-i*.01,.1-i*.01,0,2,0,0,'rgba(160,116,77,1)',0)

      }
      drawShape('qua',x,y,z,5,5.25, 5,5.5, 5.1,5.5, 5.04,5.25,'gold',1)

      break;
    case 18://Lunacy spell (the moon)
    drawShape('tri',x,y,z, 5,1, 0,10, 10,10,0,0, 'rgba(190,200,255,.15)',1);  

    sx = -15*z;
    sy = 1*z;
    sz = 4;
     // drawShape('arc',x,y,z,5,5,5,0,2,0,0,0,'rgba(255,255,255,.125)',1);
      //drawShape('arc',x,y,z,5,5,4.75,0,2,0,0,0,'rgba(255,255,255,.125)',1);
      //drawShape('arc',x,y,z,5,5,4.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);
      //drawShape('arc',x,y,z,5,5,4.25,0,2,0,0,0,'rgba(255,255,255,.125)',1);

    drawShape('arc',x+sx,y+sy,z*sz,5,1,1,0,2,1,0,0,'gold',1);//moon
      drawShape('arc',x+sx,y+sy,z*sz,5,1,1,0,2,1,0,0,'rgba(0,0,0,.25)',1);//moon
            drawShape('ell',x+sx,y+sy,z*sz,4.5,1,1.25,.75,2,2,0,0,'rgba(0,0,0,.5)',1);//moon

      sx = -16*z;
    sy = 1*z;
    sz = 4;
      drawShape('tri',x+sx,y+sy,z*sz, 5.5,.4, 5,.6, 5.1,.6,0,0, 'rgba(0,0,0,.55)',1);  
      drawShape('tri',x+sx,y+sy,z*sz, 5,.75, 5,1.25, 4.9,1.25,0,0, 'rgba(0,0,0,.55)',1);  
      drawShape('tri',x+sx,y+sy,z*sz, 5,1.5, 5.25,1.45, 5.1,1.5,0,0, 'rgba(0,0,0,.75)',1);  
     // for(let h=0;h<20;h++){ //grid lines
		  //drawShape('lin',x,y,.5*z,h,0,5,5, 0,0,0,0,'green',0);//x line
		 // drawShape('lin',x,y,.5*z,0,h,5,5,0,0,0,0,'green',0);
      
    //  if (h%2 == 0){
     //   drawShape('lin',x,y,.5*z,h,0,5,5,0,0,0,0,'red',0);
     //   drawShape('lin',x,y,.5*z,0,h,5,5,0,0,0,0,'red',0);
     // }
	  //}
      /*drawShape('qua',x,y,z,5.5,.14,4.5,.14,2.5,10,7.5,10,'rgba(255,255,0,.05)',1);
      drawShape('qua',x,y,z,5.5,.14,4.5,.14,2,10,8,10,'rgba(255,255,0,.05)',1);
      drawShape('qua',x,y,z,5.5,.14,4.5,.14,1.5,10,8.5,10,'rgba(255,255,0,.05)',1);

      drawShape('ell',x,y,z,2,1.1, 2,.9, 0,2,0,0,'rgba(255,255,255,.15)',1);//cloud
      drawShape('ell',x,y,z,2.9,.9, 2,.9, 0,2,0,0,'rgba(255,255,255,.15)',1);//cloud
      drawShape('ell',x,y,z,2.3,1, 2,.9, 0,2,0,0,'rgba(255,255,255,.15)',1);//cloud
      drawShape('ell',x,y,z,8,1.1, 2,.9, 0,2,0,0,'rgba(255,255,255,.15)',1);//cloud

      drawShape('ell',x,y,z,3.1,1.1, 2,.9, 0,2,0,0,'rgba(255,255,255,.15)',1);//cloud
      drawShape('ell',x,y,z,3.5,.9, 2,.9, 0,2,0,0,'rgba(255,255,255,.15)',1);//cloud
      drawShape('ell',x,y,z,3.7,1.2, 2,.9, 0,2,0,0,'rgba(255,255,255,.15)',1);//cloud
      drawShape('ell',x,y,z,3.9,1, 2,.9, 0,2,0,0,'rgba(255,255,255,.15)',1);//cloud
      
      drawShape('arc',x,y,z,5,1,1,0,2,1,0,0,'gold',1);//moon
      drawShape('arc',x,y,z,5.1,1,1,0,2,1,0,0,'rgba(0,0,0,.25)',1);//moon
      drawShape('tri',x,y,z, 5.5,.4, 5,.6, 5.1,.6,0,0, 'rgba(0,0,0,.55)',1);  
      drawShape('tri',x,y,z, 5,.75, 5,1.25, 4.9,1.25,0,0, 'rgba(0,0,0,.55)',1);  
      drawShape('tri',x,y,z, 5,1.5, 5.25,1.45, 5.1,1.5,0,0, 'rgba(0,0,0,.75)',1);  

      drawShape('ell',x,y,z,4.4,1.1, 2,.9, 0,2,0,0,'rgba(255,255,255,.15)',1);//cloud
      drawShape('ell',x,y,z,4.9,.9, 2,.9, 0,2,0,0,'rgba(255,255,255,.15)',1);//cloud
      drawShape('ell',x,y,z,5.3,1, 2,.9, 0,2,0,0,'rgba(255,255,255,.15)',1);//cloud
      drawShape('ell',x,y,z,5.6,1.1, 2,.9, 0,2,0,0,'rgba(255,255,255,.15)',1);//cloud
      
      drawShape('ell',x,y,z,6.4,1.1, 2,.9, 0,2,0,0,'rgba(255,255,255,.15)',1);//cloud
      drawShape('ell',x,y,z,6.9,.9, 2,.9, 0,2,0,0,'rgba(255,255,255,.15)',1);//cloud
      drawShape('ell',x,y,z,7.3,1, 2,.9, 0,2,0,0,'rgba(255,255,255,.15)',1);//cloud
      drawShape('ell',x,y,z,7.6,1.1, 2,.9, 0,2,0,0,'rgba(255,255,255,.15)',1);//cloud
      sx=3*z;
      sy=5*z; 
      sz=.45;
      drawShape('qua',x+sx,y+sy,z*sz,4.7,5.5,///*tr*/ //3.5,7.5,/*br*/ 4.4,7.7,/*bl*/ 5,6.5,'lightgray',1);//l-thigh
			//drawShape('qua',x+sx,y+sy,z*sz,4.5,9.1,/*tr*/4.5,9.6,/*br*/ 2,9.6,/*l*/4.5,8.6,/*tl*/'darkgray',1);//l-foot
			//drawShape('qua',x+sx,y+sy,z*sz,4.5,9.5,/*br*/ 4.5,7.7,/*tr*/ 3.3,7.3,/*tl*/ 3.9,9,/*bl*/'darkgray',1);//l-calf
			//drawShape('qua',x+sx,y+sy,z*sz,4.5,9.5,/*br*/ 4.5,7.7,/*tr*/ 3.3,7.3,/*tl*/ 3.9,9,/*b*/'gray',0);//l-calf
			//drawShape('arc',x+sx,y+sy,z*sz,4.25,2.65, .63,0, 3,0, 0,0,'darkgray',1);//l-shoulder
			//drawShape('arc',x+sx,y+sy,z*sz,4.25,2.65, .63,0, 3,0, 0,0,'gray',0);//l-shoulder-shadow
			//drawShape('ell',x+sx,y+sy,z*sz,5.15,3.6,1.15,1.75,0,0,6,0,'lightgray',1);//torso
			//drawShape('qua',x+sx,y+sy,z*sz,4.6,1.5, 5.5,1.5 ,6,2.5, 4.1,2.5,'darkgray',1);//neck
			//drawShape('arc',x+sx,y+sy,z*sz,5,1,.9,0,2,0,0,0,'lightgray',1);//head
      
      //drawShape('tri',x+sx,y+sy,z*sz,3.5,1.5, 4.3,.25, 4.9,2,0,0,'lightgray',1);//helm nose

			//drawShape('tri',x+sx,y+sy,z*sz,3.5,1.5,4.8,1.8,4.9,2,0,0,'rgba(0,0,0,.2)',1);//helm nose
      //drawShape('tri',x+sx,y+sy,z*sz,4.1,.9, 5.6,.4, 4,-.3,0,0,'lightgray',1);//helm nose

     // drawShape('arc',x+sx,y+sy,z*sz,4.95,1,1,0,2,0,0,0,'rgba(0,0,0,.05)',1);//head
			//drawShape('arc',x+sx,y+sy,z*sz,5,1,.9,0,.7,0,0,0,'rgba(0,0,0,.1)',1);//head
			//drawShape('arc',x+sx,y+sy,z*sz,4.9,.9,.9,0,.7,0,0,0,'lightgray',1);//head
			//drawShape('arc',x+sx,y+sy,z*sz,5,1,.8,.7,0,0,0,0,'lightgray',1);//head


     // drawShape('qua',x+sx,y+sy,z*sz,4.5,5.5,/*tl*/6,4.5,/*tr*/ 6.5,7.7,/*br*/ 5.8,8,/*bl*/ 'lightgray',1);//r-thigh
			//drawShape('qua',x+sx,y+sy,z*sz,5.5,8,/*tl*/6.25,7.25,/*tm*/6.75,8,/*tr*/ 6.25,9.5,/*b*/'darkgray',1);//r-calf
			//drawShape('qua',x+sx,y+sy,z*sz,5.5,8,/*tl*/6.25,7.25,/*tm*/6.75,8,/*tr*/ 6.25,9.5,/**/'gray',0);//r-calf
			//drawShape('qua',x+sx,y+sy,z*sz,6.25,9,/*t*/5.6,9.6,/*bl*/6.25,10,/*bm*/ 6.9,9.6,/*br*/'darkgray',1);//r-foot
			//drawShape('tri',x+sx,y+sy,z*sz,6.25,9.5,/*t*/5.75,10,/*bl*/6.75,10,/*br*/ 0,0,'gray',1);//r-toe
			//drawShape('qua',x+sx,y+sy,z*sz,6.2,4.3,7.25,7.25,5.1,6.3,4.75,5.25,'darkgray',1);//hip armor
			//drawShape('qua',x+sx,y+sy,z*sz,6.2,4.3,7.25,7.25,5.1,6.3,4.75,5.25,'gray',0);//hip armor
			//drawShape('qua',x+sx,y+sy,z*sz,4.5,7, 5.2,5, 4.5,5.2, 4.2,5,'darkgray',1);//groin armor
			//drawShape('qua',x+sx,y+sy,z*sz,4.5,7, 5.2,5, 4.5,5.2, 4.2,5,'gray',0);//groin armor

		
      //drawShape('qua',x+sx,y+sy,z*sz,4,4, 5,3.75, 4.7,4.4, 4.5,4.4,'rgb(185,122,87)',1);//hand left
     // drawShape('qua',x+sx,y+sy,z*sz,4,4, 5,4, 4.7,4.4, 4.3,4.4,'rgb(185,122,87)',1);//hand left

		  //drawShape('qua',x+sx,y+sy,z*sz,2.75,1.75, 4.5,2.75, 4.5,5.8, 2.75,4.8,'gray',1);//shield top
			//drawShape('tri',x+sx,y+sy,z*sz,2.75,4.8,4.5,5.8,3.5,7.5,0,0,'gray',1);//shield bot
			//drawShape('lin',x+sx,y+sy,z*sz,3.5,7.6,3.45,2.1,0,0,0,0,'blue',0);//shield cross |
			//drawShape('lin',x+sx,y+sy,z*sz,2.75,4,4.5,5,0,0,0,0,'blue',0);//shield cross--

			//drawShape('tri',x+sx,y+sy,z*sz,/*tl*/ 5.55,3.55, /*tr*/6.3,2.5, /*br*/7.7,4, 0,0,'lightgray',1);//r-arm
		//	drawShape('tri',x+sx,y+sy,z*sz,/*tl*/ 5.6,3.5, /*tr*/6.3,2.5, /*br*/7.7,4, 0,0,'gray',0);//r-arm

			//drawShape('qua',x+sx,y+sy,z*sz,5.9,5, 5.9,5.3, 7.2,5.7, 7.2,5.3,'gold',1);//sword-hilt
			//drawShape('arc',x+sx,y+sy,z*sz,6.2,5.75,.4,0,3,0,0,0,'darkgray',1);//r-hand
			//drawShape('tri',x+sx,y+sy,z*sz,1,4.1, 5.9,4.85, 6.1,5.65,0,0,'white',1);//sword-blade
			//drawShape('qua',x+sx,y+sy,z*sz,6,4, 5.6,5.2, 6,6.3, 6.1,5.5,'gold',1);//sword-crossguard
			//drawShape('arc',x+sx,y+sy,z*sz,6,3, .63,0, 3,0, 0,0,'darkgray',1);//r-shoulder
			//drawShape('arc',x+sx,y+sy,z*sz,6,3, .63,0, 3,0, 0,0,'gray',0);//r-shoulder
			//drawShape('tri',x+sx,y+sy,z*sz,5.3,1.3, 4.95,.05, 5.4,.17, 5.4,.3,'black',1);//helmet visor
      //drawShape('qua',x+sx,y+sy,z*sz,5.8,.7, 3.85,.8, 4.05,.5, 4.15,.6,'black',1);//helmet visor

      //drawShape('tri',x+sx,y+sy,z*sz,/*br*/ 7.9,3.9, /*tr*/7.3,3.3, /*l*/6.5,5.5, 0,0,'lightgray',1);//r-forearm
			//drawShape('tri',x+sx,y+sy,z*sz,/*br*/ 7.9,3.9, /*tr*/7.3,3.3, /*l*/6.5,5.5, 0,0,'gray',0);//r-forearm

      //drawShape('qua',x+sx,y+sy,z*sz,6.9,4.9, 6.1,5.1, 6.4,5.5, 6.7,5.6,'rgb(185,122,87)',1);//hand right
      
      //drawShape('pol',x,y,z,0,9.5, 3.9,9.3, 5.75,9.25, 8.5,9.3,'rgb(185,122,87)',1, 10,9.5);//ground
      //drawShape('qua',x+sx,y+sy,z*sz,6.25,9,/*t*/5.6,9.6,/*bl*/6.25,10,/*bm*/ 6.9,9.6,/*br*/'darkgray',1);//r-foot
     // drawShape('rec',x,y,z,0,9.5, 10,.5, 5.75,9.25, 8.5,9.3,'rgb(185,122,87)',1, 10,9.5);//ground
      //drawShape('pol',x,y,z,7,10, 6.3,9.5, 5,9.4, 4,9.5,'rgba(112,146,190,.75)',1, 3,10);//ground
      //*/
      break;
    case 19://the sun Solar Rite / Hymn to the sun? item
      

      drawShape('qua',x,y,z,0,7.5,10,7.5,7.5,2.5,2.5,2.5,'rgba(128,64,0,1)',1);
			drawShape('qua',x,y,z,.2,7.1,9.8,7.1,7.5,2.5,2.5,2.5,'rgba(255,255,128,1)',1);
			drawShape('lin',x,y,z,5,7.5,5,2.5,0,0,0,0,'rgba(128,64,0,.85)',1);
			drawShape('arc',x,y,z,3.75,3.8,1.79,1.25,1.75,0,0,0,'rgba(255,255,128,1)',1);
			drawShape('arc',x,y,z,6.25,3.8,1.79,1.25,1.75,0,0,0,'rgba(255,255,128,1)',1);
      
      drawShape('qua',x,y,z,4.77,7.2, 4.9,2.4, 4,6, 4.488,6.51,'rgba(0,0,0,.1)',1);
      drawShape('qua',x,y,z,5.188,7.2, 5.1,2.4, 6,6, 5.512,6.51,'rgba(0,0,0,.1)',1);



			drawShape('arc',x,y,z,2.5,7.9,2.4,1.1,1.9,0,0,0,'rgba(248,179,16,.85)',1);
			drawShape('arc',x,y,z,7.5,7.9,2.4,1.1,1.9,0,0,0,'rgba(248,179,16,.85)',1);
      
      for (let i = 0;i<40;i++){
        drawShape('arc',x,y,z,2.5,7.89, 2.39-i*.05,1.1,1.9,0,0,0,'rgba(0,0,0,.25)',0);
			  drawShape('arc',x,y,z,7.5,7.89, 2.39-i*.05,1.1,1.9,0,0,0,'rgba(0,0,0,.25)',0);
      }
      drawShape('rec',x,y,z,0.2,7.13,9.6,.35,0,0,0,0,'rgb(128,64,0)',1);

      drawShape('pol',x,y,z,4.75,8, 4.9,2.42, 5.1,2.42, 5.2,8,'rgba(63,72,204,.45)',1, 5,7.8);
      
      //title
      sx = 2.9*z;
      sy = 2.3*z;
      drawText(x+sx,y+sy,2,.3,'  ','red',z)
      
      //left page
      sx = 2.45*z;
      sy = 2.9*z;
      drawText(x+sx,y+sy,2.5,.75,'      ','red',z)

      sx = 2*z;
      sy = 3.75*z;
      drawText(x+sx,y+sy,2.75,.7,'     ','red',z)

       sx = 1.6*z;
      sy = 4.758*z;
      drawText(x+sx,y+sy,2.9,.8,'      ','red',z)

      //right page
       sx = 5.3*z;
      sy = 2.3*z;
       drawText(x+sx,y+sy,2,.75,'       ','red',z)
       sx = 6*z;
      sy = 4.3*z;
       drawText(x+sx,y+sy,2.25,1.25,'        ','red',z)
      drawShape('pol',x,y,z, 6.5,2.9, 6.25,4.25, 7.1,3.1,5.75,4, 'gold',1,7.25,4);
      drawShape('pol',x,y,z, 5.9,3.1, 6.75,4.25, 6.25,3, 6.5,4.25, 'gold',1,6.5,3.5);
      drawShape('ell',x,y,z,6.5,3.65, .6,.6 ,0,2,0,0,'rgba(255,255,0,.55)',1);//sun shadow

      drawShape('ell',x,y,z,6.5,3.65, .5,.5 ,0,2,0,0,'gold',1);//sun
      drawShape('ell',x,y,z,6.5,3.65, .5,.5 ,0,2,0,0,'rgba(0,0,0,.25)',0);//sun shadow

      break;
    case 20://Horn of judgement item

      drawShape('arc', x, y, z, 5, 5, 4, 0, 2, 0, 0, 0, 'rgba(255,255,0,.05)', 1);
      drawShape('arc', x, y, z, 5, 5, 4.5, 0, 2, 0, 0, 0, 'rgba(255,255,0,.05)', 1);
      drawShape('arc', x, y, z, 5, 5, 5, 0, 2, 0, 0, 0, 'rgba(255,255,0,.05)', 1);

      sx = 0*z;
      sy = .5*z;
      sz = .9;
      
      for (let i = 0; i < 50; i++) {
        let t = i / 50;                   // 0  1
        let cx = 7.5 - t * 5;              // moves left
        let cy = 7.75 - Math.pow(t, 2) * 8; // curves upward (parabola)
        let r  = 2 - t * 2;                // shrinks radius gradually
        drawShape('arc', x+sx, y+sy, z*sz, cx, cy, r, 0, 2, 0, 0, 0, 'gold', 1);
      }

      for (let i = 0; i < 50; i++) {
        let t = i / 50;                   // 0  1
        let cx = 7.5 - t * 5;              // moves left
        let cy = 7.75 - Math.pow(t, 2) * 8; // curves upward (parabola)
        let r  = 2 - t * 2;                // shrinks radius gradually
        drawShape('arc', x+sx, y+sy, z*sz, cx, cy, r, .3, .9, 0, 0, 0, 'rgba(0,0,0,.05)', 1);
        drawShape('arc', x+sx, y+(1*z)+sy, z*sz, cx, cy, r, .3, .9, 0, 0, 0, 'rgba(0,0,0,.05)', 1);

      }
      drawShape('arc',x+sx,y+sy,z*sz,7.5,7.75, 2.02,0,2,0,0,0,'rgba(0,0,0,.45)',0);//horn mouth
      drawShape('arc',x+sx,y+sy,z*sz,7.5,7.75, 2,0,2,0,0,0,'rgba(0,0,0,.45)',0);//horn mouth
      drawShape('arc',x+sx,y+sy,z*sz,7.5,7.75, 2.01,0,2,0,0,0,'rgba(0,0,0,.45)',0);//horn mouth

      drawShape('arc',x+sx,y+sy,z*sz,7.5,7.75, 1.8,0,2,0,0,0,'rgba(0,0,0,.45)',1);//horn mouth
      drawShape('pol',x+sx,y+sy,z*sz,2.95,2, 2.6,.5, 2.55,0, 2.6,0,'gold',1 ,3.36,1.5);//horn mouth
      drawShape('arc',x+sx,y+sy,z*sz,7.5,7.75, 1.8,-.1,.9,0,0,0,'rgba(0,0,0,.15)',1);//horn mouth

    break;
    case 21://World Serpent monster
      for (let i = 0; i < 40; i++) {
        drawShape('ell',x,y,z,5,.6+i*.02,      0+i*.07,   0+i*.01,     0,1.25,1.24,0,`rgba(0,128,0,1)`,0)
      }
      for (let i=0;i<40;i++){  
        drawShape('ell',x,y,z,5,1.65+i*.035,3+i*.05,.75+i*.01, 0,2,1,0,`rgba(0,128,0,1)`,0)
      }
      drawShape('pol',x,y,z,4,10, 3.5,8, 5,5, 4.5,9,'rgba(51,26,0,1)',1,4,8);//root
      drawShape('pol',x,y,z,6,10, 6.5,8, 5,5, 5.5,9,'rgba(51,26,0,1)',1,6,8);//root
      drawShape('pol',x,y,z,2.5,10, 3,8, 5,5, 2,9,'rgba(51,26,0,1)',1,3.5,8);//root
      drawShape('pol',x,y,z,2,10, 4.5,8, 5,5, 3.5,9,'rgba(51,26,0,1)',1,4,8);//root
      drawShape('pol',x,y,z,2,9.5, 4.5,8, 5,5, 4.5,9,'rgba(51,26,0,1)',1,4,8);//root
      drawShape('pol',x,y,z,5.5,1.5, 6,5, 5.75,9.75, 3.5,5,'rgba(103,50,0,1)',1,4.5,1.5);//trunk
      drawShape('pol',x,y,z,5,2, 2,1.5, .5,2.5, 2,2.25,'rgba(93,40,0,1)',1,4.1,3);//branch
      drawShape('pol',x,y,z,5,2.5, 2,2, .5,2.5, 2,2.25,'rgba(0,0,0,.4)',1,4.1,3);//branch
      drawShape('pol',x,y,z,5,3, 8,3.25, 9.5,4, 7.5,3.5,'rgba(93,40,0,1)',1,6,4);//branch
      drawShape('pol',x,y,z,5,3.5, 7.5,3.3, 9.5,4, 7.5,3.5,'rgba(0,0,0,.4)',1,6,4);//branch
      /////////////////////////////////////
      for (let i=0;i<60;i++){
        drawShape('ell',x,y,z,5,9,3-i*.01,.75-i*.01, 0,1,2,0,`rgba(${0},${64-i},${0},1)`,0)
        drawShape('ell',x,y,z,5,8,3-i*.01,.75-i*.01, 0,1,2,0,`rgba(${0},${64-i},${0},1)`,0)
        drawShape('ell',x,y,z,5,7.5,3-i*.01,.75-i*.01, 0,1,2,0,`rgba(${0},${64-i},${0},1)`,0)
        drawShape('ell',x,y,z,5,8.5,3.9-i*.01,.75-i*.01, 0,1,2,0,`rgba(${0},${64-i},${0},1)`,0)
        drawShape('ell',x,y,z,5,6.9,2.5-i*.01,.75-i*.01, 0,1,1.7,0,`rgba(${0},${64-i},${0},1)`,0)
      }
      /////////////////////////////////////
      drawShape('pol',x,y,z,4.5,1.5, 8,1.5, 9,3, 7.5,2.5,'rgba(93,40,0,1)',1,5.5,2.5);//branch
      drawShape('pol',x,y,z,4.5,1.5, 8,2.3, 9,3, 7.5,2.5,'rgba(0,0,0,.4)',1,5.5,2.5);//branch
      drawShape('pol',x,y,z,7.5,10, 7,8, 5,5, 8,9,'rgba(51,26,0,1)',1,6.5,8);//root
      drawShape('pol',x,y,z,8,10, 5.5,8, 5,5, 6.5,9,'rgba(51,26,0,1)',1,6,8);//root
      drawShape('pol',x,y,z,8,9.5, 5.5,8, 5,5, 5.5,9,'rgba(51,26,0,1)',1,6,8);//root
      //leftmost roots
      drawShape('pol',x,y,z,5,1, 6,5, 6.25,9.75, 5,5,'rgba(103,50,0,1)',1,2,9.5);//trunk
      drawShape('pol',x,y,z,1,9.5, 2,7.5, 5,7, 3.5,7.5,'rgba(120,70,37,1)',1,2.25,8.25);//root
      drawShape('pol',x,y,z,1.5,10, 2,8, 5,7, 3.5,7.9,'rgba(160,116,77,1)',1,2.25,8.25);//root
      //rightmost roots
      drawShape('pol',x,y,z,9,9.5, 8,7.5, 5,7, 6.5,7.5,'rgba(120,70,37,1)',1,7.75,8.25);//root
      drawShape('pol',x,y,z,8.5,10, 8,8, 5,7, 6.5,7.9,'rgba(160,116,77,1)',1,7.75,8.25);//root   
      //middle roots
      drawShape('pol',x,y,z,3.5,10, 2,8, 5,5, 3.5,7.9,'rgba(140,96,57,1)',1,3.25,8.25);//root
      drawShape('pol',x,y,z,6.5,10, 8,8, 5,5, 6.5,7.9,'rgba(140,96,58,1)',1,6.75,8.25);//root
      drawShape('pol',x,y,z,5,10, 3.5,8, 5,5, 5,7.55,'rgba(120,70,37,1)',1,4.5,8);//root
      drawShape('pol',x,y,z,5,1, 4,5, 3.75,9.75, 5,5,'rgba(113,60,0,1)',1,8,9.5);//trunk
      //////////////////////////////
      for (let i=0;i<60;i++){
        drawShape('ell',x,y,z,5,8.5,3.9-i*.01,.75-i*.01, 0,2,1,0,`rgba(${0},${64+i},${0},1)`,0)
      }
      /////////////////////////////
      drawShape('pol',x,y,z,5,1, 5.3,5, 8,9.5, 5,5,'rgba(0,0,0,.25)',1,5.1,3.5);//trunk
      drawShape('pol',x,y,z,4.9,1, 5,5, 3.75,9.75, 4.55,6,'rgba(0,0,0,.25)',1,4.5,5);//trunk
      ////////////////////////
      for (let i=0;i<60;i++){
        drawShape('ell',x,y,z,5,8,2.7-i*.01,.75-i*.01, 0,1.9,1.1,0,`rgba(${0},${64+i},${0},1)`,0) 
      }
      ///////////////////////////////
      drawShape('pol',x,y,z,5,10, 6.5,8, 5,5, 5,7.55,'rgba(120,70,37,1)',1,5.5,8);//root
      drawShape('pol',x,y,z,5,10, 4.5,8, 5,5, 5.5,9,'rgba(80,30,0,1)',1,5,8);//root  
      //canopy front lower
      for (let i=0;i<40;i++){
        drawShape('ell',x,y,z,5,1.65+i*.035,3+i*.05,.75+i*.01, 0,1,2,0,`rgba(0,128,0,1)`,0)
      }
      /////Halo/Saturn ring style DO NOT DELETE
      /*const n = 60;                    // more = smoother gradient
      for (let i = 0; i < n; i++) {
        const t  = i/(n-1);            // 01
        const rx = 3   - 0.6*t;        // shrink radii slightly each layer
        const ry = 0.5 - 0.12*t;

        // ---- back half (top) darker: angles 0  1
        const aBack = 0.25 + 0.55*t;   // 0.250.8 alpha ramp
        drawShape('ell', x, y, z,
            5, 2.65, rx, ry,
            0, 0, 1,
        `rgba(80,50,30,${aBack})`, 0);
        // ---- front half (bottom) lighter: angles 1  2
        const aFront = 0.35 + 0.45*(1-t); // 0.80.35 fade
        drawShape('ell', x, y, z,
            5, 2.65, rx, ry,
            0, 1, 2,
            `rgba(200,150,100,${aFront})`, 0);
      }*/
   
      for (let i=0;i<60;i++){
        drawShape('ell',x,y,z,5,9,3-i*.01,.75-i*.01, 0,2,1,0,`rgba(${0},${64+i},${0},1)`,0)
        drawShape('ell',x,y,z,5,7.45,3-i*.01,.75-i*.01, 0,2,1,0,`rgba(${0},${64+i},${0},1)`,0)
        drawShape('ell',x,y,z,5,6.9,2.5-i*.01,.75-i*.01, 0,2.7,1,0,`rgba(${0},${64+i},${0},1)`,0)
        // drawShape('ell',x,y,z,1.8,6.95,2.5-i*.01,.75-i*.01, 0,0,.25,0,`rgba(${0},${64+i},${0},1)`,0)
        // drawShape('ell',x,y,z,1.8,6.95,2.5-i*.01,.75-i*.01, 0,0,.23,0,`rgba(${0},${64+i},${0},1)`,0)
        drawShape('ell',x,y,z*.8,5,7.8,2.3-i*.01,1.6-i*.01, 0,1.7,.6,0,`rgba(${0},${64+i},${0},1)`,0)
        //BOAT from above/Leaf? drawShape('ell',x,y,z,    1+i*.001, 6+i*.001,        2-i*.01,   0+i*.01,  0,    0,   2,    0,   `rgba(${0},${64+i},${0},1)`,0)
        drawShape('ell',x,y,z,    4.4+i*.001, 5.69+i*.001,        0+i*.001,   0+i*.002,  0,    .75,   1.5,    0,   `rgba(${255},${255},${255},1)`,0)
        drawShape('ell',x,y,z,    4.67+i*.000005, 5.680+i*.001,        0+i*.001,   0+i*.002,  0,    1.5,   .2,    0,   `rgba(${255},${255},${255},1)`,0)
        //head
        drawShape('ell',x,y,z,    4.5+i*.001, 5.25+i*.001,        0.2+i*.005,   0+i*.005,  0,    0,   2,    0,   `rgba(${0},${64+i},${0},1)`,0)
        //upper jaw
        drawShape('ell',x,y,z,    4.5+i*.001, 5.5+i*.001,        .5-i*.005,   0+i*.005,  0,    1,   2,    0,   `rgba(${0},${128-i},${0},1)`,0)
        //bottom jaw     
        drawShape('ell',x,y,z,    4.51+i*.001, 5.4+i*.001,        .49-i*.005,   0+i*.01,  0,    2,   1,    0,   `rgba(${0},${64+i},${0},1)`,0)
      }
      drawShape('pol',x,y,z,    4.55, 5.6,   4.5, 6.3,   4.4,6.4,   4.55,6.3,   `rgba(${128},${0},${0},1)`,1, 4.6,6.5)
      drawShape('ell',x,y,z,    4.8, 5.25,   .2, .15,   0,   1.6,  .5,   0,   `rgba(${255},${255},${0},1)`,1, 4.6,6.5)
      drawShape('ell',x,y,z,    4.3, 5.25,   .2, .15,   0,   .5,  1.4,   0,   `rgba(${255},${255},${0},1)`,1, 4.6,6.5)
      drawShape('ell',x,y,z,    4.86, 5.26,   .05, .12,   0,   -.45,  .25,   0,   `rgba(${0},${0},${0},1)`,1, 4.6,6.5)
      drawShape('ell',x,y,z,    4.21, 5.26,   .05, .12,   0,   .75,  -.5,   0,   `rgba(${0},${0},${0},1)`,1, 4.6,6.5)
      ///jormungandr head
    
      break;
    
    case 22: //Wand 1
    
      drawShape('qua',x,y,z,0.2,9.5, 6.21,0, 10,3.77, .2,9.9,'rgba(85,43,0,1)',1);//handle
      drawShape('qua',x,y,z,0.2,9.5, 6.21,.1, 7,.8, .2,9.6,'rgba(0,0,0,.5)',1);//handle
      drawShape('qua',x,y,z,0.2,9.9, 6.5,4.5, 6.52,4.5, .2,9.9,'rgba(0,0,0,.5)',1);//handle
      //drawShape('tri',x,y,z,10,0, 6.21,0, 10,3.77, 0,0,'rgb(109,39,19)',1);//GFR
      drawShape('tri',x,y,z,10,0, 6.21,0, 8.2,2, 0,0,'rgba(255,0,0,.2)',1);//gfl
      drawShape('tri',x,y,z,10,0, 6.21,0, 10,3.77, 0,0,'rgba(209,70,47,.2)',1);//GFR
      //drawShape('tri',x,y,z,10,0, 6.21,0, 8.2,2, 0,0,'rgb(109,39,19)',1);//gfl
      drawShape('tri',x,y,z,6.21,0, 10,3.77, 9,1, 0,0,'rgba(255,0,0,.25)',1);//handle
      drawShape('tri',x,y,z,10,0, 6.21,0, 10,3.77, 0,0,'rgba(255,0,0,.3)',1);//gem mask
      break;
    case 23://Wisp monster2
			drawShape('arc',x,y,z,5,5,5,0,6,0,0,0,'rgba(163,73,164,.25)',1);//glow
			drawShape('arc',x,y,z,5,5,3,0,6,0,0,0,'rgba(163,73,164,.45)',1);//glow
			drawShape('tri',x,y,z,2.3,3.5,1.9,4.5,3,5.3,0,0,'black',1);//glow
			drawShape('tri',x,y,z,3,5.3,5,4.2,5,5.9,0,0,'black',1);//glow
			drawShape('tri',x,y,z,2,5.9,2.9,7,4,6.5,0,0,'black',1);//glow
		break;
		case 24: //scry3
      drawShape('qua',x,y,z,4.2,4.5, .8,9.25, 1.5,9.88, 5.25,5.5,'rgba(128,64,0,1)',1)
      drawShape('arc',x,y,z,6.85,2.75,2.75,0,6,0,0,0,'rgba(255,255,255,.5)',1);
      drawShape('arc',x,y,z,6.75,3,3,0,6,0,0,0,'rgba(255,255,255,.5)',1);
      break;
    case 25://Elixir 4
      drawShape('qua',x,y,z, 4.4,0.75, 5.6,0.75, 5.25,2.45, 4.75,2.45,'rgba(186,103,0,1)',1)//cork
      drawShape('qua',x,y,z, 3.95,3.449, 6.0456,3.4488, 5.5,1.25, 4.5,1.25,'rgba(249,255,255,.28)',1);//bottleneck
      drawShape('arc',x,y,z,5,6.38,  2.8,  1.667,1.337,0,0,0,'rgba(255,0,0,1)',1);//liquid
      drawShape('arc',x,y,z,5,6.25,  3,  1.6163,1.3836,0,0,0,'rgba(249,255,255,.28)',1);//bottle
      drawShape('ell',x,y,z,5,3.95, 1.4,.3, 1, 1,2,0,'rgba(0,0,0,.2)',1);//surface liquid
      drawShape('ell',x,y,z,6.3,5.44, .55,.35, 1, 0,2,0,'rgba(255,255,255,.8)',1);//reflection
    break;
    case 26://Fire5
		  drawShape('arc',x,y,z,5,6.5,3.5,0,2,0,0,0,'rgba(176,9,0,.75)',1);//CRA
			drawShape('tri',x,y,z,1.5,6.5,2,0,8,5,0,0,'rgba(176,9,0,.65)',1);//LRT
			drawShape('tri',x,y,z,10-1.5,6.5,5,0,10-8,5,0,0,'rgba(176,9,0,.65)',1);//CRT
			drawShape('tri',x,y,z,10-1.5,6.5,10-2,0,10-8,5,0,0,'rgba(176,9,0,.65)',1);//RRT
			drawShape('tri',x,y,z,2.5,7.5,2.5,1,7,6,0,0,'rgba(232,220,0,.65)',1);//LYT
			drawShape('tri',x,y,z,10-2.5,7.5,5,1,10-7,6,0,0,'rgba(232,220,0,.65)',1);//CYT
			drawShape('tri',x,y,z,10-2.5,7.5,10-2.5,1,10-7,6,0,0,'rgba(232,220,0,.65)',1);//RYT
			drawShape('arc',x,y,z,5,7.5,2.5,0,2,0,0,0,'rgba(232,220,0,1)',1);//CYA
			break;
		case 27://Amulet6
      drawShape('arc',x,y,z,5,5,5,0,2,0,0,0,'rgba(255,0,0,.25)',1);

         sz = 8;
      sx = -35*z;
      sy=-28*z;
      drawShape('lin',x+sx,y+sy,z*sz,4.5,3.5, 5,4.5, 0,0, 0,0,'rgb(255,126,60)',0);//string
      drawShape('lin',x+sx,y+sy,z*sz,5.5,3.5, 5,4.5, 0,0, 0,0,'rgb(255,126,60)',0);//string
      drawShape('arc',x+sx,y+sy,z*sz,5,4.6,.13,0,6,0,0,0,'darkred',1);//amulet
      drawShape('arc',x+sx,y+sy,z*sz,5,4.6,.1,0,6,0,0,0,'red',1);//amulet
		break;
		case 28://Defense spell7
    	drawShape('arc',x,y,z,5,5,5,0,6,0,0,0,'rgba(0,0,255,.25)',1);//glow
			drawShape('rec',x,y,z,1,1,8,5,0,0,0,0,'gray',1);
			drawShape('tri',x,y,z,1,6,5.1,9,9,6,0,0,'gray',1);
			drawShape('lin',x,y,z,5.1,1,5.1,9,0,0,0,0,'blue',0);
			drawShape('lin',x,y,z,1,3.5,9,3.5,0,0,0,0,'blue',0);
			break;
    case 29://Haste8
          drawShape('arc',x,y,z,5,5,5,0,2,0,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.065)`,1);//bag

    sx = -1*z;
      sy = -1*z;
      sz = 1;
      drawShape('qua',x+sx,y+sy,z*sz,6,8, 9.5,6, 9.3,5.8, 9.35,5.95,'gray',1);
       sx = -1*z;
      sy = -2*z;
      sz = 1;
      drawShape('qua',x+sx,y+sy,z*sz,6,8, 9.5,6, 9.3,5.8, 9.35,5.95,'gray',1);
       sx = 0*z;
      sy = -1*z;
      sz = 1;
      drawShape('qua',x+sx,y+sy,z*sz,6,8, 9.5,6, 9.3,5.8, 9.35,5.95,'gray',1);
			drawShape('pol',x,y,z,0,9.5, 3,9.5, 7,7.4, 4,0.5,'rgba(255,128,64,1)',1,5,6);
			drawShape('tri',x,y,z,5,6, 0,0, 4,0, 4,0.5,'rgba(255,128,64,1)',1,5,6);
      drawShape('qua',x,y,z,6,8, 9.5,6, 9.3,5.8, 9.35,5.95,'gray',1);
      
      
      
      break;	
    case 30://Protect Orb item9
      drawShape('arc',x,y,z,5,5,5,0,2,0,0,0,'rgba(128,64,32,.16)',1);//bag

			sx = -31 *z;
      sy = 1*z;
      sz = 4;
      drawShape('arc',x+sx,y+sy,z*sz,9,1,.8,0,6,0,0,0,'magenta',1);//bag
      drawShape('arc',x+sx,y+sy,z*sz,8.95,.95,.75,0,6,0,0,0,'rgba(255,255,255,.15)',1);//bag
      drawShape('arc',x+sx,y+sy,z*sz,8.9,1,.7,0,6,0,0,0,'rgba(255,255,255,.15)',1);//bag
      drawShape('arc',x+sx,y+sy,z*sz,8.85,1,.65,0,6,0,0,0,'rgba(255,255,255,.15)',1);//bag
      drawShape('arc',x+sx,y+sy,z*sz,8.8,1,.6,0,6,0,0,0,'rgba(255,255,255,.15)',1);//bag
		break;
		case 31://TOME10
      drawShape('arc',x,y,z,5,5,5,0,2,0,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.0316)`,1);//bag
			// hourglass example drawShape('qua',x,y,z,0,10,10,10,2.5,5,7.5,5,'rgba(63,72,204,.45)',1);
			//drawShape('arc',x,y,z,5,5.25,5.3,0,6,0,0,0,'rgba(255,255,255,.45)',1);
			drawShape('qua',x,y,z,0,7.5,10,7.5,7.5,2.5,2.5,2.5,'rgba(128,64,0,.85)',1);
			drawShape('qua',x,y,z,.2,7.1,9.8,7.1,7.5,2.5,2.5,2.5,'rgba(255,255,128,1)',1);

      drawShape('lin',x,y,z,5,7.5,5,2.5,0,0,0,0,'rgba(128,64,0,.85)',1);
			drawShape('qua',x,y,z,5,7.2, 4.8,7.2, 2.5,5.5, 5,2.5,'rgba(0,0,0,.15)',1);
      drawShape('qua',x,y,z,5,7.2, 5.2,7.2, 7.5,5.5, 5,2.5,'rgba(0,0,0,.15)',1);
     // drawShape('qua',x,y,z,4.5,7.1,5.5,7.1, 5.1,2.5, 4.9,2.5,'rgba(0,0,0,.25)',1);
      //drawShape('qua',x,y,z,4.5,7.1,5.5,7.1, 5.1,2.5, 4.9,2.5,'rgba(0,0,0,.25)',1);
      //drawShape('qua',x,y,z,4.75,7.1,5.25,7.1, 5.1,2.5, 4.9,2.5,'rgba(0,0,0,.25)',1);
     // drawShape('qua',x,y,z,4.95,7.1,5.5,7.1, 5.1,2.5, 4.9,2.5,'rgba(0,0,0,.25)',1);

      drawShape('arc',x,y,z,3.75,3.8,1.75,1.25,1.75,0,0,0,'rgba(255,255,128,1)',1);
			drawShape('arc',x,y,z,6.25,3.8,1.75,1.25,1.75,0,0,0,'rgba(255,255,128,1)',1);
			drawShape('arc',x,y,z,2.5,7.9,2.4,1.1,1.9,0,0,0,'rgba(248,179,16,.85)',1);
			
      drawShape('arc',x,y,z,7.5,7.9,2.4,1.1,1.9,0,0,0,'rgba(248,179,16,.85)',1);

      //drawShape('arc',x,y,z,5,3.6,.75,0,2,0,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.37)`,1);//bag
      //drawShape('arc',x,y,z,5,3.6,.75,0,2,0,0,0,`rgba(0,0,0,.15)`,0);//bag
     // drawShape('arc',x,y,z,5,3.6,.75,.5,1.5,1,0,0,`rgba(0,0,0,.15)`,1);//bag
      
      break;
    case 32://Apprentice
          drawShape('qua',x,y,z, 7,3.5, 6.25,4, 7.5,6, 7.6,5.5,'rgba(41,121,205,.55)',1);//upper arm R

      drawShape('qua',x,y,z, 6.5,8.5, .75,9.5, 6,4, 6.5,7.5,'rgb(41,121,205)',1);//Cape Back
      drawShape('qua',x,y,z, 6.5,8.5, .75,9.5, 6,4, 6.5,7.5,'rgba(0,0,0,.8)',1);//Cape Back
      drawShape('qua',x,y,z, 2.75,7.5, 1.5,9.5, 1,9.5, 3.5,5.5,'rgb(0,0,0,.45)',1);//left calf
      drawShape('qua',x,y,z, 5,5, 4,6, 5.5,8, 6.5,8,'rgba(0,0,0,.3)',1);//right thigh
      //drawShape('qua',x,y,z,3.5,3.5,4.5,3,5,3,6,3.6,'rgb(41,121,205)',1);//neck
      drawShape('qua',x,y,z,3.5,3.5,4.5,3,5,3,6,3.6,'rgb(41,121,205)',1);//neck
      drawShape('tri',x,y,z,4.5,3.5, 5,3.5, 5,3.1,6,3.6,'rgb(185,122,87)',1);//neck

      drawShape('qua',x,y,z, 3,3.4, 7,3.6, 1.2,9.3, .75,9.5,'rgba(41,121,205,.4)',1);//Cape Front
      drawShape('qua',x,y,z, 3,3.4, 7,3.6, 1.2,9.3, .75,9.5,'rgba(0,0,0,.17)',1);//body/left leg/cape?
      drawShape('pol',x,y,z, 3,3.6, 7,3.4, 6,5.5, 7,9.5,'rgba(41,121,205,.4)',1,.75,9.5);//body/left leg/cape?

      drawShape('qua',x,y,z, 9,5.5, 9,6.5, 8.5,8, 8.5,6,'rgba(41,121,205,.9)',1,8.5,6);//upper arm L
      drawShape('qua',x,y,z, 9,5.5, 9,6.5, 8.5,8, 8.5,6,'rgba(0,0,0,.6)',1,8.5,6);//upper arm L

      drawShape('qua',x,y,z, 9.1,5.7, 9.5,6, 9.25,6.25, 8.8,6,'rgb(185,122,87)',1);//rHand1
      drawShape('qua',x,y,z, 7.5,5.5, 7.5,6, 9,6, 9.1,5.7,'rgb(185,122,87)',1);//Forearm R
      drawShape('qua',x,y,z, 9.1,5.7, 9.5,6, 9.25,6.25, 8.8,6,'rgb(185,122,87)',1);//rHand2
      drawShape('tri',x,y,z,2.75,1.25, 2.65,1, 3,1.25,0,0,'darkred',1);//knot
      drawShape('tri',x,y,z,2.75,1.25, 2.75,.8, 2.9,1.25,0,0,'darkred',1);//knot
      drawShape('qua',x,y,z,5,1.4, 5,3.5, 5.5,3.5, 7,2,'rgb(51,55,154)',1);//head

      drawShape('qua',x,y,z,5,.9, 3.5,1, 4.5,3.5, 7,2,'rgb(185,122,87)',1);//Head
      drawShape('tri',x,y,z,4.39,3.2, 5.2,3.1, 4.5,3.5,0,0,'rgba(0,0,0,.45)',1);//neck shadow

      drawShape('tri',x,y,z,5.25,2, 5.75,2.5, 5.5,2.5, 0,0,'rgba(0,0,0,.45)',1);//Nose
      drawShape('tri',x,y,z,4.75,2.75, 5.25,2.95, 5.3,2.87, 0,0,'rgba(255,0,0,.25)',1);//mouth

      //drawShape('tri',x,y,z,5.4,2.051, 5.4,2.0515, 5.6,2, 0,0,'rgba(0,0,0,.45)',1);//eye
      drawShape('tri',x,y,z,4.6,1.8, 5.1,2, 5.05,1.92, 0,0,'rgba(0,0,0,.45)',1);//eye
      drawShape('tri',x,y,z,6.16,1.85, 5.5,2.05, 5.45,1.97, 0,0,'rgba(0,0,0,.45)',1);//eye

      drawShape('tri',x,y,z,3.5,1, 3.6,2, 5,1.4,0,0,'rgba(41,121,205,1)',1);//head
      drawShape('qua',x,y,z,3.5,1, 3.5,3.5, 4.5,3.5, 5,1.4,'rgba(41,121,205,1)',1);//head
          drawShape('pol',x,y,z,5,.9, 2,.5, 1.75,.75, 2,.69,'rgba(41,121,205,1)',1,4,3);//head
            drawShape('tri',x,y,z,2,.7, 3.5,2.5, 3.5,1.5,0,0,'rgba(0,0,0,.2)',1);//head

      drawShape('qua',x,y,z,5,1.4, 7,2, 5.5,3.5,6,2,'rgba(0,0,0,.15)',1);//head
       drawShape('tri',x,y,z,3.5,1, 3.6,2, 5,1.4,0,0,'rgba(0,0,0,.15)',1);//head
      drawShape('qua',x,y,z,3.5,1, 3.5,3.5, 4.5,3.5, 5,1.4,'rgba(0,0,0,.15)',1);//head
          drawShape('pol',x,y,z,5,.9, 2,.5, 1.75,.75, 2,.69,'rgba(0,0,0,.15)',1,4,3);//head

      drawShape('qua',x,y,z,5,1.4, 7,2, 5.5,3.5,6,2,'rgba(41,121,205,1)',1);//head
      drawShape('tri',x,y,z,3.5,1, 7,2, 5,.9,0,0,'rgb(41,121,205)',1);//hat
      drawShape('tri',x,y,z,3.5,1, 7,2, 5,.9,0,0,'rgba(0,0,0,.05)',1);//hat
      drawShape('qua',x,y,z,5,1.4, 7,2, 5.5,3.5,6,2,'rgba(0,0,0,.2)',1);//head
      drawShape('tri',x,y,z,3.5,1, 7,2, 5,.9,0,0,'rgba(0,0,0,.2)',1);//hat
      drawShape('tri',x,y,z,3.5,1, 7,2, 5,.9,0,0,'rgba(0,0,0,.05)',1);//hat
      //drawShape('qua',x,y,z*1.4, 4.5,1.25, 5.5,.75, 5,1.25, 4.6,1.17,'darkred',1);//feather

      drawShape('qua',x,y,z, 6.5,8, 5,9.5, 4.5,9.5, 5.5,8,'rgb(0,0,0,.015)',1);//right calf
            

      drawShape('qua',x,y,z, 1.5,7, 1.25,7.25, 1.5,7.5, 2.25,7.25,'rgb(128,0,0)',1);//right calf

      drawShape('qua',x,y,z, 3,3.42, 2.8,4.8, 1.75,6, 1.5,5.5,'rgba(41,121,205,.55)',1);//upper arm L

      drawShape('qua',x,y,z, 1.5,5.5, 1.4,7.1, 1.7,6.9, 2,5.5,'rgb(185,122,87)',1);//Forearm L
      drawShape('qua',x,y,z, 1.4,7.1, 1.4,7.5, 2,7, 1.7,6.8,'rgb(185,122,87)',1);//handL
      drawShape('qua',x,y,z, 1.4,7.5, 2,7.5, 2,7, 1.7,6.8,'rgb(185,122,87)',1);//handL
      drawShape('qua',x,y,z,4.5,9.5, 4.25,9.9, 7,9.9, 5,9.5,'rgb(51,55,154)',1);//rFoot
      drawShape('qua',x,y,z,1,9.5, .75,9.9, 3,9.9,1.5,9.5,'rgb(51,55,154)',1);//lfoot
      drawShape('qua',x,y,z, 2,7, 1.75,7.25, 2,7.5, 4,7.25,'rgb(128,64,0)',1);//right calf
      drawShape('arc',x,y,z,3.75,7.25,.75,0,2,0,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.37)`,1);//bag
      drawShape('arc',x,y,z,9.25,6,.5,0,2,0,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1);//bag
      
      drawShape('pol',x,y,z, 3,3.42, 1.5,5.5, 1.25,7, 2,6.75,'rgba(41,121,205,.9)',1,2.8,4.75);//upper arm L
            drawShape('pol',x,y,z, 3,3.42, 1.5,5.5, 1.25,7, 2,6.75,'rgba(0,0,0,.13)',1,2.8,4.75);//upper arm L
      drawShape('qua',x,y,z, 9,5.5, 8.5,6, 8.5,8, 8.8,6,'rgba(41,121,205,.9)',1,8.5,6);//upper arm L
      drawShape('qua',x,y,z, 8.5,8, 7,6.5, 6,4.5, 6.5,4,'rgba(41,121,205,.9)',1,8.5,6);//upper arm L
      drawShape('qua',x,y,z, 7,3.4, 7.5,5.5, 9,5.5, 8.5,6,'rgba(41,121,205,.9)',1,8.5,8);//upper arm L
      drawShape('qua',x,y,z, 8.25,5.5, 8.5,6, 8.5,8, 7.5,6,'rgba(41,121,205,.9)',1,7.5,5.5);//upper arm L
      drawShape('tri',x,y,z, 8.25,5.5, 7.5,6, 7,3.5, 7.5,6,'rgba(41,121,205,.9)',1,7.5,5.5);//upper arm L
      drawShape('tri',x,y,z, 7,3.4, 6.6,4.25, 7.5,6, 7.5,6,'rgba(41,121,205,.9)',1,7.5,5.5);//upper arm L
      drawShape('tri',x,y,z, 7,3.4, 6.6,4.25, 7.5,6, 7.5,6,'rgba(0,0,0,.2)',1,7.5,5.5);//upper arm L

      drawShape('qua',x,y,z, 9,5.5, 8.5,6, 8.5,8, 8.8,6,'rgba(0,0,0,.1)',1,8.5,6);//upper arm L
      drawShape('qua',x,y,z, 8.5,8, 7,6.5, 6,4.5, 6.5,4,'rgba(0,0,0,.3)',1,8.5,6);//upper arm L
      drawShape('qua',x,y,z, 7,3.4, 7.5,5.5, 9,5.5, 8.5,6,'rgba(0,0,0,.2)',1,8.5,8);//upper arm L
      drawShape('qua',x,y,z, 8.25,5.5, 8.5,6, 8.5,8, 7.5,6,'rgba(0,0,0,.2)',1,7.5,5.5);//upper arm L
      drawShape('tri',x,y,z, 8.25,5.5, 7.5,6, 7,3.5, 7.5,6,'rgba(0,0,0,.2)',1,7.5,5.5);//upper arm L


      
      break;
    case 33://Salamander
      drawShape('arc',x,y,z,5,6.5,3.5,0,2,0,0,0,'rgba(176,9,0,.095)',1);//CRA
			drawShape('tri',x,y,z,1.5,6.5,2,0,8,5,0,0,'rgba(176,9,0,.095)',1);//LRT
			drawShape('tri',x,y,z,10-1.5,6.5,5,0,10-8,5,0,0,'rgba(176,9,0,.095)',1);//CRT
			drawShape('tri',x,y,z,10-1.5,6.5,10-2,0,10-8,5,0,0,'rgba(176,9,0,.095)',1);//RRT
			drawShape('tri',x,y,z,2.5,7.5,2.5,1,7,6,0,0,'rgba(232,220,0,.095)',1);//LYT
			drawShape('tri',x,y,z,10-2.5,7.5,5,1,10-7,6,0,0,'rgba(232,220,0,.095)',1);//CYT
			drawShape('tri',x,y,z,10-2.5,7.5,10-2.5,1,10-7,6,0,0,'rgba(232,220,0,.095)',1);//RYT
			drawShape('tri',x,y,z,1.5,6.5,2,0,8,5,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.025)`,1);//LRT
			drawShape('tri',x,y,z,10-1.5,6.5,5,0,10-8,5,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.025)`,1);//CRT
			drawShape('tri',x,y,z,10-1.5,6.5,10-2,0,10-8,5,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.025)`,1);//RRT
			drawShape('tri',x,y,z,2.5,7.5,2.5,1,7,6,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.025)`,1);//LYT
			drawShape('tri',x,y,z,10-2.5,7.5,5,1,10-7,6,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.025)`,1);//CYT
			drawShape('tri',x,y,z,10-2.5,7.5,10-2.5,1,10-7,6,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.025)`,1);//RYT
      
      sx = .75*z;
      sy = -1*z;
      //rear right arm 2 claws right
      drawShape('pol',x+sx,y+sy,z, 7.25,7.5, 7.5,7.5, 8,8, 7.25,7.75,'rgba(244,69,11,.5)',1,7.2,7.6);//Cape Back
      sx = 5*z;
      sy = -1*z;
      drawShape('pol',x+sx,y+sy,z, 2.75,7.5, 2.5,7.75, 2.5,8.5, 2.8,7.75,'rgb(244,69,11,.5)',1,2.8,7.6);//Cape Back
      //rear right arm 2 claws left
      sx = 5.25*z;
      sy = -1*z;
    //drawShape('pol',x+sx,y+sy,z, 2.75,7.5, 2.5,7.5, 2,8, 2.75,7.75,'rgba(244,69,11,.5)',1,2.8,7.6);//Cape Back
     drawShape('pol',x+sx,y+sy,z, 2.75,7.5, 2.5,7.75, 2.5,8.5, 2.8,7.75,'rgb(244,69,11,.5)',1,2.8,7.6);//Cape Back

      //front l
      sx = 0.2*z;
      sy = -7.25*z;
      sz = 1.5;
      drawShape('pol',x+sx,y+sy,z*sz, 2.5,8.75, 1.5,9.2, 1.75,9.95, 1.9,9.3,'rgb(244,69,11)',1,2.5,9.2);//Cape Back
      //left arm 2 claws left
      drawShape('pol',x,y,z, 2.75,7.5, 2.5,7.5, 2,8, 2.75,7.75,'rgba(244,69,11,.5)',1,2.8,7.6);//Cape Back
      drawShape('pol',x,y,z, 2.75,7.5, 2.5,7.75, 2.5,8.5, 2.8,7.75,'rgb(244,69,11,.5)',1,2.8,7.6);//Cape Back
      //right arm 2 claws right
      drawShape('pol',x,y,z, 7.25,7.5, 7.5,7.5, 8,8, 7.25,7.75,'rgba(244,69,11,.5)',1,7.2,7.6);//Cape Back
      drawShape('pol',x,y,z, 2.75,7.5, 2.5,7.75, 2.5,8.5, 2.8,7.75,'rgb(244,69,11,.5)',1,2.8,7.6);//Cape Back
      
      //left arm 2 claws left
      sx = -4.6*z;
      sy = 0*z;
     drawShape('pol',x+sx,y+sy,z, 7.25,7.5, 7.5,7.5, 8,8, 7.25,7.75,'rgba(244,69,11,.5)',1,7.2,7.6);//Cape Back
     // drawShape('pol',x+sx,y+sy,z, 2.75,7.5, 2.5,7.75, 2.5,8.5, 2.8,7.75,'rgb(244,69,11,.5)',1,2.8,7.6);//Cape Back
      
      //back l
      sx = 1.75*z;
      sy = -8.5*z;
      sz = 1.5;
      drawShape('pol',x+sx,y+sy,z*sz, 2.5,8.75, 1.5,9.2, 1.75,9.95, 1.9,9.3,'rgb(244,69,11)',1,2.5,9.2);//Cape Back
      
      //front r
      sx = -.5*z;
      sy = -7.1*z;
      sz = 1.5;
      drawShape('pol',x+sx,y+sy,z*sz, 4.5,8.7, 5.5,9.2, 5.25,9.95, 5.1,9.3,'rgb(244,69,11)',1,4.5,9.2);//Cape Back
      
      //right arm 2 claws left
      sx = 4.6*z;
      sy = 0*z;
      drawShape('pol',x+sx,y+sy,z, 2.75,7.5, 2.5,7.5, 2,8, 2.75,7.75,'rgba(244,69,11,.5)',1,2.8,7.6);//Cape Back
      drawShape('pol',x+sx,y+sy,z, 2.75,7.5, 2.5,7.75, 2.5,8.5, 2.8,7.75,'rgb(244,69,11,.5)',1,2.8,7.6);//Cape Back

      //back r
      sx = 0*z;
      sy = -8*z;
      sz = 1.5;
      drawShape('pol',x+sx,y+sy,z*sz, 4.5,8.7, 5.5,9.2, 5.25,9.95, 5.1,9.3,'rgb(244,69,11)',1,4.5,9.2);//Cape Back
      //main body and head
      sx = -8.7*z;
      sy = -9.6*z;
      sz = 3;
      for (let i=0;i<60;i++){
        ////////////////////////////
        //floating island top
        // drawShape('ell',x+sx,y+sy,z*sz,    4.5+i*.001, 4.5+i*.001,        .5-i*.005,   0+i*.005,  0,    1,   2,    0,   `rgba(${255},${69-i},${11},1)`,0)
        //floating island botn     
        // drawShape('ell',x+sx,y+sy,z*sz,    4.51+i*.001, 4.4+i*.001,        .49-i*.005,   0+i*.01,  0,    2,   1,    0,   `rgba(${255},${69+i},${11},1)`,0)
        //eclipse
        //drawShape('ell',x+sx,y+sy,z*sz,    4.5+i*.001, 4.75+i*.001,        .2+i*.0025,   0.2+i*.0025,  0,    0,   2,    0,   `rgba(${244},${69+i},${11},1)`,0)
        ///////////////
        //teeth
        drawShape('ell',x+sx,y+sy,z*sz,    4.4+i*.001, 5.69+i*.001,        0+i*.001,   0+i*.002,  0,    .75,   1.5,    0,   `rgba(${255},${255},${255},1)`,0)
        drawShape('ell',x+sx,y+sy,z*sz,    4.67+i*.000005, 5.680+i*.001,        0+i*.001,   0+i*.002,  0,    1.5,   .2,    0,   `rgba(${255},${255},${255},1)`,0)
        //head
        drawShape('ell',x+sx,y+sy,z*sz,    4.75+i*.001, 5+i*.001,        0.2+i*.005,   0+i*.007,  0,    1,   .4,    0,   `rgba(${244},${69+i},${11},1)`,0)
        //body
        drawShape('ell',x+sx,y+sy,z*sz,    4.5+i*.001, 5.25+i*.001,        0.2+i*.005,   0+i*.005,  0,    0,   2,    0,   `rgba(${244},${69+i},${11},1)`,0)
        //upper jaw
        drawShape('ell',x+sx,y+sy,z*sz,    4.5+i*.001, 5.5+i*.001,        .5-i*.005,   0+i*.005,  0,    1,   2,    0,   `rgba(${255},${69-i},${11},1)`,0)
        //bottom jaw     
        drawShape('ell',x+sx,y+sy,z*sz,    4.51+i*.001, 5.4+i*.001,        .49-i*.005,   0+i*.01,  0,    2,   1,    0,   `rgba(${255},${69+i},${11},1)`,0)
        //tail
        drawShape('ell',x+sx-27.75*z,y+sy-27.5*z,z*sz*3,    4.5+i*.001, 4.5+i*.001,        .2+i*.0025,   0.2+i*.003,  0,    1,   .4,    0,   `rgba(${244},${69+i},${11},1)`,0)
      }
      sx = -8.7*z;
      sy = -9.6*z;
      sz = 3;
      drawShape('pol',x+sx,y+sy,z*sz,    4.55, 5.6,   4.5, 6.3,   4.4,6.4,   4.55,6.3,   `rgba(${128},${0},${0},1)`,1, 4.6,6.5)
      drawShape('ell',x+sx,y+sy,z*sz,    4.8, 5.25,   .2, .15,   0,   1.6,  .5,   0,   `rgba(${255},${0},${0},1)`,1, 4.6,6.5)
      drawShape('ell',x+sx,y+sy,z*sz,    4.3, 5.25,   .2, .15,   0,   .5,  1.4,   0,   `rgba(${255},${0},${0},1)`,1, 4.6,6.5)
      drawShape('ell',x+sx,y+sy,z*sz,    4.86, 5.26,   .05, .12,   0,   -.45,  .25,   0,   `rgba(${0},${0},${0},1)`,1, 4.6,6.5)
      drawShape('ell',x+sx,y+sy,z*sz,    4.21, 5.26,   .05, .12,   0,   .75,  -.5,   0,   `rgba(${0},${0},${0},1)`,1, 4.6,6.5)
      //left arm

      break;
    case 34://Witch Queen
      drawShape('pol',x,y,z,0,10-Math.random()*.1, 5,Math.random()*.5, 10,10-Math.random()*.1, 8,10,'rgba(64,0,0,.5)',1,2,10);//lower arm R
      sx = 7*z;
      sy = 1.5*z
      sz = .1;
       drawShape('arc',x+sx,y+sy,z*sz,5,6.5,3.5,0,2,0,0,0,'rgba(176,9,0,.75)',1);//CRA
			drawShape('tri',x+sx,y+sy,z*sz,1.5,6.5,2,0,8,5,0,0,'rgba(176,9,0,.65)',1);//LRT
			drawShape('tri',x+sx,y+sy,z*sz,10-1.5,6.5,5,0,10-8,5,0,0,'rgba(176,9,0,.65)',1);//CRT
			drawShape('tri',x+sx,y+sy,z*sz,10-1.5,6.5,10-2,0,10-8,5,0,0,'rgba(176,9,0,.65)',1);//RRT
			drawShape('tri',x+sx,y+sy,z*sz,2.5,7.5,2.5,1,7,6,0,0,'rgba(232,220,0,.65)',1);//LYT
			drawShape('tri',x+sx,y+sy,z*sz,10-2.5,7.5,5,1,10-7,6,0,0,'rgba(232,220,0,.65)',1);//CYT
			drawShape('tri',x+sx,y+sy,z*sz,10-2.5,7.5,10-2.5,1,10-7,6,0,0,'rgba(232,220,0,.65)',1);//RYT
			drawShape('arc',x+sx,y+sy,z*sz,5,7.5,2.5,0,2,0,0,0,'rgba(232,220,0,1)',1);//CYA
      	drawShape('arc',x+sx,y+sy,z*sz,5,6.5,3.5,0,2,0,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.25)`,1);//CRA

      drawShape('tri',x+sx,y+sy,z*sz,1.5,6.5,2,0,8,5,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.1)`,1);//LRT
			drawShape('tri',x+sx,y+sy,z*sz,10-1.5,6.5,5,0,10-8,5,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.1)`,1);//CRT
			drawShape('tri',x+sx,y+sy,z*sz,10-1.5,6.5,10-2,0,10-8,5,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.1)`,1);//RRT
			drawShape('tri',x+sx,y+sy,z*sz,2.5,7.5,2.5,1,7,6,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.1)`,1);//LYT
			drawShape('tri',x+sx,y+sy,z*sz,10-2.5,7.5,5,1,10-7,6,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.1)`,1);//CYT
			drawShape('tri',x+sx,y+sy,z*sz,10-2.5,7.5,10-2.5,1,10-7,6,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.1)`,1);//RYT
      			drawShape('arc',x+sx,y+sy,z*sz,5,7.5,2.5,0,2,0,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.1)`,1);//CYA

//legs red boots
      sx = -.5*z; 
      sy = -.1*z;
      sz = 1.1;
      drawShape('qua',x+sx,y+sy,z*sz, 5.5,7, 5.8,8.5, 6,8, 6,6.5,'rgba(136,0,21,.65)',1);
      drawShape('qua',x+sx,y+sy,z*sz, 4,7, 4,8.5, 4.25,8.3, 4.5,7,'rgba(136,0,21,.65)',1);
      drawShape('qua',x+sx,y+sy,z*sz, 4,8.25, 3.6,9, 4,8.8, 4.35,8.23,'rgba(230,0,0,.65)',1);
      drawShape('qua',x+sx,y+sy,z*sz, 6,8, 6.3,9, 6,9, 5.7,8.5,'rgba(230,0,0,.65)',1);
      //Empress upper
      sz = .8;
      sx = 1*z;
      sy = .0*z;
      drawShape('qua',x+sx,y+sy,z*sz, 5.25,3, 5.5,3.5, 5,4, 4.5,2.5,'rgb(135,82,47)',1);//neck
      drawShape('qua',x+sx,y+sy,z*sz, 4.5,2.5, 5.5,3.5, 5,4, 4.5,2.5,'rgb(165,102,67)',1);//neckL

      drawShape('qua',x+sx,y+sy,z*sz,4,1.8, 3.9,3, 4.25,3.25, 4.25,1.75,'rgba(64,0,0,1)',1);//bangs left
      drawShape('qua',x+sx,y+sy,z*sz, 5.25,3.5, 4.15,2.25, 5,1.3, 6,2.5,'rgb(185,122,87)',1);//face
      //nose
      sz = .8;
      sx = .8*z;
      sy = .0*z;
      drawShape('tri',x+sx,y+sy,z*sz, 5.45,2.2, 5.4,2.8, 5.6,2.9, 0,0,'rgba(0,0,0,.2)',1);//nose
      //eyes
      sz = .8;
      sx = .8*z;
      sy = .0*z;
      drawShape('tri',x+sx,y+sy,z*sz, 5,2.2, 5.4,2.15, 5.2,2.3, 0,0,'rgba(0,0,0,.25)',1);//eye
      drawShape('tri',x+sx,y+sy,z*sz, 5.5,2.15, 5.9,2, 5.7,2.3, 0,0,'rgba(0,0,0,.25)',1);//eye
      //mouth 
      sz = .8;
      sx = .8*z;
      sy = .0*z;
      drawShape('tri',x+sx,y+sy,z*sz, 5.25,3, 5.6,2.95, 5.4,3.075, 0,0,'rgba(255,0,0,.25)',1);//mouth
      //hair
      sz = .8;
      sx = 1*z;
      sy = .0*z;
      drawShape('qua',x+sx,y+sy,z*sz,5,1.3, 4.2,1.75, 4,2.2, 5,1.85,'rgba(64,0,0,1)',1);//hair
      drawShape('qua',x+sx,y+sy,z*sz,5,1.3, 5.8,1.75, 6,2, 5,1.85,'rgba(64,0,0,1)',1);
       
      drawShape('qua',x+sx,y+sy,z*sz,5.55,1.9, 6,2.5, 5.8,3.4, 6,3.5,'rgba(64,0,0,1)',1);
      drawShape('qua',x+sx,y+sy,z*sz,5.55,1.9, 6,2.5, 5.8,3.4, 6,2,'rgba(64,0,0,1)',1);
      //drawShape('qua',x,y,z,4.25,1.9, 3.8,2.5, 4,3.4, 3.8,3.5,'gold',1);
      drawShape('qua',x+sx,y+sy,z*sz,5,1.8, 4.28,2.07, 4.8,3.4, 4.5,3.5,'rgba(64,0,0,1)',1);
      drawShape('qua',x+sx,y+sy,z*sz,4.28,2.07, 3.85,2.5, 4.05,3.4, 3.85,3.5,'rgba(0,0,0,.25)',1);
      //larm
       sz = .8;
      sx = 1.25*z;
      sy = 1*z;
      drawShape('qua',x+sx,y+sy,z*sz, 3.9,4, 3,6, 3.5,6, 4,5,'rgba(136,0,21,.65)',1);//dress left forearm
        
      drawShape('qua',x+sx,y+sy,z*sz, 3,6, 3.5,6, 3.4,6.3, 3,6.5,'rgb(185,122,87)',1);//left hand
      drawShape('qua',x+sx,y+sy,z*sz, 3.4,6, 2.7,8, 2.4,8, 3.2,5.9,'red',1);//scepter
      drawShape('qua',x+sx,y+sy,z*sz, 3.4,6, 2.7,8, 2.4,8, 3.2,5.9,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.3)`,1);//scepter

       sz = .7;
      sx = 1.7*z;
      sy = 3.45*z;
      drawShape('qua',x+sx,y+sy,z*sz, 3,4, 2.6,3.4, 3,3.5, 3.5,3.4,'rgb(165,102,67)',1);//left hand
         sz = .8;
      sx = 1.36*z;
      sy = .8*z;
      drawShape('tri',x+sx,y+sy,z*sz, 2.6,6.6, 3.5,6.6, 3,6.5, 2.75,9,'rgb(160,100,70)',1);//left fingers
      drawShape('qua',x+sx,y+sy,z*sz, 3.4,6.55, 3.25,6.5, 3.25,6.45, 3.4,6.3,'rgb(170,110,70)',1);//left thumb
      sz = .8;
      sx = 1.25*z;
      sy = 1*z;
      drawShape('qua',x+sx,y+sy,z*sz, 4.5,6, 4.5,4.5, 3.9,4, 4,6,'rgba(136,0,21,.65)',1);//dress left arm
      drawShape('qua',x+sx,y+sy,z*sz, 5,6, 5.5,3, 4.5,4.5, 4.5,6,'rgba(136,0,21,.65)',1);//dress left mid
      //
       sz = .8;
      sx = 1*z;
      sy = .0*z;
      drawShape('qua',x+sx,y+sy,z*sz, 5.5,3.5, 6,3.5, 6.5,3.75, 7.5,5,'rgba(136,0,21,.75)',1);//dress right shoulder n tricep
      drawShape('qua',x+sx,y+sy,z*sz, 6.5,5, 6,6, 7,9.5, 3,9.5,'rgba(136,0,21,1)',1);//dress bottom right n forearm
      drawShape('qua',x+sx,y+sy,z*sz, 7.5,5, 6,6, 7,9.5, 3,9.5,'rgba(0,0,0,.25)',1);//dress bottom right n forearm
      drawShape('qua',x+sx,y+sy,z*sz, 5.5,3.5, 5,4, 5,7.5, 7.5,5,'rgba(136,0,21,.75)',1);//dress collarR
      drawShape('qua',x+sx,y+sy,z*sz, 5,4, 4.8,3.4, 4.5,3.5, 4,4,'rgba(136,0,21,.75)',1);//dress collarL
      drawShape('qua',x+sx,y+sy,z*sz, 4.5,4, 4.25,4.5, 4.25,5, 5,5.75,'rgba(136,0,21,.65)',1);//bl
      drawShape('qua',x+sx,y+sy,z*sz, 5.5,4, 5.75,4.5, 5.75,5, 5,5.75,'rgba(136,0,21,,.65)',1);//br
      drawShape('qua',x+sx,y+sy,z*sz, 5.5,4, 5.05,4.5, 5.05,5, 5.8,5.75,'rgba(136,0,21,,.65)',1);//brmain
           
      //
      sz = .8;
      sx = 2*z;
      sy = .0*z;
      drawShape('qua',x+sx,y+sy,z*sz, 6.1,6, 7,4, 6.5,4, 6,5,'rgba(136,0,21,.65)',1);//dress left forearm
        
      drawShape('qua',x+sx,y+sy,z*sz, 7,4, 6.5,4, 6.6,3.7, 7,3.5,'rgb(185,122,87)',1);//left hand

      drawShape('qua',x+sx,y+sy,z*sz, 7,4, 7.4,3.4, 7,3.5, 6.5,3.4,'rgb(165,102,67)',1);//left hand
        
      drawShape('tri',x+sx,y+sy,z*sz, 7.4,3.4, 6.5,3.4, 7,3.5, 7.25,1,'rgb(160,100,70)',1);//left fingers
      drawShape('qua',x+sx,y+sy,z*sz, 6.6,3.45, 6.75,3.5, 6.75,3.55, 6.6,3.7,'rgb(170,110,70)',1);//left thumb

      drawShape('qua',x+sx,y+sy,z*sz, 5.5,4, 5.5,5.5, 6.1,6, 6,4,'rgba(136,0,21,.65)',1);//dress left arm
      drawShape('qua',x+sx,y+sy,z*sz, 5,4, 4.5,7, 5.5,5.5, 5.5,4,'rgba(136,0,21,.65)',1);//dress left mid
     //////
      drawShape('pol',x,y,z, 4.25,3.2, 4.4,4.25, 4.25,6.5, 6,6,'rgba(136,0,21,,.65)',1,5,3);//brmain
      //hat
        drawShape('pol',x,y,z, 3.75,1.5, 5.1,1.65, 6.5,1.6, 5,1.25,'rgba(136,0,21,,.65)',1,4.25,1.25);//brmain
        drawShape('pol',x,y,z, 5.5,1.5, 5.25,1, 5,0, 4.5,1,'rgba(136,0,21,,.65)',1,4.25,1.3);//brmain
        drawShape('qua',x,y,z, 5,.9, 4.8,1.1, 5,1.3, 5.1,1.1,'rgba(255,255,255,1)',1,4.25,1.3);//brmain
        drawShape('qua',x,y,z, 5,.9, 4.8,1.1, 5,1.3, 5.1,1.1,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.3)`,1,4.25,1.3);//brmain

    break;
    case 35://Djinn
              drawShape('arc',x,y,z,5,5,5,0,2,0,0,0,`rgba(255,255,255,.016)`,1);//bag

          drawShape('arc',x,y,z,5,5,5,0,2,0,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.0316)`,1);//bag

      //ribs+spine
			drawShape('ell',x,y,z,5,5,1,1,0,0.1,.9,0,'rgba(128,0,0,.2)',1);//rib5
			drawShape('ell',x,y,z,5,5,.75,.7,0,0.1,.9,0,'black',1);//rib5-shadow
			drawShape('ell',x,y,z,5,4.5,1.5,1,0,0.1,.9,0,'rgba(128,0,0,.2)',1);//rib4
			drawShape('ell',x,y,z,5,4.5,1,.7,0,0.1,.9,0,'black',1);//rib4-shadow
			drawShape('ell',x,y,z,5,4,1.5,1,0,0.1,.9,0,'rgba(128,0,0,.2)',1);//rib3
			drawShape('ell',x,y,z,5,4,1,.7,0,0.1,.9,0,'black',1);//rib3-shadow
			drawShape('ell',x,y,z,5,3.5,1.5,1,0,0.1,.9,0,'rgba(128,0,0,.2)',1);//rib2
			drawShape('ell',x,y,z,5,3.5,1,.7,0,0.1,.9,0,'black',1);//rib2-shadow
			drawShape('ell',x,y,z,5,3,1.5,1,0,0.1,.9,0,'rgba(128,0,0,.2)',1);//rib1
			drawShape('ell',x,y,z,5,3,1,.7,0,0.1,.9,0,'black',1);//rib1-shadow
			drawShape('lin',x,y,z,5,3.5,5,6,0,0,0,0,'rgba(128,0,0,.2)',0);//spine
      	//arms
			drawShape('arc',x,y,z,3.5,3.5,.5,0,6,0,0,0,'rgba(128,0,0,.2)',1);//l-shoulder
			drawShape('arc',x,y,z,6.5,3.5,.5,0,6,0,0,0,'rgba(128,0,0,.2)',1);//r-shoulder
			drawShape('arc',x,y,z,3.5,3.5,.5,0,6,0,0,0,'black',0);//l-shoulder-shadow
			drawShape('arc',x,y,z,6.5,3.5,.5,0,6,0,0,0,'black',0);//r-shoulder-shadow
			drawShape('tri',x,y,z,3,3.5,3.5,4,2,5,0,0,'rgba(128,0,0,.2)',1);//l-arm
			drawShape('tri',x,y,z,7,3.5,6.5,4,8,5,0,0,'rgba(128,0,0,.2)',1);//r-arm
			drawShape('tri',x,y,z,2,5,1.5,6.5,2.4,4.9,0,0,'rgba(128,0,0,.2)',1);//l-forearm
			drawShape('tri',x,y,z,7.8,4.8,8.5,6.3,7.5,4.8,0,0,'rgba(128,0,0,.2)',1);//r-forearm
			drawShape('arc',x,y,z,1.7,6.3,.35,0,6,0,0,0,'rgba(128,0,0,.2)',1);//l-hand
			drawShape('arc',x,y,z,8.3,6.25,.35,0,6,0,0,0,'rgba(128,0,0,.2)',1);//r-hand
			//lower body
			drawShape('ell',x,y,z,5,6.5,1,.5,0,0,6,0,'rgba(128,0,0,.2)',1);//hip
			drawShape('arc',x,y,z,5.75,6.5,.5,0,6,0,0,0,'rgba(128,0,0,.2)',1);//hip
			drawShape('arc',x,y,z,4.25,6.5,.5,0,6,0,0,0,'rgba(128,0,0,.2)',1);//hip
			
      
      //left upper arm upper
      drawShape('pol',x,y,z, 2,5, 2.5,4, 3.2,3, 3.5,3.5,'rgba(41,121,205,.35)',1,3.5,4);//upper arm R
      //left upper arm lower
      drawShape('qua',x,y,z, 2,5, 2.25,5, 3,4.5, 3.5,4,'rgba(41,121,205,.55)',1);//upper arm R
      //left upper arm upper
      drawShape('pol',x,y,z, 2,5, 1.9,5, 1.6,5.5, 1.5,6.5,'rgba(41,121,205,.35)',1,2,5.5);//upper arm R
      //left upper arm lower
      drawShape('pol',x,y,z, 2,5, 2.5,4.8, 2,6, 1.5,6.5,'rgba(41,121,205,.55)',1,1.75,5.5);//upper arm R
      //r upper arm upper
      drawShape('pol',x,y,z, 8,5, 7.5,4, 6.8,3, 6.5,3.5,'rgba(41,121,205,.35)',1,6.5,4);//upper arm R
      //r upper arm lower
      drawShape('qua',x,y,z, 8,5, 7.75,5, 7,4.5, 6.5,4,'rgba(41,121,205,.55)',1);//upper arm R
      //r upper arm upper
      drawShape('pol',x,y,z, 8,5, 8.1,5, 8.4,5.5, 8.5,6.5,'rgba(41,121,205,.35)',1,8.2,5.5);//upper arm R
      //r upper arm lower
      drawShape('pol',x,y,z, 8,5, 7.5,4.8, 8,6, 8.5,6.5,'rgba(41,121,205,.55)',1,8.25,5.5);//upper arm R
      //shoulders
      drawShape('pol',x,y,z, 3.2,3, 6.8,3, 6.5,4, 5,3,'rgba(41,121,205,.55)',1,3.5,4);//upper arm R
      //left torso
      drawShape('pol',x,y,z, 3.5,4, 3.53,5, 3.75,5.5, 4,6,'rgba(41,121,205,.55)',1,5,3);//upper arm R
      //r torso
      drawShape('pol',x,y,z, 6.5,4, 6.47,5, 6.25,5.5, 6,6,'rgba(41,121,205,.55)',1,5,3);//upper arm R
      //mid torso
      drawShape('tri',x,y,z, 5,3, 4,6, 6,6, 6,6,'rgba(41,121,205,.55)',1,5,3);//upper arm R
      
      //l chest
      drawShape('pol',x,y,z, 5,4, 4.8,4.5, 4.25,4.5, 3.5,4,'rgba(41,121,205,.55)',1,3.5,3.25);//upper arm R
      //r chest
      drawShape('pol',x,y,z, 5,4, 5.2,4.5, 5.75,4.5, 6.5,4,'rgba(41,121,205,.55)',1,6.5,3.25);//upper arm R
      //shorts l
      drawShape('pol',x,y,z, 4,6, 3.7,6.2, 3.6,6.5, 3.7,6.8,'rgba(128,0,0,.55)',1,4.5,7);//upper arm R
      //shorts r
      drawShape('pol',x,y,z, 6,6, 6.3,6.2, 6.4,6.5, 6.3,6.8,'rgba(128,0,0,.55)',1,5.5,7);//upper arm R
      drawShape('pol',x,y,z, 4,6, 4.5,7, 5.5,7, 6,6,'rgba(128,0,0,.55)',1,5,5.95);//upper arm R
      //turban circle
      drawShape('arc',x,y,z,5,1.5,1.5,0,6,0,0,0,'rgba(128,0,0,.4)',1);//head
      //lamp
      drawShape('pol',x,y,z, 3.6,9.36, 4,9.45, 4.5,9.5, 5,9.25,'rgba(255,201,14,.65)',1, 4.9,10);//upper arm R
      drawShape('pol',x,y,z,5.6,9.5, 6,9.45, 5.5,9.5, 5,9.25,'rgba(255,201,14,.65)',1, 5.1,10);//upper arm R
        drawShape('pol',x,y,z,4.6,10, 4.9,9.9, 5,9.25, 5.1,9.9,'rgba(255,201,14,.75)',1, 5.4,10);//upper arm R
        drawShape('pol',x,y,z,5.5,9.5, 5.6,9.4, 5.8,9.5, 5.75,9.75,'rgba(255,201,14,.75)',1, 5.6,9.7);//upper arm R
        drawShape('arc',x,y,z,5.65,9.57,.069,0,6,0,0,0,'rgba(0,0,0,.9)',1);//head

      //smoke
        drawShape('pol',x,y,z, 3.6,9.3, 4,9.2, 4.5,9, 5,8.5,'rgba(255,255,255,.55)',1, 3.6,9.4);//upper arm R
        drawShape('pol',x,y,z, 4.5,9, 5.5,8.5, 4.5,9, 6,7.5,'rgba(255,255,255,.55)',1, 6.25,6.75);//upper arm R
        drawShape('pol',x,y,z, 3.69,6.75, 4,7.5, 4.5,8, 4.25,9,'rgba(255,255,255,.55)',1, 6,8);//upper arm R
        drawShape('pol',x,y,z, 6,8, 6,7.5, 6.3,6.75, 5,7,'rgba(255,255,255,.75)',1, 3.69,6.75);//upper arm R
      //lhand
      drawShape('pol',x,y,z, 8.5,6, 8.75,6.25, 8.75,6.5, 8.25,6.75,'rgba(41,121,205,.55)',1,8,6.5);//upper arm R
      drawShape('pol',x,y,z, 8,6, 8,6.5, 8.75,6.5, 8.5,6,'rgba(41,121,205,.55)',1,8,6);//upper arm R
//rhand
      drawShape('pol',x,y,z, 1.5,6, 1.25,6.25, 1.25,6.5, 1.75,6.75,'rgba(41,121,205,.55)',1,2,6.5);//upper arm R
      drawShape('pol',x,y,z, 2,6, 2,6.5, 1.25,6.5, 1.5,6,'rgba(41,121,205,.55)',1,2,6);//upper arm R

      sx = 2*z;
      sy = 0*z
      sz = 1;
			drawShape('tri',x+sx,y+sy,z*sz,3,2,3,4,5,2,0,0,'rgba(41,121,205,.55)',1);//H-head
			drawShape('tri',x+sx,y+sy,z*sz,3,2,2.25,3.25,3,3,0,0,'rgba(128,0,0,.2)',1);//H-nose
			//drawShape('tri',x+sx,y+sy,z*sz,3,2.25,3,2.75,3.75,2.75,0,0,'red',1);//H-eye(sad)
      sx = 2.5*z;
      sy = 0*z
      sz = 1;
			drawShape('tri',x+sx,y+sy,z*sz,3,2.25,3,2.75,3.75,2.1,0,0,'blue',1);//H-eye(mad)
			//drawShape('tri',x+sx,y+sy,z*sz,3,2.25,3,2.75,3.75,2.25,0,0,'red',1);//H-eye(neutral)
			sx = 2*z;
      sy = 0*z
      sz = 1;
      drawShape('tri',x+sx,y+sy,z*sz,4,2.25,4,2.75,4.75,1.75,0,0,'rgba(64,0,0,.2)',1);//H-ear
      sx = -2*z;
      sy = 0*z
      sz = 1;
			drawShape('tri',x+sx,y+sy,z*sz,7,2, 7,4, 5,2, 0,0,'rgba(41,121,205,.55)',1);//H-head
			drawShape('tri',x+sx,y+sy,z*sz,7,2, 7.75,3.25, 7,3, 0,0,'rgba(128,0,0,.2)',1);//H-nose
			sx = -2.5*z;
      sy = 0*z
      sz = 1;
      //drawShape('tri',x+sx,y+sy,z*sz,3,2.25,3,2.75,3.75,2.75,0,0,'red',1);//H-eye(sad)
			drawShape('tri',x+sx,y+sy,z*sz,7,2.25, 7,2.75, 6.25,2.1, 0,0,'blue',1);//H-eye(mad)
			//drawShape('tri',x+sx,y+sy,z*sz,3,2.25,3,2.75,3.75,2.25,0,0,'red',1);//H-eye(neutral)
			sx = -2*z;
      sy = 0*z
      sz = 1;
      drawShape('tri',x+sx,y+sy,z*sz,6,2.25, 6,2.75, 5.25,1.75, 0,0,'rgba(64,0,0,.2)',1);//H-ear
			drawShape('arc',x+sx,y+sy,z*sz,7.3,3.2, .25,1.25, 2,0, 0,0,'black',1);//H-nostril
			drawShape('arc',x+sx,y+sy,z*sz,6.7,3.2, .25,1, 1.75,0, 0,0,'black',1);//H-nostril
      drawShape('tri',x+sx,y+sy,z*sz,5,0, 7,2, 5,2, 0,0,'tan',1);//H-hat
      sx = 2*z;
      sy = 0*z
      sz = 1;
      drawShape('tri',x+sx,y+sy,z*sz,5,0,3,2,5,2,0,0,'tan',1);//H-hat
    	                
      break;
    
    case 36://hourglass
      drawShape('qua',x,y,z,1,9,9,9,1,1,9,1,'white',1);//body
      drawShape('rec',x,y,z,1,.75,8,.25,0,0,0,0,'blue',1);
      drawShape('rec',x,y,z,1,9,8,.25,0,0,0,0,'blue',1);

      drawShape('tri',x,y,z,2.5,9,7.5,9,5,8.5,0,0,'blue',1);//bottom sand
      drawShape('tri',x,y,z,5,5,2.5,2.5,7.5,2.5,0,0,'blue',1);//top sand
      drawShape('qua',x,y,z,5,5, 4.9,6, 5.1,7, 4.9,8.5,'blue',1);//drip sand
      break;
    case 37://Siren 2  

      //front l
      sx = 1.3*z;
      sy = -6.25*z;
      sz = 1.5;
      drawShape('pol',x+sx,y+sy,z*sz, 2.5,8.75, 1.5,9.2, 1.75,9.95, 1.9,9.3,'rgb(244,69,11)',1,2.5,9.2);//Cape Back
      sx = 1.2*z;
      sy = 1*z;
      //left arm 2 claws left
      drawShape('pol',x+sx,y+sy,z, 2.75,7.5, 2.5,7.5, 2,8, 2.75,7.75,'rgba(244,69,11,.5)',1,2.8,7.6);//Cape Back
      drawShape('pol',x+sx,y+sy,z, 2.75,7.5, 2.5,7.75, 2.5,8.5, 2.8,7.75,'rgb(244,69,11,.5)',1,2.8,7.6);//Cape Back
      sx = -1.4*z;
      sy = 1*z;
      //right arm 2 claws right
      drawShape('pol',x+sx,y+sy,z, 7.25,7.5, 7.5,7.5, 8,8, 7.25,7.75,'rgba(244,69,11,.5)',1,7.2,7.6);//Cape Back
      
      //left arm 2 claws left
      sx = -3.3*z;
      sy = 1*z;
      drawShape('pol',x+sx,y+sy,z, 7.25,7.5, 7.5,7.5, 8,8, 7.25,7.75,'rgba(244,69,11,.5)',1,7.2,7.6);//Cape Back
      
    
      //front r
      sx = -2*z;
      sy = -6.3*z;
      sz = 1.5;
      drawShape('pol',x+sx,y+sy,z*sz, 4.5,8.7, 5.5,9.2, 5.25,9.95, 5.1,9.3,'rgb(244,69,11)',1,4.5,9.2);//Cape Back
      
      //right arm 2 claws left
      sx = 3.2*z;
      sy = 1*z;
      drawShape('pol',x+sx,y+sy,z, 2.75,7.5, 2.5,7.5, 2,8, 2.75,7.75,'rgba(244,69,11,.5)',1,2.8,7.6);//Cape Back
      drawShape('pol',x+sx,y+sy,z, 2.75,7.5, 2.5,7.75, 2.5,8.5, 2.8,7.75,'rgb(244,69,11,.5)',1,2.8,7.6);//Cape Back

      //tail
      sx = -8.7*z;
      sy = -9.6*z;
      sz = 3;
      for (let i=0;i<60;i++){
        drawShape('ell',x+sx-27.75*z,y+sy-27.5*z,z*sz*3,    4.5+i*.001, 4.5+i*.001,        .2+i*.0025,   0.2+i*.003,  0,    1,   .4,    0,   `rgba(${0},${128+i},${128},1)`,0)
        
        drawShape('ell',x,y,z,    1.9+i*.001, 3.6+i*.001,        1.9-i*.01,   0+i*.02,  0,    i*.03,   2,    0,   `rgba(${0},${128+i},${128},1)`,0)
        
      }
      //wind special effect
     // for (let i=0;i<120;i++){
      //drawShape('ell',x+sx-27.75*z,y+sy-27.5*z,z*sz*3,    4.5+i*.001, 4.5+i*.001,        .2+i*.0025,   0.2+i*.003,  0,    1,   .4,    0,   `rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.3)`,0)
        
       // drawShape('ell',x,y,z,    1.9+i*.001, 3.6+i*.001,        1.9-i*.01,   0+i*.02,  0,    i*.03,   2,    0,   `rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.3)`,0)
      //}//
      //wings
      ///////////////////////////////////////////////
      //////////////////////////////////////
       
      drawShape('qua',x,y,z, 4.5,3, 3.75,3.3, 3,7, 6,9.9,'lightblue',1);//robe left
      drawShape('qua',x,y,z, 4.5,3, 3.75,3.3, 3,7, 6,9.9,'rgba(0,0,0,.1)',1);//robe left
      drawShape('qua',x,y,z, 5.5,3, 6.25,3.3, 7,7, 4,9.3,'lightblue',1);//robe left
      drawShape('qua',x,y,z, 5.5,3, 6.25,3.3, 7,7, 4,9.3,'rgba(0,0,0,.15)',1);//robe left
      for (let i=0;i<10;i++){
        for(let h = 0;h<4;h++){
          sx = (1.8+(i*.1))*z
          sy = (3+((i*.1)+h))*z
          sz = .25;
          drawShape('qua',x+sx,y+sy,z*sz,7.8,1, 8,.7, 8.3,4.2, 6.3,6.4,'rgba(255,255,255,.1)',1);
          drawShape('qua',x+sx,y+sy,z*sz,7.8,1, 8,.7, 8.02,.9, 6.3,6.4,'rgba(0,0,0,.1)',1);
          sx = (2.7+(i*.1))*z
          sy = (2.9+((i*.01)+h))*z
          sz = .15;
          drawShape('qua',x+sx,y+sy,z*sz,7.8,1, 8,.7, 8.3,4.2, 6.3,6.4,'rgba(255,255,255,.1)',1);
          drawShape('qua',x+sx,y+sy,z*sz,7.8,1, 8,.7, 8.02,.9, 6.3,6.4,'rgba(0,0,0,.1)',1);
        }
      }
      for (let i=0;i<5;i++){
        for(let h = 0;h<2;h++){
          sx = (1.5+(i*.1))*z
          sy = (4.6+((i*.1)+h))*z
          sz = .25;
          drawShape('qua',x+sx,y+sy,z*sz,7.8,1, 8,.7, 8.3,4.2, 6.3,6.4,'rgba(255,255,255,.1)',1);
          drawShape('qua',x+sx,y+sy,z*sz,7.8,1, 8,.7, 8.02,.9, 6.3,6.4,'rgba(0,0,0,.1)',1);
            drawShape('qua',x+sx,y+sy,z*sz,7.8,1, 8,.7, 8.3,4.2, 6.3,6.4,'rgba(255,255,255,.1)',1);
          drawShape('qua',x+sx,y+sy,z*sz,7.8,1, 8,.7, 8.02,.9, 6.3,6.4,'rgba(0,0,0,.1)',1);
          
          sx = (2.5+(i*.1))*z
          sy = (2.9+((i*.1)+h))*z
          sz = .25;
          drawShape('qua',x+sx,y+sy,z*sz,7.8,1, 8,.7, 8.3,4.2, 6.3,6.4,'rgba(255,255,255,.1)',1);
          drawShape('qua',x+sx,y+sy,z*sz,7.8,1, 8,.7, 8.02,.9, 6.3,6.4,'rgba(0,0,0,.1)',1);
            sx = (4.5+(i*.1))*z
          sy = (4.6+((i*.1)+h))*z
          sz = .25;
          drawShape('qua',x+sx,y+sy,z*sz,7.8,1, 8,.7, 8.3,4.2, 6.3,6.4,'rgba(255,255,255,.1)',1);
          drawShape('qua',x+sx,y+sy,z*sz,7.8,1, 8,.7, 8.02,.9, 6.3,6.4,'rgba(0,0,0,.1)',1);
       }     
     }
      for (let i=0;i<10;i++){
        for(let h = 0;h<4;h++){
          sx = (3+(i*.1))*z
          sy = (3+((i*.1)+h))*z
          sz = .25;
          drawShape('qua',x+sx,y+sy,z*sz,2.2,1, 2,.7, 1.7,4.2, 3.7,6.4,'rgba(255,255,255,.1)',1);
          drawShape('qua',x+sx,y+sy,z*sz,2.2,1, 2,.7, 1.98,.9, 3.7,6.4,'rgba(0,0,0,.1)',1);
          sx = (5+(i*.1))*z
          sy = (3+((i*.1)+h))*z
          sz = .25;
          drawShape('qua',x+sx,y+sy,z*sz,2.2,1, 2,.7, 1.7,4.2, 3.7,6.4,'rgba(255,255,255,.1)',1);
          drawShape('qua',x+sx,y+sy,z*sz,2.2,1, 2,.7, 1.98,.9, 3.7,6.4,'rgba(0,0,0,.1)',1);
        
          sx = (4+(i*.1))*z
          sy = (4+((i*.1)+h))*z
          sz = .25;
          drawShape('qua',x+sx,y+sy,z*sz,2.2,1, 2,.7, 1.7,4.2, 3.7,6.4,'rgba(255,255,255,.1)',1);
          drawShape('qua',x+sx,y+sy,z*sz,2.2,1, 2,.7, 1.98,.9, 3.7,6.4,'rgba(0,0,0,.1)',1);
          sx = (3+(i*.1))*z
          sy = (4+((i*.1)+h))*z
          sz = .25;
          drawShape('qua',x+sx,y+sy,z*sz,7.8,1, 8,.7, 8.3,4.2, 6.3,6.4,'rgba(255,255,255,.1)',1);
          drawShape('qua',x+sx,y+sy,z*sz,7.8,1, 8,.7, 8.02,.9, 6.3,6.4,'rgba(0,0,0,.1)',1);
          sx = (3.6+(i*.1))*z
          sy = (2.6+((i*.1)+h))*z
          sz = .25;
          drawShape('qua',x+sx,y+sy,z*sz,7.8,1, 8,.7, 8.3,4.2, 6.3,6.4,'rgba(255,255,255,.1)',1);
          drawShape('qua',x+sx,y+sy,z*sz,7.8,1, 8,.7, 8.02,.9, 6.3,6.4,'rgba(0,0,0,.1)',1);
       }
      }
        ////////////////////////////////////
       ////////////////////////////////////
      drawShape('qua',x,y,z, 4.5,3, 3.75,3.3, 3,7, 6,9.9,'rgba(0,0,0,.1)',1);//robe left
      drawShape('qua',x,y,z, 5.5,3, 6.25,3.3, 7,7, 4,9.3,'rgba(0,0,0,.15)',1);//robe left
      drawShape('qua',x,y,z, 4.3,1.5, 4,3.5, 4.5,4.5, 4.55,2,'rgba(128,128,128,.75)',1);//neck
      drawShape('qua',x,y,z, 5.7,1.5, 6,3.5, 5.5,4.5, 5.45,2,'rgba(128,128,128,.75)',1);//neck

      drawShape('qua',x,y,z, 4.5,3, 5,2.5, 5.5,3, 5,3.5,'rgb(174,111,77)',1);//neck
      drawShape('arc',x,y,z,5,1.69,.7,0,2,0,0,0,'rgb(185,122,87)',1);
      drawShape('tri',x,y,z, 4.23,1.9, 5.78,1.9, 5,3, 0,0,'rgb(185,122,87)',1);//face bottom
      drawShape('tri',x,y,z, 5,1.75, 5.15,2.25, 5,2.25, 0,0,'rgba(0,0,0,.25)',1);//nose
      drawShape('tri',x,y,z, 4.7,2.5, 5.3,2.5, 5,2.59, 0,0,'rgba(255,0,0,.525)',1);//mouth
      drawShape('tri',x,y,z, 4.5,1.8, 4.9,1.8, 4.75,1.83, 0,0,'rgba(0,0,0,.25)',1);//left eye
      drawShape('tri',x,y,z, 5.5,1.8, 5.1,1.8, 5.25,1.83, 0,0,'rgba(0,0,0,.25)',1);//r eye
      
      drawShape('qua',x,y,z, 5,1, 4.5,1, 4.25,1.5, 4,2,'rgba(128,128,128,.75)',1);//neck
      drawShape('qua',x,y,z, 5,1, 4.5,.5, 4.5,1, 5,1.5,'rgba(128,128,128,.75)',1);//neck
      drawShape('qua',x,y,z, 5,1, 5.5,1, 5.75,1.5, 6,2,'rgba(128,128,128,.75)',1);//neck
      drawShape('qua',x,y,z, 5,1, 5.5,.5, 5.5,1, 5,1.5,'rgba(128,128,128,.75)',1);//neck
      
      drawShape('qua',x,y,z, 4.5,1, 4.5,2.5, 4.15,2, 4.5,1,'rgba(128,128,128,.75)',1);//neck
      drawShape('qua',x,y,z, 5.5,1, 5.5,2.5, 5.85,2, 5.5,1,'rgba(128,128,128,.75)',1);//neck
       

      drawShape('qua',x,y,z, 4.5,3, 4.98,5.2, 5.5,3, 5,3.5,'rgba(239,228,176,.5)',1);//neck
      break;
    case 38://Quest Reward 3
          drawShape('arc',x,y,z,5,5,5,0,2,0,0,0,'rgba(128,64,32,.16)',1);//bag

      //tomearc
      sx = 1.5*z;
      sy = 1*z;
      sz = .75;
      drawShape('qua',x+sx,y+sy,z*sz,0,7.5,10,7.5,7.5,2.5,2.5,2.5,'rgba(128,64,0,1)',1);
			drawShape('qua',x+sx,y+sy,z*sz,.2,7.1,9.8,7.1,7.5,2.5,2.5,2.5,'rgba(255,255,128,1)',1);
			drawShape('lin',x+sx,y+sy,z*sz,5,7.5,5,2.5,0,0,0,0,'rgba(128,64,0,.85)',1);
			drawShape('arc',x+sx,y+sy,z*sz,3.75,3.8,1.79,1.25,1.75,0,0,0,'rgba(255,255,128,1)',1);
			drawShape('arc',x+sx,y+sy,z*sz,6.25,3.8,1.79,1.25,1.75,0,0,0,'rgba(255,255,128,1)',1);
      drawShape('qua',x+sx,y+sy,z*sz,4.77,7.2, 4.9,2.4, 4,6, 4.488,6.51,'rgba(0,0,0,.1)',1);
      drawShape('qua',x+sx,y+sy,z*sz,5.188,7.2, 5.1,2.4, 6,6, 5.512,6.51,'rgba(0,0,0,.1)',1);
			drawShape('arc',x+sx,y+sy,z*sz,2.5,7.9,2.4,1.1,1.9,0,0,0,'rgba(248,179,16,.85)',1);
			drawShape('arc',x+sx,y+sy,z*sz,7.5,7.9,2.4,1.1,1.9,0,0,0,'rgba(248,179,16,.85)',1);
      for (let i = 0;i<40;i++){
        drawShape('arc',x+sx,y+sy,z*sz,2.5,7.89, 2.39-i*.05,1.1,1.9,0,0,0,'rgba(0,0,0,.25)',0);
			  drawShape('arc',x+sx,y+sy,z*sz,7.5,7.89, 2.39-i*.05,1.1,1.9,0,0,0,'rgba(0,0,0,.25)',0);
      }
      drawShape('rec',x+sx,y+sy,z*sz,0.2,7.13,9.6,.35,0,0,0,0,'rgb(128,64,0)',1);
      drawShape('pol',x+sx,y+sy,z*sz,4.75,7.1, 4.9,2.42, 5.1,2.42, 5.2,7.2,'rgba(0,0,0,.45)',1, 5,7.1);
      
      //sword pommel
      sx = -.15*z;
      sy = -2*z;
      sz = 1;
      drawShape('arc',x+sx,y+sy,z*sz,.5,8.25, .3,.3, 0,2  ,0,0,'gold',1);//sword-pommel
      drawShape('arc',x+sx,y+sy,z*sz,.5,8.25, .3,.3, 0,2  ,0,0,'rgba(0,0,0,.3)',1);//sword-pommel
      drawShape('ell',x+sx,y+sy,z*sz,.5,8.15, .2,.13, 0, 2  ,0 ,0,'rgba(128,0,0,1)',1);//sword-pommel
      drawShape('arc',x+sx,y+sy,z*sz,.45,8.3, .275,0, 2,2  ,0,0,'rgba(0,0,0,.15)',1);//sword-pommel
      drawShape('arc',x+sx,y+sy,z*sz,.5,8.25, .3,.2, .95, 0  ,0 ,0,'rgba(0,0,0,.24)',1);//sword-pommel
      drawShape('arc',x+sx,y+sy,z*sz,.5,8.25, .3,0, 1.2, 0  ,0 ,0,'rgba(0,0,0,.24)',1);//sword-pommel

      //sword
      sx = -3.65*z;
      sy = -2.25*z;
      sz = 1.5;
      drawShape('qua',x+sx,y+sy,z*sz,4.1,5.5, 4.1,5.8, 2.8,5.81, 2.8,5.5,'gold',1);//sword-handle
      drawShape('qua',x+sx,y+sy,z*sz,4.1,5.9, 4.1,6,   2.8,5.81, 2.8,5.7,'rgba(0,0,0,.4)',1);//sword-handle
      drawShape('qua',x+sx,y+sy,z*sz,4.1,5.7, 4.1,5.8, 2.8,5.81, 2.8,5.5,'rgba(0,0,0,.4)',1);//sword-handle
			drawShape('tri',x+sx,y+sy,z*sz,9,5.8, 4.1,5.35, 3.9,6.15  ,0,0,'white',1);//sword-blade
      drawShape('tri',x+sx,y+sy,z*sz,9,5.8, 4.1,5.5,  3.9,5.8  ,0,0,'rgba(0,0,0,.15)',1);//sword-blade
			drawShape('tri',x+sx,y+sy,z*sz,9,5.8, 4.1,5.35, 3.9,6.1  ,0,0,'rgba(0,0,0,.15)',1);//sword-blade
			drawShape('tri',x+sx,y+sy,z*sz,9,5.8, 4.1,5.45, 3.9,6.15  ,0,0,'rgba(0,0,0,.15)',1);//sword-blade
			drawShape('qua',x+sx,y+sy,z*sz,4.2,4.5, 4.1,5.7, 3.7,6.8, 3.6,6,'gold',1);//sword-crossguard
      drawShape('qua',x+sx,y+sy,z*sz,4.2,4.5, 3.8,5.7, 3.7,6.8, 3.6,6,'rgba(0,0,0,.4)',1);//sword-crossguard
			drawShape('qua',x+sx,y+sy,z*sz,4.2,4.5, 4.1,5.7, 3.7,6.8, 3.6,6,'rgba(0,0,0,.4)',1);//sword-crossguard

      //potion
      sx = 5*z;
      sy = 3*z;
      sz = .5;
      drawShape('qua',x+sx,y+sy,z*sz, 4.4,0.75, 5.6,0.75, 5.25,2.45, 4.75,2.45,'rgba(186,103,0,1)',1)//cork
      drawShape('qua',x+sx,y+sy,z*sz, 4.4,0.75, 5.6,0.75, 5.25,.9, 4.75,.9,'rgba(255,255,255,.1)',1)//cork
      drawShape('qua',x+sx,y+sy,z*sz, 4.4,0.75, 4.5,0.75, 5.25,2.45, 4.75,2.45,'rgba(0,0,0,.40)',1)//cork
      drawShape('qua',x+sx,y+sy,z*sz, 3.95,3.449, 6.0456,3.4488, 5.5,1.25, 4.5,1.25,'rgba(249,255,255,.28)',1);//bottleneck
      drawShape('qua',x+sx,y+sy,z*sz, 3.95,3.449, 6.0456,3.4488, 5.5,1.25, 4.5,1.25,'rgba(0,0,0,.28)',1);//bottleneck
      drawShape('arc',x+sx,y+sy,z*sz,5,6.38,  2.8,  1.667,1.337,0,0,0,'rgba(255,0,0,1)',1);//liquid
      drawShape('arc',x+sx,y+sy,z*sz,5,6.25,  3,  1.6163,1.3836,0,0,0,'rgba(249,255,255,.28)',1);//bottle
      drawShape('arc',x+sx,y+sy,z*sz,5,6.25,  3,  1.6163,1.3836,0,0,0,'rgba(0,0,0,.28)',1);//bottle
      drawShape('ell',x+sx,y+sy,z*sz,5,3.95, 1.4,.3, 1, 1,2,0,'rgba(0,0,0,.2)',1);//surface liquid
      drawShape('ell',x+sx,y+sy,z*sz,6.3,5.44, .55,.35, 1, 0,2,0,'rgba(255,255,255,.8)',1);//reflection
      
      //coins
      sx = 3.5*z;
      sy = 4.5*z;
      sz = 1;
      for (let i = 10;i>0;i--){
        drawShape('ell',x+sx,y+sy,z*sz,2,2.1+i*.1,.5,.15,  0,2,0,0,'rgba(0,0,0,.4)',1);
        drawShape('ell',x+sx,y+sy,z*sz,2,2.1+i*.1,.5,.15,  0,2,0,0,'rgba(0,0,0,.4)',0);
        drawShape('ell',x+sx,y+sy,z*sz,2,2+i*.1,.5,.15,  0,2,0,0,'rgba(255,255,0,1)',1);
      }
      break;
    case 39://Dragon Wing 6
      drawShape('pol',x,y,z,10,0, 8,.5 ,2,5 ,0,8,'rgba(0,32,0,1)',1,0,10);
      drawShape('tri',x,y,z,10,0, 10,5 ,5.5,2 ,0,10,'rgba(0,32,0,1)',1,9,9);

      drawShape('pol',x,y,z,10,5, 8.5,2 ,4,4.45 ,0,10,'rgba(255,255,128,1)',1,9,9);
      drawShape('tri',x,y,z,10,5, 10,7 ,9.5,6 ,0,10,'rgba(255,255,128,1)',1,9,9);
      drawShape('pol',x,y,z,9,9, 10,7 ,9.75,6.25 ,8.75,7.25,'rgba(0,0,0,1)',1,8.75,8.25);
      drawShape('pol',x,y,z,9,9.1, 4.5,9.6 ,5,8.5 ,6,8.25,'rgba(0,0,0,1)',1,8,8.5);
      drawShape('pol',x,y,z,0,10, 4.5,9.7 ,4,9 ,3,8.75,'rgba(0,0,0,1)',1,2,9);
      drawShape('qua',x,y,z,0,10, 4.5,5 ,8.5,2 ,5,5,'rgba(0,0,0,.25)',1,2,9);
      drawShape('qua',x,y,z,4.5,9, 5,6 ,8.5,2 ,5.5,6,'rgba(0,0,0,.25)',1,2,9);
      drawShape('qua',x,y,z,9,9, 7.55,6 ,8.5,2 ,8,6,'rgba(0,0,0,.25)',1,2,9);
      drawShape('qua',x,y,z,10,7, 9.5,5 ,8.5,2 ,9.3,5,'rgba(0,0,0,.25)',1,2,9);
      drawShape('tri',x,y,z,0,9.75, 2.25,5 ,0,7 ,6,8.25,'rgba(0,6,13,1)',1,8,8.5);

    break;
    case 40://Steal 5
      drawShape('arc',x,y,z,5,5,5,0,2,0,0,0,'rgba(255,255,0,.25)',1);
      drawShape('qua',x,y,z,8,6, 5,4, 5,6, 8,10,'gray',1);
      sx = -6.25*z;
      sy = -6*z
      sz = 1.25;
      drawShape('qua',x+sx,y+sy,z*sz,9,8, 7,9.5, 6,8, 7.5,7.5,'rgb(255,187,119)',1);
      drawShape('qua',x+sx,y+sy,z*sz,7,9.5, 6,8, 8,8, 7.75,8.75,'rgba(0,0,0,.55)',1);
    	drawShape('tri',x,y,z,5,5, 5,6, 4.25,4.75, 8,6,'rgb(255,187,119)',1);
			drawShape('tri',x,y,z,5,4, 5,5, 4.25,4.75, 8,6,'rgb(255,187,119)',1);
			drawShape('tri',x,y,z,5,4, 4.2,4.6, 4.25,4.75, 8,6,'rgb(255,187,119)',1);
			drawShape('tri',x,y,z,5,4, 4.2,4.6, 4.25,4.75, 8,6,'rgba(0,0,0,.25)',1);
      sx = .25*z;
      sy = 0-.25*z
      sz = 1;
      drawShape('pol',x+sx,y+sy,z*sz,1.25,4, 1,5, 1.5,5.5, 2.5,5.9,'rgba(255,187,119,.5)',1,1.5,5);

      sx = .25*z;
      sy = 0*z
      sz = 1;
      drawShape('pol',x+sx,y+sy,z*sz,1.25,4, 1,5, 1.5,5.5, 2.5,5.9,'rgba(255,187,119,.75)',1,1.5,5);

      drawShape('pol',x,y,z,1.25,4, 1,5, 1.5,5.5, 2.5,5.9,'rgb(255,187,119)',1,1.5,5);
      drawShape('pol',x,y,z,2.5,5.9, 2.4,5.75, 2.5,5.5, 3.5,4.9,'rgb(255,187,119)',1,3.7,4);
      drawShape('pol',x,y,z,2.5,5.9, 3,5.5, 4,4, 3,4,'rgb(255,187,119)',1,3,4.75);
      drawShape('qua',x,y,z,1.5,4.5, 1.5,4, 1.25,4, 1.25,4.5,'rgb(255,187,119)',1,3,4.75);
      drawShape('pol',x,y,z,3,3.75, 1.5,4.2, 1.6,4.25, 1.5,4.45,'rgba(255,187,119,.45)',1,3,4.2);
      drawShape('pol',x,y,z,3,3.95, 1.5,4.4, 1.6,4.45, 1.5,4.65,'rgba(255,187,119,.45)',1,3,4.4);

      drawShape('pol',x,y,z,3,3.5, 1.5,4, 1.6,4.5, 2,4.25,'rgb(255,187,119)',1,3,4);
      drawShape('arc',x,y,z,2.5,8,.5,0,2,0,0,0,'rgba(255,0,0,.25)',1);
      drawShape('pol',x,y,z,8,6, 9,6.5, 9.5,7, 10,7.25,'rgba(255,255,255,.095)',1,10,10);
      drawShape('pol',x,y,z,8,6, 8,10, 10,10, 10,9,'rgba(255,255,255,.095)',1,8,6);

      sz = 2;
      sx = -7.5*z;
      sy=-1.25*z;
      drawShape('lin',x+sx,y+sy,z*sz,4.97,3.5, 5,4.5, 0,0, 0,0,'rgb(255,126,60)',0);//string
      drawShape('lin',x+sx,y+sy,z*sz,5.03,3.5, 5,4.5, 0,0, 0,0,'rgb(255,126,60)',0);//string
      drawShape('arc',x+sx,y+sy,z*sz,5,4.6,.13,0,6,0,0,0,'darkred',1);//amulet
      drawShape('arc',x+sx,y+sy,z*sz,5,4.6,.1,0,6,0,0,0,'red',1);//amulet
        
      break;
    case 41://Loot 6 
      drawShape('arc',x,y,z,5,5,5,0,2,0,0,0,'rgba(0,128,255,.1)',1);

      sx = -2*z;
      sy = 0*z;
      sz = 1;
      drawShape('qua',x+sx,y+sy,z*sz,5,9,6,9,7,8,6,8,'darkgreen',1);//IL-foot
			drawShape('qua',x+sx,y+sy,z*sz,6,8,7,8,4,6,4,7,'darkgreen',1);//IL-calf+knee
			drawShape('tri',x+sx,y+sy,z*sz,4,6,7,5,5,7,0,0,'darkgreen',1);//IL-thigh
			drawShape('tri',x+sx,y+sy,z*sz,7,5,8,5,8,6,0,0,'green',1);//OL-hip
			drawShape('qua',x+sx,y+sy,z*sz,7,5,5,7,6,7,8,6,'green',1);//OL-thigh
			drawShape('qua',x+sx,y+sy,z*sz,5,7,7,9,8,9,6,7,'green',1);//OL-calf+knee
			drawShape('qua',x+sx,y+sy,z*sz,7,9,8,9,7,10,5.5,9.9,'green',1);//OL-foot
			drawShape('tri',x+sx,y+sy,z*sz,3,3,5,5,4,2,0,0,'darkgreen',1);//Inner arm
			drawShape('arc',x+sx,y+sy,z*sz,4.5,3.5,.75,0,6,0,0,0,'darkgreen',1);//T-Ishoulder
			drawShape('arc',x+sx,y+sy,z*sz,5.8,4.4,2.5,1.4,2.25,0,0,0,'brown',1);//T-hump
			drawShape('qua',x+sx,y+sy,z*sz,6,5.5,8,5,5,2,4,3,'brown',1);//T-torso
			drawShape('tri',x+sx,y+sy,z*sz,4,3,5,2,5,3,0,0,'darkgreen',1);//T-neck
			drawShape('arc',x+sx,y+sy,z*sz,5.5,2.5,.75,0,6,0,0,0,'darkgreen',1);//T-Oshoulder
			drawShape('qua',x+sx,y+sy,z*sz,7,5,7,6,8,7,8,5,'brown',1);//T-hip armor
			
			drawShape('tri',x+sx,y+sy,z*sz,5,0,3,2,5,2,0,0,'red',1);//H-hat
			drawShape('tri',x+sx,y+sy,z*sz,3,2,3,4,5,2,0,0,'green',1);//H-head
			drawShape('tri',x+sx,y+sy,z*sz,3,2,2.25,3.25,3,3,0,0,'green',1);//H-nose
			drawShape('tri',x+sx,y+sy,z*sz,3,3,3.5,3,3,4,0,0,'black',1);//H-mouth
			drawShape('tri',x+sx,y+sy,z*sz,3,2.25,3,2.75,3.75,2.1,0,0,'red',1);//H-eye(mad)
			drawShape('tri',x+sx,y+sy,z*sz,4,2.25,4,2.75,4.75,1.75,0,0,'darkgreen',1);//H-ear
			drawShape('arc',x+sx,y+sy,z*sz,2.7,3.2,.25,1,1.75,0,0,0,'black',1);//H-nostril
			

    drawShape('arc',x+sx,y+sy,z*sz,5,6.38,  2.8,  1.667,1.337,0,0,0,'rgba(63,21,1,.1)',1);//liquid
    drawShape('tri',x+sx,y+sy,z*sz,5,5, 4.5,4.5, 4.75,3,0,0,'darkgreen',1);//Inner forearm
			
    			drawShape('tri',x+sx,y+sy,z*sz,5,2.5, 4.5,5, 6,3,0,0,'green',1);//Outer arm

    drawShape('tri',x+sx,y+sy,z*sz,4.5,5, 5,4, 4.5,3,0,0,'green',1);//Outer forearm

    
      
      sx = 4*z;
      sy = 0*z;
      sz = .75;
    drawShape('qua',x+sx,y+sy,z*sz, 4.4,0.75, 5.6,0.75, 5.25,1.25, 4.75,1.25,'rgba(62,21,10,1)',1)//cork
      drawShape('qua',x+sx,y+sy,z*sz, 2.52,4.5, 7.48,4.5, 5.5,1.25, 4.5,1.25,'rgba(62,21,1,1)',1);//bottleneck
      drawShape('qua',x+sx,y+sy,z*sz, 2.53,4.5, 7.47,4.5, 5.5,1.25, 4.5,1.25,'rgba(0,0,0,.25)',0);//bottleneck

      
      drawShape('arc',x+sx,y+sy,z*sz,5,6.25,  3,  1.6163,1.3836,0,0,0,'rgba(63,21,1,1)',1);//bottle
      drawShape('arc',x+sx,y+sy,z*sz,5,6.25,  3,  1.6163,1.3836,0,0,0,'rgba(0,0,0,.25)',0);//bottle

      drawShape('ell',x+sx,y+sy,z*sz,5,3.95, 1.4,.3, 1, 1,2,0,'rgba(62,21,1,1)',1);//surface liquid
      drawShape('pol',x,y,z, 8,.5, 5.5,.25, 4,1, 3,2,'rgba(62,21,1,1)',1,2.5,3.5);//bottleneck
      drawShape('qua',x,y,z, 6,3.5, 5.5,2.5, 4.5,2.1, 8,.5,'rgba(62,21,1,1)',1,2.5,3.5);//bottleneck
      drawShape('tri',x,y,z, 2.9,3, 1.5,3.5, 2,4, 8,.5,'rgba(62,21,1,1)',1,2.5,3.5);//bottleneck
/*
      //tomearc
      sx = 6*z;
      sy = 3.5*z;
      sz = .3;
      drawShape('qua',x+sx,y+sy,z*sz,0,7.5,10,7.5,7.5,2.5,2.5,2.5,'rgba(128,64,0,.1)',1);
			drawShape('qua',x+sx,y+sy,z*sz,.2,7.1,9.8,7.1,7.5,2.5,2.5,2.5,'rgba(255,255,128,.1)',1);
			drawShape('lin',x+sx,y+sy,z*sz,5,7.5,5,2.5,0,0,0,0,'rgba(128,64,0,.185)',1);
			drawShape('arc',x+sx,y+sy,z*sz,3.75,3.8,1.79,1.25,1.75,0,0,0,'rgba(255,255,128,.1)',1);
			drawShape('arc',x+sx,y+sy,z*sz,6.25,3.8,1.79,1.25,1.75,0,0,0,'rgba(255,255,128,.1)',1);
      drawShape('qua',x+sx,y+sy,z*sz,4.77,7.2, 4.9,2.4, 4,6, 4.488,6.51,'rgba(0,0,0,.1)',1);
      drawShape('qua',x+sx,y+sy,z*sz,5.188,7.2, 5.1,2.4, 6,6, 5.512,6.51,'rgba(0,0,0,.1)',1);
			drawShape('arc',x+sx,y+sy,z*sz,2.5,7.9,2.4,1.1,1.9,0,0,0,'rgba(248,179,16,.185)',1);
			drawShape('arc',x+sx,y+sy,z*sz,7.5,7.9,2.4,1.1,1.9,0,0,0,'rgba(248,179,16,.185)',1);
      for (let i = 0;i<40;i++){
        drawShape('arc',x+sx,y+sy,z*sz,2.5,7.89, 2.39-i*.05,1.1,1.9,0,0,0,'rgba(0,0,0,.125)',0);
			  drawShape('arc',x+sx,y+sy,z*sz,7.5,7.89, 2.39-i*.05,1.1,1.9,0,0,0,'rgba(0,0,0,.125)',0);
      }
      drawShape('rec',x+sx,y+sy,z*sz,0.2,7.13,9.6,.35,0,0,0,0,'rgba(128,64,0.1)',1);
      drawShape('pol',x+sx,y+sy,z*sz,4.75,7.1, 4.9,2.42, 5.1,2.42, 5.2,7.2,'rgba(0,0,0,.145)',1, 5,7.1);
      //orb
      sx = 0.1 *z;
      sy = 3.95*z;
      sz = 1;
      drawShape('arc',x+sx,y+sy,z*sz,9,1,.8,0,6,0,0,0,'rgba(255,255,255,.015)',1);//bag
      drawShape('arc',x+sx,y+sy,z*sz,8.95,.95,.75,0,6,0,0,0,'rgba(255,255,255,.015)',1);//bag
      drawShape('arc',x+sx,y+sy,z*sz,8.9,1,.7,0,6,0,0,0,'rgba(255,255,255,.015)',1);//bag
      drawShape('arc',x+sx,y+sy,z*sz,8.85,1,.65,0,6,0,0,0,'rgba(255,255,255,.015)',1);//bag
      drawShape('arc',x+sx,y+sy,z*sz,8.8,1,.6,0,6,0,0,0,'rgba(255,255,255,.015)',1);//bag
      //sword pommel
      sx = 6.33*z;
      sy = 4.05*z;
      sz = .25;
      drawShape('arc',x+sx,y+sy,z*sz,.5,8.25, .3,.3, 0,2  ,0,0,'rgba(0,0,0,.15)',1);//sword-pommel
      drawShape('arc',x+sx,y+sy,z*sz,.5,8.25, .3,.3, 0,2  ,0,0,'rgba(0,0,0,.13)',1);//sword-pommel
      drawShape('ell',x+sx,y+sy,z*sz,.5,8.15, .2,.13, 0, 2  ,0 ,0,'rgba(128,0,0,.1)',1);//sword-pommel
      drawShape('arc',x+sx,y+sy,z*sz,.45,8.3, .275,0, 2,2  ,0,0,'rgba(0,0,0,.115)',1);//sword-pommel
      drawShape('arc',x+sx,y+sy,z*sz,.5,8.25, .3,.2, .95, 0  ,0 ,0,'rgba(0,0,0,.124)',1);//sword-pommel
      drawShape('arc',x+sx,y+sy,z*sz,.5,8.25, .3,0, 1.2, 0  ,0 ,0,'rgba(0,0,0,.124)',1);//sword-pommel

      //sword
      sx = 5.5*z;
      sy = 4*z;
      sz = .375;
      drawShape('qua',x+sx,y+sy,z*sz,4.1,5.5, 4.1,5.8, 2.8,5.81, 2.8,5.5,'rgba(0,0,0,.15)',1);//sword-handle
      drawShape('qua',x+sx,y+sy,z*sz,4.1,5.9, 4.1,6,   2.8,5.81, 2.8,5.7,'rgba(0,0,0,.14)',1);//sword-handle
      drawShape('qua',x+sx,y+sy,z*sz,4.1,5.7, 4.1,5.8, 2.8,5.81, 2.8,5.5,'rgba(0,0,0,.14)',1);//sword-handle
			drawShape('tri',x+sx,y+sy,z*sz,9,5.8, 4.1,5.35, 3.9,6.15  ,0,0,'rgba(0,0,0,.15)',1);//sword-blade
      drawShape('tri',x+sx,y+sy,z*sz,9,5.8, 4.1,5.5,  3.9,5.8  ,0,0,'rgba(0,0,0,.15)',1);//sword-blade
			drawShape('tri',x+sx,y+sy,z*sz,9,5.8, 4.1,5.35, 3.9,6.1  ,0,0,'rgba(0,0,0,.15)',1);//sword-blade
			drawShape('tri',x+sx,y+sy,z*sz,9,5.8, 4.1,5.45, 3.9,6.15  ,0,0,'rgba(0,0,0,.15)',1);//sword-blade
			drawShape('qua',x+sx,y+sy,z*sz,4.2,4.5, 4.1,5.7, 3.7,6.8, 3.6,6,'rgba(0,0,0,.15)',1);//sword-crossguard
      drawShape('qua',x+sx,y+sy,z*sz,4.2,4.5, 3.8,5.7, 3.7,6.8, 3.6,6,'rgba(0,0,0,.14)',1);//sword-crossguard
			drawShape('qua',x+sx,y+sy,z*sz,4.2,4.5, 4.1,5.7, 3.7,6.8, 3.6,6,'rgba(0,0,0,.14)',1);//sword-crossguard

      //potion
      sx = 7*z;
      sy = 4*z;
      sz = .25;
      drawShape('qua',x+sx,y+sy,z*sz, 4.4,0.75, 5.6,0.75, 5.25,2.45, 4.75,2.45,'rgba(186,103,0,.11)',1)//cork
      drawShape('qua',x+sx,y+sy,z*sz, 4.4,0.75, 5.6,0.75, 5.25,.9, 4.75,.9,'rgba(255,255,255,.11)',1)//cork
      drawShape('qua',x+sx,y+sy,z*sz, 4.4,0.75, 4.5,0.75, 5.25,2.45, 4.75,2.45,'rgba(0,0,0,.140)',1)//cork
      drawShape('qua',x+sx,y+sy,z*sz, 3.95,3.449, 6.0456,3.4488, 5.5,1.25, 4.5,1.25,'rgba(249,255,255,.128)',1);//bottleneck
      drawShape('qua',x+sx,y+sy,z*sz, 3.95,3.449, 6.0456,3.4488, 5.5,1.25, 4.5,1.25,'rgba(0,0,0,.128)',1);//bottleneck
      drawShape('arc',x+sx,y+sy,z*sz,5,6.38,  2.8,  1.667,1.337,0,0,0,'rgba(255,0,0,.1)',1);//liquid
      drawShape('arc',x+sx,y+sy,z*sz,5,6.25,  3,  1.6163,1.3836,0,0,0,'rgba(249,255,255,.128)',1);//bottle
      drawShape('arc',x+sx,y+sy,z*sz,5,6.25,  3,  1.6163,1.3836,0,0,0,'rgba(0,0,0,.128)',1);//bottle
      drawShape('ell',x+sx,y+sy,z*sz,5,3.95, 1.4,.3, 1, 1,2,0,'rgba(0,0,0,.2)',1);//surface liquid
      drawShape('ell',x+sx,y+sy,z*sz,6.3,5.44, .55,.35, 1, 0,2,0,'rgba(255,255,255,.18)',1);//reflection
      
      //coins
      sx = 6*z;
      sy = 4.5*z;
      sz = .5;
      for (let i = 20;i>0;i--){
        drawShape('ell',x+sx,y+sy,z*sz,2,2.1+i*.1,.5,.15,  0,2,0,0,'rgba(0,0,0,.14)',1);
        drawShape('ell',x+sx,y+sy,z*sz,2,2.1+i*.1,.5,.15,  0,2,0,0,'rgba(0,0,0,.14)',0);
        drawShape('ell',x+sx,y+sy,z*sz,2,2+i*.1,.5,.15,  0,2,0,0,'rgba(255,255,0,.1)',1);
      }
      //coins
      sx = 6.5*z;
      sy = 4.5*z;
      sz = .5;
      for (let i = 20;i>0;i--){
        drawShape('ell',x+sx,y+sy,z*sz,2,2.1+i*.1,.5,.15,  0,2,0,0,'rgba(0,0,0,.14)',1);
        drawShape('ell',x+sx,y+sy,z*sz,2,2.1+i*.1,.5,.15,  0,2,0,0,'rgba(0,0,0,.14)',0);
        drawShape('ell',x+sx,y+sy,z*sz,2,2+i*.1,.5,.15,  0,2,0,0,'rgba(255,255,0,.1)',1);
      }
      //coins
      sx = 7*z;
      sy = 4.5*z;
      sz = .5;
      for (let i = 20;i>0;i--){
        drawShape('ell',x+sx,y+sy,z*sz,2,2.1+i*.1,.5,.15,  0,2,0,0,'rgba(0,0,0,.14)',1);
        drawShape('ell',x+sx,y+sy,z*sz,2,2.1+i*.1,.5,.15,  0,2,0,0,'rgba(0,0,0,.14)',0);
        drawShape('ell',x+sx,y+sy,z*sz,2,2+i*.1,.5,.15,  0,2,0,0,'rgba(255,255,0,.1)',1);
      }
*/
    drawShape('tri',x,y,z,3,3.5, 2.25,3, 3,2.5,0,0,'darkgreen',1);//T-neck
    drawShape('tri',x,y,z,2.75,3.5, 2,3, 2.75,2.5,0,0,'green',1);//T-neck

    break;
    case 42://Shade 7
      drawShape('arc',x,y,z,5,5,5,0,2,0,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.0316)`,1);//bag

      drawShape('qua',x,y,z, 6.5,8.5, .75,9.5, 6,4, 6.5,7.5,'rgb(41,121,205)',1);//Cape Back
      drawShape('qua',x,y,z, 6.5,8.5, .75,9.5, 6,4, 6.5,7.5,'rgba(0,0,0,.8)',1);//Cape Back
      drawShape('qua',x,y,z, 2.75,7.5, 1.5,9.5, 1,9.5, 3.5,5.5,'rgb(0,0,0,.45)',1);//left calf
      drawShape('qua',x,y,z, 5,5, 4,6, 5.5,8, 6.5,8,'rgba(0,0,0,.3)',1);//right thigh
      drawShape('qua',x,y,z,4,3.5, 5,3, 5.5,3 ,6.5,3.6,'rgb(41,121,205)',1);//neck
      sx = 1*z;
      drawShape('qua',x+sx,y,z, 3,3.4, 7,3.6, 1.2,9.3, .75,9.5,'rgba(64,0,64,.4)',1);//Cape Front
      drawShape('qua',x+sx,y,z, 3,3.4, 7,3.6, 1.2,9.3, .75,9.5,'rgba(0,0,0,.17)',1);//body/left leg/cape?
      drawShape('pol',x+sx,y,z, 3,3.6, 7,3.4, 6,5.5, 7,9.5,'rgba(64,0,64,.4)',1,.75,9.5);//body/left leg/cape?

      drawShape('qua',x,y,z, 9,5.5, 9,6.5, 8.5,8, 8.5,6,'rgba(51,55,154,.9)',1,8.5,6);//upper arm L
      drawShape('qua',x,y,z, 9,5.5, 9,6.5, 8.5,8, 8.5,6,'rgba(0,0,0,.6)',1,8.5,6);//upper arm L

      ////////////////////////////////////
      drawShape('qua',x,y,z,5,1.4, 5.5,3.5, 4.5,3.5, 3,2,'rgb(51,55,154)',1);//head



      drawShape('tri',x,y,z,4.5,2, 5,2.3, 4.4,2.25, 0,0,'rgba(255,0,0,.45)',1);//eye
      
      drawShape('tri',x,y,z,4.5,2, 5,2.3, 4.4,2.25, 0,0,'rgba(255,0,0,.45)',1);//eye


      drawShape('tri',x,y,z,6.5,1, 6.4,2, 5,1.4,0,0,'rgba(64,0,64,1)',1);//head
      drawShape('qua',x,y,z,6.5,1, 6.5,3.5, 5.5,3.5, 5,1.4,'rgba(64,0,64,1)',1);//head
            drawShape('tri',x,y,z,8,.7, 6.5,2.5, 6.5,1.5,0,0,'rgba(0,0,0,.2)',1);//head

      drawShape('qua',x,y,z,5,1.4, 3,2, 4.5,3.5,4,2,'rgba(0,0,0,.15)',1);//head
       drawShape('tri',x,y,z,6.5,1, 6.4,2, 5,1.4,0,0,'rgba(0,0,0,.15)',1);//head
      drawShape('qua',x,y,z,6.5,1, 6.5,3.5, 5.5,3.5, 5,1.4,'rgba(0,0,0,.15)',1);//head
          drawShape('pol',x,y,z,5,.9, 8,.5, 8.25,.75, 8,.69,'rgba(0,0,0,.15)',1,6,3);//head

      drawShape('qua',x,y,z,5,1.4, 3,2, 4.5,3.5, 4,2,'rgba(64,0,64,1)',1);//head
      drawShape('tri',x,y,z,6.5,1, 3,2, 5,.9,0,0,'rgb(41,121,205)',1);//hat
      drawShape('tri',x,y,z,6.5,1, 3,2, 5,.9,0,0,'rgba(0,0,0,.05)',1);//hat
      drawShape('qua',x,y,z,5,1.4, 3,2, 4.5,3.5, 4,2,'rgba(0,0,0,.2)',1);//head
      drawShape('tri',x,y,z,6.5,1, 3,2, 5,.9,0,0,'rgba(0,0,0,.2)',1);//hat
      drawShape('tri',x,y,z,6.5,1, 3,2, 5,.9,0,0,'rgba(0,0,0,.05)',1);//hat
      ////////////////////////////////////////////////////////////////
      drawShape('qua',x,y,z,5.5,3.5, 6,3.5, 6.1,2, 5,1.5,'rgb(51,55,154)',1);//head
      ////////////////////////////////////////////////////////////
      drawShape('qua',x,y,z, 6.5,8, 5,9.5, 4.5,9.5, 5.5,8,'rgb(0,0,0,.015)',1);//right calf
      drawShape('pol',x,y,z, 3,3.42, 1.5,5.5, 1.25,7, 2,6.75,'rgba(0,0,0,.13)',1,2.8,4.75);//upper arm L
      drawShape('qua',x,y,z, 9,5.5, 8.5,6, 8.5,8, 8.8,6,'rgba(64,0,64,.9)',1,8.5,6);//upper arm L
      drawShape('qua',x,y,z, 8.5,8, 7,6.5, 6,4.5, 6.5,4,'rgba(64,0,64,.9)',1,8.5,6);//upper arm L
      drawShape('qua',x,y,z, 7,3.4, 7.5,5.5, 9,5.5, 8.5,6,'rgba(64,0,64,.9)',1,8.5,8);//upper arm L
      drawShape('qua',x,y,z, 8.25,5.5, 8.5,6, 8.5,8, 7.5,6,'rgba(64,0,64,.9)',1,7.5,5.5);//upper arm L
      drawShape('tri',x,y,z, 8.25,5.5, 7.5,6, 7,3.5, 7.5,6,'rgba(64,0,64,.9)',1,7.5,5.5);//upper arm L
      drawShape('tri',x,y,z, 7,3.4, 6.6,4.25, 7.5,6, 7.5,6,'rgba(64,0,64,.9)',1,7.5,5.5);//upper arm L
      drawShape('tri',x,y,z, 7,3.4, 6.6,4.25, 7.5,6, 7.5,6,'rgba(0,0,0,.2)',1,7.5,5.5);//upper arm L

      drawShape('qua',x,y,z, 9,5.5, 8.5,6, 8.5,8, 8.8,6,'rgba(0,0,0,.1)',1,8.5,6);//upper arm L
      drawShape('qua',x,y,z, 8.5,8, 7,6.5, 6,4.5, 6.5,4,'rgba(0,0,0,.3)',1,8.5,6);//upper arm L
      drawShape('qua',x,y,z, 7,3.4, 7.5,5.5, 9,5.5, 8.5,6,'rgba(0,0,0,.2)',1,8.5,8);//upper arm L
      drawShape('qua',x,y,z, 8.25,5.5, 8.5,6, 8.5,8, 7.5,6,'rgba(0,0,0,.2)',1,7.5,5.5);//upper arm L
      drawShape('tri',x,y,z, 8.25,5.5, 7.5,6, 7,3.5, 7.5,6,'rgba(0,0,0,.2)',1,7.5,5.5);//upper arm L
        //////////////////////////////////////////////////////////////////////////
      sx = 1*z;
      drawShape('qua',x+sx,y,z, 3.5,8, 5,9.5, 5.5,9.5, 4.5,8,'rgb(0,0,0,.015)',1);//right calf
      drawShape('pol',x+sx,y,z, 3,3.42, 1.5,5.5, 1.25,7, 2,6.75,'rgba(0,0,0,.13)',1,7.2,4.75);//upper arm L
      drawShape('qua',x+sx,y,z, 1,5.5, 1.5,6, 1.5,8, 1.2,6,'rgba(64,0,64,.9)',1,8.5,6);//upper arm L
      drawShape('qua',x+sx,y,z, 1.5,8, 3,6.5, 4,4.5, 3.5,4,'rgba(64,0,64,.9)',1,8.5,6);//upper arm L
      drawShape('qua',x+sx,y,z, 3,3.4, 2.5,5.5, 1,5.5, 1.5,6,'rgba(64,0,64,.9)',1,8.5,8);//upper arm L
      drawShape('qua',x+sx,y,z, 1.75,5.5, 1.5,6, 1.5,8, 2.5,6,'rgba(64,0,64,.9)',1,7.5,5.5);//upper arm L
      drawShape('tri',x+sx,y,z, 1.75,5.5, 2.5,6, 3,3.5, 2.5,6,'rgba(64,0,64,.9)',1,7.5,5.5);//upper arm L
      drawShape('tri',x+sx,y,z, 3,3.4, 3.4,4.25, 2.5,6, 2.5,6,'rgba(64,0,64,.9)',1,7.5,5.5);//upper arm L
      drawShape('tri',x+sx,y,z, 3,3.4, 3.4,4.25, 2.5,6, 2.5,6,'rgba(0,0,0,.2)',1,7.5,5.5);//upper arm L

      drawShape('qua',x+sx,y,z, 1,5.5, 1.5,6, 1.5,8, 1.2,6,'rgba(0,0,0,.1)',1,8.5,6);//upper arm L
      drawShape('qua',x+sx,y,z, 1.5,8, 3,6.5, 4,4.5, 3.5,4,'rgba(0,0,0,.3)',1,8.5,6);//upper arm L
      drawShape('qua',x+sx,y,z, 3,3.4, 2.5,5.5, 1,5.5, 1.5,6,'rgba(0,0,0,.2)',1,8.5,8);//upper arm L
      drawShape('qua',x+sx,y,z, 1.75,5.5, 1.5,6, 1.5,8, 2.5,6,'rgba(0,0,0,.2)',1,7.5,5.5);//upper arm L
      drawShape('tri',x+sx,y,z, 1.75,5.5, 2.5,6, 3,3.5, 2.5,6,'rgba(0,0,0,.2)',1,7.5,5.5);//upper arm L
      //
      drawShape('qua',x+sx,y,z, 1,5.5, 1,6.5, 1.5,8, 1.5,6,'rgba(51,55,154.9)',1,8.5,6);//upper arm L
      drawShape('qua',x+sx,y,z, 1,5.5, 1,6.5, 1.5,8, 1.5,6,'rgba(0,0,0,.6)',1,8.5,6);//upper arm L
            drawShape('tri',x,y,z,5.6,2, 5.1,2.3, 5.7,2.25, 0,0,'rgba(255,0,0,.45)',1);//eye
            drawShape('tri',x,y,z,5.6,2, 5.1,2.3, 5.7,2.25, 0,0,'rgba(255,0,0,.45)',1);//eye
      /////////////////////////////////////////////////////////////////////////////////////
       //////////////////////////////////////////////////////////////////////////////////////////
      drawShape('qua',x,y,z, 6.5,8.5, .75,9.5, 6,4, 6.5,7.5,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1);//Cape Back
      drawShape('qua',x,y,z, 6.5,8.5, .75,9.5, 6,4, 6.5,7.5,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1);//Cape Back
      drawShape('qua',x,y,z, 2.75,7.5, 1.5,9.5, 1,9.5, 3.5,5.5,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1);//left calf
      drawShape('qua',x,y,z, 5,5, 4,6, 5.5,8, 6.5,8,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1);//right thigh
      drawShape('qua',x,y,z,4,3.5, 5,3, 5.5,3 ,6.5,3.6,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1);//neck
      sx = 1*z;
      drawShape('qua',x+sx,y,z, 3,3.4, 7,3.6, 1.2,9.3, .75,9.5,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1);//Cape Front
      drawShape('qua',x+sx,y,z, 3,3.4, 7,3.6, 1.2,9.3, .75,9.5,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1);//body/left leg/cape?
      drawShape('pol',x+sx,y,z, 3,3.6, 7,3.4, 6,5.5, 7,9.5,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1,.75,9.5);//body/left leg/cape?

      drawShape('qua',x,y,z, 9,5.5, 9,6.5, 8.5,8, 8.5,6,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1,8.5,6);//upper arm L
      drawShape('qua',x,y,z, 9,5.5, 9,6.5, 8.5,8, 8.5,6,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1,8.5,6);//upper arm L

      ////////////////////////////////////
      drawShape('qua',x,y,z,5,1.4, 5.5,3.5, 4.5,3.5, 3,2,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1);//head



      drawShape('tri',x,y,z,4.5,2, 5,2.3, 4.4,2.25, 0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1);//eye
      
      drawShape('tri',x,y,z,4.5,2, 5,2.3, 4.4,2.25, 0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1);//eye


      drawShape('tri',x,y,z,6.5,1, 6.4,2, 5,1.4,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1);//head
      drawShape('qua',x,y,z,6.5,1, 6.5,3.5, 5.5,3.5, 5,1.4,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1);//head
            drawShape('tri',x,y,z,8,.7, 6.5,2.5, 6.5,1.5,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1);//head

      drawShape('qua',x,y,z,5,1.4, 3,2, 4.5,3.5,4,2,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1);//head
       drawShape('tri',x,y,z,6.5,1, 6.4,2, 5,1.4,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1);//head
      drawShape('qua',x,y,z,6.5,1, 6.5,3.5, 5.5,3.5, 5,1.4,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1);//head
          drawShape('pol',x,y,z,5,.9, 8,.5, 8.25,.75, 8,.69,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1,6,3);//head

      drawShape('qua',x,y,z,5,1.4, 3,2, 4.5,3.5, 4,2,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1);//head
      drawShape('tri',x,y,z,6.5,1, 3,2, 5,.9,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1);//hat
      drawShape('tri',x,y,z,6.5,1, 3,2, 5,.9,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1);//hat
      drawShape('qua',x,y,z,5,1.4, 3,2, 4.5,3.5, 4,2,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1);//head
      drawShape('tri',x,y,z,6.5,1, 3,2, 5,.9,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1);//hat
      drawShape('tri',x,y,z,6.5,1, 3,2, 5,.9,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1);//hat
      ////////////////////////////////////////////////////////////////
      drawShape('qua',x,y,z,5.5,3.5, 6,3.5, 6.1,2, 5,1.5,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1);//head
        ////////////////////////////////////////////////////////////
      drawShape('qua',x,y,z, 6.5,8, 5,9.5, 4.5,9.5, 5.5,8,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1);//right calf
      drawShape('pol',x,y,z, 3,3.42, 1.5,5.5, 1.25,7, 2,6.75,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1,2.8,4.75);//upper arm L
      drawShape('qua',x,y,z, 9,5.5, 8.5,6, 8.5,8, 8.8,6,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1,8.5,6);//upper arm L
      drawShape('qua',x,y,z, 8.5,8, 7,6.5, 6,4.5, 6.5,4,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1,8.5,6);//upper arm L
      drawShape('qua',x,y,z, 7,3.4, 7.5,5.5, 9,5.5, 8.5,6,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1,8.5,8);//upper arm L
      drawShape('qua',x,y,z, 8.25,5.5, 8.5,6, 8.5,8, 7.5,6,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1,7.5,5.5);//upper arm L
      drawShape('tri',x,y,z, 8.25,5.5, 7.5,6, 7,3.5, 7.5,6,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1,7.5,5.5);//upper arm L
      drawShape('tri',x,y,z, 7,3.4, 6.6,4.25, 7.5,6, 7.5,6,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1,7.5,5.5);//upper arm L
      drawShape('tri',x,y,z, 7,3.4, 6.6,4.25, 7.5,6, 7.5,6,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1,7.5,5.5);//upper arm L

      drawShape('qua',x,y,z, 9,5.5, 8.5,6, 8.5,8, 8.8,6,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1,8.5,6);//upper arm L
      drawShape('qua',x,y,z, 8.5,8, 7,6.5, 6,4.5, 6.5,4,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1,8.5,6);//upper arm L
      drawShape('qua',x,y,z, 7,3.4, 7.5,5.5, 9,5.5, 8.5,6,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1,8.5,8);//upper arm L
      drawShape('qua',x,y,z, 8.25,5.5, 8.5,6, 8.5,8, 7.5,6,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1,7.5,5.5);//upper arm L
      drawShape('tri',x,y,z, 8.25,5.5, 7.5,6, 7,3.5, 7.5,6,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1,7.5,5.5);//upper arm L
/     /////////////////////////////////////////////////////////////////////////
      sx = 1*z;
      drawShape('qua',x+sx,y,z, 3.5,8, 5,9.5, 5.5,9.5, 4.5,8,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1);//right calf
      drawShape('pol',x+sx,y,z, 3,3.42, 1.5,5.5, 1.25,7, 2,6.75,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1,7.2,4.75);//upper arm L
      drawShape('qua',x+sx,y,z, 1,5.5, 1.5,6, 1.5,8, 1.2,6,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1,8.5,6);//upper arm L
      drawShape('qua',x+sx,y,z, 1.5,8, 3,6.5, 4,4.5, 3.5,4,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1,8.5,6);//upper arm L
      drawShape('qua',x+sx,y,z, 3,3.4, 2.5,5.5, 1,5.5, 1.5,6,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1,8.5,8);//upper arm L
      drawShape('qua',x+sx,y,z, 1.75,5.5, 1.5,6, 1.5,8, 2.5,6,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1,7.5,5.5);//upper arm L
      drawShape('tri',x+sx,y,z, 1.75,5.5, 2.5,6, 3,3.5, 2.5,6,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1,7.5,5.5);//upper arm L
      drawShape('tri',x+sx,y,z, 3,3.4, 3.4,4.25, 2.5,6, 2.5,6,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1,7.5,5.5);//upper arm L
      drawShape('tri',x+sx,y,z, 3,3.4, 3.4,4.25, 2.5,6, 2.5,6,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1,7.5,5.5);//upper arm L

      drawShape('qua',x+sx,y,z, 1,5.5, 1.5,6, 1.5,8, 1.2,6,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1,8.5,6);//upper arm L
      drawShape('qua',x+sx,y,z, 1.5,8, 3,6.5, 4,4.5, 3.5,4,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1,8.5,6);//upper arm L
      drawShape('qua',x+sx,y,z, 3,3.4, 2.5,5.5, 1,5.5, 1.5,6,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1,8.5,8);//upper arm L
      drawShape('qua',x+sx,y,z, 1.75,5.5, 1.5,6, 1.5,8, 2.5,6,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1,7.5,5.5);//upper arm L
      drawShape('tri',x+sx,y,z, 1.75,5.5, 2.5,6, 3,3.5, 2.5,6,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.03)`,1,7.5,5.5);//upper arm L
//
      break;
    case 43://Teleportation Crystal 8
              drawShape('arc',x,y,z,5,5,5,0,2,0,0,0,'rgba(255,255,255,.05)',1);

 
      aniDice.setColor(0,0, .7)
      aniDice.setGlow(Math.floor(Math.random()*255))
      aniDice.animate((x)+5*z,(y)+5*z,7*z,.13,globalDt);
      
                        
     
    break;
    case 44://9 Djinn Lamp
       drawShape('arc',x,y,z,5,5,5,0,2,0,0,0,'rgba(255,255,255,.05)',1);
      //lamp
      sx = -14*z;
      sy = -33*z;
      sz = 4;

      drawShape('pol',x+sx,y+sy,z*sz, 3.6,9.36, 4,9.45, 4.5,9.5, 5,9.25,'rgba(255,201,14,.65)',1, 4.9,10);//upper arm R
      drawShape('pol',x+sx,y+sy,z*sz,5.6,9.5, 6,9.45, 5.5,9.5, 5,9.25,'rgba(255,201,14,.65)',1, 5.1,10);//upper arm R
      drawShape('pol',x+sx,y+sy,z*sz,4.6,10, 4.9,9.9, 5,9.25, 5.1,9.9,'rgba(255,201,14,.75)',1, 5.4,10);//upper arm R
      drawShape('pol',x+sx,y+sy,z*sz,5.5,9.5, 5.6,9.4, 5.8,9.5, 5.75,9.75,'rgba(255,201,14,.75)',1, 5.6,9.7);//upper arm R
      drawShape('arc',x+sx,y+sy,z*sz,5.65,9.57,.069,0,6,0,0,0,'rgba(0,0,0,.9)',1);//head
      break;
    case 45://10 Lucky Charm
      drawShape('arc',x,y,z,5,5,5,0,2,0,0,0,'rgba(0,128,255,.05)',1);
      drawShape('arc',x,y,z,5,6.25,2,0,2,0,0,0,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},${Math.random()*.13})`,1);

      for (let i=0;i<10;i++){
        drawShape('ell',x,y,z,5,2.65,3-i*.01,2.5-i*.01,0,2,0,0,'rgba(160,116,77,1)',0)
      }
      sz = 8;
      sx = -35*z;
      sy=-30.6*z;
      drawShape('arc',x+sx,y+sy,z*sz,5,4.6,.13,0,6,0,0,0,'gold',1);//amulet
      drawShape('arc',x+sx,y+sy,z*sz,5,4.6,.1,0,6,0,0,0,'yellow',1);//amulet
     drawShape('arc',x+sx,y+sy,z*sz,5,4.6,.13,0,6,0,0,0,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},${Math.random()*.3})`,1);//amulet
     
      for (let i=0;i<10;i++){
      drawShape('ell',x,y,z,5,5.1,.1-i*.01,.1-i*.01,0,2,0,0,'rgba(160,116,77,1)',0)

      }

      break;
    case 46://Sea Serpent

      for (let i=0;i<60;i++){
        ////////////////////////////
        drawShape('ell',x,y,z,    1+i*.001, 9+i*.001,        Math.random()*.6+i*.005,   Math.random()*.6+i*.005,  0,    0,   2,    0,   `rgba(0,${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.random()*.4})`,0)

        drawShape('ell',x,y,z,    7+i*.001, 2+i*.001,        Math.random()*.4+i*.005,   Math.random()*.4+i*.005,  0,    0,   2,    0,   `rgba(0,${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.random()*.4})`,0)
        drawShape('ell',x,y,z,    5+i*.001, 8+i*.001,        Math.random()*0.01+i*.0025,   Math.random()*.01+i*.0025,  0,    0,   2,    0,   `rgba(0,${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.random()*.4})`,0)
        drawShape('ell',x,y,z,    2+i*.001, 3+i*.001,        Math.random()*0.01+i*.0025,   Math.random()*.01+i*.0025,  0,    0,   2,    0,   `rgba(0,${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.random()*.4})`,0)
        drawShape('ell',x,y,z,    4+i*.001, 4+i*.001,        Math.random()*0.01+i*.0025,   Math.random()*.01+i*.0025,  0,    0,   2,    0,   `rgba(0,${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.random()*.4})`,0)
        drawShape('ell',x,y,z,    9+i*.001, 6+i*.001,        Math.random()*0.01+i*.0025,   Math.random()*.01+i*.0025,  0,    0,   2,    0,   `rgba(0,${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.random()*.4})`,0)
        drawShape('ell',x,y,z,    8+i*.001, 1+i*.001,        Math.random()*0.01+i*.0025,   Math.random()*.01+i*.0025,  0,    0,   2,    0,   `rgba(0,${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.random()*.4})`,0)
        drawShape('ell',x,y,z,    1+i*.001, 6+i*.001,        Math.random()*0.01+i*.0025,   Math.random()*.01+i*.0025,  0,    0,   2,    0,   `rgba(0,${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.random()*.4})`,0)
        drawShape('ell',x,y,z,    4.5+i*.001, 1+i*.001,        Math.random()*0.01+i*.0025,   Math.random()*.01+i*.0025,  0,    0,   2,    0,   `rgba(0,${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.random()*.4})`,0)


        drawShape('ell',x,y,z,    1.5+Math.random()*8+i*.001, 1.5+Math.random()*8+i*.001,        Math.random()*0.01+i*.0025,   Math.random()*.01+i*.0025,  0,    0,   2,    0,   `rgba(0,${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.random()*.4})`,0)
      drawShape('ell',x,y,z,    2+i*.001, 2+i*.001,        Math.random()+i*.005,   Math.random()+i*.005,  0,    0,   2,    0,   `rgba(0,${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.random()*.4})`,0)

      drawShape('ell',x,y,z,    8+i*.001, 8+i*.001,        Math.random()+i*.005,   Math.random()+i*.005,  0,    0,   2,    0,   `rgba(0,${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.random()*.4})`,0)

      }
      //tail
      drawShape('pol',x,y,z,3.5,6.1, 5.5,6.5, 8,5, 6,3,'rgb(0,128,128)',1,7,5);
      //tail shadow
      drawShape('pol',x,y,z,3.5,6.1, 5.5,6.5, 8,5, 6,3,'rgba(0,0,0,.2)',1,7,5);
      drawShape('pol',x,y,z,5,6, 8,5, 7,4, 7.5,5,'rgb(0,128,128)',1,6.5,5.5);
      drawShape('qua',x,y,z,4,6, 7,5, 6,3, 7.5,5,'rgb(0,128,128)',1,5,6);
      //back glow
      drawShape('arc',x,y,z,5,5,5,0,2,0,0,0,'rgba(0,128,128,.09)',1);
      //Head and mouth gap offsets
      sx = 3.75*z;
      sy = -6*z
      sz = 1.25;
      //main head 
      drawShape('qua',x+sx,y+sy,z*sz,1,8, 3,9.5, 4,8, 2.5,7.5,'rgb(0,128,128)',1);
      //mouth gap
      drawShape('qua',x+sx,y+sy,z*sz,3,9.51, 4.005,8, 2,8, 2.25,8.75,'rgba(0,0,0,.9)',1);
			//throat
      drawShape('tri',x,y,z,5,5, 5,6, 5.75,4.75, 2,6,'rgb(0,128,128)',1);
      drawShape('tri',x,y,z,5,4, 5,5, 5.75,4.75, 2,6,'rgb(0,128,128)',1);
			drawShape('tri',x,y,z,5,4, 5.8,4.6, 5.75,4.75, 2,6,'rgb(0,128,128)',1);

      //inside mouth
      drawShape('pol',x,y,z,6.5,4, 7,4.5, 7.5,5.5, 7.5,6,'rgba(0,128,128,.2)',1,5,4);
      drawShape('pol',x,y,z,8.75,4, 8.2,4.35, 7.5,4.5, 6.5,4.5,'rgba(0,128,128,.2)',1,6.5,4);
      //throat
      drawShape('tri',x,y,z,5,4, 5.8,4.6, 5.75,4.75, 2,6,'rgba(0,0,0,.7)',1);

      //eye
      drawShape('arc',x,y,z,7,3.5,.15,0,2,0,0,0,'rgba(0,0,0,.9)',1);
      //body lower
    drawShape('pol',x,y,z,5.5,6.5, 4.5,7, 4,8, 3,9,'rgb(0,128,128)',1,4,6);
        drawShape('pol',x,y,z,5.5,6.5, 4.5,7, 4,8, 3,9,'rgba(0,0,0,.2)',1,4,6);

   // drawShape('pol',x,y,z,6,0, 2.5,3, 4,4, 5,4,'rgba(0,0,0,.2)',1,8,0);

      //body upper
    
      //drawShape('qua',x,y,z,5.5,6.5, 4.5,7, 7,9, 8.5,10,'rgba(0,0,0,.75)',1,8,10);
      //drawShape('qua',x,y,z,5.5,6.5, 4.5,7, 7,9, 8.5,10,'rgba(0,0,0,.75)',1,8,10);
      drawShape('arc',x,y,z,2.9,7.36,1.6,.48,1.6,1,0,0,'rgba(0,128,128,1)',1);
      drawShape('qua',x,y,z,2,7.5, 2,8, 2,7, 2,6,'rgb(0,128,128)',1);
      drawShape('qua',x,y,z,2,6, 5,4, 5,6, 3,9,'rgb(0,128,128)',1);
    break;
    case 47://Undine 
    sy = -1*z
      //ribs bone
			drawShape('ell',x,y+sy,z,5,4.5, .9,1,0,0.1,.9,0,'rgba(41,121,205,.05)',1);//rib5
			drawShape('ell',x,y+sy,z,5,4.5, .5,.7,0,0.1,.9,0,'rgba(41,121,205,.05)',1);//rib5-shadow
			drawShape('ell',x,y+sy,z,5,4, .9,1,0,0.1,.9,0,'rgba(41,121,205,.05)',1);//rib4
			drawShape('ell',x,y+sy,z,5,4, 1,.7,0,0.1,.9,0,'rgba(41,121,205,.05)',1);//rib4-shadow
			drawShape('ell',x,y+sy,z,5,3.5, 1,1,0,0.1,.9,0,'rgba(41,121,205,.05)',1);//rib3
			drawShape('ell',x,y+sy,z,5,3.5, 1,.7,0,0.1,.9,0,'rgba(41,121,205,.05)',1);//rib3-shadow
			drawShape('ell',x,y+sy,z,5,3, 1.3,1,0,0.1,.9,0,'rgba(41,121,205,.05)',1);//rib2
			drawShape('ell',x,y+sy,z,5,3, 1,.7,0,0.1,.9,0,'rgba(41,121,205,.05)',1);//rib2-shadow
			drawShape('ell',x,y+sy,z,5,2.9, .9,1,0,0.1,.9,0,'rgba(41,121,205,.35)',1);//rib1
			//lower body bone
			drawShape('ell',x,y+sy,z,5,6,1,.5,0,0,6,0,'rgba(41,121,205,.05)',1);//hip
			drawShape('arc',x,y+sy,z,5.75,6,.5,0,6,0,0,0,'rgba(41,121,205,.05)',1);//hip
			drawShape('arc',x,y+sy,z,4.25,6,.5,0,6,0,0,0,'rgba(41,121,205,.05)',1);//hip
      
      //upper body
      drawShape('pol',x,y+sy,z,4,3.5, 4.1,4.6, 4.25,5.25, 4.5,5.5,'rgba(41,121,205,.35)',1,5,4.5);//lower arm R
      drawShape('pol',x,y+sy,z,6,3.5, 5.9,4.6, 5.75,5.25, 5.5,5.5,'rgba(41,121,205,.35)',1,5,4.5);//lower arm R
      drawShape('qua',x,y+sy,z,4,3.5, 6,3.5, 4.5,5.5, 5.5,5.5,'rgba(41,121,205,.35)',1,6,3.5);//lower arm R
      drawShape('tri',x,y+sy,z,5,4.5, 4.5,5.5, 5.5,5.5, 5.5,5.5,'rgba(41,121,205,.35)',1,6,3.5);//lower arm R
      //hips
     // drawShape('arc',x,y+sy,z,4.5,6,.75,0,6,0,0,0,'rgba(41,121,205,.35)',1);//r-hand
     // drawShape('arc',x,y+sy,z,5.5,6,.75,0,6,0,0,0,'rgba(41,121,205,.35)',1);//r-hand
      //thighs
      drawShape('pol',x,y+sy,z,3.75,6, 3.5,7.5, 4,8, 5,7,'rgba(41,121,205,.35)',1,5,4.5);//lower arm R
      drawShape('pol',x,y+sy,z,6.25,6, 6.5,7.5, 6,8, 5,7,'rgba(41,121,205,.15)',1,5,4.5);//lower arm R
      drawShape('qua',x,y,z,6,4.5, 5.5,4.25, 5,4.6, 6,6,'rgba(41,121,205,.35)',1,4,5);//lower arm R

      //feet
      drawShape('pol',x,y,z,4,8, 3.5,8.5, 4,9, 4.5,8.5,'rgba(41,121,205,.1)',1,4.1,8);//lower arm R
      drawShape('qua',x,y,z,6,7.5, 6,8, 7,8.5, 6.5,8,'rgba(41,121,205,.1)',1,4.1,8);//lower arm R
      //shoulders
      drawShape('qua',x,y,z,3.25,2, 4.2,2.25, 4.5,2.5, 4,3,'rgba(41,121,205,.35)',1,4.1,8);//lower arm R
      drawShape('qua',x,y,z,6.75,2, 5.8,2.25, 5.5,2.5, 6,3,'rgba(41,121,205,.35)',1,4.1,8);//lower arm R
      //weapon
      sy = 1.5*z;
      sx = -1*z;
      drawShape('pol',x+sx,y+sy,z,4,4.5, 7,2.5, 8.25,1.75, 1.5,6,'rgba(41,121,205,.35)',1,3.5,4.5);//lower arm R
      
        drawShape('pol',x+sx,y+sy,z,4,4.5, 7,2.5, 8.25,1.75, 1.5,6,'rgba(41,121,205,.35)',1,4,5);//lower arm R
           
        drawShape('pol',x+sx,y+sy,z,4,4.5, 7,2.5, 8.25,1.75, 1.5,6,`rgba(41,121,205,${Math.random()}`,1,3.5,4.5);//lower arm R
      
        drawShape('pol',x+sx,y+sy,z,4,4.5, 7,2.5, 8.25,1.75, 1.5,6,'rgba(41,121,205,Math.random())',1,4,5);//lower arm R
       
        //hands
        drawShape('qua',x,y,z,6,4.5, 5.5,4.25, 5,4.8, 5.75,4.7,'rgba(41,121,205,.8)',1,4,5);//lower arm R
        drawShape('qua',x,y,z,3.5,5, 4,5.25, 4,5.5, 3.5,5.75,'rgba(41,121,205,.8)',1,3.4,5.5);//lower arm R
        drawShape('qua',x,y,z,3,6.1, 7.75,3, 7.5,3, 3,6,'rgba(41,121,205,.3)',1,4,5);//lower arm R
        drawShape('tri',x,y,z,3.5,5, 3,4, 3.5,5.5, 3.5,5.5,'rgba(41,121,205,.2)',1,3.4,5.5);//lower arm R
        drawShape('qua',x,y,z,3.5,5.5, 3.4,5.4, 3,4.5, 4,5.5,'rgba(41,121,205,.2)',1,3.4,5.5);//lower arm R
        drawShape('tri',x,y,z,4,5.2, 3.25,4.5, 3.5,5.5, 3.5,5.5,'rgba(41,121,205,.2)',1,3.4,5.5);//lower arm R

        sy = -1*z;
      sx = .25*z;
			//arms
      drawShape('tri',x+sx,y+sy,z,3.25,3.5, 3.63,3.63, 2, 5,0,0,'rgba(41,121,205,.05)',1);//l-arm
			drawShape('arc',x+sx,y+sy,z,3.5,3.5,.25,0,6,0,0,0,'rgba(41,121,205,.05)',1);//l-shoulder
      drawShape('tri',x+sx,y+sy,z,2,5, 2.75,3.5, 2.3,5,0,0,'rgba(41,121,205,.05)',1);//l-forearm
      //upper arm l
      drawShape('pol',x+sx,y+sy,z, 2,5, 2.5,4.25, 3.5,3, 3.5,3.5,'rgba(41,121,205,.35)',1,3.5,4);//upper arm l
      //lower arm l
      drawShape('pol',x,y,z, 2.25,4, 2.5,3.5, 3.5,5, 3.5,5.5,'rgba(41,121,205,.35)',1,3.55,5.5);//lower arm l
      drawShape('arc',x+sx,y+sy,z,3.5,3.5,.35,0,6,0,0,0,'rgba(41,121,205,.35)',1);//r-hand
      sx = -.25*z;
			drawShape('arc',x+sx,y+sy,z,6.5,3.5,.25,0,6,0,0,0,'rgba(41,121,205,.05)',1);//r-shoulder
			drawShape('tri',x+sx,y+sy,z,6.75,3.5,6.25,3.5,8,5,0,0,'rgba(41,121,205,.05)',1);//r-arm
			drawShape('tri',x+sx,y+sy,z,7.8,4.8,8,5,5.5,5.75,0,0,'rgba(41,121,205,.05)',1);//r-forearm
			//upper arm r
      drawShape('pol',x+sx,y+sy,z, 8,5, 7.5,4.25, 6.5,3, 6.5,3.5,'rgba(41,121,205,.35)',1,6.5,4);//upper arm R
      //lower arm r
      drawShape('pol',x+sx,y+sy,z, 8,5, 6.5,5.5, 6,5.5, 7,5,'rgba(41,121,205,.35)',1,7.5,4.6);//lower arm R
      drawShape('arc',x+sx,y+sy,z,6.5,3.5,.35,0,6,0,0,0,'rgba(41,121,205,.35)',1);//r-hand
      sz= 1.5;
      let xoffset = -2.5*z;
      let yoffset = -1*z
      //hair
      sy = .5*z+yoffset
      sx = .5*z+xoffset
        drawShape('pol',x+sx,y+sy,z*sz, 5,1, 4.5,1.5, 4.75,2.3, 4.5,1.4,'rgba(41,121,205,.2)',1,7.5,1.6);//lower arm 
      sy = .25*z+yoffset
      sx = .25*z+xoffset
      drawShape('pol',x+sx,y+sy,z*sz, 5,1, 4.5,1.5, 4.75,2.3, 4.5,1.4,'rgba(41,121,205,.2)',1,7.5,1.6);//lower arm R
      sx = 0*z+xoffset
      sy = 0*z+yoffset
      drawShape('qua',x+sx,y+sy,z*sz, 5,1, 5.5,1.5, 5.25,2.3, 5,1.5,'rgba(41,121,205,.2)',1,7.5,1.6);//lower arm R
      drawShape('pol',x+sx,y+sy,z*sz, 5,1, 4.5,1.5, 4.75,2.3, 4.5,1.4,'rgba(41,121,205,.2)',1,7.5,1.6);//lower arm R
      sx = -.25*z+xoffset
      drawShape('qua',x+sx,y+sy,z*sz, 5,1, 4.5,1.5, 4.75,2.3, 5,1.5,'rgba(41,121,205,.2)',1,7.5,1.6);//lower arm R
      drawShape('qua',x+sx,y+sy,z*sz, 5,1, 5.5,1.5, 5.25,2.3, 5,1.5,'rgba(41,121,205,.2)',1,7.5,1.6);//lower arm R
      sy = 0*z+yoffset
      sx = 0*z+xoffset
      //head
      drawShape('qua',x+sx,y+sy,z*sz, 5.1,1.3, 4.5,1.8, 5,2.3, 5.5,1.8,'rgba(41,121,205,.45)',1,7.5,4.6);//lower arm R
      
      //hair
      drawShape('qua',x+sx,y+sy,z*sz, 5,1, 4.5,1.5, 4.75,2.3, 5,1.5,'rgba(41,121,205,.2)',1,7.5,1.6);//lower arm R
      drawShape('pol',x+sx,y+sy,z*sz, 5,1, 4.5,1.5, 4.75,2.3, 4.5,1.4,'rgba(41,121,205,.2)',1,7.5,1.6);//lower arm R


      
      //left calf
      sx = -6.3*z;
      sy = -2.3*z;
      sz = 2.25;
      for (let i=0;i<60;i++){
        ////////////////////////////
        //floating island topMath.random()*8
        drawShape('ell',x+sx,y+sy,z*sz,    4.5+i*.001, 4+i*.001,        .5-i*.005,   0+i*.005,  0,    1,   2,    0,   `rgba(41,121,205,.15)`,0)
        //floating island botn     
        drawShape('ell',x+sx,y+sy,z*sz,    4.51+i*.001, 4+i*.001,        .49-i*.005,   0+i*.01,  0,    2,   1,    0,   `rgba(41,121,205,.15)`,0)
       //floating island topM ath.random()*8
        drawShape('ell',x+sx,y+sy,z*sz,    4.5+i*.001, 4.5+i*.001,       Math.random()+ .25-i*.0025,   0+i*.005,  0,    1,   2,    0,   `rgba(41,121,205,.05)`,0)
        //floating island botn     
        drawShape('ell',x+sx,y+sy,z*sz,    4.51+i*.001, 4.4+i*.001,        Math.random()+.249-i*.0025,   0+i*.01,  0,    2,   1,    0,   `rgba(41,121,205,.05)`,0)
      
      }
      //right calf 
      sx = -3*z;
      sy = -1.5*z;
      sz = 2;
      for (let i=0;i<60;i++){
       //floating island topMath.random()*8
        drawShape('ell',x+sx,y+sy,z*sz,    4.5+i*.001, 4+i*.001,        .5-i*.005,   0+i*.005,  0,    1,   2,    0,   `rgba(41,121,205,.15)`,0)
        //floating island botn     
        drawShape('ell',x+sx,y+sy,z*sz,    4.51+i*.001, 4+i*.001,        .49-i*.005,   0+i*.01,  0,    2,   1,    0,   `rgba(41,121,205,.15)`,0)
        //floating island topM ath.random()*8
        drawShape('ell',x+sx,y+sy,z*sz,    4.5+i*.001, 4.5+i*.001,       Math.random()+ .25-i*.0025,   0+i*.005,  0,    1,   2,    0,   `rgba(41,121,205,.05)`,0)
        //floating island botn     
        drawShape('ell',x+sx,y+sy,z*sz,    4.51+i*.001, 4.4+i*.001,        Math.random()+.249-i*.0025,   0+i*.01,  0,    2,   1,    0,   `rgba(41,121,205,.05)`,0)
      

       
      }
           drawShape('pol',x,y,z,0,7, 5,Math.random(), 10,7, 8,10,'rgba(41,121,205,.055)',1,2,10);//lower arm R

			break;
    case 48://Ice Queen - Queen
       //right calf 
      sx = -3*z;
      sy = -1.5*z;
      sz = 2;
    
       
           drawShape('pol',x,y,z,0,7-Math.random()*.1, 5,Math.random()*.5, 10,7-Math.random()*.1, 8,10,'rgba(41,121,255,.15)',1,2,10);//lower arm R

       
            drawShape('arc',x,y,z,4.8,4.9,.05,0,6,0,0,0,'rgba(41,121,205,.25)',1);//r-hand

          drawShape('arc',x,y,z,7.5,2,.75,0,6,0,0,0,'rgba(41,121,205,.075)',1);//r-hand
        drawShape('pol',x,y,z,7,4, 5,9, 4,5, 4.5,4,'rgba(41,121,205,.25)',1,5,2.5);

     aniDice.setColor(0,0, .7)
      aniDice.setGlow(Math.floor(Math.random()*255))
      aniDice.animate(x+7.55*z,y+2*z,1*z,.25,globalDt);

        drawShape('qua',x,y,z,4.25,2, 4.5,3, 5,2.5, 4.55,1.5,'rgba(41,121,205,.45)',1);
        drawShape('pol',x,y,z,4.45,5.5, 4,7.5, 4.5,7.5, 4.5,7,'rgba(41,121,205,.45)',1,5.25,5.5);
        drawShape('pol',x,y,z,5.6,5, 6,6.5, 6,7, 5.6,7.5,'rgba(41,121,205,.45)',1,5.6,6.5);
        drawShape('tri',x,y,z,5.75,7, 5,5.5, 5.6,5, 5.5,7.5,'rgba(41,121,205,.45)',1,5.6,6.5);
        drawShape('pol',x,y,z,5.5,5, 5.4,4.5, 5.5,3.5, 6.9,4.8,'rgba(41,121,205,.45)',1,5.5,3);

      //legs red boots
      sx = -.5*z; 
      sy = -.1*z;
      sz = 1.1;
      drawShape('qua',x+sx,y+sy,z*sz, 5.5,7, 5.8,8.5, 6,8, 6,6.5,'rgba(41,121,205,.35)',1);
      drawShape('qua',x+sx,y+sy,z*sz, 4,7, 4,8.5, 4.25,8.3, 4.5,7,'rgba(41,121,205,.35)',1);
      drawShape('qua',x+sx,y+sy,z*sz, 4,8.25, 3.6,9, 4,8.8, 4.35,8.23,'rgba(41,121,205,.35)',1);
      drawShape('qua',x+sx,y+sy,z*sz, 6,8, 6.3,9, 6,9, 5.7,8.5,'rgba(41,121,205,.35)',1);
      //Empress upper
      sz = .8;
      sx = 1*z;
      sy = .0*z;
      //drawShape('qua',x+sx,y+sy,z*sz, 5.25,3, 5.5,3.5, 5,4, 4.5,2.5,'rgba(41,121,205,.35)',1);//neck
      drawShape('qua',x+sx,y+sy,z*sz, 4.5,2.5, 5.5,3.5, 5,4, 4.5,2.5,'rgba(41,121,205,.35)',1);//neckL

      drawShape('qua',x+sx,y+sy,z*sz,4,1.8, 3.9,3, 4.25,3.25, 4.25,1.75,'rgba(41,121,205,.35)',1);//bangs left
      drawShape('qua',x+sx,y+sy,z*sz, 5.25,3.5, 4.15,2.25, 5,1.3, 6,2.5,'rgba(41,121,205,.35)',1);//face
      //nose
      sz = .8;
      sx = .8*z;
      sy = .0*z;
      drawShape('tri',x+sx,y+sy,z*sz, 5.45,2.2, 5.4,2.8, 5.6,2.9, 0,0,'rgba(41,121,205,.35)',1);//nose
      //eyes
      sz = .8;
      sx = .8*z;
      sy = .0*z;
      drawShape('tri',x+sx,y+sy,z*sz, 5,2.2, 5.4,2.15, 5.2,2.3, 0,0,'rgba(41,121,205,.35)',1);//eye
      drawShape('tri',x+sx,y+sy,z*sz, 5.5,2.15, 5.9,2, 5.7,2.3, 0,0,'rgba(41,121,205,.35)',1);//eye
      //mouth 
      sz = .8;
      sx = .8*z;
      sy = .0*z;
      drawShape('tri',x+sx,y+sy,z*sz, 5.25,3, 5.6,2.95, 5.4,3.075, 0,0,'rgba(41,121,205,.35)',1);//mouth
      //hair
      sz = .8;
      sx = 1*z;
      sy = .0*z;
      drawShape('qua',x+sx,y+sy,z*sz,5,1.3, 4.2,1.75, 4,2.2, 5,1.85,'rgba(41,121,205,.35)',1);//hair
      drawShape('qua',x+sx,y+sy,z*sz,5,1.3, 5.8,1.75, 6,2, 5,1.85,'rgba(41,121,205,.35)',1);
       
      drawShape('qua',x+sx,y+sy,z*sz,5.55,1.9, 6,2.5, 5.8,3.4, 6,3.5,'rgba(41,121,205,.35)',1);
      drawShape('qua',x+sx,y+sy,z*sz,5.55,1.9, 6,2.5, 5.8,3.4, 6,2,'rgba(41,121,205,.35)',1);
      //drawShape('qua',x,y,z,4.25,1.9, 3.8,2.5, 4,3.4, 3.8,3.5,'gold',1);
      drawShape('qua',x+sx,y+sy,z*sz,5,1.8, 4.28,2.07, 4.8,3.4, 4.5,3.5,'rgba(41,121,205,.35)',1);
      drawShape('qua',x+sx,y+sy,z*sz,4.28,2.07, 3.85,2.5, 4.05,3.4, 3.85,3.5,'rgba(41,121,205,.35)',1);
      //larm
       sz = .8;
      sx = 1.25*z;
      sy = 1*z;
      drawShape('qua',x+sx,y+sy,z*sz, 3.9,4, 3,6, 3.5,6, 4,5,'rgba(41,121,205,.35)',1);//dress left forearm
        
      drawShape('qua',x+sx,y+sy,z*sz, 3,6, 3.5,6, 3.4,6.3, 3,6.5,'rgba(41,121,205,.35)',1);//left hand
 drawShape('qua',x+sx,y+sy,z*sz, 3.4,6, 2.7,8, 2.4,8, 3.2,5.9,'blue',1);//scepter
      drawShape('qua',x+sx,y+sy,z*sz, 3.4,6, 2.7,8, 2.4,8, 3.2,5.9,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.3)`,1);//scepter

    
       sz = .7;
      sx = 1.7*z;
      sy = 3.45*z;
      drawShape('qua',x+sx,y+sy,z*sz, 2.8,4, 2.75,3.4, 3,3.6, 3.4,3.9,'rgba(41,121,205,.35)',1);//left hand
         sz = .8;
      sx = 1.36*z;
      sy = .8*z;
     drawShape('tri',x+sx,y+sy,z*sz, 3,6.6, 3.5,6.6, 3,6.5, 2.75,9,'rgba(41,121,205,.35)',1);//left fingers
     drawShape('qua',x+sx,y+sy,z*sz, 3.4,6.55, 3.25,6.5, 3.25,6.45, 3.3,6.3,'rgba(41,121,205,.35)',1);//left thumb
      sz = .8;
      sx = 1.25*z;
      sy = 1*z;
     // drawShape('qua',x+sx,y+sy,z*sz, 4.5,6, 4.5,4.5, 3.9,4, 4,6,'rgba(41,121,205,.35)',1);//dress left arm
     // drawShape('qua',x+sx,y+sy,z*sz, 5,6, 5.5,3, 4.5,4.5, 4.5,6,'rgba(41,121,205,.35)',1);//dress left mid
      //
       sz = .8;
      sx = 1*z;
      sy = .0*z;
      //drawShape('qua',x+sx,y+sy,z*sz, 5.5,3.5, 6,3.5, 6.5,3.75, 7.5,5,'rgba(41,121,205,.35)',1);//dress right shoulder n tricep
      //drawShape('qua',x+sx,y+sy,z*sz, 6.5,5, 6,6, 7,9.5, 3,9.5,'rgba(41,121,205,.35)',1);//dress bottom right n forearm
      //drawShape('qua',x+sx,y+sy,z*sz, 7.5,5, 6,6, 7,9.5, 3,9.5,'rgba(41,121,205,.35)',1);//dress bottom right n forearm
      drawShape('qua',x+sx,y+sy,z*sz, 5.5,3.5, 5,4, 5,7.5, 7.5,5,'rgba(41,121,205,.35)',1);//dress collarR
      drawShape('qua',x+sx,y+sy,z*sz, 5,4, 4.8,3.4, 4.5,3.5, 4,4,'rgba(41,121,205,.35)',1);//dress collarL
           sz = .8;
      sx = .83*z;
      sy = .0*z;
       drawShape('qua',x+sx,y+sy,z*sz, 4.5,4, 4,4.5, 4.45,5, 5,4.9,'rgba(41,121,205,.25)',1);//bl
        sx = .5*z;
        sy = .0*z;
       drawShape('qua',x+sx,y+sy,z*sz, 5.5,4, 4.8,4.5, 5.25,5, 5.8,4.9,'rgba(41,121,205,.15)',1);//brmain

      //
      sz = .8;
      sx = 2*z;
      sy = .0*z;
      drawShape('qua',x+sx,y+sy,z*sz, 6.1,6, 7,4, 6.5,4, 6,5,'rgba(41,121,205,.35)',1);//dress left forearm
        
      drawShape('qua',x+sx,y+sy,z*sz, 7,4, 6.5,4, 6.6,3.7, 7,3.5,'rgba(41,121,205,.35)',1);//left hand

      drawShape('qua',x+sx,y+sy,z*sz, 7,4, 7.4,3.4, 7,3.5, 6.5,3.4,'rgba(41,121,205,.35)',1);//left hand
        
      drawShape('tri',x+sx,y+sy,z*sz, 7.4,3.4, 6.5,3.4, 7,3.5, 7.25,1,'rgba(41,121,205,.35)',1);//left fingers
      drawShape('qua',x+sx,y+sy,z*sz, 6.6,3.45, 6.75,3.5, 6.75,3.55, 6.6,3.7,'rgba(41,121,205,.35)',1);//left thumb

     // drawShape('qua',x+sx,y+sy,z*sz, 5.5,4, 5.5,5.5, 6.1,6, 6,4,'rgba(41,121,205,.35)',1);//dress left arm
     // drawShape('qua',x+sx,y+sy,z*sz, 5,4, 4.5,7, 5.5,5.5, 5.5,4,'rgba(41,121,205,.35)',1);//dress left mid
     //////
      drawShape('pol',x,y,z, 4.5,3.2, 4.4,4.25, 4.5,6.5, 5,6,'rgba(41,121,205,.35)',1,5,3);//brmain
           
      drawShape('pol',x,y,z, 4.25,1.5, 4,1, 4.5,1.75, 4.5,1,'rgba(41,121,205,.35)',1,5,1.5);//brmain
      drawShape('pol',x,y,z, 5.75,1.5, 6,1, 5.5,1.75, 5.5,1,'rgba(41,121,205,.35)',1,5,1.5);//brmain
      drawShape('pol',x,y,z, 4.25,1.5, 4,1, 4.5,1.75, 4.5,1,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.5)`,1,5,1.5);//brmain
      drawShape('pol',x,y,z, 5.75,1.5, 6,1, 5.5,1.75, 5.5,1,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.5)`,1,5,1.5);//brmain
    break;
    case 49://Kraken King  
         // drawShape('ell',x,y,z,5, 7, 4, 4,  0,    1,   2,    0,   `rgba(${255},${201},${14},.25)`,1)
            drawShape('pol',x,y,z, .5,5.9, .5,6.5, 1,6.5, 1,6,'rgba(41,200,205,.65)',1,.9,5.6);//face
       drawShape('pol',x,y,z, 8.35,4.6, 8.5,5, 8.5,5.5, 7.75,5.5,'rgba(41,180,205,.34)',1,8.1,4.9);//face

         //tail
      sx = 9.3*z;
      sy = 12.9*z;
      sz = 1.5;
      for (let i=0;i<60;i++){
        drawShape('ell',x+sx-27.75*z,y+sy-27.5*z,z*sz*3,    4.5+i*.001, 4.5+i*.001,        .2+i*.0025,   0.2+i*.003,  0,    1,   .1,    0,   `rgba(${0},${128+i},${128},1)`,0)        

      }
      //tail
      sx = 15.1*z;
      sy = 13.69*z;
      sz = 1.5;
      for (let i=0;i<60;i++){
        drawShape('ell',x+sx-27.75*z,y+sy-27.5*z,z*sz*3,    4.5+i*.00021, 4.5+i*.00031,        .2+i*.00125,   0.4+i*.0023,  0,   1,   1.7,    0,   `rgba(${0},${128+i},${128},1)`,0)        

      }
      sx = -17.7*z;
      sy = -19*z;
      sz = 5;
      for (let i=0;i<60;i++){
        //fin
        drawShape('ell',x+sx,y+sy,z*sz,    4.48+i*.001, 4.4+i*.001,        .49-i*.007,   0+i*.01,  0,    1,   2,    0,   `rgba(${0},${64+i},${128},1)`,0)
      }
      sx = -8.7*z;
      sy = -10*z;
      sz = 3;
      for (let i=0;i<60;i++){
        //body
        drawShape('ell',x+sx,y+sy,z*sz,4.5+i*.001, 5.5+i*.0001, 0.2+i*.005, 0+i*.02,  0,    1,   2,    0,   `rgba(${0},${64+i},${128},1)`,0)
        drawShape('ell',x+sx,y+sy,z*sz,4.5+i*.001, 5.51+i*.0001, 0.2+i*.005, 0+i*.02,  0,    1,   2,    0,   `rgba(${0},${64+i},${128},1)`,0)

      }
      sx = -8.7*z;
      sy = -10*z;
      sz = 3;
      for (let i=0;i<60;i++){
        //body
        drawShape('ell',x+sx,y+sy,z*sz,4.5+i*.001, 5.5+i*.0001, 0.2+i*.005, 0+i*.00512,  0,    2,   1,    0,   `rgba(${0},${64+i},${128},1)`,0)
        drawShape('ell',x+sx,y+sy,z*sz,4.5+i*.001, 5.51+i*.001, 0.2+i*.005, 0+i*.00512,  0,    2,   1,    0,   `rgba(${0},${64+i},${128},1)`,0)

      }
      //tail
      sx = 9.3*z;
      sy = 13.9*z;
      sz = 1.5;
      for (let i=0;i<60;i++){
        drawShape('ell',x+sx-27.75*z,y+sy-27.5*z,z*sz*3,    4.5+i*.001, 4.5+i*.001,        .2+i*.0025,   0.2+i*.003,  0,    1,   0,    0,   `rgba(${0},${128+i},${128},1)`,0)        

      }
      //tail
      sx = 12*z;
      sy = 15*z;
      sz = 1.5;
      for (let i=0;i<60;i++){
        drawShape('ell',x+sx-27.75*z,y+sy-27.5*z,z*sz*3,    4.5+i*.001, 4.5+i*.001,        .35+i*.0025,   0.3+i*.00123,  0,   0,   1,    0,   `rgba(${0},${128+i},${128},1)`,0)        

      }
       //tail
      sx = 9*z;
      sy = 15*z;
      sz = 1.5;
      for (let i=0;i<60;i++){
        drawShape('ell',x+sx-27.75*z,y+sy-27.5*z,z*sz*3,    4.5+i*.001, 4.5+i*.001,        .015+i*.0015,   0.3+i*.00123,  0,   1.2,   2,    0,   `rgba(${0},${128+i},${128},1)`,0)        

      }
      sx = -1*z;
      sy = 4.75*z;
      sz = .39;
      drawShape('qua',x+sx,y+sy,z*sz,7.8,1, 8,.7, 8.3,4.2, 6.3,6.4,'lightgray',1);
			drawShape('qua',x+sx,y+sy,z*sz,7.8,1, 8,.7, 8.02,.9, 6.3,6.4,'gray',1);
   			
      //tail
      sx = 16*z;
      sy = 13.75*z;
      sz = 1.5;
      for (let i=0;i<60;i++){
        drawShape('ell',x+sx-27.75*z,y+sy-27.5*z,z*sz*3,    4.5+i*.0001, 4.5+i*.0001,        .3+i*.0025,   0.2+i*.0023,  0,   1,   1.7,    0,   `rgba(${0},${128+i},${128},1)`,0)        

      }
      sx = 5.25*z;
      sy = 7.5*z;
      sz = .39;
     drawShape('qua',x+sx,y+sy,z*sz,7.8,1, 8,.7, 8.3,4.2, 6.3,6.4,'rgba(255,255,255,.25)',1);
			drawShape('qua',x+sx,y+sy,z*sz,7.8,1, 8,.7, 8.02,.9, 6.3,6.4,'rgba(255,255,255,.25)',1);
      
      //ocean mid
      sx = -5.3*z;
      sy = -2*z;
      sz = 2.25;
      for (let i=0;i<60;i++){
       //floating island topM ath.random()*8
        drawShape('ell',x+sx,y+sy,z*sz,    4.5+i*.001, 4.5+i*.001,       Math.random()+ .25-i*.0025,   0+i*.005,  0,    1,   2,    0,   `rgba(41,121,205,.02)`,0)
        //floating island botn     
        drawShape('ell',x+sx,y+sy,z*sz,    4.51+i*.001, 4.4+i*.001,        Math.random()+.249-i*.0025,   0+i*.01,  0,    2,   1,    0,   `rgba(41,121,205,.02)`,0)
      
      }
      sx = -7.3*z;
      sy = -2*z;
      sz = 2.25;
      for (let i=0;i<60;i++){
       //floating island topM ath.random()*8
        drawShape('ell',x+sx,y+sy,z*sz,    4.5+i*.001, 4.5+i*.001,       Math.random()+ .25-i*.0025,   0+i*.005,  0,    1,   2,    0,   `rgba(41,121,205,.02)`,0)
        //floating island botn     
        drawShape('ell',x+sx,y+sy,z*sz,    4.51+i*.001, 4.4+i*.001,        Math.random()+.249-i*.0025,   0+i*.01,  0,    2,   1,    0,   `rgba(41,121,205,.02)`,0)
      
      }
      sx = -3*z;
      sy = -2*z;
      sz = 2.25;
      for (let i=0;i<60;i++){
       //floating island topM ath.random()*8
        drawShape('ell',x+sx,y+sy,z*sz,    4.5+i*.001, 4.5+i*.001,       Math.random()+ .25-i*.0025,   0+i*.01,  0,    1,   2,    0,   `rgba(41,121,205,.02)`,0)
        //floating island botn     
        drawShape('ell',x+sx,y+sy,z*sz,    4.51+i*.001, 4.4+i*.001,        Math.random()+.249-i*.0025,   0+i*.01,  0,    2,   1,    0,   `rgba(41,121,205,.02)`,0)
      
      }
     //ocean bottom
     sx = -5.3*z;
      sy = -1.5*z;
      sz = 2.25;
      for (let i=0;i<60;i++){
       //floating island topM ath.random()*8
        drawShape('ell',x+sx,y+sy,z*sz,    4.5+i*.001, 4.5+i*.001,       Math.random()+ .25-i*.0025,   0+i*.005,  0,    1,   2,    0,   `rgba(41,121,205,.04)`,0)
        //floating island botn     
        drawShape('ell',x+sx,y+sy,z*sz,    4.51+i*.001, 4.4+i*.001,        Math.random()+.249-i*.0025,   0+i*.01,  0,    2,   1,    0,   `rgba(41,121,205,.04)`,0)
      
      }
      sx = -7.3*z;
      sy = -1.5*z;
      sz = 2.25;
      for (let i=0;i<60;i++){
       //floating island topM ath.random()*8
        drawShape('ell',x+sx,y+sy,z*sz,    4.5+i*.001, 4.5+i*.001,       Math.random()+ .25-i*.0025,   0+i*.005,  0,    1,   2,    0,   `rgba(41,121,205,.04)`,0)
        //floating island botn     
        drawShape('ell',x+sx,y+sy,z*sz,    4.51+i*.001, 4.4+i*.001,        Math.random()+.249-i*.0025,   0+i*.01,  0,    2,   1,    0,   `rgba(41,121,205,.04)`,0)
      
      }
      sx = -3*z;
      sy = -1.5*z;
      sz = 2.25;
      for (let i=0;i<60;i++){
       //floating island topM ath.random()*8
        drawShape('ell',x+sx,y+sy,z*sz,    4.5+i*.001, 4.5+i*.001,       Math.random()+ .25-i*.0025,   0+i*.01,  0,    1,   2,    0,   `rgba(41,121,205,.04)`,0)
        //floating island botn     
        drawShape('ell',x+sx,y+sy,z*sz,    4.51+i*.001, 4.4+i*.001,        Math.random()+.249-i*.0025,   0+i*.01,  0,    2,   1,    0,   `rgba(41,121,205,.04)`,0)
      
      }
 //left calf
      sx = -5.3*z;
      sy = -3.3*z;
      sz = 2.25;
      for (let i=0;i<60;i++){
       //floating island topM ath.random()*8
        drawShape('ell',x+sx,y+sy,z*sz,    4.5+i*.001, 4.5+i*.001,       Math.random()+ .25-i*.0025,   0+i*.005,  0,    1,   2,    0,   `rgba(41,121,205,.05)`,0)
        //floating island botn     
        drawShape('ell',x+sx,y+sy,z*sz,    4.51+i*.001, 4.4+i*.001,        Math.random()+.249-i*.0025,   0+i*.01,  0,    2,   1,    0,   `rgba(41,121,205,.05)`,0)
      
      }
      sx = -7.3*z;
      sy = -3.3*z;
      sz = 2.25;
      for (let i=0;i<60;i++){
       //floating island topM ath.random()*8
        drawShape('ell',x+sx,y+sy,z*sz,    4.5+i*.001, 4.5+i*.001,       Math.random()+ .25-i*.0025,   0+i*.005,  0,    1,   2,    0,   `rgba(41,121,205,.05)`,0)
        //floating island botn     
        drawShape('ell',x+sx,y+sy,z*sz,    4.51+i*.001, 4.4+i*.001,        Math.random()+.249-i*.0025,   0+i*.01,  0,    2,   1,    0,   `rgba(41,121,205,.05)`,0)
      
      }
      sx = -3*z;
      sy = -3.3*z;
      sz = 2.25;
      for (let i=0;i<60;i++){
       //floating island topM ath.random()*8
        drawShape('ell',x+sx,y+sy,z*sz,    4.5+i*.001, 4.5+i*.001,       Math.random()+ .25-i*.0025,   0+i*.005,  0,    1,   2,    0,   `rgba(41,121,205,.05)`,0)
        //floating island botn     
        drawShape('ell',x+sx,y+sy,z*sz,    4.51+i*.001, 4.4+i*.001,        Math.random()+.249-i*.0025,   0+i*.01,  0,    2,   1,    0,   `rgba(41,121,205,.05)`,0)
      
      }
      drawShape('pol',x,y,z, 0,6.5, 1,6.65, 2.5,6.3, 6,6.5,'rgba(41,121,205,.05)',1,10,10);
      drawShape('pol',x,y,z, 10,6.5, 9,6.65, 7.5,6.3, 4,6.5,'rgba(41,121,205,.05)',1,0,10);
      drawShape('rec',x,y,z, 0,6.65, 10,3.35, 2.5,6.3, 6,6.5,'rgba(41,121,205,.35)',1,10,10);

      ////ship
for (let i=0;i<60;i++){
       drawShape('ell',x,y,z,    3+i*.001, 7.5+i*.001,        2-i*.01,   0+i*.01,  0,    2,   1,    0,   `rgba(${128},${64},${0},${1-i*.015})`,0)
             drawShape('ell',x,y,z,    3+i*.001, 7.5+i*.001,        2-i*.01,   0+i*.01,  0,    2,   1,    0,   `rgba(${128},${64},${0},${1-i*.015})`,0)

      }
      sx = 6.5*z;
      sy = 4.5*z;
      sz = .39;
      drawShape('qua',x+sx,y+sy,z*sz,7.8,1, 8,.7, 8.3,4.2, 6.3,6.4,'lightgray',1);
			drawShape('qua',x+sx,y+sy,z*sz,7.8,1, 8,.7, 8.02,.9, 6.3,6.4,'gray',1);
     sx = 0.25*z;
      sy = 5*z;
      sz = .39;
      drawShape('qua',x+sx,y+sy,z*sz,7.8,1, 8,.7, 8.3,4.2, 6.3,6.4,'lightgray',1);
			drawShape('qua',x+sx,y+sy,z*sz,7.8,1, 8,.7, 8.02,.9, 6.3,6.4,'gray',1);
     
      drawShape('pol',x,y,z, .5,6.9, .5,7.5, 1,8, 1,7,'rgba(41,180,205,.65)',1,.9,6.6);//face
       drawShape('pol',x,y,z, 2.5,8.1, 2.5,7.5, 3,7, 3,7.5,'rgba(41,180,205,.75)',1,3,8.2);//face
       drawShape('pol',x,y,z, 9.7,5.25, 10,5.75, 9.9,7, 9.5,6.5,'rgba(41,180,205,.34)',1,9.25,5.75);//face
       drawShape('qua',x,y,z, 7.2,6.5, 7,7, 6.2,7.2, 6.5,6.5,'rgba(41,180,205,.34)',1,9.25,5.75);//face
       drawShape('pol',x,y,z, 6,7, 6.05,7.75, 7,8.1, 7,7,'rgba(41,180,205,.34)',1,6.5,6.5);//face
       drawShape('qua',x,y,z, 1.4,7, 1.5,7.25, 1.75,7.1, 1.6,6.4,'rgba(41,180,205,.54)',1,6.5,6.5);//face
       drawShape('qua',x,y,z, 5,6.36, 4.5,7, 5,7.25,5.5,7,'rgba(254,203,1,.84)',1,6.5,6.5);//face
      drawShape('qua',x,y,z, 5,6.36, 4.5,7, 5,7.25,5.5,7,'rgba(255,128,0,.95)',0,6.5,6.5);//face

       drawShape('qua',x,y,z, 5,6.36, 4.975,7, 5,7.25,5.025,7,'rgba(128,64,0,.94)',1,6.5,6.5);//face
       drawShape('qua',x,y,z, 4.5,7, 5,7.025, 5.5,7, 5,6.975,'rgba(128,64,0,.94)',1,6.5,6.5);//face
 sz = .12;
      sx = 4.4*z;
      sy = 5.1*z;

      drawShape('ell',x+sx,y+sy,z*sz,    5.1, 5,        4.1,   2.1,  0,    2,  0,    0,   `rgba(${255},${255},${255},1)`,1)
      //drawShape('ell',x+sx,y+sy,z*sz,    4.8, 5.7,        2,   2,  0,    .77,  .23,    0,   `rgba(${185},${122},${87},1)`,1)
      //drawShape('ell',x+sx,y+sy,z*sz,    4.5, 5.97,        .5,   .5,  0,    2,  0,    0,   `rgba(${0},${0},${0},1)`,1)

       sx = 4.5*z;
      sy = 2.5*z;
      sz = .5;
      for (let i = 0;i<64;i++){
        drawShape('ell',x+sx,y+sy,z*sz,    1+i*.001, 6+i*.001,        2-i*.01,   .5+i*.01,  0,    0,   2,    0,   `rgba(41,180,205,.0024)`,1)
        drawShape('ell',x+sx,y+sy,z*sz,    1+i*.001, 6+i*.001,        2-i*.01,   .5+i*.01,  0,    1.1,   -.1,    0,   `rgba(41,180,205,.0024)`,1)
        drawShape('ell',x+sx,y+sy,z*sz,    1+i*.001, 6+i*.001,        2-i*.01,   .5+i*.01,  0,    .1,  .9,    0,   `rgba(41,180,205,.0024)`,1)
        drawShape('ell',x+sx,y+sy,z*sz,    1+i*.001, 6+i*.001,        2-i*.01,   .5+i*.01,  0,    1.1,   -.1,    0,   `rgba(41,180,205,.0024)`,1)
        drawShape('ell',x+sx,y+sy,z*sz,    1+i*.001, 6+i*.001,        2-i*.01,   .5+i*.01,  0,    .1,  .9,    0,   `rgba(41,180,205,.0024)`,1)
      }
       sz = .12;
      sx = 4.4*z;
      sy = 5.1*z;
            drawShape('ell',x+sx,y+sy,z*sz,    4.8, 5.7,        2,   2,  0,    .77,  .23,    0,   `rgba(${185},${122},${87},.95)`,1)
                        drawShape('ell',x+sx,y+sy,z*sz,    4.8, 5.7,        2,   2,  0,    .77,  .23,    0,   `rgba(${0},${0},${0},.55)`,1)

      drawShape('ell',x+sx,y+sy,z*sz,    4.5, 5.97,        .5,   .5,  0,    2,  0,    0,   `rgba(${0},${0},${0},1)`,1)

      drawShape('pol',x,y,z, 5,0.25, 4.85,.5, 4.725,1, 4.55,3.25,'rgba(41,180,205,.34)',1,5,3.5);//face
      drawShape('pol',x,y,z, 5,0.25, 5.1,.5, 5.25,1, 5.45,3.25,'rgba(41,180,205,.34)',1,5,3.5);//face
      drawShape('qua',x,y,z, 5,0.25, 5.15,3.25, 5,5, 4.85,3.25,'rgba(41,180,205,.34)',1,5,3.5);//face

    break;
  
    case 50: //SWORD 
      drawShape('qua',x,y,z,0,1, 2,3, 3,2, 1,0,'rgb(252,165,3)',1);//handle
      drawShape('qua',x,y,z,0,1, 2,3, 3,2, 1,0,'rgb(252,165,3)',0);//handle
      drawShape('tri',x,y,z,0,0, 1.4,0, 0,1.4 ,0,0,'darkgray',1);//pommel
      drawShape('tri',x,y,z,0,0, 1.4,0, 0,1.4 ,0,0,'rgb(252,165,3)',0);//pommel
      drawShape('qua',x,y,z,0,5, 1,5 ,5,1 ,5,0,'rgb(252,165,3)',1);//hilt guard
      drawShape('qua',x,y,z,2,4, 8,9, 8,8, 4,4,'gray',1);//lhalf blade
      drawShape('qua',x,y,z,4,2, 9,8, 8,8 ,4,4,'gray',1);//rhalf blade
      drawShape('tri',x,y,z,4,4, 4,2, 2,4, 0,0,'gray',1);//near hilt center
      drawShape('qua',x,y,z,9,8, 8,8, 8,9, 10,10,'gray',1);//sword tip
      drawShape('qua',x,y,z,0,5, 1,5, 5,1 ,5,0,'rgb(252,165,3)',0);//hilt guard outline
      drawShape('arc',x,y,z,3,3, .5,0, 6,0 ,0,0,'white',1);//hilt gem
      drawShape('arc',x,y,z,3,3 ,.51,0, 6,0, 0,0,'white',0);
      break;
    case 51://Overpower 2
        drawShape('arc',x,y,z,5,5,5,0,2,0,0,0,'rgba(255,201,14,.1)',1);

      sx = 0*z;
      sy = 1*z;
      sz = .9;
			drawShape('tri',x+sx,y+sy,z*sz,0,8.6, 1.4,10, 0,10 ,0,0,'rgb(252,165,3)',1);
			drawShape('qua',x+sx,y+sy,z*sz,0,9, 2,7, 3,8, 1,10,'rgb(252,165,3)',1);
			drawShape('qua',x+sx,y+sy,z*sz,0,5, 1,5 ,5,9 ,5,10,'rgb(252,165,3)',1);
     drawShape('tri',x+sx,y+sy,z*sz,0,10, 1.4,10, 0,8.6 ,0,10,'darkgray',1);//pommel

			drawShape('qua',x+sx,y+sy,z*sz,2,6, 8,1, 8,2, 4,6,'gray',1);//
			drawShape('qua',x+sx,y+sy,z*sz,4,8, 9,2, 8,2 ,4,6,'gray',1);
			drawShape('tri',x+sx,y+sy,z*sz,2,6, 4,6, 4,8, 0,0,'gray',1);
			drawShape('qua',x+sx,y+sy,z*sz,8,1, 8,2, 9,2, 10,0,'gray',1);
      	drawShape('qua',x+sx,y+sy,z*sz,2,6, 8,1, 8,2, 4,6,'rgba(0,0,0,.25)',1);//
			drawShape('qua',x+sx,y+sy,z*sz,4,8, 9,2, 8,2 ,4,6,'rgba(0,0,0,.25)',1);
			drawShape('tri',x+sx,y+sy,z*sz,2,6, 4,6, 4,8, 0,0,'rgba(0,0,0,.25)',1);
			drawShape('qua',x+sx,y+sy,z*sz,8,1, 8,2, 9,2, 10,0,'rgba(0,0,0,.25)',1);
			drawShape('qua',x+sx,y+sy,z*sz,0,5, 1,5, 5,9 ,5,10,'rgb(252,165,3)',0);
			drawShape('arc',x+sx,y+sy,z*sz,3,7, .5,0, 6,0 ,0,0,'red',1);//pommel gem
			drawShape('arc',x+sx,y+sy,z*sz,3,7 ,.5,0, 6,0, 0,0,'brown',0);
      sx = 1*z;
      sy = 1*z;
      sz = .9;
      drawShape('qua',x+sx,y+sy,z*sz,10,9, 8,7, 7,8, 9,10,'rgb(252,165,3)',1);//handle
      drawShape('qua',x+sx,y+sy,z*sz,10,9, 8,7, 7,8, 9,10,'rgb(252,165,3)',0);//handle
      drawShape('tri',x+sx,y+sy,z*sz,10,10, 8.6,10, 10,8.6 ,10,10,'darkgray',1);//pommel
      drawShape('tri',x+sx,y+sy,z*sz,10,10, 8.6,10, 10,8.6 ,10,10,'rgb(252,165,3)',0);//pommel
      drawShape('qua',x+sx,y+sy,z*sz,10,5, 9,5 ,5,9 ,5,10,'rgb(252,165,3)',1);//hilt guard
      drawShape('qua',x+sx,y+sy,z*sz,8,6, 2,1, 2,2, 6,6,'gray',1);//lhalf blade
      drawShape('qua',x+sx,y+sy,z*sz,6,8, 1,2, 2,2 ,6,6,'gray',1);//rhalf blade
      
      drawShape('tri',x+sx,y+sy,z*sz,6,6, 6,8, 8,6, 10,10,'gray',1);//near hilt center
      drawShape('qua',x+sx,y+sy,z*sz,1,2, 2,2, 2,1, 0,0,'gray',1);//sword tip
      drawShape('qua',x+sx,y+sy,z*sz,10,5, 9,5, 5,9 ,5,10,'rgb(252,165,3)',0);//hilt guard outline
      drawShape('arc',x+sx,y+sy,z*sz,7,7, .5,0, 6,0 ,0,0,'red',1);//pommel gem
			drawShape('arc',x+sx,y+sy,z*sz,7,7 ,.5,0, 6,0, 0,0,'brown',0);
          
    break;
    case 52://Backstab 3
            drawShape('arc',x,y,z,5,5,1.5,0,2,0,0,0,'rgba(64,50,7,.75)',1);

    //face
      drawShape('pol',x,y,z,7.425,.52, 7.6,1 ,8,1.1 ,7.75,1.75,'rgb(255,128,64)',1,7,2);
      drawShape('qua',x,y,z,7.426,.52, 7,2.1 ,6.5,1.5 ,6.5,1,'rgb(255,128,64)',1,7,2);
      drawShape('qua',x,y,z,7.75,1.75,8,2 ,7.2,2.25 ,6.9,2,'rgb(255,128,64)',1,7,2);
      
      drawShape('qua',x,y,z,7.75,1.75,8,2 ,7.2,2.25 ,6.9,2,'rgb(255,128,64)',1,7,2);
      //head
      drawShape('qua',x,y,z,5,4, 3.75,1.75 ,4,1.5 ,5,3,'rgba(255,255,255,.1)',1);
      drawShape('qua',x,y,z,5,2, 5,4 ,5.5,4 ,6,3,'rgba(255,255,255,.1)',1);
      drawShape('qua',x,y,z,6.5,1.5, 6.5,1 ,7.5,.5 ,6,1,'rgba(255,255,255,.1)',1);
      drawShape('qua',x,y,z,7,2.5, 7.2,2.3 ,6.75,1.75 ,6,1,'rgba(255,255,255,.1)',1);
      drawShape('qua',x,y,z,6,1, 6.5,.5 ,7,.5 ,7.5,.5,'rgba(255,255,255,.1)',1);
      drawShape('qua',x,y,z,7,2.5, 7.5,2.6 ,8,2 ,7.25,2.25,'rgba(255,255,255,.1)',1);
      drawShape('qua',x,y,z,7,2.5, 6.5,2.4 ,6,1.5 ,6,1,'rgba(255,255,255,.1)',1);

      
    	drawShape('qua',x,y,z,5,2, 9,3 ,8,6 ,6.5,5.5,'rgb(252,255,255)',1);
    	drawShape('qua',x,y,z,8,6, 8.5,9.5 ,5,8 ,6.5,5,'rgb(255,255,255)',1);
    	//bdoy
      //right shoulder
      drawShape('tri',x,y,z,8,3, 8.5,4.5 ,9,3 ,9,3,'rgba(0,0,0,.5)',1);
      //left shoulder
      drawShape('tri',x,y,z,6.5,2.4, 5,2 ,6,3 ,9,3,'rgba(0,0,0,.5)',1);
      //back outline
      drawShape('tri',x,y,z,6,3, 6.5,5 ,5,8 ,9,3,'rgba(0,0,0,.5)',1);

      //upper arm right
      drawShape('tri',x,y,z,9,3, 9,5.5 ,8.5,4.5 ,9,3,'rgba(255,255,255,.1)',1);
      //forearm right left half
      drawShape('qua',x,y,z,9,5.5, 9.45,5 ,9.5,3 ,9,4.5,'rgba(255,255,255,.1)',1);
      //right leg
      drawShape('qua',x,y,z,8,6, 9,8 ,8,10 ,7.5,10,'rgba(255,255,255,.1)',1);
      //left thigh
      drawShape('tri',x,y,z,5,8, 6.5,8 ,5,10 ,4.5,10,'rgba(255,255,255,.1)',1);
      //left calf
      drawShape('tri',x,y,z,5,8, 4.25,10 ,5,10 ,4.5,10,'rgba(255,255,255,.1)',1);
      //inside lining of cape (by right thigh and elbow)
      drawShape('tri',x,y,z,8.5,4.5, 8.5,7 ,8,6 ,5,8.1,'rgba(255,255,255,.3)',1);
      //forearm right, right half
      drawShape('qua',x,y,z,9.5,3, 9.9,3 ,9.6,4.5 ,9.45,5,'rgba(255,255,255,.1)',1);

      //belt
      drawShape('tri',x,y,z,6.25,5, 8,6 ,6.3,5.25 ,6,1,'rgba(64,0,0,.6)',1);
      drawShape('tri',x,y,z,8,5.75, 8,6 ,6.3,5.25 ,6,1,'rgba(64,0,0,.6)',1);
//dagger
       sx = 4*z;
      sy = 4*z;
      sz = .2;
			drawShape('tri',x+sx,y+sy,z*sz,0,8.6, 1.4,10, 0,10 ,0,0,'rgb(252,165,3)',1);
			drawShape('qua',x+sx,y+sy,z*sz,0,9, 2,7, 3,8, 1,10,'rgb(252,165,3)',1);
			drawShape('qua',x+sx,y+sy,z*sz,0,5, 1,5 ,5,9 ,5,10,'rgb(252,165,3)',1);
      drawShape('tri',x+sx,y+sy,z*sz,0,10, 1.4,10, 0,8.6 ,0,10,'darkgray',1);//pommel

			drawShape('qua',x+sx,y+sy,z*sz,2,6, 8,1, 8,2, 4,6,'gray',1);//
			drawShape('qua',x+sx,y+sy,z*sz,4,8, 9,2, 8,2 ,4,6,'gray',1);
			drawShape('tri',x+sx,y+sy,z*sz,2,6, 4,6, 4,8, 0,0,'gray',1);
			drawShape('qua',x+sx,y+sy,z*sz,8,1, 8,2, 9,2, 10,0,'gray',1);
      	drawShape('qua',x+sx,y+sy,z*sz,2,6, 8,1, 8,2, 4,6,'rgba(0,0,0,.25)',1);//
			drawShape('qua',x+sx,y+sy,z*sz,4,8, 9,2, 8,2 ,4,6,'rgba(0,0,0,.25)',1);
			drawShape('tri',x+sx,y+sy,z*sz,2,6, 4,6, 4,8, 0,0,'rgba(0,0,0,.25)',1);
			drawShape('qua',x+sx,y+sy,z*sz,8,1, 8,2, 9,2, 10,0,'rgba(0,0,0,.25)',1);
			drawShape('qua',x+sx,y+sy,z*sz,0,5, 1,5, 5,9 ,5,10,'rgb(252,165,3)',0);
			drawShape('arc',x+sx,y+sy,z*sz,3,7, .5,0, 6,0 ,0,0,'red',1);//pommel gem
			drawShape('arc',x+sx,y+sy,z*sz,3,7 ,.5,0, 6,0, 0,0,'brown',0);
      
      drawShape('qua',x,y,z,4.4,5.4, 4.6,5.6 ,4.5,7 ,3,9,'rgba(128,32,0,.75)',1);
      drawShape('tri',x,y,z,4.5,7, 3.5,6 ,4.2,5.4 ,3,9,'rgba(128,32,0,1)',1);
            drawShape('pol',x,y,z,4.4,5.5, 4.65,5.6 ,4.5,6 ,4.25,6.2,'rgba(255,128,64,.9)',1,4.25,5.75);

      drawShape('tri',x,y,z,4.5,5.5, 4.2,5.5 ,4.25,5.75 ,3,9,'rgba(255,128,64,1)',1);
      
      drawShape('tri',x,y,z,4.5,5.5, 4.2,5.5 ,4.25,5.75 ,3,9,'rgba(255,128,64,1)',1);
      drawShape('qua',x,y,z,3.5,6, 4,6.5 ,3,9 ,2,7.5,'rgba(128,32,0,.35)',1);
      drawShape('pol',x,y,z,2,7.5, 1,8 ,0,8 ,0,10,'rgba(128,32,0,.35)',1,3,10);
      drawShape('pol',x,y,z,0,8, 0,6 ,.5,5.5 ,1.5,5.5,'rgba(128,32,0,.35)',1,1,8);
      drawShape('qua',x,y,z,1.5,5.5, 1.75,7 ,1.5,7.75 ,1,8,'rgba(128,32,0,.15)',1,1,8);

      drawShape('tri',x,y,z,2,7.5, 3,9 ,3,10 ,1.5,5.5,'rgba(128,32,0,.35)',1,1,8);
      drawShape('tri',x,y,z,1.5,5.5, 1.75,7 ,1.5,7.75 ,1,8,'rgba(128,32,0,.0050)',1,1,8);
//hands
      drawShape('pol',x,y,z,9.5,3, 9.9,3 ,10,2.5 ,9.5,2.4,'rgba(255,255,255,.1)',1,9.25,2.75);
      drawShape('pol',x,y,z,4,1.5, 4,1 ,3.5,1 ,3.5,1.5,'rgba(255,255,255,.1)',1,3.75,1.75);

          drawShape('tri',x,y,z,7.5,1, 7.6,1 ,7.5,.8 ,1,8,'rgba(0,0,0,.4)',1,1,8);
          drawShape('tri',x,y,z,7.3,1, 7.1,1 ,7,1.2 ,1,8,'rgba(0,0,0,.4)',1,1,8);
          drawShape('tri',x,y,z,7.2,2, 7.5,1.8 ,7.75,1.75 ,1,8,'rgba(0,0,0,.4)',1,1,8);

      break;
    case 53://Camp 4
    	drawShape('pol',x,y,z,0,8, 3,6 ,5,5 ,8,6,'rgb(90,39,1)',1,10,10);
    	drawShape('tri',x,y,z,0,8, 0,10 ,10,10 ,8,6,'rgb(90,39,1)',1,10,10);
    	//tres
      drawShape('pol',x,y,z,1,7.5, 2.5,6.5 ,2,3 ,0,0,'rgba(90,39,1,.3)',1,1.5,5);
    	drawShape('pol',x,y,z,3,6, 3.5,3 ,4,2 ,2.5,2,'rgba(90,39,1,.3)',1,2.5,6);
      drawShape('pol',x,y,z,0,8, 1,7.5 ,1,4 ,3,2,'rgba(90,39,1,.3)',1,1,2);
    	drawShape('pol',x,y,z,3.5,6, 4,5.5 ,4.5,3.5 ,4,4,'rgba(90,39,1,.3)',1,4,4.5);
      drawShape('pol',x,y,z,3.25,6, 3.5,1.5 ,4,3.5 ,3.5,4.5,'rgba(90,39,1,.3)',1,3.7,6);
      drawShape('qua',x,y,z,0,8, 1,7.5 ,1.5,3 ,0,0,'rgba(30,10,1,1)',1,1.5,5);

      drawShape('pol',x,y,z,9,7.5, 7.5,6.5 ,8,3 ,10,0,'rgba(90,39,1,.3)',1,8.5,5);
    	drawShape('pol',x,y,z,7,6, 6.5,3 ,6,2 ,7.5,2,'rgba(90,39,1,.3)',1,7.5,6);
      drawShape('pol',x,y,z,10,8, 9,7.5 ,9,4 ,7,2,'rgba(90,39,1,.3)',1,9,2);
    	drawShape('pol',x,y,z,6.5,6, 6,5.5 ,5.5,3.5 ,6,4,'rgba(90,39,1,.3)',1,4,5.5);
      drawShape('pol',x,y,z,6.75,6, 6.5,1.5 ,6,3.5 ,6.5,4.5,'rgba(90,39,1,.3)',1,6.3,6);
      drawShape('qua',x,y,z,10,10, 8.5,7.5 ,8.5,3 ,10,0,'rgba(30,10,1,1)',1,8.5,5);
      drawShape('qua',x,y,z,0,5, 0,10 ,5,10 ,1,8,'rgba(0,0,0,1)',1,8.5,5);





//tent


    	drawShape('qua',x,y,z,0,5, 1,5 ,5,9 ,5,10,'rgba(252,165,1,1)',1);
sx = 4*z;
sy = 5*z
sz = .2;
      // drawShape('arc',x+sx,y+sy,z*sz,5,6.5,3.5-Math.random(),0,2,0,0,0,'rgba(176,9,0,.75)',1);//CRA
			drawShape('tri',x+sx,y+sy,z*sz,1.5,6.5,2,0+Math.random(),8,5,0,0,'rgba(176,9,0,.65)',1);//LRT
			drawShape('tri',x+sx,y+sy,z*sz,10-1.5,6.5,5,0+Math.random(),10-8,5,0,0,'rgba(176,9,0,.65)',1);//CRT
			drawShape('tri',x+sx,y+sy,z*sz,10-1.5,6.5,10-2,0+Math.random(),10-8,5,0,0,'rgba(176,9,0,.65)',1);//RRT
			drawShape('tri',x+sx,y+sy,z*sz,2.5,7.5,2.5,1-Math.random(),7,6,0,0,'rgba(232,220,0,.65)',1);//LYT
			drawShape('tri',x+sx,y+sy,z*sz,10-2.5,7.5,5,1-Math.random(),10-7,6,0,0,'rgba(232,220,0,.65)',1);//CYT
			drawShape('tri',x+sx,y+sy,z*sz,10-2.5,7.5,10-2.5,1-Math.random(),10-7,6,0,0,'rgba(232,220,0,.65)',1);//RYT
			//drawShape('arc',x+sx,y+sy,z*sz,5,7.5,2.5-Math.random(),0,2,0,0,0,'rgba(232,220,0,1)',1);//CYA
      	//drawShape('arc',x+sx,y+sy,z*sz,5,6.5,3.5+Math.random(),0,2,0,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.25)`,1);//CRA

      drawShape('tri',x+sx,y+sy,z*sz,1.5,6.5,2,0,8,5,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.1)`,1);//LRT
			drawShape('tri',x+sx,y+sy,z*sz,10-1.5,6.5,5,0,10-8,5,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.1)`,1);//CRT
			drawShape('tri',x+sx,y+sy,z*sz,10-1.5,6.5,10-2,0,10-8,5,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.1)`,1);//RRT
			drawShape('tri',x+sx,y+sy,z*sz,2.5,7.5,2.5,1,7,6,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.1)`,1);//LYT
			drawShape('tri',x+sx,y+sy,z*sz,10-2.5,7.5,5,1,10-7,6,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.1)`,1);//CYT
			drawShape('tri',x+sx,y+sy,z*sz,10-2.5,7.5,10-2.5,1,10-7,6,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.1)`,1);//RYT
      			//drawShape('arc',x+sx,y+sy,z*sz,5,7.5,2.5,0,2,0,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.1)`,1);//CYA
sx = 0*z;
    sy = 1*z;
    sz = 1;
     // drawShape('arc',x,y,z,5,5,5,0,2,0,0,0,'rgba(255,255,255,.125)',1);
      //drawShape('arc',x,y,z,5,5,4.75,0,2,0,0,0,'rgba(255,255,255,.125)',1);
      //drawShape('arc',x,y,z,5,5,4.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);
      //drawShape('arc',x,y,z,5,5,4.25,0,2,0,0,0,'rgba(255,255,255,.125)',1);

    drawShape('arc',x+sx,y+sy,z*sz,5,1,1,0,2,1,0,0,'gold',1);//moon
      drawShape('arc',x+sx,y+sy,z*sz,5,1,1,0,2,1,0,0,'rgba(0,0,0,.25)',1);//moon
            drawShape('ell',x+sx,y+sy,z*sz,4.5,1,1.25,.75,2,2,0,0,'rgba(0,0,0,.5)',1);//moon

      sx = 0*z;
    sy = 1*z;
    sz = 1;
      drawShape('tri',x+sx,y+sy,z*sz, 5.5,.4, 5,.6, 5.1,.6,0,0, 'rgba(0,0,0,.55)',1);  
      drawShape('tri',x+sx,y+sy,z*sz, 5,.75, 5,1.25, 4.9,1.25,0,0, 'rgba(0,0,0,.55)',1);  
      drawShape('tri',x+sx,y+sy,z*sz, 5,1.5, 5.25,1.45, 5.1,1.5,0,0, 'rgba(0,0,0,.75)',1);  
     
    break;
    case 54://Goblin 5
    
			drawShape('qua',x,y,z,5,9,6,9,7,8,6,8,'darkgreen',1);//IL-foot
			drawShape('qua',x,y,z,6,8,7,8,4,6,4,7,'darkgreen',1);//IL-calf+knee
			drawShape('tri',x,y,z,4,6,7,5,5,7,0,0,'darkgreen',1);//IL-thigh
			drawShape('tri',x,y,z,7,5,8,5,8,6,0,0,'green',1);//OL-hip
			drawShape('qua',x,y,z,7,5,5,7,6,7,8,6,'green',1);//OL-thigh
			drawShape('qua',x,y,z,5,7,7,9,8,9,6,7,'green',1);//OL-calf+knee
			drawShape('qua',x,y,z,7,9,8,9,7,10,5.5,9.9,'green',1);//OL-foot
			drawShape('tri',x,y,z,3,3,5,5,4,2,0,0,'darkgreen',1);//Inner arm
			drawShape('tri',x,y,z,2.1,5.5,5,5,4.5,4.25,0,0,'darkgreen',1);//Inner forearm
			drawShape('arc',x,y,z,2.5,5.4,.4,0,6,0,0,0,'darkgreen',1);//Inner hand
			drawShape('arc',x,y,z,4.5,3.5,.75,0,6,0,0,0,'darkgreen',1);//T-Ishoulder
			drawShape('arc',x,y,z,5.8,4.4,2.5,1.4,2.25,0,0,0,'brown',1);//T-hump
			drawShape('qua',x,y,z,6,5.5,8,5,5,2,4,3,'brown',1);//T-torso
			drawShape('tri',x,y,z,4,3,5,2,5,3,0,0,'darkgreen',1);//T-neck
			drawShape('arc',x,y,z,5.5,2.5,.75,0,6,0,0,0,'darkgreen',1);//T-Oshoulder
			drawShape('qua',x,y,z,7,5,7,6,8,7,8,5,'brown',1);//T-hip armor
			drawShape('tri',x,y,z,5,3,7,5,6,2,0,0,'green',1);//Outer arm
			drawShape('qua',x,y,z,1,5,1,5.25,10,5.5,10,5.25,'brown',1);//T-spear
			drawShape('tri',x,y,z,4.1,5.5,7,5,6.5,4.25,0,0,'green',1);//Outer forearm
			drawShape('arc',x,y,z,4.5,5.4,.4,0,6,0,0,0,'green',1);//Inner hand
			drawShape('tri',x,y,z,5,0,3,2,5,2,0,0,'red',1);//H-hat
			drawShape('tri',x,y,z,3,2,3,4,5,2,0,0,'green',1);//H-head
			drawShape('tri',x,y,z,3,2,2.25,3.25,3,3,0,0,'green',1);//H-nose
			drawShape('tri',x,y,z,3,3,3.5,3,3,4,0,0,'black',1);//H-mouth
			//drawShape('tri',x,y,z,3,2.25,3,2.75,3.75,2.75,0,0,'red',1);//H-eye(sad)
			drawShape('tri',x,y,z,3,2.25,3,2.75,3.75,2.1,0,0,'red',1);//H-eye(mad)
			//drawShape('tri',x,y,z,3,2.25,3,2.75,3.75,2.25,0,0,'red',1);//H-eye(neutral)
			drawShape('tri',x,y,z,4,2.25,4,2.75,4.75,1.75,0,0,'darkgreen',1);//H-ear
			drawShape('arc',x,y,z,2.7,3.2,.25,1,1.75,0,0,0,'black',1);//H-nostril
			drawShape('tri',x,y,z,1,4.9,1,5.35,0,5.15,0,0,'lightgray',1);//H-ear
			
		
    break;
    case 55://Sailboat
      drawShape('arc',x,y,z,9,1,.8,0,6,0,0,0,'gold',1);//bag
      drawShape('arc',x,y,z,8.95,.95,.75,0,6,0,0,0,'rgba(255,255,255,.15)',1);//bag
      drawShape('arc',x,y,z,8.9,1,.7,0,6,0,0,0,'rgba(255,255,255,.15)',1);//bag
      drawShape('arc',x,y,z,8.85,1,.65,0,6,0,0,0,'rgba(255,255,255,.15)',1);//bag
      drawShape('arc',x,y,z,8.8,1,.6,0,6,0,0,0,'rgba(255,255,255,.15)',1);//bag
    	for (let i=0;i<60;i++){
       drawShape('ell',x,y,z,    3+i*.001, 6+i*.001,        2-i*.01,   0+i*.01,  0,    2,   1,    0,   `rgba(${128},${64},${0},${1-i*.015})`,0)
      }
      sx = -15*z;
      sy = -16*z;
      sz = 5;
      for (let i=0;i<60;i++){
        ////////////////////////////
        //floating island top
        drawShape('ell',x+sx,y+sy,z*sz,    4.5+i*.001, 4.5+i*.001,        .5-i*.005,   0+i*.005,  0,    1,   2,    0,   `rgba(${64},${64+i},${11},1)`,0)
        //floating island botn     
       drawShape('ell',x+sx,y+sy,z*sz,    4.51+i*.001, 4.5+i*.001,        .49-i*.005,   0+i*.01,  0,    2,   1,    0,   `rgba(${128},${64},${11},${1-i*.025})`,0)
      }
      sx = -8.7*z;
      sy = -9.6*z;
      sz = 3;
      
      //wind special effect
      for (let h=0;h<10;h++){
     for (let i=0;i<120;i++){
      drawShape('ell',x,y,z,   h+ 0.4+i*.001, 6.9+i*.001,        .2+i*.0025,   0.2+i*.003,  0,    1,   .4,    0,   `rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.3)`,0)
        
      // drawShape('ell',x,y,z,    1.9+i*.001, 3.6+i*.001,        1.9-i*.01,   0+i*.02,  0,    i*.03,   2,    0,   `rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.3)`,0)
      }}
      sx = 1.25*z;
      sy = 3.5*z;
      sz = .39;
      drawShape('qua',x+sx,y+sy,z*sz,7.8,1, 8,.7, 8.3,4.2, 6.3,6.4,'lightgray',1);
			drawShape('qua',x+sx,y+sy,z*sz,7.8,1, 8,.7, 8.02,.9, 6.3,6.4,'gray',1);
      sx = .75*z;
      sy = 3.5*z;
      sz = .39;
      drawShape('qua',x+sx,y+sy,z*sz,7.8,1, 8,.7, 8.3,4.2, 6.3,6.4,'lightgray',1);
			drawShape('qua',x+sx,y+sy,z*sz,7.8,1, 8,.7, 8.02,.9, 6.3,6.4,'gray',1);
     sx = 0.25*z;
      sy = 3.5*z;
      sz = .39;
      drawShape('qua',x+sx,y+sy,z*sz,7.8,1, 8,.7, 8.3,4.2, 6.3,6.4,'lightgray',1);
			drawShape('qua',x+sx,y+sy,z*sz,7.8,1, 8,.7, 8.02,.9, 6.3,6.4,'gray',1);
      sx = -0.25*z;
      sy = 3.5*z;
      sz = .39;
      drawShape('qua',x+sx,y+sy,z*sz,7.8,1, 8,.7, 8.3,4.2, 6.3,6.4,'lightgray',1);
			drawShape('qua',x+sx,y+sy,z*sz,7.8,1, 8,.7, 8.02,.9, 6.3,6.4,'gray',1);
   			
      drawShape('qua',x,y,z,0,6.5, 10,6.5, 10,10, 0,10,'rgba(0,0,255,.25)',1);

       break;
    case 56://Imp 7
    /*
       sx =  0.4*z;
       sy = 1*z
       sz = .36;
    drawShape('pol',x+sx,y+sy,z*sz,10,0, 8,.5 ,2,5 ,0,8,'rgba(0,6,13,1)',1,0,10);
      drawShape('tri',x+sx,y+sy,z*sz,10,0, 10,5 ,5.5,2 ,0,10,'rgba(0,6,13,1)',1,9,9);
    
      drawShape('qua',x,y,z,5,2.75, 4,2,3.45,1.6 ,4.5,3.5,'rgba(0,0,64,.5)',1,5.1,7);
      drawShape('tri',x,y,z,3.5,1.75, 3.5,1.55, 1.8,2.6 ,4.5,3.5,'rgba(0,0,64,1)',1,5.1,7);
      drawShape('tri',x,y,z,.5,4.55, 1.8,2.5, 2,2.5 ,4.5,4,'rgba(0,0,64,1)',1,5.1,7);

      drawShape('pol',x+sx,y+sy,z*sz,10,5, 8.5,2 ,4,4.45 ,0,10,'rgba(255,255,128,1)',1,9,9);
      drawShape('tri',x+sx,y+sy,z*sz,10,5, 10,7 ,9.5,6 ,0,10,'rgba(255,255,128,1)',1,9,9);
      drawShape('pol',x+sx,y+sy,z*sz,9,9, 10,7 ,9.75,6.25 ,8.75,7.25,'rgba(0,0,0,1)',1,8.75,8.25);
      drawShape('pol',x+sx,y+sy,z*sz,9,9.1, 4.5,9.6 ,5,8.5 ,6,8.25,'rgba(0,0,0,1)',1,8,8.5);
      drawShape('pol',x+sx,y+sy,z*sz,0,10, 4.5,9.7 ,4,9 ,3,8.75,'rgba(0,0,0,1)',1,2,9);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 4.5,5 ,8.5,2 ,5,5,'rgba(0,0,0,.25)',1,2,9);
      drawShape('qua',x+sx,y+sy,z*sz,4.5,9, 5,6 ,8.5,2 ,5.5,6,'rgba(0,0,0,.25)',1,2,9);
      drawShape('qua',x+sx,y+sy,z*sz,9,9, 7.55,6 ,8.5,2 ,8,6,'rgba(0,0,0,.25)',1,2,9);
      drawShape('qua',x+sx,y+sy,z*sz,10,7, 9.5,5 ,8.5,2 ,9.3,5,'rgba(0,0,0,.25)',1,2,9);
      drawShape('tri',x+sx,y+sy,z*sz,0,9.75, 2.25,5 ,0,7 ,6,8.25,'rgba(0,6,13,1)',1,8,8.5);
*/
      sx =  6*z;
       sy = 1*z
       sz = .5;
       /*
       drawShape('pol',x+sx,y+sy,z*sz,0,0, 2,.5 ,8,5 ,10,8,'rgba(0,6,13,1)',1,10,10);
      drawShape('tri',x+sx,y+sy,z*sz,0,0, 0,5 ,4.5,2 ,0,10,'rgba(0,6,13,1)',1,9,9);

      drawShape('pol',x+sx,y+sy,z*sz,0,5, 1.5,2 ,6,4.45 ,10,10,'rgba(255,255,128,1)',1,1,9);
      drawShape('tri',x+sx,y+sy,z*sz,0,5, 0,7 ,0.5,6 ,10,10,'rgba(255,255,128,1)',1,1,9);
      drawShape('pol',x+sx,y+sy,z*sz,1,9, 0,7 ,0.75,6.25 ,1.25,7.25,'rgba(0,0,0,1)',1,1.25,8.25);
      drawShape('pol',x+sx,y+sy,z*sz,1,9.1, 5.5,9.6 ,5,8.5 ,4,8.25,'rgba(0,0,0,1)',1,2,8.5);
      drawShape('pol',x+sx,y+sy,z*sz,10,10, 5.5,9.7 ,6,9 ,7,8.75,'rgba(0,0,0,1)',1,8,9);
      drawShape('qua',x+sx,y+sy,z*sz,10,10, 5.5,5 ,1.5,2 ,5,5,'rgba(0,0,0,.25)',1,8,9);
      drawShape('qua',x+sx,y+sy,z*sz,5.5,9, 5,6 ,1.5,2 ,4.5,6,'rgba(0,0,0,.25)',1,8,9);
      drawShape('qua',x+sx,y+sy,z*sz,1,9, 2.45,6 ,1.5,2 ,2,6,'rgba(0,0,0,.25)',1,8,9);
      drawShape('qua',x+sx,y+sy,z*sz,0,7, 0.5,5 ,1.5,2 ,0.7,5,'rgba(0,0,0,.25)',1,8,9);
      drawShape('tri',x+sx,y+sy,z*sz,10,9.75, 7.75,5 ,10,7 ,4,8.25,'rgba(0,6,13,1)',1,2,8.5);
            drawShape('qua',x,y,z,5,2.75, 6,2,6.55,1.7 ,5.5,3.5,'rgba(0,0,64,.5)',1,5.1,7);
      drawShape('tri',x,y,z,6.5,1.75, 6.5,1.6, 8.2,2.6 ,4.5,3.5,'rgba(0,0,64,1)',1,5.1,7);
      drawShape('tri',x,y,z,9.55,4.55, 8.2,2.5, 8,2.5 ,4.5,3.5,'rgba(0,0,64,1)',1,5.1,7);
*/ sx =  -2.5*z;
       sy = -.65*z
       sz = 1.5;
            drawShape('pol',x+sx,y+sy,z*sz,5,1, 4.25,.5 ,4.5,2 ,5,2.5,'rgba(0,6,64,.75)',1,5.5,1);
            drawShape('pol',x+sx,y+sy,z*sz,5,1, 5.75,.5 ,5.5,2 ,5,2.5,'rgba(0,6,64,.75)',1,4.5,1);
            drawShape('qua',x+sx,y+sy,z*sz,5,2, 4,2.5 ,4.5,4 ,5,5,'rgba(0,6,64,1)',1,5.5,1);
            drawShape('qua',x+sx,y+sy,z*sz,5,2, 6,2.5 ,5.5,4 ,5,5,'rgba(0,6,64,1)',1,5.5,1);

            drawShape('pol',x+sx,y+sy,z*sz,4.5,4, 4,5 ,4,6 ,4.5,5.25,'rgba(0,6,64,.75)',1,5,5);
            drawShape('pol',x+sx,y+sy,z*sz,5.5,4, 6,5 ,6,6 ,5.5,5.25,'rgba(0,6,64,.75)',1,5,5);

            drawShape('pol',x+sx,y+sy,z*sz,4,2.5, 3.5,3 ,3,4 ,3.5,3.5,'rgba(0,6,64,1)',1,4.5,3);
            drawShape('pol',x+sx,y+sy,z*sz,6,2.5, 6.5,3 ,7,4 ,6.5,3.5,'rgba(0,6,64,1)',1,5.5,3);
            drawShape('qua',x+sx,y+sy,z*sz,4,5.5, 4,7 ,4.5,6 ,4.5,5.5,'rgba(0,6,64,.75)',1,5.5,3);
            drawShape('qua',x+sx,y+sy,z*sz,6,5.5, 6,7 ,5.5,6 ,5.5,5.5,'rgba(0,6,64,.75)',1,4.5,3);
            drawShape('tri',x+sx,y+sy,z*sz,5,1.5, 4.6,1.25 ,4.6,1.45 ,5.5,5.5,'rgba(255,0,0,1)',1,4.5,3);
            drawShape('tri',x+sx,y+sy,z*sz,5,1.5, 5.4,1.25 ,5.4,1.45 ,5.5,5.5,'rgba(255,0,0,1)',1,4.5,3);

            drawShape('qua',x+sx,y+sy,z*sz,3.25,3.6, 2.75,3.75 ,3.25,3.75 ,3.5,4,'rgba(0,6,64,1)',1,4.5,3);
            drawShape('qua',x+sx,y+sy,z*sz,6.75,3.6, 7.25,3.75 ,6.75,3.75 ,6.5,4,'rgba(0,6,64,1)',1,4.5,3);

            drawShape('pol',x+sx,y+sy,z*sz,4.6,1.7, 4.9,2.2 ,5.1,2.2 ,5.4,1.7,'rgba(0,0,0,1)',1,5.4,1.7);
            drawShape('tri',x+sx,y+sy,z*sz,4.9,2, 5.1,2 ,5,3 ,5,3,'rgba(255,0,0,1)',1,5.4,1.7);
            drawShape('tri',x+sx,y+sy,z*sz,4.6,1.7, 4.7,1.7 ,4.6,1.9 ,5,3,'rgba(255,255,255,1)',1,5.4,1.7);
            drawShape('tri',x+sx,y+sy,z*sz,5.4,1.7, 5.3,1.7 ,5.4,1.9 ,5,3,'rgba(255,255,255,1)',1,5.4,1.7);
            drawShape('pol',x+sx,y+sy,z*sz,4.9,5, 5.1,5 ,5.1,6 ,5.3,7,'rgba(0,0,64,1)',1,5.1,6.3);

    break;
    case 57: //Spider 8
    sz = .69
    sx = 1.55*z
    sy = 1.5*z
			//back legs
			drawShape('ell',x+sx,y+sy,z*sz,6.5,5,5.5,.6,1.5,0,6,0,'darkgreen',1);//r-leg-rear-base
			drawShape('ell',x+sx,y+sy,z*sz,10.2,2.6,2.4,.3,.73,0,6,0,'darkgreen',1);//r-leg-rear-mid
			drawShape('ell',x+sx,y+sy,z*sz,11.3,4.4,.5,.15,1.5,0,6,0,'darkgreen',1);//r-leg-rear-tip
			drawShape('ell',x+sx,y+sy,z*sz,8,5,5,.5,1.38,0,6,0,'green',1);//r-leg-mrear-base
			drawShape('ell',x+sx,y+sy,z*sz,11,3.1,2,.2,2,0,6,0,'green',1);//r-leg-mrear-mid
			drawShape('ell',x+sx,y+sy,z*sz,11.3,5,.5,.15,0,0,6,0,'green',1);//r-leg-mrear-tip
			drawShape('ell',x+sx,y+sy,z*sz,3.5,5,5.5,.6,-1.5,0,6,0,'darkgreen',1);//l-leg-rear-base
			drawShape('ell',x+sx,y+sy,z*sz,-.2,2.6,2.4,.3,-.73,0,6,0,'darkgreen',1);//l-leg-rear-mid
			drawShape('ell',x+sx,y+sy,z*sz,-1.3,4.4,.5,.15,-1.5,0,6,0,'darkgreen',1);//l-leg-rear-tip
			drawShape('ell',x+sx,y+sy,z*sz,2,5,5,.5,-1.38,0,6,0,'green',1);//l-leg-mrear-base
			drawShape('ell',x+sx,y+sy,z*sz,-1,3.1,2,.2,2,0,6,0,'green',1);//l-leg-mrear-mid
			drawShape('ell',x+sx,y+sy,z*sz,-1.3,5,.5,.15,0,0,6,0,'green',1);//l-leg-mrear-tip
			//body
			drawShape('ell',x+sx,y+sy,z*sz,5,5,5,4,0,0,6,0,'darkgreen',1);//body
			drawShape('ell',x+sx,y+sy,z*sz,5,5,5,4,0,.05,.95,0,'rgba(0,0,0,.45)',1);//body shadow
			drawShape('ell',x+sx,y+sy,z*sz,5,3,6.13,4,0,.2,.8,0,'darkgreen',1);//body shadowcurve
			drawShape('qua',x+sx,y+sy,z*sz,2,1.73,9.5,5.5,0.5,5.5,8,1.73,'red',1);//hourglass
			//front legs
			drawShape('ell',x+sx,y+sy,z*sz,2,7,4,.4,-1.25,0,6,0,'green',1);//l-leg-mfront-base
			drawShape('ell',x+sx,y+sy,z*sz,-.9,6.7,2,.3,2,0,6,0,'green',1);//l-leg-mfront-mid
			drawShape('ell',x+sx,y+sy,z*sz,-1.1,9,.7,.2,1.5,0,6,0,'green',1);//l-leg-mfront-tip
			drawShape('ell',x+sx,y+sy,z*sz,8,7,4,.4,1.25,0,6,0,'green',1);//r-leg-mfront-base
			drawShape('ell',x+sx,y+sy,z*sz,10.9,6.7,2,.3,2,0,6,0,'green',1);//r-leg-mfront-mid
			drawShape('ell',x+sx,y+sy,z*sz,11.1,9,.7,.2,-1.5,0,6,0,'green',1);//r-leg-mfront-tip
			drawShape('ell',x+sx,y+sy,z*sz,7.5,5,5,.5,1.5,0,6,0,'green',1);//r-leg-front-base
			drawShape('ell',x+sx,y+sy,z*sz,10,5,4,.4,2,0,6,0,'green',1);//r-leg-front1-mid
			drawShape('ell',x+sx,y+sy,z*sz,10,5,4,.4,2,0,6,0,'darkgreen',0);//r-leg-front1-mid
			drawShape('ell',x+sx,y+sy,z*sz,9.6,9,1,.3,1.5,0,6,0,'green',1);//r-leg-front-tip
			drawShape('ell',x+sx,y+sy,z*sz,2.5,5,5,.5,-1.5,0,6,0,'green',1);//l-leg-front-base
			drawShape('ell',x+sx,y+sy,z*sz,0,5,4,.4,2,0,6,0,'green',1);//l-leg-front-mid
			drawShape('ell',x+sx,y+sy,z*sz,0,5,4,.4,2,0,6,0,'darkgreen',0);//l-leg-front-mid
			drawShape('ell',x+sx,y+sy,z*sz,.4,9,1,.3,-1.5,0,6,0,'green',1);//l-leg-front-tip
			//head
			drawShape('ell',x+sx,y+sy,z*sz,5,8,2.3,2,0,0,6,0,'green',1);//head
			drawShape('ell',x+sx,y+sy,z*sz,5,8,2.3,2,0,0,6,0,'darkgreen',0);//head
			drawShape('ell',x+sx,y+sy,z*sz,5,8,2.3,2,0,.05,.95,0,'rgba(0,0,0,.45)',1);//head shadow
			drawShape('ell',x+sx,y+sy,z*sz,5,7,2.8,2,0,.2,.8,0,'green',1);//head shadowcurve
			drawShape('arc',x+sx,y+sy,z*sz,4.5,8,.5,0,6,0,0,0,'black',1);//l-eye1
			drawShape('arc',x+sx,y+sy,z*sz,5.5,8,.5,0,6,0,0,0,'black',1);//r-eye1
			drawShape('arc',x+sx,y+sy,z*sz,3.73,7,.2,0,6,0,0,0,'black',1);//l-eyebot
			drawShape('arc',x+sx,y+sy,z*sz,4.23,7.2,.2,0,6,0,0,0,'black',1);//l-eyemid
			drawShape('arc',x+sx,y+sy,z*sz,4.7,7.35,.2,0,6,0,0,0,'black',1);//l-eyetop
			drawShape('arc',x+sx,y+sy,z*sz,6.26,7,.2,0,6,0,0,0,'black',1);//r-eyebot
			drawShape('arc',x+sx,y+sy,z*sz,5.77,7.2,.2,0,6,0,0,0,'black',1);//r-eyemid
			drawShape('arc',x+sx,y+sy,z*sz,5.3,7.35,.2,0,6,0,0,0,'black',1);//r-eyebot
			drawShape('ell',x+sx,y+sy,z*sz,5,9.3,1.5,.5,0,.65,2.35,0,'black',1);//mouth
			drawShape('ell',x+sx,y+sy,z*sz,5.2,9.5,.8,.5,1.9,1.1,1.9,0,'white',1);//r-fang
			drawShape('ell',x+sx,y+sy,z*sz,4.8,9.5,.8,.5,-1.9,1.1,1.9,0,'white',1);//l-fang
			drawShape('ell',x+sx,y+sy,z*sz,6.8,8.4,1,.8,1.1,1.1,1.9,0,'green',1);//r-fang
			drawShape('ell',x+sx,y+sy,z*sz,6.8,8,1,.8,1.1,1.1,1.9,0,'darkgreen',0);//r-fang
			drawShape('ell',x+sx,y+sy,z*sz,3.3,8.4,1,.8,-1.1,1.1,1.9,0,'green',1);//l-fang
			drawShape('ell',x+sx,y+sy,z*sz,3.3,8,1,.8,-1.1,1.1,1.9,0,'darkgreen',0);//l-fang
			
		 
    break;
    case 58://Intimidate 9
    drawShape('arc',x,y,z,5,5,5,0,2,0,0,0,'rgba(64,50,7,.75)',1);

    drawShape('tri',x,y,z,4.5,5.5, .5,2 ,.5,5 ,0,10,'rgba(128,6,13,1)',1,9,9);
    drawShape('tri',x,y,z,5.5,5.5, 9.5,2 ,9.5,5 ,10,10,'rgba(128,6,13,1)',1,9,9);
    drawShape('qua',x,y,z,4.5,5, 3.5,3 ,2,2 ,3,3,'rgba(0,6,13,1)',1,9,9);
    drawShape('qua',x,y,z,5.5,5, 6.5,3 ,8,2 ,7,3,'rgba(0,6,13,1)',1,9,9);

    break;
    case 59: //Critical Strike 10
      drawShape('arc',x,y,z,5,5,5,0,2,0,0,0,'rgba(255,201,14,.1)',1);
      drawShape('qua',x,y,z,5-Math.random(),1-Math.random(), 8,7+Math.random() ,7-Math.random(),1+Math.random() ,6+Math.random(),8+Math.random(),'rgba(128,6,13,1)',1,9,9);
    
      drawShape('qua',x,y,z,2-Math.random(),3.5-Math.random(), 6-Math.random(),8.5+Math.random() ,4-Math.random(),3.5-Math.random() ,4,9.5+Math.random(),'rgba(128,6,13,1)',1,9,9);

      sx = 0*z;
      sy = 1*z;
      sz = .9;
			drawShape('tri',x+sx,y+sy,z*sz,0,8.6, 1.4,10, 0,10 ,0,0,'rgb(252,165,3)',1);
			drawShape('qua',x+sx,y+sy,z*sz,0,9, 2,7, 3,8, 1,10,'rgb(252,165,3)',1);
			drawShape('qua',x+sx,y+sy,z*sz,0,5, 1,5 ,5,9 ,5,10,'rgb(252,165,3)',1);
       drawShape('tri',x+sx,y+sy,z*sz,0,10, 1.4,10, 0,8.6 ,0,10,'darkgray',1);//pommel

			drawShape('qua',x+sx,y+sy,z*sz,2,6, 8,1, 8,2, 4,6,'gray',1);//
			drawShape('qua',x+sx,y+sy,z*sz,4,8, 9,2, 8,2 ,4,6,'gray',1);
			drawShape('tri',x+sx,y+sy,z*sz,2,6, 4,6, 4,8, 0,0,'gray',1);
			drawShape('qua',x+sx,y+sy,z*sz,8,1, 8,2, 9,2, 10,0,'gray',1);
      	drawShape('qua',x+sx,y+sy,z*sz,2,6, 8,1, 8,2, 4,6,'rgba(0,0,0,.25)',1);//
			drawShape('qua',x+sx,y+sy,z*sz,4,8, 9,2, 8,2 ,4,6,'rgba(0,0,0,.25)',1);
			drawShape('tri',x+sx,y+sy,z*sz,2,6, 4,6, 4,8, 0,0,'rgba(0,0,0,.25)',1);
			drawShape('qua',x+sx,y+sy,z*sz,8,1, 8,2, 9,2, 10,0,'rgba(0,0,0,.25)',1);
			drawShape('qua',x+sx,y+sy,z*sz,0,5, 1,5, 5,9 ,5,10,'rgb(252,165,3)',0);
			drawShape('arc',x+sx,y+sy,z*sz,3,7, .5,0, 6,0 ,0,0,'red',1);//pommel gem
			drawShape('arc',x+sx,y+sy,z*sz,3,7 ,.5,0, 6,0, 0,0,'brown',0);
          drawShape('qua',x,y,z,5-Math.random(),1-Math.random(), 8,7+Math.random() ,7-Math.random(),1+Math.random() ,6+Math.random(),8+Math.random(),'rgba(128,6,13,.25)',1,9,9);
    
      drawShape('qua',x,y,z,3-Math.random(),3-Math.random(), 7-Math.random(),7.5+Math.random() ,5.5-Math.random(),2-Math.random() ,5.5-Math.random(),9+Math.random(),'rgba(128,6,13,.25)',1,9,9);

    break;
    case 60: //Pixie Page
        
      drawShape('pol',x,y,z,0,8, 4.5,7.5, 10,7.5, 10,10,'rgba(0,128,0,1)',1, 0,10);//hipclothesleft
      drawShape('tri',x,y,z,3,8, 0,4.5, 0,8, 10,10,'rgba(255,255,255,.5)',1, 0,10);//hipclothesleft
      drawShape('pol',x,y,z,1,9, 4,8, 10,9, 6,8.25,'rgba(0,0,255,1)',1, 0,8.9);//hipclothesleft

        drawShape('pol',x,y,z,8,10, 4,7, 2,5.5, 3,7.5,'rgba(64,32,0,1)',1, 5,10);//hipclothesleft
        drawShape('pol',x,y,z,6.5,10, 4,8, 2,5.5, 3,7.5,'rgba(0,0,0,.2)',1, 5,10);//hipclothesleft

        drawShape('tri',x,y,z,9,10, 9,7, 10,3, 3,7.5,'rgba(64,32,0,1)',1, 5,10);//hipclothesleft
        drawShape('tri',x,y,z,10,3, 8,10, 10,10, 3,7.5,'rgba(64,32,0,1)',1, 5,10);//hipclothesleft
        drawShape('tri',x,y,z,10,3, 8,10, 10,10, 3,7.5,'rgba(0,0,0,.55)',1, 5,10);//hipclothesleft

         sx = .5*z;
      sy = .5*z;
      sz = .9;
      drawShape('qua',x+sx,y+sy,z*sz,5.5,9, 5,8, 4.9,8.1, 5.1,8.75,'gold',1);//rfoottop
      drawShape('tri',x+sx,y+sy,z*sz,5.5,9, 5.5,8.5, 5,8, 5.1,8.75,'gold',1);//rfootbot

       sx = .5*z;
      sy = .5*z
      //drawShape('pol',x,y+sy,z,6.25,6.5, 6,6.4, 3.5,6.5, 4.5,6,'brown',1, 6.01,6.1);//llegcalf
      //drawShape('pol',x,y+sy,z,6.5,3.5, 6.6,3.75, 6.25,5, 5.75,4.5,'brown',1,6,4);//llegthigh
        //drawShape('ell',x,y+sy,z,4.1,6.34, .6,.39, .48,0, 1,1,'brown',1);

      drawShape('qua',x+sx,y+sy,z*sz,5.2,8.4, 5.2,8, 4.9,7, 4.95,8.1,'brown',1);//rlegleft
      drawShape('pol',x+sx,y+sy,z*sz,5.2,8, 4.9,7, 4.75,5.8, 5.5,5.25,'brown',1, 5.3,7);//rlegright
      sx = 0*z;
      sy = 0*z
      drawShape('qua',x+sx,y+sy,z*sz,4.5,9, 5,8, 5.1,8.1, 4.9,8.75,'gold',1);//rfoottop
      drawShape('tri',x+sx,y+sy,z*sz,4.5,9, 4.5,8.5, 5,8, 4.9,8.75,'gold',1);//rfootbot

      drawShape('qua',x+sx,y+sy,z*sz,4.8,8.4, 4.8,8, 5.1,7, 5.05,8.1,'brown',1);//rlegleft
      drawShape('pol',x+sx,y+sy,z*sz,4.8,8, 5.1,7, 5.25,5.8, 4.5,5.25,'brown',1, 4.7,7);//rlegright
      sx = .5*z;
      sy = .5*z
      drawShape('pol',x+sx,y+sy,z*sz,4.25,5.5, 3.75,5, 3.7,5.2, 3.5,4.8,'cyan',1, 4.3,4);//hipclothesleft
      drawShape('pol',x+sx,y+sy,z*sz,4.25,5.5, 3.75,5, 3.7,5.2, 3.5,4.8,'rgba(0,0,0,.4)',1, 4.3,4);//hipclothesleft
      drawShape('pol',x+sx,y+sy,z*sz,4.25,5.5, 4.5,5.25, 4.75,5.8, 5.5,5.25,'cyan',1, 5.8,4.5);//hipclothesright
      drawShape('pol',x+sx,y+sy,z*sz,4.25,5.5, 4.5,5.25, 4.75,5.8, 5.5,5.25,'rgba(0,0,0,.2)',1, 5.8,4.5);//hipclothesright

      drawShape('pol',x+sx,y+sy,z*sz,4.25,5.5, 5.8,4.5, 5.5,4, 4.75,4.2,'cyan',1, 4.3,4);//hipclothesmid
      drawShape('qua',x+sx,y+sy,z*sz,4.8,3.2, 2.6,2.5-Math.random(), 5,0.9, 7.4,2.5-Math.random(),'rgba(255,255,255,.05)',1);//arms
      drawShape('qua',x+sx,y+sy,z*sz,4.8,3.2, 2.6,2.5-Math.random(), 5,.9, 7.4,2.5-Math.random(),'rgba(255,255,255,.05)',1);//arms
      drawShape('qua',x+sx,y+sy,z*sz,4.8,3, 3.5,2.5-Math.random(), 4.8,2, 6.5,2.5-Math.random(),'rgba(255,255,255,.45)',1);//arms
      drawShape('arc',x+sx,y,z*sz,9,1.25,1,0,3,0,0,0,'rgba(255,255,255,1)',1);//r-hand
      drawShape('arc',x+sx,y,z*sz,9,1.25,1.1,0,3,0,0,0,'rgba(255,255,0,.25)',1);//r-hand
      drawShape('arc',x+sx,y,z*sz,9,1.25,1.15,0,3,0,0,0,'rgba(255,255,0,.25)',1);//r-hand
      drawShape('arc',x+sx,y,z*sz,9,1.25,1.2,0,3,0,0,0,'rgba(255,255,0,.25)',1);//r-hand
      drawShape('arc',x+sx,y,z*sz,9,1.25,1.25,0,3,0,0,0,'rgba(255,255,0,.25)',1);//r-hand
      drawShape('arc',x+sx,y,z*sz,9,1.25,1.3,0,3,0,0,0,'rgba(255,255,0,.25)',1);//r-hand
      sy = -3.5*z
  drawShape('qua',x+sx,y+sy,z*sz,4.8,6.8, 2.6,7.5+Math.random(), 5,9.1, 7.4,7.5+Math.random(),'rgba(255,255,255,.05)',1);//arms
      drawShape('qua',x+sx,y+sy,z*sz,4.8,6.8, 2.6,7.5+Math.random(), 5,9.1, 7.4,7.5+Math.random(),'rgba(255,255,255,.05)',1);//arms
      drawShape('qua',x+sx,y+sy,z*sz,4.8,7, 3.5,7.5+Math.random(), 4.8,8, 6.5,7.5+Math.random(),'rgba(255,255,255,.45)',1);//arms
      sy = .5*z

      drawShape('pol',x+sx,y+sy,z*sz,4.3,4, 4,2.5, 4.1,1.5, 5.85,1.5,'cyan',1, 5.8,2);//tunicl
            drawShape('pol',x+sx,y+sy,z*sz,4.3,4, 4,2.5, 4.1,1.5, 5.85,1.5,'rgba(0,0,0,.2)',1, 5.8,2);//tunicl

      drawShape('qua',x+sx,y+sy,z*sz,5.8,2, 5.5,4, 4.75,4.25, 4.3,4,'cyan',1);//tunicr
            drawShape('qua',x+sx,y+sy,z*sz,5.8,2, 5.5,4, 4.75,4.25, 4.3,4,'rgba(0,0,0,.1)',1);//tunicr


      drawShape('pol',x+sx,y+sy,z*sz,4.5,1.5, 4.5,1.6, 5,1.75, 5.5,1.6,'rgb(255,179,102)',1, 5.5,1.5);//collar

      drawShape('pol',x+sx,y,z*sz,4.55,1.5, 4.35,0.7, 5,0, 5.6,0.7,'gold',1, 5.4,1.6);//hair
      sy = .5*z
      drawShape('pol',x+sx,y+sy,z*sz,4.55,1.5, 4.8,1.1, 5.25,1.25, 5.3,1.4,'rgb(255,179,102)',1, 5.5,1.5);//neck
      drawShape('pol',x+sx,y+sy,z*sz,4.6,1.25, 4.5,0.25, 5,0.275, 5.5,0.3,'rgb(245,169,92)',1, 5.3,1.5);//neck
       sx = .5*z;
      sy = .2*z
            drawShape('tri',x+sx,y+sy,z*sz,4.55,1, 4.8,0.95, 4.95,1, 0,0,'rgba(0,0,0,.7)',1, 5.4,8.4);//hair
            drawShape('tri',x+sx,y+sy,z*sz,5.45,1, 5.2,0.95, 5.05,1, 0,0,'rgba(0,0,0,.7)',1, 5.4,8.4);//hair
            drawShape('pol',x+sx,y+sy,z*sz,5,1.4, 4.9,1.35, 5,1.2, 5,1.35,'rgba(0,0,0,.7)',1, 5.1,1.35);//hair
            drawShape('tri',x+sx,y+sy,z*sz,4.75,1.5, 5,1.55, 5.25,1.5, 0,0,'rgba(255,0,0,.55)',1, 5.4,8.4);//hair
     
      drawShape('qua',x,y,z,4,4, 3.5,5, 3.4,4.9, 3.5,3.75,'rgba(255,128,64,1)',1, 4.3,4);//hipclothesleft
      drawShape('qua',x,y,z,6,4, 6.5,5, 6.6,4.9, 6.5,3.75,'rgba(255,128,64,1)',1, 4.3,4);//hipclothesleft
      
      drawShape('qua',x,y,z,3.4,5.1, 3.5,5.5, 3.25,6, 3.2,5.4,'gold',1, 3.4,4.9);//hipclothesleft

      drawShape('pol',x,y,z,3.5,5, 3.5,5.5, 3.4,5.1, 3.2,5.4,'rgba(255,128,64,1)',1, 3.4,4.9);//hipclothesleft
      drawShape('pol',x,y,z,3.4,5.4, 2.5,5, 1,4.6, 2.25,5.25,'silver',1, 3.3252,5.7);//hipclothesleft
      drawShape('pol',x,y,z,3.5,5.5, 3.8,5.75, 3.7,5.75, 3.5,5.75,'gold',1, 3.4,4.9);//hipclothesleft


      drawShape('qua',x,y,z,4.2,1.9, 3.5,3.75, 4,4.25, 4.2,3.25,'cyan',1, 4.3,4);//hipclothesleft
      drawShape('qua',x,y,z,4.2,1.9, 3.5,3.75, 4,4.25, 4.2,3.25,'rgba(0,0,0,.5)',1, 4.3,4);//hipclothesleft

      drawShape('qua',x,y,z,5.69,1.9, 6.5,3.75, 6,4.25, 5.63,2.8,'cyan',1, 4.3,4);//hipclothesleft
      drawShape('qua',x,y,z,5.69,1.9, 6.5,3.75, 6,4.25, 5.63,2.8,'rgba(0,0,0,.15)',1, 4.3,4);//hipclothesleft
      drawShape('tri',x,y,z,3.5,5.5, 3.5,5.8, 3.4,5.7, 3.5,3.75,'rgba(255,128,64,1)',1, 4.3,4);//hipclothesleft

      drawShape('qua',x,y,z,6.6,5.1, 6.5,5.5, 6.75,6, 6.8,5.4,'gold',1, 3.4,4.9);//hipclothesleft

      drawShape('pol',x,y,z,6.5,5, 6.5,5.5, 6.6,5.1, 6.8,5.4,'rgba(255,128,64,1)',1, 6.6,4.9);//hipclothesleft
      drawShape('pol',x,y,z,6.4,5.4, 7.5,5, 9,4.6, 7.75,5.25,'silver',1, 6.6848,5.7);//hipclothesleft
      drawShape('pol',x,y,z,6.5,5.5, 6.2,5.75, 6.2,5.75, 6.5,5.75,'gold',1, 6.6,4.9);//hipclothesleft


      drawShape('qua',x,y,z,5.8,1.9, 6.5,3.75, 6,4.25, 5.8,3.25,'cyan',1, 4.3,4);//hipclothesleft
      drawShape('qua',x,y,z,5.8,1.9, 6.5,3.75, 6,4.25, 5.8,3.25,'rgba(0,0,0,.5)',1, 4.3,4);//hipclothesleft

      drawShape('qua',x,y,z,4.31,1.9, 4.5,3.75, 4,4.25, 4.47,2.8,'cyan',1, 4.3,4);//hipclothesleft
      drawShape('qua',x,y,z,4.31,1.9, 4.5,3.75, 4,4.25, 4.47,2.8,'rgba(0,0,0,.15)',1, 4.3,4);//hipclothesleft
      drawShape('tri',x,y,z,6.5,5.5, 6.5,5.8, 6.6,5.7, 6.5,3.75,'rgba(255,128,64,1)',1, 4.3,4);//hipclothesleft

    break;
    case 61://Sylph Knight
        drawShape('qua',x,y,z,5,0, 0,5 ,5,10, 10,5,`rgba(128,128,${0},.15)`,1);//neck


    		drawShape('qua',x,y,z,5.5,3, 6,1.5 ,7.5,1, 7.5,2.5,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},${0+Math.random()*.5})`,1);//neck
    			drawShape('qua',x,y,z,5.5,2.75, 7,3 ,8,5.25, 6.5,4.75,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},${0+Math.random()*.5})`,1);//neck
          drawShape('qua',x,y,z,4.5,3, 4,1.5 ,2.5,1, 2.5,2.5,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},${0+Math.random()*.5})`,1);//neck
    			drawShape('qua',x,y,z,4.5,2.75, 3,3 ,2,5.25, 3.5,4.75,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},${0+Math.random()*.5})`,1);//neck
       
       sx=.5*z;
       sy=1*z; 
       sz=.9;
          		drawShape('tri',x+sx,y+sy,z*sz,/*tl*/ 4.45,3.55, /*tr*/3.7,2.5, /*br*/2.3,4, 0,0,'rgba(255,255,255,1)',1);//r-arm
			drawShape('tri',x+sx,y+sy,z*sz,/*tl*/ 4.4,3.5, /*tr*/3.7,2.5, /*br*/2.3,4, 0,0,'rgba(0,0,0,.4)',1);//r-arm
         drawShape('tri',x+sx,y+sy,z*sz,/*br*/ 2.1,3.9, /*tr*/2.7,3.3, /*l*/3.5,5.5, 0,0,'rgba(255,255,255,1)',1);//r-forearm
			drawShape('tri',x+sx,y+sy,z*sz,/*br*/ 2.1,3.9, /*tr*/2.7,3.3, /*l*/3.5,5.5, 0,0,'rgba(0,0,0,.4)',0);//r-forearm
     
    sx=.5*z;
      sy=1*z; 
      sz=.9;

			drawShape('arc',x+sx,y+sy,z*sz,4.25,2.65, .63,0, 3,0, 0,0,'rgba(255,255,255,1)',1);//l-shoulder
			drawShape('arc',x+sx,y+sy,z*sz,4.25,2.65, .63,0, 3,0, 0,0,'rgba(0,0,0,.2)',1);//l-shoulder
      drawShape('arc',x+sx,y+sy,z*sz,4.25,2.65, .63,0, 3,0, 0,0,'rgba(255,255,255,.5)',0);//l-shoulder-shadow
			drawShape('ell',x+sx,y+sy,z*sz,5.15,3.6,1.15,1.75,0,0,6,0,'rgba(255,255,255,1)',1);//torso
      			drawShape('ell',x+sx,y+sy,z*sz,5.15,3.6,1.15,1.75,0,0,6,0,'rgba(0,0,0,.3)',1);//torso

			drawShape('qua',x+sx,y+sy,z*sz,4.7,1.5, 5.5,1.5 ,6,2.5, 4.3,2.5,'rgba(255,255,255,1)',1);//neck
      			drawShape('qua',x+sx,y+sy,z*sz,4.7,1.5, 5.5,1.5 ,6,2.5, 4.3,2.5,'rgba(0,0,0,.33)',1);//neck

			drawShape('arc',x+sx,y+sy,z*sz,5,1,.9,0,2,0,0,0,'rgba(255,255,255,1)',1);//head
      			drawShape('arc',x+sx,y+sy,z*sz,5,1,.9,0,2,0,0,0,'rgba(0,0,0,.3)',1);//head


      //drawShape('tri',x+sx,y+sy,z*sz,4.1,.9, 5.6,.4, 4,-.3,0,0,'lightgray',1);//helm nose

     drawShape('arc',x+sx,y+sy,z*sz,4.95,1.1,1,0,2,0,0,0,'rgba(255,255,255,.5)',1);//head
			drawShape('arc',x+sx,y+sy,z*sz,5,1.1,.9,0,.7,0,0,0,'rgba(255,255,255,.1)',1);//head
			drawShape('arc',x+sx,y+sy,z*sz,4.9,.9,.9,0,.7,0,0,0,'rgba(255,255,255,1)',1);//head
      			drawShape('arc',x+sx,y+sy,z*sz,4.9,.9,.9,0,.7,0,0,0,'rgba(0,0,0,.2)',1);//head
			drawShape('arc',x+sx,y+sy,z*sz,5,1,.8,.7,0,0,0,0,'rgba(0,0,0,.2)',1);//head

			drawShape('arc',x+sx,y+sy,z*sz,5,1,.8,.7,0,0,0,0,'rgba(255,255,255,1)',1);//head
      			drawShape('arc',x+sx,y+sy,z*sz,5,1,.8,.7,0,0,0,0,'rgba(0,0,0,.3)',1);//head

      			drawShape('arc',x+sx,y+sy,z*sz,4.9,.9,.9,0,.7,0,0,0,'rgba(0,0,0,.1)',1);//head

      drawShape('tri',x+sx,y+sy,z*sz,3.5,1.5, 4.3,.75, 4.9,1.5,0,0,'rgba(255,255,255,1)',1);//helm nose
			      drawShape('tri',x+sx,y+sy,z*sz,3.5,1.5, 4.3,.75, 4.9,1.5,0,0,'rgba(0,0,0,.3)',1);//helm nose

      
      drawShape('tri',x+sx,y+sy,z*sz,3.5,1.5,4.8,1.5,4.9,2,0,0,'rgba(255,255,255,1)',1);//helm nose
			drawShape('tri',x+sx,y+sy,z*sz,3.5,1.5,4.8,1.5,4.9,2,0,0,'rgba(0,0,0,.2)',1);//helm nose
  
      drawShape('qua',x,y,z,5,6.5, 4-Math.random()*.25,7.5, 5,9+Math.random(), 6+Math.random()*.25,7.5,`rgba(255,255,255,${1-Math.random()})`,1);//FLOATING THING
  drawShape('qua',x,y,z,5,6.5, 4-Math.random()*.25,7.5, 5,9+Math.random(), 6+Math.random()*.25,7.5,`rgba(0,0,0,${0+Math.random()*.5})`,1);//FLOATING THING
			drawShape('qua',x+sx,y+sy,z*sz,6.2,4.3,7.25,7.25,5.1,6.3,4.75,5.25,'rgba(255,255,255,.5)',1);//hip armor
     drawShape('qua',x+sx,y+sy,z*sz,6.2,4.3,7.25,7.25,5.1,6.3,4.75,5.25,'rgba(0,0,0,.25)',1);//hip armor

			drawShape('qua',x+sx,y+sy,z*sz,4.2,4.3,2.75,7.25,4.9,6.3,5.25,5.25,'rgba(255,255,255,.5)',1);//hip armor
      drawShape('qua',x+sx,y+sy,z*sz,4.2,4.3,2.75,7.25,4.9,6.3,5.25,5.25,'rgba(0,0,0,.25)',1);//hip armor
			drawShape('qua',x+sx,y+sy,z*sz,4.75,7, 5.45,5, 4.75,5.2, 4.4,5,'rgba(255,255,255,1)',1);//groin armor
			drawShape('qua',x+sx,y+sy,z*sz,4.75,7, 5.45,5, 4.75,5.2, 4.4,5,'rgba(0,0,0,.3)',1);//groin armor

		
      sx=-.5*z;
		  drawShape('qua',x+sx,y+sy,z*sz,2.75,1.75, 4.5,2.75, 4.5,5.8, 2.75,4.8,'rgba(255,255,255,1)',1);//shield top
			drawShape('tri',x+sx,y+sy,z*sz,2.75,4.8,4.5,5.8,3.5,7.5,0,0,'rgba(255,255,255,1)',1);//shield bot
			 drawShape('qua',x+sx,y+sy,z*sz,2.75,1.75, 4.5,2.75, 4.5,5.8, 2.75,4.8,'rgba(0,0,0,.5)',1);//shield top
			drawShape('tri',x+sx,y+sy,z*sz,2.75,4.8,4.5,5.8,3.5,7.5,0,0,'rgba(0,0,0,.5)',1);//shield bot
      drawShape('lin',x+sx,y+sy,z*sz,3.5,7.6,3.45,2.1,0,0,0,0,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.2)`,0);//shield cross |
			drawShape('lin',x+sx,y+sy,z*sz,2.75,4,4.5,5,0,0,0,0,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.2)`,0);//shield cross--
sx=.5*z;
			drawShape('tri',x+sx,y+sy,z*sz,/*tl*/ 5.55,3.5, /*tr*/6.3,2.5, /*br*/7.7,4, 0,0,'rgba(255,255,255,1)',1);//r-arm
			drawShape('tri',x+sx,y+sy,z*sz,/*tl*/ 5.6,3.5, /*tr*/6.3,2.5, /*br*/7.7,4, 0,0,'rgba(0,0,0,.4)',1);//r-arm
	
      sx=.5*z;

			drawShape('qua',x+sx,y+sy,z*sz,5.9,5, 5.9,5.3, 7.2,5.7, 7.2,5.3,'gold',1);//sword-hilt
			drawShape('tri',x+sx,y+sy,z*sz,1,4.1, 5.9,4.85, 6.1,5.65,0,0,'white',1);//sword-blade
      			drawShape('tri',x+sx,y+sy,z*sz,1,4.1, 5.9,4.85, 6.1,5.65,0,0,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},1)`,1);//sword-blade

			drawShape('qua',x+sx,y+sy,z*sz,6,4, 5.6,5.2, 6,6.3, 6.1,5.5,'gold',1);//sword-crossguard
      sx=.5*z;

			drawShape('arc',x+sx,y+sy,z*sz,6,3, .63,0, 3,0, 0,0,'rgba(255,255,255,1)',1);//r-shoulder
			drawShape('arc',x+sx,y+sy,z*sz,6,3, .63,0, 3,0, 0,0,'rgba(0,0,0,.1)',1);//r-shoulder
			//drawShape('tri',x+sx,y+sy,z*sz,5.3,1.3, 4.95,.05, 5.4,.17, 5.4,.3,'black',1);//helmet visor
      drawShape('qua',x+sx,y+sy,z*sz,5.8,.7, 4.2,.8, 4.05,.5, 4.15,.6,'rgba(0,0,0,1)',1);//helmet visor

      drawShape('tri',x+sx,y+sy,z*sz,/*br*/ 7.9,3.9, /*tr*/7.3,3.3, /*l*/6.5,5.5, 0,0,'rgba(255,255,255,1)',1);//r-forearm
			drawShape('tri',x+sx,y+sy,z*sz,/*br*/ 7.9,3.9, /*tr*/7.3,3.3, /*l*/6.5,5.5, 0,0,'rgba(0,0,0,.4)',1);//r-forearm
      drawShape('qua',x+sx,y+sy,z*sz,6.9,4.9, 6.1,5.1, 6.4,5.5, 6.7,5.6,'rgba(255,255,255,1)',1);//hand right
            drawShape('qua',x+sx,y+sy,z*sz,6.9,4.9, 6.1,5.1, 6.4,5.5, 6.7,5.6,'rgba(0,0,0,.4)',1);//hand right


            

    break;
    case 62: //Fairy Queen
     
    
       
    drawShape('qua',x,y,z,0,5, 5,Math.random()*.2, 10,5, 5,10,'rgba(128,128,0,.15)',1,2,10);//lower arm R
    //right calf 
    sy= .25*z
  	drawShape('qua',x,y+sy,z,5.5,3, 6,1.5 ,7.5,1, 7.5,2.5,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},${0+Math.random()*.5})`,1);//neck
    			drawShape('qua',x,y+sy,z,5.5,2.75, 7,3 ,8,5.25, 6.5,4.75,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},${0+Math.random()*.5})`,1);//neck
          drawShape('qua',x,y+sy,z,4.5,3, 4,1.5 ,2.5,1, 2.5,2.5,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},${0+Math.random()*.5})`,1);//neck
    			drawShape('qua',x,y+sy,z,4.5,2.75, 3,3 ,2,5.25, 3.5,4.75,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},${0+Math.random()*.5})`,1);//neck
       
       
            drawShape('arc',x,y,z,4.8,4.9,.05,0,6,0,0,0,'rgba(128,128,0,.25)',1);//r-hand

          drawShape('arc',x,y,z,7.5,2,.75,0,6,0,0,0,'rgba(128,128,0,.075)',1);//r-hand
        drawShape('pol',x,y,z,7,4, 5,9, 4,5, 4.5,4,'rgba(128,128,0,.25)',1,5,2.5);

     aniDice.setColor(1,1, 0)
      aniDice.setGlow(Math.random())
      aniDice.animate(x+7.55*z,y+2*z,1*z,.25,globalDt);

        drawShape('qua',x,y,z,4.25,2, 4.5,3, 5,2.5, 4.55,1.5,'rgba(0,0,0,1)',1);
        drawShape('pol',x,y,z,4.45,5.5, 4,7.5, 4.5,7.5, 4.5,7,'rgba(128,128,0,.5)',1,5.25,5.5);
        drawShape('pol',x,y,z,5.6,5, 6,6.5, 6,7, 5.6,7.5,'rgba(128,128,0,.5)',1,5.6,6.5);
        drawShape('tri',x,y,z,5.75,7, 5,5.5, 5.6,5, 5.5,7.5,'rgba(128,128,0,.5)',1,5.6,6.5);
        drawShape('pol',x,y,z,5.5,5, 5.4,4.5, 5.5,3.5, 6.9,4.8,'rgba(128,128,0,.5)',1,5.5,3);

      //legs red boots
      sx = -.5*z; 
      sy = -.1*z;
      sz = 1.1;
      drawShape('qua',x+sx,y+sy,z*sz, 5.5,7, 5.8,8.5, 6,8, 6,6.5,'rgba(128,128,0,.5)',1);
      drawShape('qua',x+sx,y+sy,z*sz, 4,7, 4,8.5, 4.25,8.3, 4.5,7,'rgba(128,128,0,.5)',1);
      drawShape('qua',x+sx,y+sy,z*sz, 4,8.25, 3.6,9, 4,8.8, 4.35,8.23,'rgba(128,128,0,1)',1);
      drawShape('qua',x+sx,y+sy,z*sz, 6,8, 6.3,9, 6,9, 5.7,8.5,'rgba(128,128,0,1)',1);
      //Empress upper
      sz = .8;
      sx = 1*z;
      sy = .0*z;
      //drawShape('qua',x+sx,y+sy,z*sz, 5.25,3, 5.5,3.5, 5,4, 4.5,2.5,'rgba(128,128,0,1)',1);//neck
      drawShape('qua',x+sx,y+sy,z*sz, 4.5,2.5, 5.5,3.5, 5,4, 4.5,2.5,'rgba(255,196,168,.9)',1);//neckL

      drawShape('qua',x+sx,y+sy,z*sz,4,1.8, 3.9,3, 4.25,3.25, 4.25,1.75,'rgba(0,0,0,.75)',1);//bangs left
      drawShape('qua',x+sx,y+sy,z*sz, 5.25,3.5, 4.15,2.25, 5,1.3, 6,2.5,'rgba(255,196,168,1)',1);//face
      //nose
      sz = .8;
      sx = .8*z;
      sy = .0*z;
      drawShape('tri',x+sx,y+sy,z*sz, 5.45,2.2, 5.4,2.8, 5.6,2.9, 0,0,'rgba(0,0,0,.2)',1);//nose
      //eyes
      sz = .8;
      sx = .8*z;
      sy = .0*z;
      drawShape('tri',x+sx,y+sy,z*sz, 5,2.2, 5.4,2.15, 5.2,2.3, 0,0,'rgba(0,0,0,.3)',1);//eye
      drawShape('tri',x+sx,y+sy,z*sz, 5.5,2.15, 5.9,2.1, 5.7,2.3, 0,0,'rgba(0,0,0,.3)',1);//eye
      //mouth 
      sz = .8;
      sx = .8*z;
      sy = .0*z;
      drawShape('tri',x+sx,y+sy,z*sz, 5.25,3, 5.6,2.95, 5.4,3.075, 0,0,'rgba(64,0,0,.4)',1);//mouth
      //hair
      sz = .8;
      sx = 1*z;
      sy = .0*z;
      drawShape('qua',x+sx,y+sy,z*sz,5,1.3, 4.2,1.75, 4,2.2, 5,1.85,'rgba(0,0,0,1)',1);//hair
      drawShape('qua',x+sx,y+sy,z*sz,5,1.3, 5.8,1.75, 6,2, 5,1.85,'rgba(0,0,0,1)',1);
       
      drawShape('qua',x+sx,y+sy,z*sz,5.55,1.9, 6,2.5, 5.8,3.4, 6,3.5,'rgba(0,0,0,1)',1);
      drawShape('qua',x+sx,y+sy,z*sz,5.55,1.9, 6,2.5, 5.8,3.4, 6,2,'rgba(0,0,0,.75)',1);
      //drawShape('qua',x,y,z,4.25,1.9, 3.8,2.5, 4,3.4, 3.8,3.5,'gold',1);
      drawShape('qua',x+sx,y+sy,z*sz,5,1.8, 4.28,2.07, 4.8,3.4, 4.5,3.5,'rgba(0,0,0,1)',1);
      drawShape('qua',x+sx,y+sy,z*sz,4.28,2.07, 3.85,2.5, 4.05,3.4, 3.85,3.5,'rgba(0,0,0,.75)',1);
      //larm
       sz = .8;
      sx = 1.25*z;
      sy = 1*z;
      drawShape('qua',x+sx,y+sy,z*sz, 3.9,4, 3,6, 3.5,6, 4,5,'rgba(128,128,0,.5)',1);//dress left forearm
        
 drawShape('qua',x+sx,y+sy,z*sz, 3.4,6, 2.5,9, 2.4,8, 3.2,5.9,'gold',1);//scepter
      drawShape('qua',x+sx,y+sy,z*sz, 3.4,6, 2.7,8, 2.4,8, 3.2,5.9,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.3)`,1);//scepter

          drawShape('qua',x+sx,y+sy,z*sz, 3,6, 3.5,6, 3.4,6.3, 3,6.5,'rgba(128,128,0,1)',1);//left hand

       sz = .7;
      sx = 1.7*z;
      sy = 3.45*z;
      drawShape('qua',x+sx,y+sy,z*sz, 2.8,4, 2.75,3.4, 3,3.6, 3.4,3.9,'rgba(128,128,0,1)',1);//left hand
         sz = .8;
      sx = 1.36*z;
      sy = .8*z;

     drawShape('qua',x+sx,y+sy,z*sz, 3.4,6.55, 3.2,6.5, 3.25,6.45, 3.2,6.3,'rgba(128,128,0,1)',1);//left thumb
      sz = .8;
      sx = 1.25*z;
      sy = 1*z;
     // drawShape('qua',x+sx,y+sy,z*sz, 4.5,6, 4.5,4.5, 3.9,4, 4,6,'rgba(128,128,0,1)',1);//dress left arm
     // drawShape('qua',x+sx,y+sy,z*sz, 5,6, 5.5,3, 4.5,4.5, 4.5,6,'rgba(128,128,0,1)',1);//dress left mid
      //
       sz = .8;
      sx = 1*z;
      sy = .0*z;
      //drawShape('qua',x+sx,y+sy,z*sz, 5.5,3.5, 6,3.5, 6.5,3.75, 7.5,5,'rgba(128,128,0,1)',1);//dress right shoulder n tricep
      //drawShape('qua',x+sx,y+sy,z*sz, 6.5,5, 6,6, 7,9.5, 3,9.5,'rgba(128,128,0,1)',1);//dress bottom right n forearm
      //drawShape('qua',x+sx,y+sy,z*sz, 7.5,5, 6,6, 7,9.5, 3,9.5,'rgba(128,128,0,1)',1);//dress bottom right n forearm
      drawShape('qua',x+sx,y+sy,z*sz, 5.5,3.5, 5,4, 5,7.5, 7.5,5,'rgba(128,128,0,.5)',1);//dress collarR
      drawShape('qua',x+sx,y+sy,z*sz, 5,4, 4.8,3.4, 4.5,3.5, 4,4,'rgba(128,128,0,.5)',1);//dress collarL
           sz = .8;
      sx = .83*z;
      sy = .0*z;
       drawShape('qua',x+sx,y+sy,z*sz, 4.5,4, 4,4.5, 4.45,5, 5,4.9,'rgba(128,128,0,.25)',1);//bl
        sx = .5*z;
        sy = .0*z;
       drawShape('qua',x+sx,y+sy,z*sz, 5.5,4, 4.8,4.5, 5.25,5, 5.8,4.9,'rgba(128,128,0,.5)',1);//brmain

      //
      sz = .8;
      sx = 2*z;
      sy = .0*z;
      drawShape('qua',x+sx,y+sy,z*sz, 6.1,6, 7,4, 6.5,4, 6,5,'rgba(128,128,0,.5)',1);//dress left forearm
        
      drawShape('qua',x+sx,y+sy,z*sz, 7,4, 6.5,4, 6.6,3.7, 7,3.5,'rgba(128,128,0,1)',1);//left hand

      drawShape('qua',x+sx,y+sy,z*sz, 7,4, 7.4,3.4, 7,3.5, 6.5,3.4,'rgba(128,128,0,1)',1);//left hand
        
      drawShape('tri',x+sx,y+sy,z*sz, 7.4,3.4, 6.5,3.4, 7,3.5, 7.25,1,'rgba(128,128,0,1)',1);//left fingers
      drawShape('qua',x+sx,y+sy,z*sz, 6.6,3.45, 6.75,3.5, 6.75,3.55, 6.6,3.7,'rgba(128,128,0,1)',1);//left thumb

     // drawShape('qua',x+sx,y+sy,z*sz, 5.5,4, 5.5,5.5, 6.1,6, 6,4,'rgba(128,128,0,1)',1);//dress left arm
     // drawShape('qua',x+sx,y+sy,z*sz, 5,4, 4.5,7, 5.5,5.5, 5.5,4,'rgba(128,128,0,1)',1);//dress left mid
     //////
      drawShape('pol',x,y,z, 4.5,3.2, 4.4,4.25, 4.5,6.5, 5,6,'rgba(128,128,0,1)',1,5,3);//brmain
           
      drawShape('pol',x,y,z, 4.25,1.5, 4,1, 4.5,1.75, 4.5,1,'rgba(128,128,0,1)',1,5,1.5);//brmain
      drawShape('pol',x,y,z, 5.75,1.5, 6,1, 5.5,1.75, 5.5,1,'rgba(128,128,0,1)',1,5,1.5);//brmain
      drawShape('pol',x,y,z, 4.25,1.5, 4,1, 4.5,1.75, 4.5,1,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.5)`,1,5,1.5);//brmain
      drawShape('pol',x,y,z, 5.75,1.5, 6,1, 5.5,1.75, 5.5,1,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.5)`,1,5,1.5);//brmain
   
    break;
    case 63: //Dragon
               drawShape('qua',x,y,z,0,5, 5,Math.random()*.2, 10,5, 5,10,`rgba(${128},${128},${0},${.2})`,1,2,10);//lower arm R

    sx = 0*z;
    sy = 4*z;
    sz = .6;
    drawShape('pol',x+sx,y+sy,z*sz,10,0, 8,.5 ,2,5 ,0,8,'rgba(0,32,0,1)',1,0,10);
      drawShape('tri',x+sx,y+sy,z*sz,10,0, 10,5 ,5.5,2 ,0,10,'rgba(0,32,0,1)',1,9,9);

      drawShape('pol',x+sx,y+sy,z*sz,10,5, 8.5,2 ,4,4.45 ,0,10,'rgba(255,255,128,1)',1,9,9);
      drawShape('tri',x+sx,y+sy,z*sz,10,5, 10,7 ,9.5,6 ,0,10,'rgba(255,255,128,1)',1,9,9);
      drawShape('pol',x+sx,y+sy,z*sz,9,9, 10,7 ,9.75,6.25 ,8.75,7.25,'rgba(0,0,0,1)',1,8.75,8.25);
      drawShape('pol',x+sx,y+sy,z*sz,9,9.1, 4.5,9.6 ,5,8.5 ,6,8.25,'rgba(0,0,0,1)',1,8,8.5);
      drawShape('pol',x+sx,y+sy,z*sz,0,10, 4.5,9.7 ,4,9 ,3,8.75,'rgba(0,0,0,1)',1,2,9);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 4.5,5 ,8.5,2 ,5,5,'rgba(0,0,0,.25)',1,2,9);
      drawShape('qua',x+sx,y+sy,z*sz,4.5,9, 5,6 ,8.5,2 ,5.5,6,'rgba(0,0,0,.25)',1,2,9);
      drawShape('qua',x+sx,y+sy,z*sz,9,9, 7.55,6 ,8.5,2 ,8,6,'rgba(0,0,0,.25)',1,2,9);
      drawShape('qua',x+sx,y+sy,z*sz,10,7, 9.5,5 ,8.5,2 ,9.3,5,'rgba(0,0,0,.25)',1,2,9);
      drawShape('tri',x+sx,y+sy,z*sz,0,9.75, 2.25,5 ,0,7 ,6,8.25,'rgba(0,6,13,1)',1,8,8.5);
//tail
        drawShape('pol',x,y,z,3.6,5.8, 3.6,7.5 ,4,7.5 ,4.25,7.25,'rgba(0,32,0,1)',1,3.9,6.9);
        drawShape('pol',x,y,z,6,7.5, 6,8 ,6.5,9 ,5.5,8.5,'rgba(0,32,0,1)',1,5,7);

      sx = -3*z;
      sy = -6.6*z;
      sz = 2.75;
      for (let i=0;i<60;i++){
        drawShape('ell',x+sx-27.75*z,y+sy-27.4*z,z*sz*3,    4.5+i*.001, 4.5+i*.001,        .2+i*.0025,   0.2+i*.003,  0,    1,   .4,    0,   `rgba(${0},${64+i},${0},1)`,0)
        drawShape('ell',x+sx-27.75*z,y+sy-27.37*z,z*sz*3,    4.5+i*.001, 4.5+i*.001,        .2+i*.0025,   0.2+i*.003,  0,    1,   .4,    0,   `rgba(${0},${64+i},${0},1)`,0)

        drawShape('ell',x+sx-28.75*z,y+sy-26.5*z,z*sz*3,    4.5+i*.001, 4.5+i*.001,        .2+i*.0025,   0.2+i*.003,  0,    .1,   .8,    0,   `rgba(${0},${64+i},${0},1)`,0)
        drawShape('ell',x+sx-28.75*z,y+sy-26.51*z,z*sz*3,    4.5+i*.001, 4.5+i*.001,        .2+i*.0025,   0.2+i*.003,  0,    .1,   .8,    0,   `rgba(${0},${64+i},${0},1)`,0)

        
      }
 
  sx = -13*z;
      sy = -13.3*z;
      sz = 3.5;
      for (let i=0;i<60;i++){
       drawShape('ell',x+sx-30.75*z,y+sy-25.5*z,z*sz*3,    4.5+i*.001, 4.5+i*.001,        .2+i*.0025,   0.2+i*.003,  0,    1.2,   -.49,    0,   `rgba(${0},${64+i},${0},1)`,0)

      }
sx =6*z;
    sy = 4*z;
    sz = .4;
    drawShape('pol',x+sx,y+sy,z*sz,0,0, 2,.5 ,8,5 ,10,8,'rgba(0,64,0,.75)',1,10,10);
      drawShape('tri',x+sx,y+sy,z*sz,0,0, 0,5 ,4.5,2 ,10,10,'rgba(0,64,0,.75)',1,1,9);

      drawShape('pol',x+sx,y+sy,z*sz,0,5, 1.5,2 ,6,4.45 ,10,10,'rgba(0,64,0,.75)',1,1,9);
      drawShape('tri',x+sx,y+sy,z*sz,0,5, 0,7 ,0.5,6 ,10,10,'rgba(0,64,0,.75)',1,1,9);
      drawShape('pol',x+sx,y+sy,z*sz,1,9, 0,7 ,0.25,6.25 ,1.25,7.25,'rgba(0,64,0,.75)',1,1.25,8.25);
      drawShape('pol',x+sx,y+sy,z*sz,1,9.1, 5.5,9.6 ,5,8.5 ,4,8.25,'rgba(0,64,0,.75)',1,2,8.5);
      drawShape('pol',x+sx,y+sy,z*sz,10,10, 5.5,9.7 ,6,9 ,7,8.75,'rgba(0,64,0,.75)',1,8,9);
      drawShape('qua',x+sx,y+sy,z*sz,10,10, 5.5,5 ,1.5,2 ,5,5,'rgba(0,64,0,.75)',1,8,9);
      drawShape('qua',x+sx,y+sy,z*sz,5.5,9, 5,6 ,1.5,2 ,4.5,6,'rgba(0,64,0,.75)',1,8,9);
      drawShape('qua',x+sx,y+sy,z*sz,1,9, 2.45,6 ,1.5,2 ,2,6,'rgba(0,64,0,.75)',1,8,9);
      drawShape('qua',x+sx,y+sy,z*sz,0,7, 0.5,5 ,1.5,2 ,0.7,5,'rgba(0,64,0,.75)',1,8,9);
      drawShape('tri',x+sx,y+sy,z*sz,10,9.75, 7.75,5 ,10,7 ,4,8.25,'rgba(0,64,13,.75)',1,2,8.5);
sx = -7.5*z;
      sy = -3.6*z;
      sz = 2;
      for (let i=0;i<60;i++){
        ////////////////////////////
        //floating island top
        // drawShape('ell',x+sx,y+sy,z*sz,    4.5+i*.001, 4.5+i*.001,        .5-i*.005,   0+i*.005,  0,    1,   2,    0,   `rgba(${255},${69-i},${11},1)`,0)
        //floating island botn     
        // drawShape('ell',x+sx,y+sy,z*sz,    4.51+i*.001, 4.4+i*.001,        .49-i*.005,   0+i*.01,  0,    2,   1,    0,   `rgba(${255},${69+i},${11},1)`,0)
        //eclipse
        //drawShape('ell',x+sx,y+sy,z*sz,    4.5+i*.001, 4.75+i*.001,        .2+i*.0025,   0.2+i*.0025,  0,    0,   2,    0,   `rgba(${244},${69+i},${11},1)`,0)
        ///////////////
        //teeth
        drawShape('ell',x+sx,y+sy,z*sz,    4.4+i*.001, 5.69+i*.001,        0+i*.001,   0+i*.002,  0,    .75,   1.5,    0,   `rgba(${255},${255},${255},1)`,0)
        drawShape('ell',x+sx,y+sy,z*sz,    4.67+i*.000005, 5.680+i*.001,        0+i*.001,   0+i*.002,  0,    1.5,   .2,    0,   `rgba(${255},${255},${255},1)`,0)
        //head
        //body
        drawShape('ell',x+sx,y+sy,z*sz,    4.5+i*.001, 5.25+i*.001,        0.2+i*.005,   0+i*.005,  0,    0,   2,    0,   `rgba(${0},${64+i},${0},1)`,0)
        //upper jaw
        drawShape('ell',x+sx,y+sy,z*sz,    4.5+i*.001, 5.5+i*.001,        .5-i*.005,   0+i*.005,  0,    1,   2,    0,   `rgba(${0},${64-i},${0},1)`,0)
        //bottom jaw     
        drawShape('ell',x+sx,y+sy,z*sz,    4.51+i*.001, 5.4+i*.001,        .49-i*.005,   0+i*.01,  0,    2,   1,    0,   `rgba(${0},${64+i},${0},1)`,0)
        //tail
      }
      sx = -7.5*z;
      sy = -3.6*z;
      sz = 2;
      drawShape('pol',x+sx,y+sy,z*sz,    4.55, 5.6,   4.5, 6.3,   4.4,6.4,   4.55,6.3,   `rgba(${128},${0},${0},1)`,1, 4.6,6.5)
      drawShape('ell',x+sx,y+sy,z*sz,    4.8, 5.25,   .2, .15,   0,   1.6,  .5,   0,   `rgba(${255},${255},${128},1)`,1, 4.6,6.5)
      drawShape('ell',x+sx,y+sy,z*sz,    4.3, 5.25,   .2, .15,   0,   .5,  1.4,   0,   `rgba(${255},${255},${128},1)`,1, 4.6,6.5)
      drawShape('ell',x+sx,y+sy,z*sz,    4.86, 5.26,   .05, .12,   0,   -.45,  .25,   0,   `rgba(${0},${0},${0},1)`,1, 4.6,6.5)
      drawShape('ell',x+sx,y+sy,z*sz,    4.21, 5.26,   .05, .12,   0,   .75,  -.5,   0,   `rgba(${0},${0},${0},1)`,1, 4.6,6.5)
   
       drawShape('qua',x,y,z,6,4, 4,5 ,4.5,5.5 ,6,6,'rgba(0,64,0,1)',1,0,10);
       drawShape('pol',x,y,z,4,5, 5,6 ,5.5,7 ,4.5,7.5,'rgba(0,32,0,1)',1,5,6.5);
        drawShape('tri',x,y,z,4,5, 4.5,6 ,5,6.5 ,4.75,8,'rgba(0,32,0,1)',1,5,7);
        
        
        drawShape('pol',x,y,z,7,7.5, 7,8 ,7.5,9 ,6.5,8.5,'rgba(0,32,0,1)',1,6,7);
        drawShape('qua',x,y,z,7.5,8.5, 6.5,9 ,7,9 ,7,9.5,'rgba(0,32,0,1)',1,6,7);
        drawShape('qua',x,y,z,6.5,8.5, 5.5,9 ,6,9 ,6,9.5,'rgba(0,32,0,1)',1,6,7);
        drawShape('qua',x,y,z,4.9,7, 4.5,7 ,4.75,7.25 ,5,7.5,'rgba(0,32,0,1)',1,6,7);
        drawShape('pol',x,y,z,4,7,3.9,6.5 ,4.1,6.9 ,4.3,7,'rgba(0,32,0,1)',1,4,7.5);
        drawShape('pol',x,y,z,1.6+Math.random()*.1,7.6,   1-Math.random()*.75,9+Math.random()*.4 ,       1.6, 10-Math.random()*.3 ,        2.5+Math.random(),9+Math.random()*.3,`rgba(${255},${Math.random()*100},${0},1)`,1,1.6+Math.random()*.3,8.5-Math.random()*.3);
        drawShape('pol',x,y,z,1,6.6, 1.5,6.5 ,1,6 ,.5,6,'rgba(255,255,128,1)',1,1.1,6.25);
        sx= -6.75*z
        drawShape('pol',x+sx,y,z,9,6.6, 8.5,6.5 ,9,6 ,9.5,6,'rgba(255,255,128,1)',1,8.9,6.25);



      break;
    
    case 64: //Ace of Pentacles 
       drawShape('arc',x,y,z,4.8,5,4.5,0,6,0,0,0,'rgba(40,20,0,1)',1);
      drawShape('arc',x,y,z,5,5,4.5,0,6,0,0,0,'rgba(85,43,0,1)',1);
      drawShape('rec',x,y,z,0.5,5,9,.11,0,0,0,0,'rgba(0,0,0,.35)',1)
      drawShape('rec',x,y,z,.95,3,8.1,.11,0,0,0,0,'rgba(0,0,0,.35)',1)
      drawShape('rec',x,y,z,1,7,8,.11,0,0,0,0,'rgba(0,0,0,.35)',1)
      drawShape('qua',x,y,z,5,4,6,5,5,6,4,5,'green',1);
      drawShape('qua',x,y,z,3,1, 7,1.1, 2.8,1.2, 8,2,'rgba(0,0,0,.35)',1);
      drawShape('qua',x,y,z,3-1,1+1, 7-1,1.1+1, 2.8-1,1.2+1, 8-1,2+1,'rgba(0,0,0,.35)',1);
      drawShape('qua',x,y,z,1+3,1+2, 1+7,1.1+2, 1+2.8,1.2+2, 1+8,2+2,'rgba(0,0,0,.35)',1);
      drawShape('qua',x,y,z,1+3,1+5, 1+7,1.1+5, 1+2.8,1.2+5, 1+8,2+5,'rgba(0,0,0,.35)',1);
      drawShape('qua',x,y,z,3,1+6, 7,1.1+6, 2.8,1.2+6, 8,2+6,'rgba(0,0,0,.35)',1);
      drawShape('qua',x,y,z,3-1,1+7, 7-1,1.1+7, 2.8-1,1.2+7, 8-1,2+7,'rgba(0,0,0,.35)',1);
     
        break;
		case 65://Shield Bash 2  
          drawShape('arc',x+sx,y,z,5,5,5,0,6,0,0,0,'rgba(0,255,0,.15)',1);//glow

       
      sx = -3.6*z
      //face
      drawShape('pol',x+sx,y,z,7.425,.52, 7.6,1 ,8,1.1 ,7.75,1.75,'rgb(255,128,64)',1,7,2);
      drawShape('qua',x+sx,y,z,7.426,.52, 7,2.1 ,6.5,1.5 ,6.5,1,'rgb(255,128,64)',1,7,2);
      drawShape('qua',x+sx,y,z,7.75,1.75,8,2 ,7.2,2.25 ,6.9,2,'rgb(255,128,64)',1,7,2);
      
      drawShape('qua',x+sx,y,z,7.75,1.75,8,2 ,7.2,2.25 ,6.9,2,'rgb(255,128,64)',1,7,2);
      //head
      sx = 0;
      drawShape('qua',x+sx,y,z,1.4,4, 2.5,5.5 ,2.5,4.9 ,1.9,3.9,'rgba(255,255,255,.1)',1);
      drawShape('pol',x+sx,y,z,2.5,5, 4.25,6.25 ,5.5,8 ,4,7,'rgba(255,255,255,1)',1,2.5,5.5);
      drawShape('tri',x+sx,y,z,2.25,5.75, 3,5 ,2.5,5.75 ,4,7,'rgba(255,255,0,1)',1,2.5,5.5);
      sx = -3.6*z
      drawShape('qua',x+sx,y,z,5,2, 5,4 ,5.5,4 ,6,3,'rgba(255,255,255,.1)',1);
      drawShape('qua',x+sx,y,z,6.5,1.5, 6.5,1 ,7.5,.5 ,6,1,'rgba(255,255,255,.1)',1);
      drawShape('qua',x+sx,y,z,7,2.5, 7.2,2.3 ,6.75,1.75 ,6,1,'rgba(255,255,255,.1)',1);
      drawShape('qua',x+sx,y,z,6,1, 6.5,.5 ,7,.5 ,7.5,.5,'rgba(255,255,255,.1)',1);
      drawShape('qua',x+sx,y,z,7,2.5, 7.5,2.6 ,8,2 ,7.25,2.25,'rgba(255,255,255,.1)',1);
      drawShape('qua',x+sx,y,z,7,2.5, 6.5,2.4 ,6,1.5 ,6,1,'rgba(255,255,255,.1)',1);

      
    	//drawShape('qua',x+sx,y,z,5,2, 9,3 ,8,6 ,6.5,5.5,'rgb(252,255,255)',1);
    	//drawShape('qua',x+sx,y,z,8,6, 8.5,9.5 ,5,8 ,6.5,5,'rgb(255,255,255)',1);
    	//bdoy
      //right shoulder
      drawShape('tri',x+sx,y,z,8,3, 8.5,4.5 ,9,3 ,9,3,'rgba(0,0,0,.5)',1);
      //left shoulder
      drawShape('tri',x+sx,y,z,6.5,2.4, 5,2 ,6,3 ,9,3,'rgba(0,0,0,.5)',1);
      //back outline
      drawShape('tri',x+sx,y,z,6,3, 6.5,5 ,5,8 ,9,3,'rgba(0,0,0,.5)',1);

      //upper arm right
      drawShape('tri',x+sx,y,z,9,3, 9,5.5 ,8.5,4.5 ,9,3,'rgba(255,255,255,.1)',1);
      //forearm right left half
      drawShape('qua',x+sx,y,z,9,5.5, 9.45,5 ,9.5,3 ,9,4.5,'rgba(255,255,255,.1)',1);
      //right leg
      drawShape('qua',x+sx,y,z,8,6, 9,8 ,8,10 ,7.5,10,'rgba(255,255,255,.1)',1);
      //left thigh
      drawShape('tri',x+sx,y,z,5,8, 6.5,8 ,5,10 ,4.5,10,'rgba(255,255,255,.1)',1);
      //left calf
      drawShape('tri',x+sx,y,z,5,8, 4.25,10 ,5,10 ,4.5,10,'rgba(255,255,255,.1)',1);
      //inside lining of cape (by right thigh and elbow)
      drawShape('tri',x+sx,y,z,8.5,4.5, 8.5,7 ,8,6 ,5,8.1,'rgba(255,255,255,.3)',1);
      //forearm right, right half
      drawShape('qua',x+sx,y,z,9.5,3, 9.9,3 ,9.6,4.5 ,9.45,5,'rgba(255,255,255,.1)',1);

      //belt
      drawShape('tri',x+sx,y,z,6.25,5, 8,6 ,6.3,5.25 ,6,1,'rgba(64,0,0,.6)',1);
      drawShape('tri',x+sx,y,z,8,5.75, 8,6 ,6.3,5.25 ,6,1,'rgba(64,0,0,.6)',1);
     if(Math.random()<.0025){sx = Math.random()+3*z
      	drawShape('rec',x+sx,y,z,2,1,3,5,0,0,0,0,'gray',1);
			drawShape('tri',x+sx,y,z,2,6,5.1,9,5,1,0,0,'gray',1);
		
	    sx2 = 7*z;
      sy2 = 3.25*z;
      sz2 = .35;
      const cx2 = 5*Math.random()*.4, cy2 = 5*Math.random()*.4;      // center in your 10x10 local grid
      const R2  = 3.2+(Math.random()+Math.random()*2);            // outer radius (long points)
      const r2  = 1.6+(Math.random()+Math.random()*2);            // inner radius (between points)
      const N2  = 8*(Math.random()+Math.random()*2);
      const pts2 = [];

      // build 16 vertices (outer/inner alternating), start at top
      for (let k = 0; k < 2*N2; k++) {
        const ang2 = -Math.PI/2 + k * (Math.PI / N2);   // 22.5 steps
        const rad2 = (k % 2 === 0) ? R2 : r2;
        pts2.push([cx2 + rad2 * Math.cos(ang2), cy2 + rad2 * Math.sin(ang2)]);
      }

      // filled star (triangle fan from center)
      for (let k = 0; k < pts2.length; k++) {
        const k2 = (k + 1) % pts2.length;
        drawShape('tri', x+sx2, y+sy2, z*sz2, cx2, cy2, pts2[k][0], pts2[k][1], pts2[k2][0], pts2[k2][1], 0, 0, `rgba(255,255,0,${1-Math.random()*.3})`, 1);
      }


     }else{sx = 2*z
      	drawShape('rec',x+sx,y,z,2,1,3,5,0,0,0,0,'gray',1);
			drawShape('tri',x+sx,y,z,2,6,5.1,9,5,1,0,0,'gray',1);
		
     }
      
					drawShape('tri',x,y,z,3.2,1.3, 3.51,1, 3.3,1.4,0,0,'rgba(0,0,0,.2)',1);
					drawShape('tri',x,y,z,3.7,.9, 4,1, 3.5,1,0,0,'rgba(0,0,0,.2)',1);
					drawShape('tri',x,y,z,3.5,1, 3.9,1.5, 3.6,1.5,0,0,'rgba(0,0,0,.2)',1);
					drawShape('tri',x,y,z,3.65,2, 3.75,1.75, 4,1.75,0,0,'rgba(0,0,0,.2)',1);

      
      break;
    case 66: //Armor 3  
      drawShape('arc',x+sx,y,z,5,5,5,0,6,0,0,0,'rgba(0,255,0,.05)',1);//glow
     sx = -2*z;
     sy = -1.32*z;
     sz = 1.4;
      //upper chest
      drawShape('qua',x+sx,y+sy,z*sz,3,2, 7,2, 6.5,4, 5.5,6,'rgba(255,255,255,1)',1);
      drawShape('qua',x+sx,y+sy,z*sz,7,2, 3,2, 3.5,4, 4.5,6,'rgba(255,255,255,1)',1);
      drawShape('qua',x+sx,y+sy,z*sz,3,2, 7,2, 6.5,4, 5.5,6,'rgba(0,0,0,.4)',1);
      drawShape('qua',x+sx,y+sy,z*sz,7,2, 3,2, 3.5,4, 4.5,6,'rgba(0,0,0,.4)',1);
      //left shoulder
      drawShape('qua',x+sx,y+sy,z*sz,3,2, 2.5,1.5, 1.5,2.5, 3,3,'rgba(255,255,255,1)',1);
      drawShape('qua',x+sx,y+sy,z*sz,3,2, 2.5,1.5, 1.5,2.5, 3,3,'rgba(0,0,0,.4)',1);
      drawShape('qua',x+sx,y+sy,z*sz,3,2, 2.5,1.75, 1.5,2.5, 3,3,'rgba(0,0,0,.4)',1);

      //right shoulder   
      drawShape('qua',x+sx,y+sy,z*sz,7,2, 7.5,1.5, 8.5,2.5, 7,3,'rgba(255,255,255,1)',1);
      drawShape('qua',x+sx,y+sy,z*sz,7,2, 7.5,1.5, 8.5,2.5, 7,3,'rgba(0,0,0,.4)',1);
      drawShape('qua',x+sx,y+sy,z*sz,7,2, 7.5,1.75, 8.5,2.5, 7,3,'rgba(0,0,0,.4)',1);

      //left hip armor
      drawShape('qua',x+sx,y+sy,z*sz,4.5,6, 4,7, 3,7.5, 4,5,'rgba(255,255,255,1)',1);
      drawShape('qua',x+sx,y+sy,z*sz,4.5,6, 4,7, 3,7.5, 4,5,'rgba(0,0,0,.45)',1);
      //right hip armor
      drawShape('qua',x+sx,y+sy,z*sz,5.5,6, 6,7, 7,7.5, 6,5,'rgba(255,255,255,1)',1);
      drawShape('qua',x+sx,y+sy,z*sz,5.5,6, 6,7, 7,7.5, 6,5,'rgba(0,0,0,.45)',1);
      //groin armor
      drawShape('qua',x+sx,y+sy,z*sz,5,5.19, 4.5,6, 5,7, 5.5,6,'rgba(255,255,255,1)',1);
      drawShape('qua',x+sx,y+sy,z*sz,5,5.19, 4.5,6, 5,7, 5.5,6,'rgba(0,0,0,.4)',1);
      //Neck area
      drawShape('pol',x+sx,y+sy,z*sz,4,2, 4.5,2.5, 5,2.7, 5.5,2.5,'rgba(0,0,0,.5)',1,6,2);
//////////////////////////////////////////////////////////////////
//upper chest
      drawShape('qua',x+sx,y+sy,z*sz,3,2, 7,2, 6.5,4, 5.5,6,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},${Math.random()*.2})`,1);
      drawShape('qua',x+sx,y+sy,z*sz,7,2, 3,2, 3.5,4, 4.5,6,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},${Math.random()*.2})`,1);

      //left shoulder
      drawShape('qua',x+sx,y+sy,z*sz,3,2, 2.5,1.5, 1.5,2.5, 3,3,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},${Math.random()*.2})`,1);
 
      //right shoulder   
      drawShape('qua',x+sx,y+sy,z*sz,7,2, 7.5,1.5, 8.5,2.5, 7,3,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},${Math.random()*.2})`,1);
   
      //left hip armor
      drawShape('qua',x+sx,y+sy,z*sz,4.5,6, 4,7, 3,7.5, 4,5,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},${Math.random()*.2})`,1);
      //right hip armor
      drawShape('qua',x+sx,y+sy,z*sz,5.5,6, 6,7, 7,7.5, 6,5,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},${Math.random()*.2})`,1);
      //groin armor
      drawShape('qua',x+sx,y+sy,z*sz,5,5.19, 4.5,6, 5,7, 5.5,6,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},${Math.random()*.2})`,1);
      //Neck area
    //Neck area
      drawShape('pol',x+sx,y+sy,z*sz,4,2, 4.5,2.5, 5,2.7, 5.5,2.5,'rgba(0,0,0,.5)',1,6,2);

			break;
    case 67://Dragon Hoard 4 
      drawShape('pol',x,y,z,5,3.5, 0,7, 0,10, 10,10,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},${Math.random()*.5})`,1,10,7);

      drawShape('pol',x,y,z,5,3.5, 0,7, 0,10, 10,10,`rgba(${255},${255},${0},.75)`,1,10,7);

  drawShape('arc',x,y,z,5,5,5,0,2,0,0,0,'rgba(255,255,255,.05)',1);

        //lamp
        sx = 0*z;
        sy = -6.13*z;
        sz = 1;

      drawShape('pol',x+sx,y+sy,z*sz, 3.6,9.36, 4,9.45, 4.5,9.5, 5,9.25,'rgba(255,201,14,.65)',1, 4.9,10);//upper arm R
      drawShape('pol',x+sx,y+sy,z*sz,5.6,9.5, 6,9.45, 5.5,9.5, 5,9.25,'rgba(255,201,14,.65)',1, 5.1,10);//upper arm R
        drawShape('pol',x+sx,y+sy,z*sz,4.6,10, 4.9,9.9, 5,9.25, 5.1,9.9,'rgba(255,201,14,.75)',1, 5.4,10);//upper arm R
        drawShape('pol',x+sx,y+sy,z*sz,5.5,9.5, 5.6,9.4, 5.8,9.5, 5.75,9.75,'rgba(255,201,14,.75)',1, 5.6,9.7);//upper arm R
        drawShape('arc',x+sx,y+sy,z*sz,5.65,9.57,.069,0,6,0,0,0,'rgba(0,0,0,.9)',1);//head

       sx =4*z;
     sy = 6*z;
     sz = .45;
      //upper chest
      drawShape('qua',x+sx,y+sy,z*sz,3,2, 7,2, 6.5,4, 5.5,6,'rgba(255,255,255,1)',1);
      drawShape('qua',x+sx,y+sy,z*sz,7,2, 3,2, 3.5,4, 4.5,6,'rgba(255,255,255,1)',1);
      drawShape('qua',x+sx,y+sy,z*sz,3,2, 7,2, 6.5,4, 5.5,6,'rgba(0,0,0,.4)',1);
      drawShape('qua',x+sx,y+sy,z*sz,7,2, 3,2, 3.5,4, 4.5,6,'rgba(0,0,0,.4)',1);
      //left shoulder
      drawShape('qua',x+sx,y+sy,z*sz,3,2, 2.5,1.5, 1.5,2.5, 3,3,'rgba(255,255,255,1)',1);
      drawShape('qua',x+sx,y+sy,z*sz,3,2, 2.5,1.5, 1.5,2.5, 3,3,'rgba(0,0,0,.4)',1);
      drawShape('qua',x+sx,y+sy,z*sz,3,2, 2.5,1.75, 1.5,2.5, 3,3,'rgba(0,0,0,.4)',1);

      //right shoulder   
      drawShape('qua',x+sx,y+sy,z*sz,7,2, 7.5,1.5, 8.5,2.5, 7,3,'rgba(255,255,255,1)',1);
      drawShape('qua',x+sx,y+sy,z*sz,7,2, 7.5,1.5, 8.5,2.5, 7,3,'rgba(0,0,0,.4)',1);
      drawShape('qua',x+sx,y+sy,z*sz,7,2, 7.5,1.75, 8.5,2.5, 7,3,'rgba(0,0,0,.4)',1);

      //left hip armor
      drawShape('qua',x+sx,y+sy,z*sz,4.5,6, 4,7, 3,7.5, 4,5,'rgba(255,255,255,1)',1);
      drawShape('qua',x+sx,y+sy,z*sz,4.5,6, 4,7, 3,7.5, 4,5,'rgba(0,0,0,.45)',1);
      //right hip armor
      drawShape('qua',x+sx,y+sy,z*sz,5.5,6, 6,7, 7,7.5, 6,5,'rgba(255,255,255,1)',1);
      drawShape('qua',x+sx,y+sy,z*sz,5.5,6, 6,7, 7,7.5, 6,5,'rgba(0,0,0,.45)',1);
      //groin armor
      drawShape('qua',x+sx,y+sy,z*sz,5,5.19, 4.5,6, 5,7, 5.5,6,'rgba(255,255,255,1)',1);
      drawShape('qua',x+sx,y+sy,z*sz,5,5.19, 4.5,6, 5,7, 5.5,6,'rgba(0,0,0,.4)',1);
      //Neck area
      drawShape('pol',x+sx,y+sy,z*sz,4,2, 4.5,2.5, 5,2.7, 5.5,2.5,'rgba(0,0,0,.5)',1,6,2);
//////////////////////////////////////////////////////////////////
//upper chest
      drawShape('qua',x+sx,y+sy,z*sz,3,2, 7,2, 6.5,4, 5.5,6,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},${Math.random()*.2})`,1);
      drawShape('qua',x+sx,y+sy,z*sz,7,2, 3,2, 3.5,4, 4.5,6,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},${Math.random()*.2})`,1);

      //left shoulder
      drawShape('qua',x+sx,y+sy,z*sz,3,2, 2.5,1.5, 1.5,2.5, 3,3,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},${Math.random()*.2})`,1);
 
      //right shoulder   
      drawShape('qua',x+sx,y+sy,z*sz,7,2, 7.5,1.5, 8.5,2.5, 7,3,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},${Math.random()*.2})`,1);
   
      //left hip armor
      drawShape('qua',x+sx,y+sy,z*sz,4.5,6, 4,7, 3,7.5, 4,5,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},${Math.random()*.2})`,1);
      //right hip armor
      drawShape('qua',x+sx,y+sy,z*sz,5.5,6, 6,7, 7,7.5, 6,5,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},${Math.random()*.2})`,1);
      //groin armor
      drawShape('qua',x+sx,y+sy,z*sz,5,5.19, 4.5,6, 5,7, 5.5,6,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},${Math.random()*.2})`,1);
      //Neck area
    //Neck area
      drawShape('pol',x+sx,y+sy,z*sz,4,2, 4.5,2.5, 5,2.7, 5.5,2.5,'rgba(0,0,0,.5)',1,6,2);
  //tomearc
      sx = 1.5*z;
      sy = 5*z;
      sz = .2;
      drawShape('qua',x+sx,y+sy,z*sz,0,7.5,10,7.5,7.5,2.5,2.5,2.5,'rgba(128,64,0,1)',1);
			drawShape('qua',x+sx,y+sy,z*sz,.2,7.1,9.8,7.1,7.5,2.5,2.5,2.5,'rgba(255,255,128,1)',1);
			drawShape('lin',x+sx,y+sy,z*sz,5,7.5,5,2.5,0,0,0,0,'rgba(128,64,0,.85)',1);
			drawShape('arc',x+sx,y+sy,z*sz,3.75,3.8,1.79,1.25,1.75,0,0,0,'rgba(255,255,128,1)',1);
			drawShape('arc',x+sx,y+sy,z*sz,6.25,3.8,1.79,1.25,1.75,0,0,0,'rgba(255,255,128,1)',1);
      drawShape('qua',x+sx,y+sy,z*sz,4.77,7.2, 4.9,2.4, 4,6, 4.488,6.51,'rgba(0,0,0,.1)',1);
      drawShape('qua',x+sx,y+sy,z*sz,5.188,7.2, 5.1,2.4, 6,6, 5.512,6.51,'rgba(0,0,0,.1)',1);
			drawShape('arc',x+sx,y+sy,z*sz,2.5,7.9,2.4,1.1,1.9,0,0,0,'rgba(248,179,16,.85)',1);
			drawShape('arc',x+sx,y+sy,z*sz,7.5,7.9,2.4,1.1,1.9,0,0,0,'rgba(248,179,16,.85)',1);
      for (let i = 0;i<40;i++){
        drawShape('arc',x+sx,y+sy,z*sz,2.5,7.89, 2.39-i*.05,1.1,1.9,0,0,0,'rgba(0,0,0,.25)',0);
			  drawShape('arc',x+sx,y+sy,z*sz,7.5,7.89, 2.39-i*.05,1.1,1.9,0,0,0,'rgba(0,0,0,.25)',0);
      }
      drawShape('rec',x+sx,y+sy,z*sz,0.2,7.13,9.6,.35,0,0,0,0,'rgb(128,64,0)',1);
      drawShape('pol',x+sx,y+sy,z*sz,4.75,7.1, 4.9,2.42, 5.1,2.42, 5.2,7.2,'rgba(0,0,0,.45)',1, 5,7.1);
      
      //sword pommel
      sx = 1.75*z;
      sy = 4.83*z;
      sz = .4;
      drawShape('arc',x+sx,y+sy,z*sz,.5,8.25, .3,.3, 0,2  ,0,0,'gold',1);//sword-pommel
      drawShape('arc',x+sx,y+sy,z*sz,.5,8.25, .3,.3, 0,2  ,0,0,'rgba(0,0,0,.3)',1);//sword-pommel
      drawShape('ell',x+sx,y+sy,z*sz,.5,8.15, .2,.13, 0, 2  ,0 ,0,'rgba(128,0,0,1)',1);//sword-pommel
      drawShape('arc',x+sx,y+sy,z*sz,.45,8.3, .275,0, 2,2  ,0,0,'rgba(0,0,0,.15)',1);//sword-pommel
      drawShape('arc',x+sx,y+sy,z*sz,.5,8.25, .3,.2, .95, 0  ,0 ,0,'rgba(0,0,0,.24)',1);//sword-pommel
      drawShape('arc',x+sx,y+sy,z*sz,.5,8.25, .3,0, 1.2, 0  ,0 ,0,'rgba(0,0,0,.24)',1);//sword-pommel

      //sword
      sx = 1*z;
      sy = 6.03*z;
      sz = .375;
      drawShape('qua',x+sx,y+sy,z*sz,4.1,5.5, 4.1,5.8, 2.8,5.81, 2.8,5.5,'gold',1);//sword-handle
      drawShape('qua',x+sx,y+sy,z*sz,4.1,5.9, 4.1,6,   2.8,5.81, 2.8,5.7,'rgba(0,0,0,.4)',1);//sword-handle
      drawShape('qua',x+sx,y+sy,z*sz,4.1,5.7, 4.1,5.8, 2.8,5.81, 2.8,5.5,'rgba(0,0,0,.4)',1);//sword-handle
			drawShape('tri',x+sx,y+sy,z*sz,9,5.8, 4.1,5.35, 3.9,6.15  ,0,0,'white',1);//sword-blade
      drawShape('tri',x+sx,y+sy,z*sz,9,5.8, 4.1,5.5,  3.9,5.8  ,0,0,'rgba(0,0,0,.15)',1);//sword-blade
			drawShape('tri',x+sx,y+sy,z*sz,9,5.8, 4.1,5.35, 3.9,6.1  ,0,0,'rgba(0,0,0,.15)',1);//sword-blade
			drawShape('tri',x+sx,y+sy,z*sz,9,5.8, 4.1,5.45, 3.9,6.15  ,0,0,'rgba(0,0,0,.15)',1);//sword-blade
			drawShape('qua',x+sx,y+sy,z*sz,4.2,4.5, 4.1,5.7, 3.7,6.8, 3.6,6,'gold',1);//sword-crossguard
      drawShape('qua',x+sx,y+sy,z*sz,4.2,4.5, 3.8,5.7, 3.7,6.8, 3.6,6,'rgba(0,0,0,.4)',1);//sword-crossguard
			drawShape('qua',x+sx,y+sy,z*sz,4.2,4.5, 4.1,5.7, 3.7,6.8, 3.6,6,'rgba(0,0,0,.4)',1);//sword-crossguard

      //potion
      sx = 8*z;
      sy = 8.5*z;
      sz = .15;
      drawShape('qua',x+sx,y+sy,z*sz, 4.4,0.75, 5.6,0.75, 5.25,2.45, 4.75,2.45,'rgba(186,103,0,1)',1)//cork
      drawShape('qua',x+sx,y+sy,z*sz, 4.4,0.75, 5.6,0.75, 5.25,.9, 4.75,.9,'rgba(255,255,255,.1)',1)//cork
      drawShape('qua',x+sx,y+sy,z*sz, 4.4,0.75, 4.5,0.75, 5.25,2.45, 4.75,2.45,'rgba(0,0,0,.40)',1)//cork
      drawShape('qua',x+sx,y+sy,z*sz, 3.95,3.449, 6.0456,3.4488, 5.5,1.25, 4.5,1.25,'rgba(249,255,255,.28)',1);//bottleneck
      drawShape('qua',x+sx,y+sy,z*sz, 3.95,3.449, 6.0456,3.4488, 5.5,1.25, 4.5,1.25,'rgba(0,0,0,.28)',1);//bottleneck
      drawShape('arc',x+sx,y+sy,z*sz,5,6.38,  2.8,  1.667,1.337,0,0,0,'rgba(255,0,0,1)',1);//liquid
      drawShape('arc',x+sx,y+sy,z*sz,5,6.25,  3,  1.6163,1.3836,0,0,0,'rgba(249,255,255,.28)',1);//bottle
      drawShape('arc',x+sx,y+sy,z*sz,5,6.25,  3,  1.6163,1.3836,0,0,0,'rgba(0,0,0,.28)',1);//bottle
      drawShape('ell',x+sx,y+sy,z*sz,5,3.95, 1.4,.3, 1, 1,2,0,'rgba(0,0,0,.2)',1);//surface liquid
      drawShape('ell',x+sx,y+sy,z*sz,6.3,5.44, .55,.35, 1, 0,2,0,'rgba(255,255,255,.8)',1);//reflection
      
      	sx = 0 *z;
      sy = 5*z;
      sz = .5;
      drawShape('arc',x+sx,y+sy,z*sz,9,1,.8,0,6,0,0,0,'magenta',1);//bag
      drawShape('arc',x+sx,y+sy,z*sz,8.95,.95,.75,0,6,0,0,0,'rgba(255,255,255,.15)',1);//bag
      drawShape('arc',x+sx,y+sy,z*sz,8.9,1,.7,0,6,0,0,0,'rgba(255,255,255,.15)',1);//bag
      drawShape('arc',x+sx,y+sy,z*sz,8.85,1,.65,0,6,0,0,0,'rgba(255,255,255,.15)',1);//bag
      drawShape('arc',x+sx,y+sy,z*sz,8.8,1,.6,0,6,0,0,0,'rgba(255,255,255,.15)',1);//bag
		         sz = 1;
      sx = 3*z;
      sy=2*z;
      drawShape('lin',x+sx,y+sy,z*sz,4.5,3.5, 5,4.5, 0,0, 0,0,'rgb(255,126,60)',0);//string
      drawShape('lin',x+sx,y+sy,z*sz,5.5,4, 5,4.5, 0,0, 0,0,'rgb(255,126,60)',0);//string
      drawShape('arc',x+sx,y+sy,z*sz,5,4.6,.13,0,6,0,0,0,'darkred',1);//amulet
      drawShape('arc',x+sx,y+sy,z*sz,5,4.6,.1,0,6,0,0,0,'red',1);//amulet
		

        break;
    case 68://Bad Luck Charm 5  
         drawShape('arc',x,y,z,5,5,5,0,2,0,0,0,'rgba(0,64,0,.16)',1);//bag
 	  drawShape('qua',x,y,z,5-Math.random(),1-Math.random(), 8,7+Math.random() ,7-Math.random(),1+Math.random() ,6+Math.random(),8+Math.random(),'rgba(128,6,13,1)',1,9,9);
    
      drawShape('qua',x,y,z,2-Math.random(),3.5-Math.random(), 6-Math.random(),8.5+Math.random() ,4-Math.random(),3.5-Math.random() ,4,9.5+Math.random(),'rgba(128,6,13,1)',1,9,9);

         sx = -12*z;
      sy = -13.6*z;
      sz = 3;
         for (let i=0;i<5;i++){
      drawShape('ell',x+sx,y+sy,z*sz,5,5.25,.1-i*.01,.1-i*.01,0,2,0,0,'lightgray',0)
drawShape('ell',x+sx,y+sy,z*sz,5,5.26,.1-i*.01,.1-i*.01,0,2,0,0,'lightgray',0)
drawShape('ell',x+sx,y+sy,z*sz,5,5.265,.1-i*.01,.1-i*.01,0,2,0,0,'lightgray',0)

     }
   
			sx = -31 *z;
      sy = 1*z;
      sz = 4;
      drawShape('arc',x+sx,y+sy,z*sz,9,1,.8,0,6,0,0,0,'magenta',1);//bag
      drawShape('arc',x+sx,y+sy,z*sz,8.95,.95,.75,0,6,0,0,0,'rgba(255,255,255,.15)',1);//bag
      drawShape('arc',x+sx,y+sy,z*sz,8.9,1,.7,0,6,0,0,0,'rgba(255,255,255,.15)',1);//bag
      drawShape('arc',x+sx,y+sy,z*sz,8.85,1,.65,0,6,0,0,0,'rgba(255,255,255,.15)',1);//bag
      drawShape('arc',x+sx,y+sy,z*sz,8.8,1,.6,0,6,0,0,0,'rgba(255,255,255,.15)',1);//bag
		        
      drawShape('pol',x,y,z,6.25,8.75, 7,8.75, 7.75,8.75, 8.25,7.75,'rgba(255,0,128,.25)',1,8.5,7);

      drawShape('qua',x,y,z,7.5,7.5, 8,7.5, 8.5,7, 7.5,7.3,'rgba(255,0,128,1)',1);
      drawShape('qua',x,y,z,7,8, 6.5,8, 6.25,8.75, 7,8.5,'rgba(255,0,128,1)',1);
      drawShape('tri',x,y,z,7,8, 8,9, 7.5,7.5, 5.5,6,'rgba(255,0,128,1)',1);
      sx = .8 *z;
      sy = 1.7*z;
      drawShape('tri',x+sx,y+sy,z,1.5,1.5, 3,2.5, 1.7,1.5, 5.5,6,'rgba(0,0,0,1)',1);
      drawShape('tri',x+sx,y+sy,z,1.5,2.5, 2.5,1.5, 1.7,2.4, 5.5,6,'rgba(0,0,0,1)',1);
      sx = 0 *z;
      sy = 1*z;
      drawShape('tri',x+sx,y+sy,z,5.5,1, 4,2, 5.3,1, 4.5,6,'rgba(0,0,0,1)',1);
      drawShape('tri',x+sx,y+sy,z,5.5,2, 4.5,1, 5.3,1.9, 5.5,6,'rgba(0,0,0,1)',1);

        drawShape('ell',x,y,z,4.1,3.9, 2,2, 0,1.9,.7,0,'rgba(0,0,0,1)',1);//bag
      
      drawShape('tri',x,y,z,2.96,5.49, 4,5.51,  4,4.7,     5.5,6,'rgba(255,0,128,1)',1);
      drawShape('tri',x,y,z,3.95,4.75, 5,5 ,5,4, 5.5,6,'rgba(255,0,128,1)',1);
      drawShape('tri',x,y,z,5,4, 6,4 ,6,3.25, 5.5,6,'rgba(255,0,128,1)',1);
      
      drawShape('tri',x,y,z,2.96,5.49, 4,5.51,  4,4.7, 5.5,6,'rgba(255,255,255,.55)',1);
      drawShape('tri',x,y,z,3.95,4.75, 5,5 ,5,4, 5.5,6,'rgba(255,255,255,.55)',1);
      drawShape('tri',x,y,z,5,4, 6,4 ,6,3.25, 5.5,6,'rgba(255,255,255,.55)',1);

      drawShape('qua',x,y,z,6,8,7.5,7 ,7.5,7.5, 7,8,'rgba(64,0,64,1)',1);

        break;
    case 69://Charity 6   
      sx = 2*z;
      drawShape('arc',x,y,z,5,5,5,0,2,0,0,0,'rgba(0,64,0,.25)',1);
      drawShape('qua',x+sx,y,z,8,6, 5,4, 5,6, 8,10,'gray',1);
      sx = -4.25*z;
      sy = -6*z
      sz = 1.25;
      drawShape('qua',x+sx,y+sy,z*sz,9,8, 7,9.5, 6,8, 7.5,7.5,'rgb(255,187,119)',1);
      drawShape('qua',x+sx,y+sy,z*sz,7,9.5, 6,8, 8,8, 7.75,8.75,'rgba(0,0,0,.55)',1);
      //drawShape('ell',x,y,z,7.65,4.5, 2.8,2, 0,.65,-.19,.5,'rgb(255,187,119)',1);
      // drawShape('ell',x,y,z,7,6.5, .75,2, 0,-.05,.5,.5,'rgba(0,0,0,.25)',1);
			drawShape('arc',x,y,z,4.5,6,.5,0,2,0,0,0,'rgba(255,255,0,1)',1);

      sx = 2*z;
      drawShape('tri',x+sx,y,z,5,5, 5,6, 4.25,4.75, 8,6,'rgb(255,187,119)',1);
			drawShape('tri',x+sx,y,z,5,4, 5,5, 4.25,4.75, 8,6,'rgb(255,187,119)',1);
			
      drawShape('tri',x+sx,y,z,5,4, 4.2,4.6, 4.25,4.75, 8,6,'rgb(255,187,119)',1);
			
      drawShape('tri',x+sx,y,z,5,4, 4.2,4.6, 4.25,4.75, 8,6,'rgba(0,0,0,.25)',1);
      sx = 2.25*z;
      sy = 0-.25*z
      sz = 1;
      drawShape('pol',x+sx,y+sy,z*sz,1.25,4, 1,5, 1.5,5.5, 2.5,5.9,'rgba(255,187,119,.5)',1,1.5,5);

      sx = 2.25*z;
      sy = 0*z
      sz = 1;
      drawShape('pol',x+sx,y+sy,z*sz,1.25,4, 1,5, 1.5,5.5, 2.5,5.9,'rgba(255,187,119,.75)',1,1.5,5);
      sx = 2*z;
      drawShape('pol',x+sx,y,z,1.25,4, 1,5, 1.5,5.5, 2.5,5.9,'rgb(255,187,119)',1,1.5,5);
      drawShape('pol',x+sx,y,z,2.5,5.9, 2.4,5.75, 2.5,5.5, 3.5,4.9,'rgb(255,187,119)',1,3.7,4);
      drawShape('pol',x+sx,y,z,2.5,5.9, 3,5.5, 4,4, 3,4,'rgb(255,187,119)',1,3,4.75);
      drawShape('qua',x+sx,y,z,1.5,4.5, 1.5,4, 1.25,4, 1.25,4.5,'rgb(255,187,119)',1,3,4.75);
      drawShape('pol',x+sx,y,z,3,3.75, 1.5,4.2, 1.6,4.25, 1.5,4.45,'rgba(255,187,119,.45)',1,3,4.2);
      drawShape('pol',x+sx,y,z,3,3.95, 1.5,4.4, 1.6,4.45, 1.5,4.65,'rgba(255,187,119,.45)',1,3,4.4);

      drawShape('pol',x+sx,y,z,3,3.5, 1.5,4, 1.6,4.5, 2,4.25,'rgb(255,187,119)',1,3,4);
      //drawShape('pol',x,y,z,8,6, 9,6.5, 9.5,7, 10,7.25,'rgba(255,255,255,.095)',1,10,10);
      //drawShape('pol',x,y,z,8,6, 8,10, 10,10, 10,9,'rgba(255,255,255,.095)',1,8,6);

      ////////////////////////////////////////////////////////////

     let charityx = -2.5*z;
     let charityy = 2.5*z;
      drawShape('qua',x,y,z,0,10, 5,8.85, 4.5,8, 0,8.3,'rgb(255,187,119)',1);
      sx = charityx+-6.25*z;
      sy = charityy+-6*z
      sz = 1.25;
    //  drawShape('qua',x+sx,y+sy,z*sz,1,2, 3,0.5, 4,2, 2.5,2.5,'rgb(255,187,119)',1);
    //  drawShape('qua',x+sx,y+sy,z*sz,3,0.5, 4,2, 2,2, 2.25,1.25,'rgba(0,0,0,.55)',1);
      sx = charityx+-3.25*z;
      sy = -6*z
    drawShape('tri',x+sx,y+sy,z,5,5, 5,4, 5.75,5.25, 2,4,'rgb(255,187,119)',1);
      drawShape('tri',x+sx,y+sy,z,5,6, 5,5, 5.75,5.25, 2,4,'rgb(255,187,119)',1);
      drawShape('tri',x+sx,y+sy,z,5,6, 5.8,5.4, 5.75,5.25, 2,4,'rgb(255,187,119)',1);
      drawShape('tri',x+sx,y+sy,z,5,6, 5.8,5.4, 5.75,5.25, 2,4,'rgba(0,0,0,.25)',1);
      sx = charityx+.25*z;
      sy = charityy+0-.25*z
      sz = 1;
      drawShape('pol',x+sx,y+sy,z*sz,8.75,6, 9,5, 8.5,4.5, 7.5,4.1,'rgba(255,187,119,.5)',1,8.5,5);

      sx = charityx+.25*z;
      sy = charityy+0*z
      sz = 1;
      drawShape('pol',x+sx,y+sy,z*sz,8.75,6, 9,5, 8.5,4.5, 7.5,4.1,'rgba(255,187,119,.75)',1,8.5,5);
sx = charityx+0*z;
      sy = charityy+0*z
      sz = 1;
      drawShape('pol',x+sx,y+sy,z,8.75,6, 9,5, 8.5,4.5, 7.5,4.1,'rgb(255,187,119)',1,8.5,5);
      drawShape('pol',x+sx,y+sy,z,7.5,4.1, 7.6,4.25, 7.5,4.5, 6.5,5.1,'rgb(255,187,119)',1,6.3,6);
      drawShape('pol',x+sx,y+sy,z,7.5,4.1, 7,4.5, 6,6, 7,6,'rgb(255,187,119)',1,7,5.25);
      drawShape('qua',x+sx,y+sy,z,8.5,5.5, 8.5,6, 8.75,6, 8.75,5.5,'rgb(255,187,119)',1,7,5.25);
      drawShape('pol',x+sx,y+sy,z,7,6.25, 8.5,5.8, 8.4,5.75, 8.5,5.55,'rgba(255,187,119,.45)',1,7,5.8);
      drawShape('pol',x+sx,y+sy,z,7,6.05, 8.5,5.6, 8.4,5.55, 8.5,5.35,'rgba(255,187,119,.45)',1,7,5.6);

      drawShape('pol',x+sx,y+sy,z,7,6.5, 8.5,6, 8.4,5.5, 8,5.75,'rgb(255,187,119)',1,7,6);
      //drawShape('pol',x+sx,y+sy,z,2,4, 1,3.5, 0.5,3, 0,2.75,'rgba(255,255,255,.095)',1,0,0);
      //drawShape('pol',x+sx,y+sy,z,2,4, 2,0, 0,0, 0,1,'rgba(255,255,255,.095)',1,2,4);


        break;
    case 70://Cultivate 7  
      drawShape('arc',x,y,z,5,5,5-Math.random(),0,2,0,0,0,'rgba(0,64,0,.25)',1);
      sx = -5*z;
      sy = -1.5*z;
      sz = 2;
      //neck
      drawShape('qua',x+sx,y+sy,z*sz,5,2, 4.5,2.5, 4.5,3, 5,3.5,`rgba(${0},${128},${0},.5)`,1,10,7);
       drawShape('qua',x+sx,y+sy,z*sz,5,2, 5.5,2.5, 5.5,3, 5,3.5,`rgba(${0},${128},${0},.5)`,1,10,7);
      //shoulders
      drawShape('qua',x+sx,y+sy,z*sz,5,2.5, 4,2.5, 3.5,3, 5,3,`rgba(${0},${128},${0},.5)`,1,10,7);
      drawShape('qua',x+sx,y+sy,z*sz,5,2.5, 6,2.5, 6.5,3, 5,3,`rgba(${0},${128},${0},.5)`,1,10,7);
      //torso
      drawShape('qua',x+sx,y+sy,z*sz,4,3, 5,5, 6,3, 5,2.5,`rgba(${0},${128},${0},.5)`,1,10,7);
      //legs
      drawShape('qua',x+sx,y+sy,z*sz,5.5,4, 7,5, 6,5, 5,5,`rgba(${0},${128},${0},.5)`,1,10,7);
      drawShape('qua',x+sx,y+sy,z*sz,4.5,4, 3,5, 4,5, 5,5,`rgba(${0},${128},${0},.5)`,1,10,7);
            
      drawShape('qua',x+sx,y+sy,z*sz,3,5, 5.5,5.5, 4,4.8, 3.5,4.75,`rgba(${0},${128},${0},.5)`,1,10,7);
      drawShape('qua',x+sx,y+sy,z*sz,7,5, 4.5,5.5, 6,4.8, 6.5,4.75,`rgba(${0},${128},${0},.5)`,1,10,7);
      //arms
      drawShape('tri',x+sx,y+sy,z*sz,3.5,3, 4,4, 4,3, 3.5,4.75,`rgba(${0},${128},${0},.5)`,1,10,7);
      drawShape('tri',x+sx,y+sy,z*sz,6.5,3, 6,4, 6,3, 3.5,4.75,`rgba(${0},${128},${0},.5)`,1,10,7);

      drawShape('tri',x+sx,y+sy,z*sz,4,3.5, 4,4, 5,4.5, 3.5,4.75,`rgba(${0},${128},${0},.5)`,1,10,7);
      drawShape('tri',x+sx,y+sy,z*sz,6,3.5, 6,4, 5,4.5, 3.5,4.75,`rgba(${0},${128},${0},.5)`,1,10,7);
    sx = -1.25*z;
      sy = .5*z;
      sz = 1.25;
      //head l
      drawShape('qua',x+sx,y+sy,z*sz,5,.25, 4,1, 4.5,2, 5,2.5,`rgba(${0},${128},${0},1)`,1,10,7);
      //head r
      drawShape('qua',x+sx,y+sy,z*sz,5,.25, 6,1, 5.5,2, 5,2.5,`rgba(${0},${128},${0},1)`,1,10,7);
    //////////////////////////////////////////////////////////////////////
    sx = -5*z;
        sy = -1.5*z;
        sz = 2;
        //neck
      drawShape('qua',x+sx,y+sy,z*sz,5,2, 4.5,2.5, 4.5,3, 5,3.5,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.1)`,1,10,7);
       drawShape('qua',x+sx,y+sy,z*sz,5,2, 5.5,2.5, 5.5,3, 5,3.5,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.1)`,1,10,7);
     //shoulders
      drawShape('qua',x+sx,y+sy,z*sz,5,2.5, 4,2.5, 3.5,3, 5,3,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.1)`,1,10,7);
      drawShape('qua',x+sx,y+sy,z*sz,5,2.5, 6,2.5, 6.5,3, 5,3,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.1)`,1,10,7);
     
      //torso
            drawShape('qua',x+sx,y+sy,z*sz,4,3, 5,5, 6,3, 5,2.5,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.1)`,1,10,7);
      //legs
            drawShape('qua',x+sx,y+sy,z*sz,5.5,4, 7,5, 6,5, 5,5,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.1)`,1,10,7);
            drawShape('qua',x+sx,y+sy,z*sz,4.5,4, 3,5, 4,5, 5,5,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.1)`,1,10,7);
            
            drawShape('qua',x+sx,y+sy,z*sz,3,5, 5.5,5.5, 4,4.8, 3.5,4.75,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.1)`,1,10,7);
            drawShape('qua',x+sx,y+sy,z*sz,7,5, 4.5,5.5, 6,4.8, 6.5,4.75,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.1)`,1,10,7);
     //arms
        drawShape('tri',x+sx,y+sy,z*sz,3.5,3, 4,4, 4,3, 3.5,4.75,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.1)`,1,10,7);
        drawShape('tri',x+sx,y+sy,z*sz,6.5,3, 6,4, 6,3, 3.5,4.75,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.1)`,1,10,7);

        drawShape('tri',x+sx,y+sy,z*sz,4,3.5, 4,4, 5,4.5, 3.5,4.75,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.1)`,1,10,7);
        drawShape('tri',x+sx,y+sy,z*sz,6,3.5, 6,4, 5,4.5, 3.5,4.75,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.1)`,1,10,7);
        sx = -1.25*z;
    sy = .5*z;
    sz = 1.25;
    //head l
      drawShape('qua',x+sx,y+sy,z*sz,5,.25, 4,1, 4.5,2, 5,2.5,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.1)`,1,10,7);
      //head r
      drawShape('qua',x+sx,y+sy,z*sz,5,.25, 6,1, 5.5,2, 5,2.5,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.1)`,1,10,7);

      break;
    case 71://Forge 8   
      sx = 1.5*z;
      sy = 1*z;
      sz = .15;
			drawShape('tri',x+sx,y+sy,z*sz,0,8.6, 1.4,10, 0,10 ,0,0,'rgb(252,165,3)',1);
			drawShape('qua',x+sx,y+sy,z*sz,0,9, 2,7, 3,8, 1,10,'rgb(252,165,3)',1);
			drawShape('qua',x+sx,y+sy,z*sz,0,5, 1,5 ,5,9 ,5,10,'rgb(252,165,3)',1);
     drawShape('tri',x+sx,y+sy,z*sz,0,10, 1.4,10, 0,8.6 ,0,10,'darkgray',1);//pommel

			drawShape('qua',x+sx,y+sy,z*sz,2,6, 8,1, 8,2, 4,6,'gray',1);//
			drawShape('qua',x+sx,y+sy,z*sz,4,8, 9,2, 8,2 ,4,6,'gray',1);
			drawShape('tri',x+sx,y+sy,z*sz,2,6, 4,6, 4,8, 0,0,'gray',1);
			drawShape('qua',x+sx,y+sy,z*sz,8,1, 8,2, 9,2, 10,0,'gray',1);
      	drawShape('qua',x+sx,y+sy,z*sz,2,6, 8,1, 8,2, 4,6,'rgba(0,0,0,.25)',1);//
			drawShape('qua',x+sx,y+sy,z*sz,4,8, 9,2, 8,2 ,4,6,'rgba(0,0,0,.25)',1);
			drawShape('tri',x+sx,y+sy,z*sz,2,6, 4,6, 4,8, 0,0,'rgba(0,0,0,.25)',1);
			drawShape('qua',x+sx,y+sy,z*sz,8,1, 8,2, 9,2, 10,0,'rgba(0,0,0,.25)',1);
			drawShape('qua',x+sx,y+sy,z*sz,0,5, 1,5, 5,9 ,5,10,'rgb(252,165,3)',0);
			drawShape('arc',x+sx,y+sy,z*sz,3,7, .5,0, 6,0 ,0,0,'red',1);//pommel gem
			drawShape('arc',x+sx,y+sy,z*sz,3,7 ,.5,0, 6,0, 0,0,'brown',0)
      sx = -.5*z;
     sy = 2.32*z;
     sz = .5;
      //upper chest
      drawShape('qua',x+sx,y+sy,z*sz,3,2, 7,2, 6.5,4, 5.5,6,'rgba(255,255,255,1)',1);
      drawShape('qua',x+sx,y+sy,z*sz,7,2, 3,2, 3.5,4, 4.5,6,'rgba(255,255,255,1)',1);
      drawShape('qua',x+sx,y+sy,z*sz,3,2, 7,2, 6.5,4, 5.5,6,'rgba(0,0,0,.4)',1);
      drawShape('qua',x+sx,y+sy,z*sz,7,2, 3,2, 3.5,4, 4.5,6,'rgba(0,0,0,.4)',1);
      //left shoulder
      drawShape('qua',x+sx,y+sy,z*sz,3,2, 2.5,1.5, 1.5,2.5, 3,3,'rgba(255,255,255,1)',1);
      drawShape('qua',x+sx,y+sy,z*sz,3,2, 2.5,1.5, 1.5,2.5, 3,3,'rgba(0,0,0,.4)',1);
      drawShape('qua',x+sx,y+sy,z*sz,3,2, 2.5,1.75, 1.5,2.5, 3,3,'rgba(0,0,0,.4)',1);

      //right shoulder   
      drawShape('qua',x+sx,y+sy,z*sz,7,2, 7.5,1.5, 8.5,2.5, 7,3,'rgba(255,255,255,1)',1);
      drawShape('qua',x+sx,y+sy,z*sz,7,2, 7.5,1.5, 8.5,2.5, 7,3,'rgba(0,0,0,.4)',1);
      drawShape('qua',x+sx,y+sy,z*sz,7,2, 7.5,1.75, 8.5,2.5, 7,3,'rgba(0,0,0,.4)',1);

      //left hip armor
      drawShape('qua',x+sx,y+sy,z*sz,4.5,6, 4,7, 3,7.5, 4,5,'rgba(255,255,255,1)',1);
      drawShape('qua',x+sx,y+sy,z*sz,4.5,6, 4,7, 3,7.5, 4,5,'rgba(0,0,0,.45)',1);
      //right hip armor
      drawShape('qua',x+sx,y+sy,z*sz,5.5,6, 6,7, 7,7.5, 6,5,'rgba(255,255,255,1)',1);
      drawShape('qua',x+sx,y+sy,z*sz,5.5,6, 6,7, 7,7.5, 6,5,'rgba(0,0,0,.45)',1);
      //groin armor
      drawShape('qua',x+sx,y+sy,z*sz,5,5.19, 4.5,6, 5,7, 5.5,6,'rgba(255,255,255,1)',1);
      drawShape('qua',x+sx,y+sy,z*sz,5,5.19, 4.5,6, 5,7, 5.5,6,'rgba(0,0,0,.4)',1);
      //Neck area
      drawShape('pol',x+sx,y+sy,z*sz,4,2, 4.5,2.5, 5,2.7, 5.5,2.5,'rgba(0,0,0,.5)',1,6,2);
        //////////////////////////////////////////////////////////////////
      //upper chest
      drawShape('qua',x+sx,y+sy,z*sz,3,2, 7,2, 6.5,4, 5.5,6,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},${Math.random()*.2})`,1);
      drawShape('qua',x+sx,y+sy,z*sz,7,2, 3,2, 3.5,4, 4.5,6,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},${Math.random()*.2})`,1);

      //left shoulder
      drawShape('qua',x+sx,y+sy,z*sz,3,2, 2.5,1.5, 1.5,2.5, 3,3,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},${Math.random()*.2})`,1);
 
      //right shoulder   
      drawShape('qua',x+sx,y+sy,z*sz,7,2, 7.5,1.5, 8.5,2.5, 7,3,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},${Math.random()*.2})`,1);
   
      //left hip armor
      drawShape('qua',x+sx,y+sy,z*sz,4.5,6, 4,7, 3,7.5, 4,5,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},${Math.random()*.2})`,1);
      //right hip armor
      drawShape('qua',x+sx,y+sy,z*sz,5.5,6, 6,7, 7,7.5, 6,5,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},${Math.random()*.2})`,1);
      //groin armor
      drawShape('qua',x+sx,y+sy,z*sz,5,5.19, 4.5,6, 5,7, 5.5,6,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},${Math.random()*.2})`,1);
      //Neck area
       //Neck area
      drawShape('pol',x+sx,y+sy,z*sz,4,2, 4.5,2.5, 5,2.7, 5.5,2.5,'rgba(0,0,0,.5)',1,6,2);
       
      drawShape('qua',x,y,z,0,7, 10,7, 10,10, 0,10,'rgba(64,32,16,.4)',1);

      drawShape('qua',x,y,z,1.9,3.5, 1.9,7, 2.1,7, 2.1,3.5,'rgba(64,32,16,.4)',1);

      sx = 4.5*z;
      sy = 3*z
      sz = .5;
      // drawShape('arc',x+sx,y+sy,z*sz,5,6.5,3.5-Math.random(),0,2,0,0,0,'rgba(176,9,0,.75)',1);//CRA
			drawShape('tri',x+sx,y+sy,z*sz,1.5,6.5,2,0+Math.random(),8,5,0,0,'rgba(176,9,0,.65)',1);//LRT
			drawShape('tri',x+sx,y+sy,z*sz,10-1.5,6.5,5,0+Math.random(),10-8,5,0,0,'rgba(176,9,0,.65)',1);//CRT
			drawShape('tri',x+sx,y+sy,z*sz,10-1.5,6.5,10-2,0+Math.random(),10-8,5,0,0,'rgba(176,9,0,.65)',1);//RRT
			drawShape('tri',x+sx,y+sy,z*sz,2.5,7.5,2.5,1-Math.random(),7,6,0,0,'rgba(232,220,0,.65)',1);//LYT
			drawShape('tri',x+sx,y+sy,z*sz,10-2.5,7.5,5,1-Math.random(),10-7,6,0,0,'rgba(232,220,0,.65)',1);//CYT
			drawShape('tri',x+sx,y+sy,z*sz,10-2.5,7.5,10-2.5,1-Math.random(),10-7,6,0,0,'rgba(232,220,0,.65)',1);//RYT
			//drawShape('arc',x+sx,y+sy,z*sz,5,7.5,2.5-Math.random(),0,2,0,0,0,'rgba(232,220,0,1)',1);//CYA
      	//drawShape('arc',x+sx,y+sy,z*sz,5,6.5,3.5+Math.random(),0,2,0,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.25)`,1);//CRA

      drawShape('tri',x+sx,y+sy,z*sz,1.5,6.5,2,0,8,5,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.1)`,1);//LRT
			drawShape('tri',x+sx,y+sy,z*sz,10-1.5,6.5,5,0,10-8,5,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.1)`,1);//CRT
			drawShape('tri',x+sx,y+sy,z*sz,10-1.5,6.5,10-2,0,10-8,5,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.1)`,1);//RRT
			drawShape('tri',x+sx,y+sy,z*sz,2.5,7.5,2.5,1,7,6,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.1)`,1);//LYT
			drawShape('tri',x+sx,y+sy,z*sz,10-2.5,7.5,5,1,10-7,6,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.1)`,1);//CYT
			drawShape('tri',x+sx,y+sy,z*sz,10-2.5,7.5,10-2.5,1,10-7,6,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.1)`,1);//RYT
      		   
      drawShape('qua',x,y,z,9,1, 10,3, 10,9, 7,9,'rgba(0,0,0,1)',1);
        drawShape('qua',x,y,z,5,1, 4,3, 4,9, 7,9,'rgba(0,0,0,1)',1);
        drawShape('pol',x,y,z,5,1, 6,.5, 7,.25, 8,.5,'rgba(0,0,0,1)',1,9,1);
        drawShape('qua',x,y,z,5,1, 9,1, 9,3, 5,3,'rgba(0,0,0,1)',1);
        drawShape('tri',x,y,z,6,6, 8,6, 7,9, 4,3,'rgba(0,0,0,1)',1);
 
        drawShape('qua',x,y,z,9,1, 10,3, 10,9, 7,9,'rgba(255,255,255,.2)',1);
        drawShape('qua',x,y,z,5,1, 4,3, 4,9, 7,9,'rgba(255,255,255,.2)',1);
        drawShape('pol',x,y,z,5,1, 6,.5, 7,.25, 8,.5,'rgba(255,255,255,.2)',1,9,1);
        drawShape('qua',x,y,z,5,1, 9,1, 9,3, 5,3,'rgba(255,255,255,.2)',1);
        drawShape('tri',x,y,z,6,6, 8,6, 7,9, 4,3,'rgba(255,255,255,.2)',1);
        
               drawShape('pol',x,y,z,2,8, 2,8.5, 2,9, 1.5,8.5,'rgba(0,0,0,1)',1,1.5,8);
        drawShape('qua',x,y,z,2,8.5, 2.5,8.5, 2.5,8.7, 2,9,'rgba(0,0,0,1)',1);
        drawShape('pol',x,y,z,2,8, 2,8.5, 2,9, 1.5,8.5,'rgba(255,255,255,.1)',1,1.5,8);
        drawShape('qua',x,y,z,2,8.5, 2.5,8.5, 2.5,8.7, 2,9,'rgba(255,255,255,.2)',1);

 

        drawShape('qua',x,y,z,1,7, 2,7, 3,8, 2,8,'rgba(0,0,0,1)',1);
        drawShape('qua',x,y,z,1,7, 1,7.75, 2,8.5, 2,8,'rgba(0,0,0,1)',1);
        drawShape('tri',x,y,z,2,8, 3,8, 3,8.5, 2,8,'rgba(0,0,0,1)',1);
        drawShape('tri',x,y,z,2,8, 2,8.5, 3,8.5, 2,8,'rgba(0,0,0,1)',1);

        drawShape('qua',x,y,z,1,7, 2,7, 3,8, 2,8,'rgba(255,255,255,.4)',1);
        drawShape('qua',x,y,z,1,7, 1,7.75, 2,8.5, 2,8,'rgba(255,255,255,.1)',1);
        drawShape('tri',x,y,z,2,8, 3,8, 3,8.5, 2,8,'rgba(255,255,255,.3)',1);
        drawShape('tri',x,y,z,2,8, 2,8.5, 3,8.5, 2,8,'rgba(255,255,255,.2)',1);


      break;
    case 72://Magic Ring 9  
  
        drawShape('ell',x,y,z,5,5,4,2,0,2,0,0,'gold',1);
        drawShape('ell',x,y,z,5,4.45,3.5,1.25,0,2,0,0,'rgba(0,0,0,.5)',1);
        drawShape('ell',x,y,z,5,4.7,3.5,1,0,2.1,.9,0,'rgba(0,0,0,1)',1);
        drawShape('ell',x,y,z,5,4.9,3.3,1,0,.7,2.3,0,'rgba(0,0,0,1)',1);
        

        drawShape('arc',x,y,z,5,6.75, 1, 0,2, 0,0,0,'darkred',1);
        drawShape('arc',x,y,z,5,6.75, 1+Math.random(),0, 2,0,0,0,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.25)`,1);

    
    break;
    case 73://Inheritance 10   
     sx = 1.1*z;
      sy = -3*z;
      sz = .25; 
     drawShape('pol',x,y+sy,z,5,6, 2,8, 0,9, 10,9,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},${Math.random()*.5})`,1,10,9);
      drawShape('pol',x,y+sy,z,5,6, 2,8, 0,9, 10,9,`rgba(${255},${255},${0},.75)`,1,10,9);
      drawShape('arc',x,y,z,5,5,5,0,2,0,0,0,'rgba(255,255,255,.05)',1);
          sx = 2.5*z;
       sy = 4*z;
       sz = .15; 
    drawShape('arc',x+sx,y+sy,z*sz,4.8,5,4.5,0,6,0,0,0,'rgba(40,20,0,1)',1);
      drawShape('arc',x+sx,y+sy,z*sz,5,5,4.5,0,6,0,0,0,'rgba(85,43,0,1)',1);
      drawShape('rec',x+sx,y+sy,z*sz,0.5,5,9,.11,0,0,0,0,'rgba(0,0,0,.35)',1)
      drawShape('rec',x+sx,y+sy,z*sz,.95,3,8.1,.11,0,0,0,0,'rgba(0,0,0,.35)',1)
      drawShape('rec',x+sx,y+sy,z*sz,1,7,8,.11,0,0,0,0,'rgba(0,0,0,.35)',1)
      drawShape('qua',x+sx,y+sy,z*sz,5,4,6,5,5,6,4,5,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,3,1, 7,1.1, 2.8,1.2, 8,2,'rgba(0,0,0,.35)',1);
      drawShape('qua',x+sx,y+sy,z*sz,3-1,1+1, 7-1,1.1+1, 2.8-1,1.2+1, 8-1,2+1,'rgba(0,0,0,.35)',1);
      drawShape('qua',x+sx,y+sy,z*sz,1+3,1+2, 1+7,1.1+2, 1+2.8,1.2+2, 1+8,2+2,'rgba(0,0,0,.35)',1);
      drawShape('qua',x+sx,y+sy,z*sz,1+3,1+5, 1+7,1.1+5, 1+2.8,1.2+5, 1+8,2+5,'rgba(0,0,0,.35)',1);
      drawShape('qua',x+sx,y+sy,z*sz,3,1+6, 7,1.1+6, 2.8,1.2+6, 8,2+6,'rgba(0,0,0,.35)',1);
      drawShape('qua',x+sx,y+sy,z*sz,3-1,1+7, 7-1,1.1+7, 2.8-1,1.2+7, 8-1,2+7,'rgba(0,0,0,.35)',1);
     
      sx = 1.1*z;
      sy = 5*z;
      sz = .25;
			drawShape('rec',x+sx,y+sy,z*sz,7.93,1,1.85,9,0,0,0,0,'rgb(185,122,87)',1);
			drawShape('rec',x+sx,y+sy,z*sz,2,.3,6.613,9.7,0,0,0,0,'rgb(185,122,87)',1);
			drawShape('rec',x+sx,y+sy,z*sz,1,.3,1,1,0,0,0,0,'rgb(185,122,87)',1);
			drawShape('arc',x+sx,y+sy,z*sz,1,1.3,1,0,6,0,0,0,'rgb(119,43,79)',1);
			drawShape('arc',x+sx,y+sy,z*sz,8.8,1.3,1,0,6,0,0,0,'rgb(185,122,87)',1);
			drawShape('rec',x+sx,y+sy,z*sz,0,1,2,8,0,0,0,0,'rgb(119,43,79)',1);
			drawShape('tri',x+sx,y+sy,z*sz,0,9,2,10,2,9,0,0,'rgb(119,43,79)',1);
			drawShape('lin',x+sx,y+sy,z*sz,0,4,2,5,0,0,0,0,'black',0);
			drawShape('lin',x+sx,y+sy,z*sz,2,5,10,5,0,0,0,0,'black',0);
			drawShape('rec',x+sx,y+sy,z*sz,5,4,2,2,0,0,0,0,'gold',1);
			drawShape('rec',x+sx,y+sy,z*sz,5.8,4.7,.5,1,0,0,0,0,'black',1);
  
      
        sx = 5*z;
      sy = 4*z;
      sz = .15;
			drawShape('tri',x+sx,y+sy,z*sz,0,8.6, 1.4,10, 0,10 ,0,0,'rgb(252,165,3)',1);
			drawShape('qua',x+sx,y+sy,z*sz,0,9, 2,7, 3,8, 1,10,'rgb(252,165,3)',1);
			drawShape('qua',x+sx,y+sy,z*sz,0,5, 1,5 ,5,9 ,5,10,'rgb(252,165,3)',1);
       drawShape('tri',x+sx,y+sy,z*sz,0,10, 1.4,10, 0,8.6 ,0,10,'darkgray',1);//pommel

			drawShape('qua',x+sx,y+sy,z*sz,2,6, 8,1, 8,2, 4,6,'gray',1);//
			drawShape('qua',x+sx,y+sy,z*sz,4,8, 9,2, 8,2 ,4,6,'gray',1);
			drawShape('tri',x+sx,y+sy,z*sz,2,6, 4,6, 4,8, 0,0,'gray',1);
			drawShape('qua',x+sx,y+sy,z*sz,8,1, 8,2, 9,2, 10,0,'gray',1);
      	drawShape('qua',x+sx,y+sy,z*sz,2,6, 8,1, 8,2, 4,6,'rgba(0,0,0,.25)',1);//
			drawShape('qua',x+sx,y+sy,z*sz,4,8, 9,2, 8,2 ,4,6,'rgba(0,0,0,.25)',1);
			drawShape('tri',x+sx,y+sy,z*sz,2,6, 4,6, 4,8, 0,0,'rgba(0,0,0,.25)',1);
			drawShape('qua',x+sx,y+sy,z*sz,8,1, 8,2, 9,2, 10,0,'rgba(0,0,0,.25)',1);
			drawShape('qua',x+sx,y+sy,z*sz,0,5, 1,5, 5,9 ,5,10,'rgb(252,165,3)',0);
			drawShape('arc',x+sx,y+sy,z*sz,3,7, .5,0, 6,0 ,0,0,'red',1);//pommel gem
			drawShape('arc',x+sx,y+sy,z*sz,3,7 ,.5,0, 6,0, 0,0,'brown',0);
      sx = 5*z;
      sy = 3*z;
      sz = .05;
     drawShape('qua',x+sx,y+sy,z*sz,1,9,9,9,1,1,9,1,'white',1);//body
      drawShape('rec',x+sx,y+sy,z*sz,1,.75,8,.25,0,0,0,0,'blue',1);
      drawShape('rec',x+sx,y+sy,z*sz,1,9,8,.25,0,0,0,0,'blue',1);

      drawShape('tri',x+sx,y+sy,z*sz,2.5,9,7.5,9,5,8.5,0,0,'blue',1);//bottom sand
      drawShape('tri',x+sx,y+sy,z*sz,5,5,2.5,2.5,7.5,2.5,0,0,'blue',1);//top sand
      drawShape('qua',x+sx,y+sy,z*sz,5,5, 4.9,6, 5.1,7, 4.9,8.5,'blue',1);//drip sand
      sx = 7.5*z;
      sy = 5*z;
      sz = .075;
       drawShape('qua',x+sx,y+sy,z*sz,0.2,9.5, 6.21,0, 10,3.77, .2,9.9,'rgba(85,43,0,1)',1);//handle
      drawShape('qua',x+sx,y+sy,z*sz,0.2,9.5, 6.21,.1, 7,.8, .2,9.6,'rgba(0,0,0,.5)',1);//handle
      drawShape('qua',x+sx,y+sy,z*sz,0.2,9.9, 6.5,4.5, 6.52,4.5, .2,9.9,'rgba(0,0,0,.5)',1);//handle
      //drawShape('tri',x,y,z,10,0, 6.21,0, 10,3.77, 0,0,'rgb(109,39,19)',1);//GFR
      drawShape('tri',x+sx,y+sy,z*sz,10,0, 6.21,0, 8.2,2, 0,0,'rgba(255,0,0,.2)',1);//gfl
      drawShape('tri',x+sx,y+sy,z*sz,10,0, 6.21,0, 10,3.77, 0,0,'rgba(209,70,47,.2)',1);//GFR
      //drawShape('tri',x,y,z,10,0, 6.21,0, 8.2,2, 0,0,'rgb(109,39,19)',1);//gfl
      drawShape('tri',x+sx,y+sy,z*sz,6.21,0, 10,3.77, 9,1, 0,0,'rgba(255,0,0,.25)',1);//handle
      drawShape('tri',x+sx,y+sy,z*sz,10,0, 6.21,0, 10,3.77, 0,0,'rgba(255,0,0,.3)',1);//gem mask
      
      break;
    case 74://Gargoyle      
      drawShape('qua',x,y,z,5,0+Math.random()*.3, 0,5 ,5,10, 10,5,`rgba(0,128,${0},.15)`,1);//neck

           sx =  0.4*z;
       sy = 1*z
       sz = .36;
    drawShape('pol',x+sx,y+sy,z*sz,10,0, 8,.5 ,2,5 ,0,8,'rgba(0,6,13,1)',1,0,10);
      drawShape('tri',x+sx,y+sy,z*sz,10,0, 10,5 ,5.5,2 ,0,10,'rgba(0,6,13,1)',1,9,9);
    
      drawShape('qua',x,y,z,5,2.75, 4,2,3.45,1.6 ,4.5,3.5,'rgba(255,255,255,.5)',1,5.1,7);
      drawShape('tri',x,y,z,3.5,1.75, 3.5,1.55, 1.8,2.6 ,4.5,3.5,'rgba(255,255,255,.5)',1,5.1,7);
      drawShape('tri',x,y,z,.5,4.55, 1.8,2.5, 2,2.5 ,4.5,4,'rgba(255,255,255,.5)',1,5.1,7);

      drawShape('pol',x+sx,y+sy,z*sz,10,5, 8.5,2 ,4,4.45 ,0,10,'rgba(255,255,255,.5)',1,9,9);
      drawShape('tri',x+sx,y+sy,z*sz,10,5, 10,7 ,9.5,6 ,0,10,'rgba(255,255,255,.5)',1,9,9);
      drawShape('pol',x+sx,y+sy,z*sz,9,9, 10,7 ,9.75,6.25 ,8.75,7.25,'rgba(255,255,255,.5)',1,8.75,8.25);
      drawShape('pol',x+sx,y+sy,z*sz,9,9.1, 4.5,9.6 ,5,8.5 ,6,8.25,'rgba(255,255,255,.5)',1,8,8.5);
      drawShape('pol',x+sx,y+sy,z*sz,0,10, 4.5,9.7 ,4,9 ,3,8.75,'rgba(255,255,255,.5)',1,2,9);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 4.5,5 ,8.5,2 ,5,5,'rgba(255,255,255,.5)',1,2,9);
      drawShape('qua',x+sx,y+sy,z*sz,4.5,9, 5,6 ,8.5,2 ,5.5,6,'rgba(255,255,255,.5)',1,2,9);
      drawShape('qua',x+sx,y+sy,z*sz,9,9, 7.55,6 ,8.5,2 ,8,6,'rgba(255,255,255,.5)',1,2,9);
      drawShape('qua',x+sx,y+sy,z*sz,10,7, 9.5,5 ,8.5,2 ,9.3,5,'rgba(255,255,255,.5)',1,2,9);
      drawShape('tri',x+sx,y+sy,z*sz,0,9.75, 2.25,5 ,0,7 ,6,8.25,'rgba(0,6,13,1)',1,8,8.5);

      sx =  6*z;
       sy = 1*z
       sz = .36;
       drawShape('pol',x+sx,y+sy,z*sz,0,0, 2,.5 ,8,5 ,10,8,'rgba(0,6,13,1)',1,10,10);
      drawShape('tri',x+sx,y+sy,z*sz,0,0, 0,5 ,4.5,2 ,0,10,'rgba(0,6,13,1)',1,9,9);

      drawShape('pol',x+sx,y+sy,z*sz,0,5, 1.5,2 ,6,4.45 ,10,10,'rgba(255,255,255,.5)',1,1,9);
      drawShape('tri',x+sx,y+sy,z*sz,0,5, 0,7 ,0.5,6 ,10,10,'rgba(255,255,255,.5)',1,1,9);
      drawShape('pol',x+sx,y+sy,z*sz,1,9, 0,7 ,0.75,6.25 ,1.25,7.25,'rgba(255,255,255,.5)',1,1.25,8.25);
      drawShape('pol',x+sx,y+sy,z*sz,1,9.1, 5.5,9.6 ,5,8.5 ,4,8.25,'rgba(255,255,255,.5)',1,2,8.5);
      drawShape('pol',x+sx,y+sy,z*sz,10,10, 5.5,9.7 ,6,9 ,7,8.75,'rgba(255,255,255,.5)',1,8,9);
      drawShape('qua',x+sx,y+sy,z*sz,10,10, 5.5,5 ,1.5,2 ,5,5,'rgba(255,255,255,.5)',1,8,9);
      drawShape('qua',x+sx,y+sy,z*sz,5.5,9, 5,6 ,1.5,2 ,4.5,6,'rgba(255,255,255,.5)',1,8,9);
      drawShape('qua',x+sx,y+sy,z*sz,1,9, 2.45,6 ,1.5,2 ,2,6,'rgba(255,255,255,.5)',1,8,9);
      drawShape('qua',x+sx,y+sy,z*sz,0,7, 0.5,5 ,1.5,2 ,0.7,5,'rgba(255,255,255,.5)',1,8,9);
      drawShape('tri',x+sx,y+sy,z*sz,10,9.75, 7.75,5 ,10,7 ,4,8.25,'rgba(0,6,13,1)',1,2,8.5);
            drawShape('qua',x,y,z,5,2.75, 6,2,6.55,1.7 ,5.5,3.5,'rgba(255,255,255,.5)',1,5.1,7);
      drawShape('tri',x,y,z,6.5,1.75, 6.5,1.6, 8.2,2.6 ,4.5,3.5,'rgba(255,255,255,.5)',1,5.1,7);
      drawShape('tri',x,y,z,9.55,4.55, 8.2,2.5, 8,2.5 ,4.5,3.5,'rgba(255,255,255,.5)',1,5.1,7);

            drawShape('pol',x,y,z,5,1, 4.25,.5 ,4.5,2 ,5,2.5,'rgba(255,255,255,.5)',1,5.5,1);
            drawShape('pol',x,y,z,5,1, 5.75,.5 ,5.5,2 ,5,2.5,'rgba(255,255,255,.5)',1,4.5,1);
            drawShape('qua',x,y,z,5,2, 4,2.5 ,4.5,4 ,5,5,'rgba(255,255,255,.5)',1,5.5,1);
            drawShape('qua',x,y,z,5,2, 6,2.5 ,5.5,4 ,5,5,'rgba(255,255,255,.5)',1,5.5,1);

            drawShape('pol',x,y,z,4.5,4, 4,5 ,4,6 ,4.5,5.25,'rgba(255,255,255,.5)',1,5,5);
            drawShape('pol',x,y,z,5.5,4, 6,5 ,6,6 ,5.5,5.25,'rgba(255,255,255,.5)',1,5,5);

            drawShape('pol',x,y,z,4,2.5, 3.5,3 ,3,4 ,3.5,3.5,'rgba(255,255,255,.5)',1,4.5,3);
            drawShape('pol',x,y,z,6,2.5, 6.5,3 ,7,4 ,6.5,3.5,'rgba(255,255,255,.5)',1,5.5,3);
            drawShape('qua',x,y,z,4,5.5, 4,7 ,4.5,6 ,4.5,5.5,'rgba(255,255,255,.5)',1,5.5,3);
            drawShape('qua',x,y,z,6,5.5, 6,7 ,5.5,6 ,5.5,5.5,'rgba(255,255,255,.5)',1,4.5,3);
            drawShape('tri',x,y,z,5,1.5, 4.6,1.25 ,4.6,1.45 ,5.5,5.5,'rgba(0,0,0,1)',1,4.5,3);
            drawShape('tri',x,y,z,5,1.5, 5.4,1.25 ,5.4,1.45 ,5.5,5.5,'rgba(0,0,0,1)',1,4.5,3);

            drawShape('qua',x,y,z,3.25,3.6, 2.75,3.75 ,3.25,3.75 ,3.5,4,'rgba(255,255,255,.5)',1,4.5,3);
            drawShape('qua',x,y,z,6.75,3.6, 7.25,3.75 ,6.75,3.75 ,6.5,4,'rgba(255,255,255,.5)',1,4.5,3);

            drawShape('pol',x,y,z,4.6,1.7, 4.9,2.2 ,5.1,2.2 ,5.4,1.7,'rgba(0,0,0,1)',1,5.4,1.7);
            drawShape('tri',x,y,z,4.9,2, 5.1,2 ,5,3 ,5,3,'rgba(255,255,255,.5)',1,5.4,1.7);
            drawShape('tri',x,y,z,4.6,1.7, 4.7,1.7 ,4.6,1.9 ,5,3,'rgba(255,255,255,1)',1,5.4,1.7);
            drawShape('tri',x,y,z,5.4,1.7, 5.3,1.7 ,5.4,1.9 ,5,3,'rgba(255,255,255,1)',1,5.4,1.7);
            drawShape('pol',x,y,z,4.9,5, 5.1,5 ,5.1,6 ,5.3,7.5,'rgba(255,255,255,.5)',1,5.1,7);

    break;
    case 75://Gnome KN  
          drawShape('qua',x,y,z,5,0+Math.random()*.3, 0,5 ,5,10, 10,5,`rgba(0,128,${0},.15)`,1);//neck
     
      sx = -3.75*z;
      sy = -2*z;
      sz = 1.75;
      //neck
      drawShape('qua',x+sx,y+sy,z*sz,5,2, 4.5,2.5, 4.5,3, 5,3.5,`rgba(${64},${32},${0},.5)`,1,10,7);
       drawShape('qua',x+sx,y+sy,z*sz,5,2, 5.5,2.5, 5.5,3, 5,3.5,`rgba(${64},${32},${0},.5)`,1,10,7);
      //shoulders
      drawShape('qua',x+sx,y+sy,z*sz,5,2.5, 4,2.5, 3.5,3, 5,3,`rgba(${0},${0},${0},1)`,1,10,7);
      drawShape('qua',x+sx,y+sy,z*sz,5,2.5, 6,2.5, 6.5,3, 5,3,`rgba(${0},${0},${0},1)`,1,10,7);
            drawShape('qua',x+sx,y+sy,z*sz,5,2.5, 4,2.5, 3.5,3, 5,3,`rgba(${64},${32},${0},.5)`,1,10,7);
      drawShape('qua',x+sx,y+sy,z*sz,5,2.5, 6,2.5, 6.5,3, 5,3,`rgba(${64},${32},${0},.5)`,1,10,7);
      //torso
            drawShape('qua',x+sx,y+sy,z*sz,4,3, 5,5, 6,3, 5,2.5,`rgba(${0},${0},${0},1)`,1,10,7);

      drawShape('qua',x+sx,y+sy,z*sz,4,3, 5,5, 6,3, 5,2.5,`rgba(${64},${32},${0},.5)`,1,10,7);
      //legs
    sx = -1.25*z;
      sy = -.2*z;
      sz = 1.25;
      //head l
      drawShape('qua',x+sx,y+sy,z*sz,5,.25, 4,1, 4.5,2, 5,2.5,`rgba(${64},${32},${0},1)`,1,10,7);
      //head r
      drawShape('qua',x+sx,y+sy,z*sz,5,.25, 6,1, 5.5,2, 5,2.5,`rgba(${64},${32},${0},1)`,1,10,7);
         
      drawShape('qua',x+sx,y+sy,z*sz,5,.25, 6,1, 5.5,2, 5,2.5,`rgba(${64},${32},${0},1)`,1,10,7);
      
      
      sx = .5*z;
      sy = 2.75*z;
      sz = .4;
			drawShape('rec',x+sx,y+sy,z*sz,1,1,8,5,0,0,0,0,'rgba(64,32,0,1)',1);
			drawShape('tri',x+sx,y+sy,z*sz,1,6,5.1,9,9,6,0,0,'rgba(64,32,0,1)',1);
      drawShape('rec',x+sx,y+sy,z*sz,1,1,8,5,0,0,0,0,`rgba(${0},${Math.random()*255},${0},.1)`,1);
			drawShape('tri',x+sx,y+sy,z*sz,1,6,5.1,9,9,6,0,0,`rgba(${0},${Math.random()*255},${0},.1)`,1);

      drawShape('tri',x,y,z,6,5, 7,7, 5,6, 5,2.5,`rgba(${64},${32},${0},.8)`,1,10,7);
      drawShape('tri',x,y,z,4,5, 3,7, 5,6, 5,2.5,`rgba(${64},${32},${0},.8)`,1,10,7);
      drawShape('qua',x,y,z,4,5.5, 2.5,8, 4,8, 5,6,`rgba(${64},${32},${0},.7)`,1,10,7);
      drawShape('qua',x,y,z,6,5.5, 7.5,8, 6,8, 5,6,`rgba(${64},${32},${0},.7)`,1,10,7);
      drawShape('pol',x,y,z,7.5,3.2, 8,4, 7.5,5, 7.5,4,`rgba(${64},${32},${0},1)`,1,6.5,3);
      drawShape('qua',x,y,z,7,4.5, 7.55,4.75, 7.75,5.3, 7.25,5,`rgba(${64},${32},${0},1)`,1,6.5,3);
      drawShape('tri',x,y,z,7.25,4.75, 7.6,5.1, 5,7.5, 7.25,5,`rgba(${0},${64+Math.random()*100},${0},1)`,1,6.5,3);
      drawShape('qua',x,y,z,4,8, 4,9, 1,9, 3.1,6.9,`rgba(${32},${16},${0},1)`,1,6.5,3);
      drawShape('qua',x,y,z,6,8, 6,9, 9,9, 6.9,6.9,`rgba(${32},${16},${0},1)`,1,6.5,3);


    break;
    case 76://Elf Queen      
         
    
       
    drawShape('qua',x,y,z,0,5, 5,Math.random()*.2, 10,5, 5,10,'rgba(0,255,0,.15)',1,2,10);//lower arm R
    //right calf 
    
       
            drawShape('arc',x,y,z,4.8,4.9,.05,0,6,0,0,0,'rgba(0,128,0,.25)',1);//r-hand

          drawShape('arc',x,y,z,7.5,2,.75,0,6,0,0,0,'rgba(0,128,0,.075)',1);//r-hand
        drawShape('pol',x,y,z,7,4, 5,9, 4,5, 4.5,4,'rgba(0,128,0,.25)',1,5,2.5);

     aniDice2.setColor(0,1, 0)
      aniDice2.setGlow(Math.random())
      aniDice2.animate(x+7.55*z,y+2*z,1*z,.25,globalDt);

        drawShape('qua',x,y,z,4.25,2, 4.5,3, 5,2.5, 4.55,1.5,'rgba(64,32,0,1)',1);
        drawShape('pol',x,y,z,4.45,5.5, 4,7.5, 4.5,7.5, 4.5,7,'rgba(0,128,0,.5)',1,5.25,5.5);
        drawShape('pol',x,y,z,5.6,5, 6,6.5, 6,7, 5.6,7.5,'rgba(0,128,0,.5)',1,5.6,6.5);
        drawShape('tri',x,y,z,5.75,7, 5,5.5, 5.6,5, 5.5,7.5,'rgba(0,128,0,.5)',1,5.6,6.5);
        drawShape('pol',x,y,z,5.5,5, 5.4,4.5, 5.5,3.5, 6.9,4.8,'rgba(0,128,0,.5)',1,5.5,3);

      //legs red boots
      sx = -.5*z; 
      sy = -.1*z;
      sz = 1.1;
      drawShape('qua',x+sx,y+sy,z*sz, 5.5,7, 5.8,8.5, 6,8, 6,6.5,'rgba(0,128,0,.5)',1);
      drawShape('qua',x+sx,y+sy,z*sz, 4,7, 4,8.5, 4.25,8.3, 4.5,7,'rgba(0,128,0,.5)',1);
      drawShape('qua',x+sx,y+sy,z*sz, 4,8.25, 3.6,9, 4,8.8, 4.35,8.23,'rgba(0,128,0,1)',1);
      drawShape('qua',x+sx,y+sy,z*sz, 6,8, 6.3,9, 6,9, 5.7,8.5,'rgba(0,128,0,1)',1);
      //Empress upper
      sz = .8;
      sx = 1*z;
      sy = .0*z;
      //drawShape('qua',x+sx,y+sy,z*sz, 5.25,3, 5.5,3.5, 5,4, 4.5,2.5,'rgba(0,128,0,1)',1);//neck
      drawShape('qua',x+sx,y+sy,z*sz, 4.5,2.5, 5.5,3.5, 5,4, 4.5,2.5,'rgba(255,196,168,.9)',1);//neckL

      drawShape('qua',x+sx,y+sy,z*sz,4,1.8, 3.9,3, 4.25,3.25, 4.25,1.75,'rgba(64,32,0,.75)',1);//bangs left
      drawShape('qua',x+sx,y+sy,z*sz, 5.25,3.5, 4,2.2, 5,1.3, 6,2.5,'rgba(255,196,168,1)',1);//face
      //nose
      sz = .8;
      sx = .8*z;
      sy = .0*z;
      drawShape('tri',x+sx,y+sy,z*sz, 5.45,2.2, 5.4,2.8, 5.6,2.9, 0,0,'rgba(0,0,0,.2)',1);//nose
      //eyes
      sz = .8;
      sx = .8*z;
      sy = .0*z;
      drawShape('tri',x+sx,y+sy,z*sz, 5,2.2, 5.4,2.15, 5.2,2.3, 0,0,'rgba(0,0,0,.3)',1);//eye
      drawShape('tri',x+sx,y+sy,z*sz, 5.5,2.15, 5.9,2.1, 5.7,2.3, 0,0,'rgba(0,0,0,.3)',1);//eye
      //mouth 
      sz = .8;
      sx = .8*z;
      sy = .0*z;
      drawShape('tri',x+sx,y+sy,z*sz, 5.25,3, 5.6,2.95, 5.4,3.075, 0,0,'rgba(64,0,0,.4)',1);//mouth
      //hair
      sz = .8;
      sx = 1*z;
      sy = .0*z;
      drawShape('qua',x+sx,y+sy,z*sz,5,1.3, 4.2,1.75, 4,2.2, 5,1.85,'rgba(64,32,0,1)',1);//hair
      drawShape('qua',x+sx,y+sy,z*sz,5,1.3, 5.8,1.75, 6,2, 5,1.85,'rgba(64,32,0,1)',1);
       
      drawShape('qua',x+sx,y+sy,z*sz,5.55,1.9, 6,2.5, 5.8,3.4, 6,3.5,'rgba(64,32,0,1)',1);
      drawShape('qua',x+sx,y+sy,z*sz,5.55,1.9, 6,2.5, 5.8,3.4, 6,2,'rgba(64,32,0,.75)',1);
      //drawShape('qua',x,y,z,4.25,1.9, 3.8,2.5, 4,3.4, 3.8,3.5,'gold',1);
      drawShape('qua',x+sx,y+sy,z*sz,5,1.8, 4.28,2.07, 4.8,3.4, 4.5,3.5,'rgba(64,32,0,1)',1);
      drawShape('qua',x+sx,y+sy,z*sz,4.28,2.07, 3.85,2.5, 4.05,3.4, 3.85,3.5,'rgba(64,32,0,.75)',1);
      //larm
       sz = .8;
      sx = 1.25*z;
      sy = 1*z;
      drawShape('qua',x+sx,y+sy,z*sz, 3.9,4, 3,6, 3.5,6, 4,5,'rgba(0,128,0,.5)',1);//dress left forearm
        
 drawShape('qua',x+sx,y+sy,z*sz, 3.4,6, 2.5,9, 2.4,8, 3.2,5.9,'green',1);//scepter
      drawShape('qua',x+sx,y+sy,z*sz, 3.4,6, 2.7,8, 2.4,8, 3.2,5.9,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.3)`,1);//scepter

          drawShape('qua',x+sx,y+sy,z*sz, 3,6, 3.5,6, 3.4,6.3, 3,6.5,'rgba(0,128,0,1)',1);//left hand

       sz = .7;
      sx = 1.7*z;
      sy = 3.45*z;
      drawShape('qua',x+sx,y+sy,z*sz, 2.8,4, 2.75,3.4, 3,3.6, 3.4,3.9,'rgba(0,128,0,1)',1);//left hand
         sz = .8;
      sx = 1.36*z;
      sy = .8*z;

     drawShape('qua',x+sx,y+sy,z*sz, 3.4,6.55, 3.2,6.5, 3.25,6.45, 3.2,6.3,'rgba(0,128,0,1)',1);//left thumb
      sz = .8;
      sx = 1.25*z;
      sy = 1*z;
     // drawShape('qua',x+sx,y+sy,z*sz, 4.5,6, 4.5,4.5, 3.9,4, 4,6,'rgba(0,128,0,1)',1);//dress left arm
     // drawShape('qua',x+sx,y+sy,z*sz, 5,6, 5.5,3, 4.5,4.5, 4.5,6,'rgba(0,128,0,1)',1);//dress left mid
      //
       sz = .8;
      sx = 1*z;
      sy = .0*z;
      //drawShape('qua',x+sx,y+sy,z*sz, 5.5,3.5, 6,3.5, 6.5,3.75, 7.5,5,'rgba(0,128,0,1)',1);//dress right shoulder n tricep
      //drawShape('qua',x+sx,y+sy,z*sz, 6.5,5, 6,6, 7,9.5, 3,9.5,'rgba(0,128,0,1)',1);//dress bottom right n forearm
      //drawShape('qua',x+sx,y+sy,z*sz, 7.5,5, 6,6, 7,9.5, 3,9.5,'rgba(0,128,0,1)',1);//dress bottom right n forearm
      drawShape('qua',x+sx,y+sy,z*sz, 5.5,3.5, 5,4, 5,7.5, 7.5,5,'rgba(0,128,0,.5)',1);//dress collarR
      drawShape('qua',x+sx,y+sy,z*sz, 5,4, 4.8,3.4, 4.5,3.5, 4,4,'rgba(0,128,0,.5)',1);//dress collarL
           sz = .8;
      sx = .83*z;
      sy = .0*z;
       drawShape('qua',x+sx,y+sy,z*sz, 4.5,4, 4,4.5, 4.45,5, 5,4.9,'rgba(0,128,0,.25)',1);//bl
        sx = .5*z;
        sy = .0*z;
       drawShape('qua',x+sx,y+sy,z*sz, 5.5,4, 4.8,4.5, 5.25,5, 5.8,4.9,'rgba(0,128,0,.5)',1);//brmain

      //
      sz = .8;
      sx = 2*z;
      sy = .0*z;
      drawShape('qua',x+sx,y+sy,z*sz, 6.1,6, 7,4, 6.5,4, 6,5,'rgba(0,128,0,.5)',1);//dress left forearm
        
      drawShape('qua',x+sx,y+sy,z*sz, 7,4, 6.5,4, 6.6,3.7, 7,3.5,'rgba(0,128,0,1)',1);//left hand

      drawShape('qua',x+sx,y+sy,z*sz, 7,4, 7.4,3.4, 7,3.5, 6.5,3.4,'rgba(0,128,0,1)',1);//left hand
        
      drawShape('tri',x+sx,y+sy,z*sz, 7.4,3.4, 6.5,3.4, 7,3.5, 7.25,1,'rgba(0,128,0,1)',1);//left fingers
      drawShape('qua',x+sx,y+sy,z*sz, 6.6,3.45, 6.75,3.5, 6.75,3.55, 6.6,3.7,'rgba(0,128,0,1)',1);//left thumb

     // drawShape('qua',x+sx,y+sy,z*sz, 5.5,4, 5.5,5.5, 6.1,6, 6,4,'rgba(0,128,0,1)',1);//dress left arm
     // drawShape('qua',x+sx,y+sy,z*sz, 5,4, 4.5,7, 5.5,5.5, 5.5,4,'rgba(0,128,0,1)',1);//dress left mid
     //////
      drawShape('pol',x,y,z, 4.5,3.2, 4.4,4.25, 4.5,6.5, 5,6,'rgba(0,128,0,1)',1,5,3);//brmain
           
      drawShape('pol',x,y,z, 4.25,1.5, 4,1, 4.5,1.75, 4.5,1,'rgba(0,128,0,1)',1,5,1.5);//brmain
      drawShape('pol',x,y,z, 5.75,1.5, 6,1, 5.5,1.75, 5.5,1,'rgba(0,128,0,1)',1,5,1.5);//brmain
      drawShape('pol',x,y,z, 4.25,1.5, 4,1, 4.5,1.75, 4.5,1,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.5)`,1,5,1.5);//brmain
      drawShape('pol',x,y,z, 5.75,1.5, 6,1, 5.5,1.75, 5.5,1,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.5)`,1,5,1.5);//brmain
   
        break;
    case 77://Giant  
      drawShape('arc',x,y,z,8.5,1.25,1,0,3,0,0,0,'rgba(255,255,0,.25)',1);//r-hand
      drawShape('arc',x,y,z,8.5,1.25,1,0,3,0,0,0,'rgba(255,255,0,.25)',1);//r-hand
      drawShape('arc',x,y,z,8.5,1.25,1,0,3,0,0,0,'rgba(255,255,0,.25)',1);//r-hand
      drawShape('arc',x,y,z,8.5,1.25,1,0,3,0,0,0,'rgba(255,255,0,.25)',1);//r-hand
      drawShape('arc',x,y,z,8.5,1.25,1,0,3,0,0,0,'rgba(255,255,0,.25)',1);//r-hand
      drawShape('qua',x,y,z,0,5, 5,Math.random()*.2, 10,5, 5,10,'rgba(0,255,0,.15)',1,2,10);//lower arm R
      drawShape('tri',x,y,z,4.5,10, 2.5,5.5, 0,10, 10,10,'rgba(255,255,255,.2)',1,6.5,7);//lower arm R
      drawShape('qua',x,y,z,5,10, 8,5, 10,9, 10,10,'rgba(255,255,255,.2)',1,6.5,7);//lower arm R    
      sx = 1*z;
      sy = 0*z;
      sz = 1;
      drawShape('qua',x+sx,y+sy,z*sz,3,4, 2.5,5, 2,4.5, 2,3,'rgba(255,174,94,.75)',1,6.5,7);//lower arm R
      drawShape('pol',x+sx,y+sy,z*sz,2.5,5, 1.5,4.5, .75,3.5, 1,3,'rgba(255,174,94,.75)',1,2,4);//lower arm R
      drawShape('pol',x+sx,y+sy,z*sz,.25,3.75, 5,1.5, 5.25,.75, 4.75,.25,'rgba(53,32,13,1)',1,.1,3.45);//lower arm R
      drawShape('pol',x+sx,y+sy,z*sz,1,3, 1,2.75, .5,2.9, .9,3,'rgba(255,174,94,.75)',1,1,3.5);//lower arm R
      drawShape('tri',x+sx,y+sy,z*sz,1,2.75, 1.5,3.5, 1,3.5, .9,3,'rgba(255,174,94,.75)',1,1,3.5);//lower arm R
      drawShape('tri',x+sx,y+sy,z*sz,.5,2.9, 1,3, .5,3.5, .9,3,'rgba(255,174,94,.75)',1,1,3.5);//lower arm R
      drawShape('pol',x+sx,y+sy,z*sz,3.5,1.5, 6,2.5, 3.5,4, 2,3,'rgba(255,174,94,.9)',1,2.5,2);//lower arm R
      drawShape('pol',x+sx,y+sy,z*sz,2,3, 3.5,5, 6,4.5, 5.5,2.5,'rgba(255,174,94,.75)',1,3.5,4);//lower arm R
      drawShape('pol',x+sx,y+sy,z*sz,4,4.5, 5,7, 6,8, 6.5,7,'rgba(255,174,94,.75)',1,6,4.5);//lower arm R
      drawShape('pol',x+sx,y+sy,z*sz,5.5,7.5, 5.75,8.5, 7,9.5, 7,8,'rgba(255,174,94,.75)',1,6.5,7);//lower arm R
      drawShape('pol',x+sx,y+sy,z*sz,1,6.5, 1.5,9, 2.,9, 2.5,7.5,'rgba(255,174,94,.75)',1,2,7);//lower arm R
      drawShape('tri',x+sx,y+sy,z*sz,2,7, 5.5,5.8, 4,5.5, 4,6,'rgba(255,174,94,1)',1,5,5);//lower arm R
      drawShape('pol',x+sx,y+sy,z*sz,3.5,5, 1,6.5, 2,7, 4,6,'rgba(255,174,94,1)',1,5,5);//lower arm R
      drawShape('pol',x+sx,y+sy,z*sz,2,9, 2,10, 0,10, 1.5,9.5,'rgba(255,174,94,1)',1,1.5,9);//lower arm R
      drawShape('pol',x+sx,y+sy,z*sz,5.9,8.6, 6.5,9.5, 6.5,10, 8.25,10,'rgba(255,174,94,1)',1,7.25,9.5);//lower arm R
      drawShape('pol',x+sx,y+sy,z*sz,3.5,5, 3.5,6.25, 5.5,6, 6.5,6,'rgba(0,64,0,1)',1,6,4);//lower arm R
      drawShape('pol',x+sx,y+sy,z*sz,6,4, 4,2.5, 2.25,2.5, 2,3,'rgba(0,64,0,1)',1,3.5,5);//lower arm R
      drawShape('qua',x+sx,y+sy,z*sz,2.25,2.5, 3,3, 6,2.5, 3,1,'rgba(0,128,0,.75)',1,3.5,5);//lower arm R
      drawShape('pol',x+sx,y+sy,z*sz,6,2.5, 6.5,4, 5,6, 5.25,4,'rgba(255,174,94,1)',1,4.4,2.8);//lower arm R
      drawShape('pol',x+sx,y+sy,z*sz,2,1, 3,.5, 4,1, 3,2.5,'rgba(255,174,94,1)',1,2.25,1.75);//lower arm R
      drawShape('tri',x+sx,y+sy,z*sz,2.5,1.5, 2.5,1, 2.25,1.5, 3,1,'rgba(0,0,0,.5)',1,3.5,5);//lower arm R
      drawShape('tri',x+sx,y+sy,z*sz,2.5,1.1, 2,1, 2.25,1.25, 3,1,'rgba(0,0,0,.5)',1,3.5,5);//lower arm R
      drawShape('tri',x+sx,y+sy,z*sz,2.5,1.1, 3,1, 2.75,1.25, 3,1,'rgba(0,0,0,.5)',1,3.5,5);//lower arm R
      drawShape('tri',x+sx,y+sy,z*sz,2.5,2, 3,2, 2.75,1.9, 3,1,'rgba(0,0,0,.5)',1,3.5,5);//lower arm R
      sx = 2.75*z;
      sy = 3*z;
      sz = .4;
      drawShape('arc',x+sx,y+sy,z*sz,4.8,5,4.5,0,6,0,0,0,'rgba(40,20,0,1)',1);
      drawShape('arc',x+sx,y+sy,z*sz,5,5,4.5,0,6,0,0,0,'rgba(85,43,0,1)',1);
      drawShape('rec',x+sx,y+sy,z*sz,0.5,5,9,.11,0,0,0,0,'rgba(0,0,0,.35)',1)
      drawShape('rec',x+sx,y+sy,z*sz,.95,3,8.1,.11,0,0,0,0,'rgba(0,0,0,.35)',1)
      drawShape('rec',x+sx,y+sy,z*sz,1,7,8,.11,0,0,0,0,'rgba(0,0,0,.35)',1)
      drawShape('qua',x+sx,y+sy,z*sz,5,4,6,5,5,6,4,5,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,3,1, 7,1.1, 2.8,1.2, 8,2,'rgba(0,0,0,.35)',1);
      drawShape('qua',x+sx,y+sy,z*sz,3-1,1+1, 7-1,1.1+1, 2.8-1,1.2+1, 8-1,2+1,'rgba(0,0,0,.35)',1);
      drawShape('qua',x+sx,y+sy,z*sz,1+3,1+2, 1+7,1.1+2, 1+2.8,1.2+2, 1+8,2+2,'rgba(0,0,0,.35)',1);
      drawShape('qua',x+sx,y+sy,z*sz,1+3,1+5, 1+7,1.1+5, 1+2.8,1.2+5, 1+8,2+5,'rgba(0,0,0,.35)',1);
      drawShape('qua',x+sx,y+sy,z*sz,3,1+6, 7,1.1+6, 2.8,1.2+6, 8,2+6,'rgba(0,0,0,.35)',1);
      drawShape('qua',x+sx,y+sy,z*sz,3-1,1+7, 7-1,1.1+7, 2.8-1,1.2+7, 8-1,2+7,'rgba(0,0,0,.35)',1);
      break;
    case 20.1: //HEART
			drawShape('tri',x,y,z,0,6.59,5,10,10,6.6,0,0,'rgb(255,72,72)',1);
			drawShape('arc',x,y,z,2.25,3.7,3.63,0,6,0,0,0,'rgb(255,72,72)',1);
			drawShape('arc',x,y,z,7.75,3.7,3.63,0,6,0,0,0,'rgb(255,72,72)',1);
			drawShape('arc',x,y,z,5,7,3,3,0,0,0,0,'rgb(255,72,72)',1);
			break;
  	case 20.1: //HEARTShield
			drawShape('tri',x,y,z,-1.26,4.9, 5,13, 10,6.6, 0,0,'gray',1);
			drawShape('arc',x,y,z,2.25,3.7,3.63,0,6,0,0,0,'gray',1);
			drawShape('arc',x,y,z,7.75,3.7,3.63,0,6,0,0,0,'gray',1);
			drawShape('arc',x,y,z,5,7,3,3,0,0,0,0,'gray',1);
			break;
  	case 13.1: //WBOOT
			drawShape('qua',x,y,z,4.9,1, 5.1,.7, 5.22,.9, 3.4,6.4,'gray',1);
			drawShape('qua',x,y,z,4.75,2, 4.75,2, 5.5,4.2, 3.3,6.4,'rgba(128,64,0,1)',1);
			drawShape('qua',x,y,z,3.5,1, 5,9.45, 8.3,7.4, 8.5,1,'rgba(128,64,0,1)',1)
			drawShape('qua',x,y,z,3.75,1, 6,9.45, 4.5,7.4, 8,1,'rgba(0,0,0,.06)',1)
			drawShape('qua',x,y,z*1.1,7.8,1, 8,.7, 8.3,4.2, 6.3,6.4,'lightgray',1);
			drawShape('qua',x,y,z*1.1,7.8,1, 8,.7, 8.02,.9, 6.3,6.4,'gray',1);
			drawShape('ell',x,y,z,4,7.2, 2.9,2.4,1,0,6,0,'rgba(128,64,0,1)',1);
			drawShape('ell',x,y,z,4,7.2, 2.9,2.4,1,0,6,0,'rgba(0,0,0,.06)',1);
			break;
		case 28888://Trick7
      drawShape('arc',x,y,z,5,5,5,0,2,0,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.015)`,1);//bag

      drawShape('qua',x,y,z,4,0.5, 6,0.5, 5.5,8.25, 4.5,8.25,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.025)`,1);
      drawShape('arc',x,y,z,5,9.25,.75,0,2,0,0,0,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.025)`,1);//bag

      sx = 2.8*z;
      sy = -7.2*z;
      sz = 2;
      for (let i = 0;i<64;i++){
        drawShape('ell',x+sx,y+sy,z*sz,    1+i*.001, 6+i*.001,        2-i*.01,   .5+i*.01,  0,    0,   2,    0,   `rgba(${255},${155},${155},1)`,1)
        drawShape('ell',x+sx,y+sy,z*sz,    1+i*.001, 6+i*.001,        2-i*.01,   .5+i*.01,  0,    1.1,   -.1,    0,   `rgba(${255},${179},${102},1)`,1)
        drawShape('ell',x+sx,y+sy,z*sz,    1+i*.001, 6+i*.001,        2-i*.01,   .5+i*.01,  0,    .1,  .9,    0,   `rgba(${255},${179},${102},1)`,1)
        drawShape('ell',x+sx,y+sy,z*sz,    1+i*.001, 6+i*.001,        2-i*.01,   .5+i*.01,  0,    1.1,   -.1,    0,   `rgba(${0},${0},${0},.2)`,1)
        drawShape('ell',x+sx,y+sy,z*sz,    1+i*.001, 6+i*.001,        2-i*.01,   .5+i*.01,  0,    .1,  .9,    0,   `rgba(${0},${0},${0},.2)`,1)
      }
      sz = .75;
      sx = 1.05*z;
      sy = 1.1*z;

      drawShape('ell',x+sx,y+sy,z*sz,    5.1, 5.1,        4.1,   2.1,  0,    2,  0,    0,   `rgba(${255},${255},${255},1)`,1)
      drawShape('ell',x+sx,y+sy,z*sz,    5.1, 5.1,        2,   2,  0,    2,  0,    0,   `rgba(${180},${180},${255},1)`,1)

      drawShape('ell',x+sx,y+sy,z*sz,    5.1, 5.1,        .25,   .25,  0,    2,  0,    0,   `rgba(${0},${0},${0},1)`,1)
      //drawShape('qua',x,y,z,4,0.5, 6,0.5, 5.5,8.25, 4.5,8.25,'rgba(255,0,0,.131)',1);
      //drawShape('arc',x,y,z,5,9.25,.75,0,2,0,0,0,'rgba(255,0,0,.131)',1);//bag
      drawShape('tri',x,y,z,4.5,5, 3.5,5, 3.6,5.1,    5.1,8.25,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)})`,1);
      drawShape('tri',x,y,z,4.65,5.1, 3.75,5.75, 3.76,5.5,    5.1,8.25,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)})`,1);
      drawShape('tri',x,y,z,4.75,5.2, 4.5,6, 4.25,6,    5.1,8.25,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)})`,1);

      drawShape('tri',x,y,z,5,5.25, 5.5,6, 5.8,6,    5.1,8.25,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)})`,1);
      drawShape('tri',x,y,z,5.45,5, 5.95,5, 6.35,5.1,    5.1,8.25,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)})`,1);
      drawShape('tri',x,y,z,5.2,5.1, 6.1,5.75, 6.1,5.5,    5.1,8.25,`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)})`,1);
      drawShape('tri',x,y,z,4.9,4.75, 4.85,3.75, 4.95,3.75,    5.1,8.25,'brown',1);
      drawShape('ell',x+sx,y+sy,z*sz,    5.1, 5.1,        2,   2,  0,    2,  0,    0,   `rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},.25)`,1)

      break;
    case 3.1://SKELETON
			//ribs+spine
			drawShape('ell',x,y,z,5,5,1,1,0,0.1,.9,0,'lightgray',1);//rib5
			drawShape('ell',x,y,z,5,5,.75,.7,0,0.1,.9,0,'black',1);//rib5-shadow
			drawShape('ell',x,y,z,5,4.5,1.5,1,0,0.1,.9,0,'lightgray',1);//rib4
			drawShape('ell',x,y,z,5,4.5,1,.7,0,0.1,.9,0,'black',1);//rib4-shadow
			drawShape('ell',x,y,z,5,4,1.5,1,0,0.1,.9,0,'lightgray',1);//rib3
			drawShape('ell',x,y,z,5,4,1,.7,0,0.1,.9,0,'black',1);//rib3-shadow
			drawShape('ell',x,y,z,5,3.5,1.5,1,0,0.1,.9,0,'lightgray',1);//rib2
			drawShape('ell',x,y,z,5,3.5,1,.7,0,0.1,.9,0,'black',1);//rib2-shadow
			drawShape('ell',x,y,z,5,3,1.5,1,0,0.1,.9,0,'lightgray',1);//rib1
			drawShape('ell',x,y,z,5,3,1,.7,0,0.1,.9,0,'black',1);//rib1-shadow
			drawShape('lin',x,y,z,5,3.5,5,6,0,0,0,0,'gray',0);//spine
			//head
			drawShape('arc',x,y,z,5,1.5,1.5,0,6,0,0,0,'lightgray',1);//head
			drawShape('arc',x,y,z,5.5,1.5,.5,0,6,0,0,0,'black',1);//r-eye
			drawShape('arc',x,y,z,4.5,1.5,.5,0,6,0,0,0,'black',1);//l-eye
			drawShape('lin',x,y,z,5.1,1.3,3.9,.75,0,0,0,0,'black',0);//l-eyebrow
			drawShape('lin',x,y,z,4.9,1.3,6.1,.75,0,0,0,0,'black',0);//l-eyebrow
			drawShape('tri',x,y,z,5,2,4.5,2.5,5.5,2.5,0,0,'black',1);//nose
			drawShape('lin',x,y,z,5,2,5,2.4,0,0,0,0,'lightgray',0);//nostrils
			drawShape('ell',x,y,z,5,3,1,.5,0,0,6,0,'lightgray',1);//jaw
			drawShape('lin',x,y,z,4,3,6,3,0,0,0,0,'black',0);//mouth
			//arms
			drawShape('arc',x,y,z,3.5,3.5,.5,0,6,0,0,0,'lightgray',1);//l-shoulder
			drawShape('arc',x,y,z,6.5,3.5,.5,0,6,0,0,0,'lightgray',1);//r-shoulder
			drawShape('arc',x,y,z,3.5,3.5,.5,0,6,0,0,0,'black',0);//l-shoulder-shadow
			drawShape('arc',x,y,z,6.5,3.5,.5,0,6,0,0,0,'black',0);//r-shoulder-shadow
			drawShape('tri',x,y,z,3,3.5,3.5,4,2,5,0,0,'lightgray',1);//l-arm
			drawShape('tri',x,y,z,7,3.5,6.5,4,8,5,0,0,'lightgray',1);//r-arm
			drawShape('tri',x,y,z,2,5,1.5,6.5,2.4,4.9,0,0,'lightgray',1);//l-forearm
			drawShape('tri',x,y,z,7.8,4.8,8.5,6.3,7.5,4.8,0,0,'lightgray',1);//r-forearm
			drawShape('arc',x,y,z,1.7,6.3,.35,0,6,0,0,0,'lightgray',1);//l-hand
			drawShape('arc',x,y,z,8.1,6.1,.35,0,6,0,0,0,'lightgray',1);//r-hand
			//lower body
			drawShape('ell',x,y,z,5,6.5,1,.5,0,0,6,0,'lightgray',1);//hip
			drawShape('arc',x,y,z,5.75,6.5,.5,0,6,0,0,0,'gray',1);//hip
			drawShape('arc',x,y,z,4.25,6.5,.5,0,6,0,0,0,'gray',1);//hip
			drawShape('tri',x,y,z,6.15,6.4, 5.4,6.75, 8,8, 0,0,'lightgray',1);//r-leg
			drawShape('tri',x,y,z,3.85,6.4, 4.6,6.75, 2,8, 0,0,'lightgray',1);//l-leg
			drawShape('tri',x,y,z,2,8,2.5,7.5,4,10, 0,0,'lightgray',1);//l-shin
			drawShape('tri',x,y,z,8,8,7.5,7.5,6,9, 0,0,'lightgray',1);//r-shin
			drawShape('tri',x,y,z,4,10,1.75,10,3.5,9.3, 0,0,'lightgray',1);//l-foot
			drawShape('tri',x,y,z,6.8,8.3,8,10,6,9, 0,0,'lightgray',1);//r-foot
			break;
    case 3.2: //skull
    			//head
      drawShape('arc',x,y,z,5,5,5,0,6,0,0,0,'rgba(0,0,0,.4)',1);//head
      drawShape('arc',x,y,z,5,5,4.55,0,6,0,0,0,'rgba(0,0,0,.15)',1);//head
      drawShape('arc',x,y,z,5,5,4.2,0,6,0,0,0,'rgba(0,0,0,.15)',1);//head
          sx = -8.75*z;
          sy = .2 * z;
          sz = 2.75;
			drawShape('arc',x+sx,y+sy,z*sz,5,1.5,1.5,0,6,0,0,0,'lightgray',1);//head
			drawShape('arc',x+sx,y+sy,z*sz,5.5,1.5,.5,0,6,0,0,0,'black',1);//r-eye
			drawShape('arc',x+sx,y+sy,z*sz,4.5,1.5,.5,0,6,0,0,0,'black',1);//l-eye
			drawShape('lin',x+sx,y+sy,z*sz,5.1,1.3,3.9,.75,0,0,0,0,'black',0);//l-eyebrow
			drawShape('lin',x+sx,y+sy,z*sz,4.9,1.3,6.1,.75,0,0,0,0,'black',0);//l-eyebrow
			drawShape('tri',x+sx,y+sy,z*sz,5,2,4.5,2.5,5.5,2.5,0,0,'black',1);//nose
			drawShape('lin',x+sx,y+sy,z*sz,5,2,5,2.4,0,0,0,0,'lightgray',0);//nostrils
			drawShape('ell',x+sx,y+sy,z*sz,5,3,1,.5,0,0,6,0,'lightgray',1);//jaw
			drawShape('lin',x+sx,y+sy,z*sz,4,3,6,3,0,0,0,0,'black',0);//mouth

      break;
		case 4.1://KNIGHT(emperor)
			drawShape('tri',x,y,z,5,5.5,/*tr*/ 4,8,/*br*/ 3.5,7,/*bl*/ 0,0,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.39)`,1);//l-thigh
				drawShape('qua',x,y,z,4.5,9.1,/*tr*/4.5,9.6,/*br*/ 2,9.6,/*l*/4.5,8.6,/*tl*/`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.39)`,1);//l-foot
				drawShape('qua',x,y,z,4.5,9.5,/*br*/ 4.5,7.7,/*tr*/ 3.3,7.3,/*tl*/ 3.9,9,/*bl*/`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.39)`,1);//l-calf
				drawShape('qua',x,y,z,4.5,9.5,/*br*/ 4.5,7.7,/*tr*/ 3.3,7.3,/*tl*/ 3.9,9,/*b*/`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.39)`,0);//l-calf
				drawShape('arc',x,y,z,4.25,2.65, .63,0, 3,0, 0,0,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.39)`,1);//l-shoulder
				drawShape('arc',x,y,z,4.25,2.65, .63,0, 3,0, 0,0,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.39)`,0);//l-shoulder-shadow
				drawShape('ell',x,y,z,5.15,3.6,1.15,1.75,0,0,6,0,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.39)`,1);//torso
				drawShape('qua',x,y,z,4.7,2,5.5,1.5,6,2.5,4.25,2.5,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.39)`,1);//neck
				drawShape('arc',x,y,z,5,1,1,0,2,0,0,0,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.39)`,1);//head
				drawShape('tri',x,y,z,3.5,1.5,4.3,.25,4.9,2,0,0,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.39)`,1);//helm nose
				drawShape('qua',x,y,z,4.5,5.5,/*tl*/6,4.5,/*tr*/ 6.5,7.7,/*br*/ 5.8,8,/*bl*/ `rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.39)`,1);//r-thigh
				drawShape('qua',x,y,z,5.5,8,/*tl*/6.25,7.25,/*tm*/6.75,8,/*tr*/ 6.25,9.5,/*b*/`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.39)`,1);//r-calf
				drawShape('qua',x,y,z,5.5,8,/*tl*/6.25,7.25,/*tm*/6.75,8,/*tr*/ 6.25,9.5,/**/`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.39)`,0);//r-calf
				drawShape('qua',x,y,z,6.25,9,/*t*/5.6,9.6,/*bl*/6.25,10,/*bm*/ 6.9,9.6,/*br*/`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.39)`,1);//r-foot
				drawShape('qua',x,y,z,6.2,4.3,7.25,7.25,5.1,6.3,4.75,5.25,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.39)`,1);//hip armor
				drawShape('qua',x,y,z,6.2,4.3,7.25,7.25,5.1,6.3,4.75,5.25,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.39)`,0);//hip armor
				drawShape('qua',x,y,z,4.5,7, 5.2,5, 4.5,5.2, 4.2,5,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.39)`,1);//groin armor
				drawShape('qua',x,y,z,4.5,7, 5.2,5, 4.5,5.2, 4.2,5,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.39)`,0);//groin armor
				drawShape('qua',x,y,z,2.75,1.75, 4.5,2.75, 4.5,5.8, 2.75,4.8,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.39)`,1);//shield top
				drawShape('tri',x,y,z,2.75,4.8,4.5,5.8,3.5,7.5,0,0,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.39)`,1);//shield bot
				drawShape('lin',x,y,z,3.5,7.6,3.45,2.1,0,0,0,0,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.39)`,0);//shield cross |
				drawShape('lin',x,y,z,2.75,4,4.5,5,0,0,0,0,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.39)`,0);//shield cross--
				drawShape('tri',x,y,z,/*tl*/ 5.55,3.55, /*tr*/6.3,2.5, /*br*/7.7,4, 0,0,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.39)`,1);//r-arm
				drawShape('tri',x,y,z,/*tl*/ 5.6,3.5, /*tr*/6.3,2.5, /*br*/7.7,4, 0,0,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.39)`,0);//r-arm
				drawShape('tri',x,y,z,/*br*/ 7.9,3.9, /*tr*/7.3,3.4, /*l*/6,6, 0,0,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.39)`,1);//r-forearm
				drawShape('tri',x,y,z,/*br*/ 7.9,3.9, /*tr*/7.3,3.4, /*l*/6,6, 0,0,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.39)`,0);//r-forearm
				drawShape('qua',x,y,z,5.9,5.5, 5.9,5.7, 7.2,6.1, 7.2,5.7,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.39)`,1);//sword-hilt
				drawShape('arc',x,y,z,6.2,5.75,.4,0,3,0,0,0,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.39)`,1);//r-hand
				drawShape('tri',x,y,z,1,4.6, 5.9,5.35, 6.1,6.15,0,0,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.39)`,1);//sword-blade
				drawShape('qua',x,y,z,5.8,4.5,5.9,5.7,6.3,6.8,6.4,6,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.39)`,1);//sword-crossguard
				drawShape('arc',x,y,z,6,3, .63,0, 3,0, 0,0,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.39)`,1);//r-shoulder
				drawShape('arc',x,y,z,6,3, .63,0, 3,0, 0,0,`rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},.39)`,0);//r-shoulder
				drawShape('qua',x,y,z,5.8,.7, 3.95,.8, 4.1,.5, 4.25,.6,'black',1);//helmet visor
     


        break;
    }
}
debug = 0;
let portrait =70.1;

function getAniValues(at, duration, startX, endX, startY, endY, startSize, endSize) {
    /**
 * Calculates animation position with Lerp, Safety Clamping, and Center Offset.
 * Returns {x, y, z} where Z is the Scale.
 * * @param {number} at        - Current timer value.
 * @param {number} duration  - Total animation time (e.g. 70).
 * @param {number} startX    - Starting Center X.
 * @param {number} endX      - Ending Center X.
 * @param {number} startY    - Starting Center Y.
 * @param {number} endY      - Ending Center Y.
 * @param {number} startSize - Starting Scale.
 * @param {number} endSize   - Ending Scale.
 */
  // 1. Calculate Progress & Clamp (Safety Net)
    let t = at / duration;
    if (t > 1) t = 1;
    if (t < 0) t = 0;

    // 2. Lerp the Center Positions
    let centX = startX + (endX - startX) * t;
    let centY = startY + (endY - startY) * t;
    let scale = startSize + (endSize - startSize) * t;

    // 3. Apply Centering Offset and return x, y, z
    return {
        x: centX - (scale / 2),
        y: centY - (scale / 2),
        z: scale 
    };
}//startGame = 'grimoire'
function pick(arr) {
    if (!arr || arr.length === 0) return ""; 
    return arr[Math.floor(Math.random() * arr.length)];
}
function getFullLibrary() {
    let allCards = [];
    
    // STOP at 77. 
    // This covers indices 0-77 (The Standard 78 Card Tarot Deck).
    // It EXCLUDES 78+ (Neophyte, Fire Imp, Excalibur, etc.)
    // If you WANT Excalibur (84) to appear in the gallery even if not owned,
    // you would need to manually push it here.
    for (let i = 0; i <= 77; i++) {
        allCards.push(new Card(i, 0));
    }
    
    return allCards;
}
function filterGrimoire(type, value) {
    // 1. SOURCE OF TRUTH
    // viewingFullDeck = true  -> Gallery (0-77)
    // viewingFullDeck = false -> Player Deck (Your actual loot)
    let source = viewingFullDeck ? getFullLibrary() : Dungeon.deck;
    
    let results = [];

    // 2. APPLY FILTER
    if (type === 'ALL') {
        // Create a copy so we can sort it without messing up the actual game deck order
        results = [...source]; 
    } 
    else if (type === 'SUIT') {
        if (value === 'Major') {
            results = source.filter(card => card.index < 22);
        } else {
            results = source.filter(card => card.suit === value);
        }
    } 
    else if (type === 'RANK') {
        results = source.filter(card => card.rank === value);
    }

    // 3. SAFETY CHECK
    if (results.length === 0) {
        console.log("No cards found for filter:", value);
        if(typeof MusicEngine !== 'undefined') MusicEngine.playSFX('cancel'); 
        return; 
    }

    // 4. *** THE CRITICAL FIX ***
    // We sort this ALWAYS. 
    // It doesn't matter if it's the Gallery or the Dungeon Deck.
    // We want the visual display to be ordered 0, 1, 2, 3...
    results.sort((a, b) => a.index - b.index);

    // 5. UPDATE DISPLAY LIST
    activePlaylist = results.map(card => card.index);

    // 6. RESET POINTER
    playlistIndex = 0; 
}
function getOracleText(card) {
    // --- VARIABLES ---
    var uprightText = "";
    var reversedText = "";

    // --- 1. MAJOR ARCANA ---
    if (card.suit === 'Major Arcana') {
        // Pick one random phrase from the Major arrays
        uprightText = pick(majorMeanings[card.rank] || ["significance"]);
        reversedText = pick(majorMeaningsRev[card.rank] || ["blocked energy"]);
        if(startGame == 'tarot'){
         return  uprightText + ".";

        }
        else{
        return  uprightText + ". When reversed: " + reversedText + ".";

        }
      }

    // --- 2. MINOR ARCANA ---
    // Upright
    var core = pick(rankMeanings[card.rank] || ["a turning point"]);
    var ctx  = pick(suitContexts[card.suit] || ["life"]);
    
    // Reversed
    var coreRev = pick(rankMeaningsRev[card.rank] || ["delays"]);
    var ctxRev  = pick(suitContextsRev[card.suit] || ["life"]);
    if(startGame == 'tarot'){
      return  core + ' ' +ctx + ".";
    }
    else{
    return  core + ' ' +ctx + 
           ". When reversed: " + coreRev + ' ' +ctxRev + ".";
    }
}
//ONLINE
// --- CLIENT SIDE MEMORY ---

function saveCoreFact(fact) {
    let facts = JSON.parse(localStorage.getItem(CORE_MEMORY_KEY) || "[]");
    if (!facts.includes(fact)) {
        facts.push(fact);
        localStorage.setItem(CORE_MEMORY_KEY, JSON.stringify(facts));
    }
}

function getCoreFacts() {
    return JSON.parse(localStorage.getItem(CORE_MEMORY_KEY) || "[]");
}

function updateFavor(amount) {
    let currentFavor = parseInt(localStorage.getItem(FAVOR_KEY) || "0");
    currentFavor = Math.min(10, Math.max(-10, currentFavor + amount));
    localStorage.setItem(FAVOR_KEY, currentFavor);
    return currentFavor;
}

function getFavor() {
    return parseInt(localStorage.getItem(FAVOR_KEY) || "0");
}
function saveInteraction(role, text) {
    // 1. Get existing memory
    let history = JSON.parse(localStorage.getItem(AI_MEMORY_KEY) || "[]");
    
    // 2. Add new interaction (Format specifically for Gemini API)
    history.push({
        role: role, // 'user' or 'model'
        parts: [{ text: text }]
    });

    // 3. Cap the memory (last 20 turns) to save data/costs
    if (history.length > 20) history = history.slice(history.length - 20);

    // 4. Save back to storage
    localStorage.setItem(AI_MEMORY_KEY, JSON.stringify(history));
}

function getAiMemory() {
    return JSON.parse(localStorage.getItem(AI_MEMORY_KEY) || "[]");
}
function initBattle(data, role) {
    console.log("Initializing Battle...", data);

    // 1. Determine who is Player (Me) and who is Foe
    let myDeckData, enemyDeckData, opponentId;

    if (role === 'HOST') {
        myDeckData = data.hostDeck;
        enemyDeckData = data.clientDeck;
        opponentId = data.clientId;
        // Host uses the turnOrder as generated
    } else {
        // I am the CLIENT
        myDeckData = data.clientDeck;
        enemyDeckData = data.hostDeck;
        opponentId = data.hostId;
    }

    // 2. Setup Player (Me)
    Player[0] = new Field(0, 0, opponentId);
    Player[0].deck = [];
    myDeckData.forEach((id, i) => {
        let c = new Card(id, 0);
        c.locIndex = i; c.locCount = i; c.location = 'deck';
        Player[0].deck.push(c);
    });

    // 3. Setup Foe (Them)
    Player[1] = new Field(1, 0, opponentId);
    Player[1].deck = [];
    enemyDeckData.forEach((id, i) => {
        let c = new Card(id, 1);
        c.locIndex = i; c.locCount = i; c.location = 'deck';
        Player[1].deck.push(c);
    });
Player[1].opponent = Player[0];
              Player[0].opponent = Player[1];
    // 4. Apply Shared Turn Order
    // If turnOrder is 0, Host goes first.
    // If I am Host (role 'HOST'), and turnOrder is 0, it's MY turn.
    if (role === 'HOST') {
        Player[0].turnOrder = (data.turnOrder === 0) ? 1 : 0; // 1 = Active
        Player[1].turnOrder = (data.turnOrder === 0) ? 0 : 1;
    } else {
        // I am Client. If turnOrder was 0 (Host first), it is NOT my turn.
        Player[0].turnOrder = (data.turnOrder === 1) ? 1 : 0;
        Player[1].turnOrder = (data.turnOrder === 1) ? 0 : 1;
    }

    // 5. Launch Game State
    preGame = 'explore';
    startGame = 'battle';
    Dungeon.status = 'normal';
    
    // Hide UI
    if (typeof btnYes !== 'undefined') btnYes.visible = false;
    if (typeof btnNo !== 'undefined') btnNo.visible = false;
}
// 1. UPDATE PLAYERS (Movement & Spawning)
socket.on("updatePlayers", (serverPlayers) => {
    for (let id in serverPlayers) {
        if (id === socket.id) continue; // Ignore ourselves

        let data = serverPlayers[id];

        // Create Sprite if it doesn't exist
        if (!window.remotePlayers[id]) {
            // Default to Map 0 if undefined so they aren't invisible
            let spawnMap = data.mapID || 0; 
            
            // Only spawn if they are somewhat near (optional optimization)
            window.remotePlayers[id] = new NPC(0, data.x, data.y, 1.1, 'stationary');
            window.remotePlayers[id].socketId = id;
            window.remotePlayers[id].mapID = spawnMap;
            window.remotePlayers[id].type = data.type; // <--- Ensure it's set
            window.remotePlayers[id].name = data.name;
          }

        // Update Position
        if (window.remotePlayers[id]) {
            window.remotePlayers[id].x = data.x;
            window.remotePlayers[id].y = data.y;
            window.remotePlayers[id].dir = data.dir;
            window.remotePlayers[id].status = data.status;
            if (data.type !== undefined) window.remotePlayers[id].type = data.type;
            // Update Map ID so they fade when changing rooms
            if (data.mapID !== undefined) window.remotePlayers[id].mapID = data.mapID;
          if (data.name) window.remotePlayers[id].name = data.name;
          }
    }

    // Cleanup Disconnected Players (Ghost Fix)
    for (let localId in window.remotePlayers) {
    if (!serverPlayers[localId]) {
        // DETECT IF THIS WAS MY OPPONENT
        if (typeof Player !== 'undefined' && Player[0].battleOpponentId === localId) {
            console.log("Opponent disconnected! Forcing victory.");
            
            // 1. Force Battle End
            
            // 2. Optional: Show message
            if(typeof MessageBox !== 'undefined') {
                MessageBox.show(0.5, 8, 1, 9, 2, 'Opponent fled the battle!', 'dialogue', 1, 0);
            }
        }

        // Standard cleanup
        delete window.remotePlayers[localId];
    }
}
});

// 2. RECEIVE CHALLENGE
socket.on("challenge_received", (data) => {
  if (startGame === 'battle' || startGame === 'dialogue') {
        console.log("Auto-rejecting challenge from", data.id, "- Player is busy.");
        
        // Optional: Tell the challenger we are busy
        socket.emit("battle_action", {
            targetId: data.id,
            actionType: 'CHALLENGE_REJECTED', 
            payload: { reason: 'Player is busy' } 
        });
        return; // <--- STOP HERE! Do not overwrite game state.
    }
    console.log("Challenge from:", data.id);
    Dungeon.currentSpeaker = { socketId: data.id, type: -27, name: "Challenger" };
    Dungeon.isChallenger = false;
    Dungeon.dCounter = 0;
    Dungeon.status = 'dueling';
    startGame = 'dialogue';
    // SETUP BUTTONS FOR THE "PRESS" FUNCTION
    window.pendingChallengerDeck = data.deck; 
    if (typeof btnYes !== 'undefined') {
        btnYes.foe = 'pvp_accept'; 
        btnYes.visible = true;
    }
});

// Inside socket listeners
socket.on("challenge_accepted", (data) => {
    console.log("Host: Opponent accepted. Setting up match...");

    // 1. Setup Host Deck (Me)
    let hostDeck = Dungeon.deck.map(c => c.index);
    // Shuffle Host Deck
    for (let i = hostDeck.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [hostDeck[i], hostDeck[j]] = [hostDeck[j], hostDeck[i]];
    }

    // 2. Setup Client Deck (Opponent) - They sent this in 'data'
    let clientDeck = data.opponentDeck || [];
    // Shuffle Client Deck (Host does this to ensure fairness/sync)
    for (let i = clientDeck.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [clientDeck[i], clientDeck[j]] = [clientDeck[j], clientDeck[i]];
    }

    // 3. Decide Turn Order (Random 0 or 1)
    let coinFlip = Math.floor(Math.random() * 2); 

    // 4. Construct the Final Start Data
    let matchData = {
        hostId: socket.id,
        clientId: data.opponentId,
        hostDeck: hostDeck,
        clientDeck: clientDeck,
        turnOrder: coinFlip // 0 = Host first, 1 = Client first
    };

    // 5. Start My Game (I am Host)
    initBattle(matchData, 'HOST');

    // 6. Tell the Client to Start
    socket.emit("battle_action", {
        targetId: data.opponentId,
        actionType: 'MATCH_START',
        payload: matchData
    });
});
// 4. BATTLE ACTIONS (Sync Moves)
socket.on("battle_action", (data) => {
    console.log("[battle_action] Received:", data.actionType, "from:", data.senderId);

   
    // 2. DEFINE PAYLOAD (Critical Fix)
    // You were using 'payload' in your switch cases, but it wasn't defined!
    const payload = data.payload; 

   

    switch (data.actionType) {
        // --- RUNE PICK (The Mirror Logic) ---
        case 'RUNE_PICK':
          // 1. Debug: Check if we are reading the data correctly
          // If these log as 'undefined', we know the keys don't match!
          console.log("RUNE_PICK Payload:", payload); 

          // 2. Invert Owner (0 -> 1)
          // We read 'payload.owner'. If sender sent '0', we set '1'.
          let targetOwner = (payload.owner === 0) ? 1 : 0; 

          // 3. Find the Stone
          // We read 'payload.stat'. matches eSTAT.S, etc.
          let stoneObj = null;
          if (payload.stat === eSTAT.S) stoneObj = sRune;
          if (payload.stat === eSTAT.C) stoneObj = cRune;
          if (payload.stat === eSTAT.I) stoneObj = iRune;
          if (payload.stat === eSTAT.A) stoneObj = aRune;

          // 4. Trigger Animation
          if (stoneObj) {
              console.log(`Animating Stone ${payload.stat} to owner ${targetOwner}`);
              stoneObj.changeOwner(targetOwner);
              
              
          }
          break;
        case 'SYNC_TURN_ORDER':
          // The opponent sent their turnOrder, so we update the Foe object
          console.log("Opponent updated turnOrder to:", payload.turnOrder);
          if (Player[1]) {
            Player[1].turnOrder = payload.turnOrder;
          }
          break;
        case 'RESET_TIMERS':
          console.log("Opponent is resetting timers for next round.");
          Player[0].at = 0;
          Player[0].ay = 0;
          Player[0].az = 0;
          Player[0].sentDice = false;
          Player[1].sentDice = false;
          break;
        case 'SYNC_AT': 
            // Update the opponent's animation timer/state
             Player[0].at = payload.at; 
            break;
        case 'SYNC_MONSTER_LEN':
            console.log("Syncing Monster Array Length to:", payload.len);
            if (Player[1] && Player[1].aMonster) {
              Player[1].aMonster.length = payload.len; 
            }
            break;
        case 'UNEQUIP':
            console.log("Opponent triggered unequip.");
            Player[1].unequip(); 
            break;
        case 'FORCE_OPPONENT_OPTION':
            console.log("Opponent forced MY option to:", payload.option);
            
            // The sender modified 'Foe' on their screen.
            // That corresponds to 'Player' (Me) on this screen.
           
            if (Player[0])Player[0].option = payload.option;
          
          
            break;
        case 'REROLL':
          Player[0].option = 7;
          Player[1].option = 7;
          for (let i = 0; i < Player[1].aMonster.length; i++){
            if (Player[1].aMonster[i].index == 17 && Player[1].aMonster[i].effectTriggered == 0){
              Player[1].aMonster[i].effectTriggered = 1;
            }
          }
          if(payload.choice == 1){
            Player[0].ay = 0;
            Player[0].az = 0;
            Player[0].at = 0;
            Player[1].hasReroll = 1;
            Player[1].sentDice = false;
            Player[0].rollSent = false;
          }
        break;
        case 'W_BOOT':
          Player[0].option = 7;
          Player[1].option = 7;
          for (let i = 0; i < Player[1].aMonster.length; i++){
            if (Player[1].aMonster[i].index == 7 && Player[1].aMonster[i].effectTriggered == 0){
              Player[1].aMonster[i].effectTriggered = 1;
            }
          }
          if(payload.choice == 1){Player[1].defStat = 3;}
          else{Player[1].defStat = 1;}
        break;
        case 'P_ORB':
          Player[0].option = 7;
          Player[1].option = 7;
          for (let i = 0; i < Player[1].aMonster.length; i++){
            if (Player[1].aMonster[i].index == 30 && Player[1].aMonster[i].effectTriggered == 0){
              Player[1].aMonster[i].effectTriggered = 1;
            }
          }
          if(payload.choice == 1){Player[1].defStat = 2;}
          else{Player[1].defStat = 1;}
        break;
        case 'SCRY_ADD':
              let card = Player[1].deck.splice(Player[1].look[eLOOK.D], 1)[0];
              // 2. Set location and push the OBJECT (not the array) to hand
              if (card.type == 0){
                Player[1].unequip();
                Player[1].aMonster.length = 0;
                card.location = 'field';
                Player[1].aMonster.push(card);
              }
              else{
                card.location = 'hand';
                Player[1].hand.push(card);
              }
              for(let i=0;i<Player[1].deck.length-1;i++){	//place deck on right side of field
              Player[1].deck[i].location = 'deck'
            }
              Player[0].option = 7;
              Player[1].option = 7;
        break;   
        case 'SCRY_EXIT':
          for(let i=0;i<Player[1].deck.length-1;i++){	//place deck on right side of field
              Player[1].deck[i].location = 'deck'
            }
              Player[0].option = 7;
              Player[1].option = 7;
          break;
        case 'CULTIVATE':
          Player[1].aMonster[0].stat[payload.s][eDICE.MOD]=Player[1].aMonster[0].stat[payload.s][eDICE.MOD] + 1;
          Player[1].statPoints = Player[1].statPoints - 1;
          break;
        case 'ALCHEMY':
          if (payload.soj==0){
            Player[1].look[eLOOK.STAT] = payload.s;
            Player[1].hasScalesOfJustice = 3;
          }
          else if(payload.soj == 1){
            Player[0].look[eLOOK.STAT] = payload.s;
            Player[1].hasScalesOfJustice = 4;
            Player[0].preOpt = 6.3;
            Player[1].preOpt = 6.3;
          }
          else if(payload.soj == 2){
            Player[1].hasScalesOfJustice = 2;
            Player[1].look[eLOOK.A] = 0;
            Player[0].at = 0;
            Player[0].option = 6.3;
            Player[1].option = 6.3;
          }
          break;
        case 'TREASURE':
          if (payload.choice==0){
            Player[1].hasTreasureChest = 2;
          }
          else if(payload.choise == 1){
            Player[1].hasTreasureChest = 3;
            
          }
          
          break;
        case 'Q_REWARD':
          Player[1].hand[Player[1].look[eLOOK.H]].questReward = payload.reward;
        break;
          case 'MATCH_START':
            console.log("Host started the match!");
            // The payload contains the shuffled decks and turn order
            initBattle(payload, 'CLIENT'); 
            break;
        case 'CHALLENGE_REJECTED':
            console.log("Opponent said NO.");
            Dungeon.status = 'normal';
            startGame = 'explore';
            Dungeon.isChallenger = false;
            Dungeon.dCounter = 0; 
            Dungeon.currentSpeaker = null;
            if (typeof MessageBox !== 'undefined') {
                MessageBox.show(0.5, 8, 1, 9, 2, 'Duel Rejected.', 'dialogue', 1, 0);
            }
            break;
        case 'SYNC_STATE':
        // We map this to OUR Player[1] (The Enemy)
    if (payload.src === 0) {
        if (Player[1]) {
            Player[1].sync(payload);
        }
    }
    
    // CASE B: Data came from Host's Player[1] (The "Ghost" of Me)
    // We map this to OUR Player[0] (Myself)
    // This overwrites my dice rolls with the Host's math, fixing the sync issue.
    else if (payload.src === 1) {
        // Only sync Player[0] if I am NOT the host (Client Mode)
        // If I am the host, I ignore this to avoid feedback loops
        if (Player[0]) {
            Player[0].sync(payload);
        }
    }
        break;    
        case 'CHALLENGE_CANCEL':
            console.log("Opponent cancelled the challenge.");
            startGame = 'explore';
            Dungeon.status = 'normal';
            if(typeof btnYes !== 'undefined') btnYes.visible = false;
            if(typeof btnNo !== 'undefined') btnNo.visible = false;
            break;
        case 'PRE_OPT':
           if (Player[1])Player[1].preOpt = payload.preOpt
          break;
        case 'PHASE_CHANGE': 
          if (Player[1]) Player[1].option = payload.option; 
          break;

        case 'SELECTION': 
            if (Player[1]) Player[1].look = payload.look;
            break;

        case 'COMMIT_ACTION': 
           if (Player[1]) {
                Player[1].look = payload.look;
                Player[1].option = 5; // Set to "Ready/Action" state
                console.log("Opponent committed action.");
            }
             break;

        case 'DICE_RESULT': 
    // 1. Cross-Wire: Host's P0 is My Enemy (P1)
    Player[1].look[eLOOK.R] = payload.p0_roll; 

    // 2. Cross-Wire: Host's P1 is Me (P0)
    Player[0].look[eLOOK.R] = payload.p1_roll; 
    
    // 3. Flip the "Green Light" for the Client
    Player[0].hasReceivedRoll = true; // <--- This breaks the loop in Case 6
    Player[1].hasReceivedRoll = true;

    // 4. Force Animation Snap (Optional, ensures visuals match)
    //Player[0].diceType = payload.diceType; 
    //Player[1].diceType = payload.diceType;
    break;
        case 'SYNC_DRAW':
            console.log("Syncing Draw variable to:", payload.draw);
            if (Player[1]) {
                Player[1].draw = payload.draw; 
            }
            break;
        case 'DRAW_TRIGGER': 
            Player[1].draw = 1; 
            break;

        case 'SYNC_TIMER':
            console.log("Opponent tapped to continue.");
            if (Player[1]) Player[1].at = payload.at;     
            if (Player) Player[0].at = payload.at; 
            break;

        case 'CLEANUP_READY':
            console.log("Opponent is ready for next turn.");
            if (Player[1]) {
                Player[1].isCleanupReady = true;
                if (Player[0].isCleanupReady == true&& Player[1].opponent.isCleanupReady == true&&Dungeon.isChallenger==true) {
                  Player[0].option = 0;
                  Player[0].sendAction('PHASE_CHANGE', { option: 0 });     

                  Player[1].option = 0;
                  Player[1].sendAction('FORCE_OPPONENT_OPTION', { option: 0 });     
                  Player[0].cleanupsent = 0;
                 Player[1].cleanupsent = 0
                  
                  Player[0].isCleanupReady = false;
                 Player[1].isCleanupReady = false
                }
            }
            break;
    } // end switch
});

// CLIENT SIDE - Add this with your other socket listeners
socket.on("battle_opponent_disconnected", (data) => {
    console.log("CRITICAL: Opponent disconnected abruptly!");
    
    // 1. Check if we are actually fighting this person
    if (Player[1].battleOpponentId === data.id) {
        // 2. Force Victory / End Battle
        Dungeon.status = 'normal';
        startGame = 'explore';
        Dungeon.isChallenger = false;
        
        if (typeof MessageBox !== 'undefined') {
            MessageBox.show(0.5, 8, 1, 9, 2, 'Opponent Disconnected! You Win!', 'dialogue', 1, 0);
        }
        
        // 3. Clear the Foe object so we don't keep drawing them
        Player[1] = null; 
        
        // 4. Clean up any UI buttons
        if(typeof btnYes !== 'undefined') btnYes.visible = false;
        if(typeof btnNo !== 'undefined') btnNo.visible = false;
    }
});

socket.on('chat_message', function(data) {
    // 1. Determine if it's a simple string (Old) or a fancy object (New)
    let messageText = "";
    let senderName = "Player";
    let msgColor = "white"; // Default color

    if (typeof data === 'string') {
        // Legacy support
        messageText = data;
    } else {
        // New AI/System support
        messageText = data.text;
        senderName = data.sender;
        if (data.color) msgColor = data.color;
    }
    messageText = messageText.replace(/\[REPLY\]:?\s*/gi, "");
    // 2. Add to Chat Log
    // (Adjust this line to match how your game stores chat)
    if (typeof chatLog !== 'undefined') {
      let currentTime = Date.now();
        let timeDiff = currentTime - lastMessageTimeReceived;
      let displayPrefix = senderName + ": ";
      if (senderName === lastSenderName && timeDiff < 200) {
             displayPrefix = "   "; // Indent just enough to align text
        }
        // If your chat log is just an array of strings:
        chatLog.push(displayPrefix + messageText);
        lastSenderName = senderName;
        lastMessageTimeReceived = currentTime;
        lastChatTime = Date.now();
        
        // OR if you want to support colors (Advanced):
        // chatLog.push({ text: senderName + ": " + messageText, color: msgColor });
    }

    // 3. Play Sound (Optional)
    if(typeof MusicEngine !== 'undefined') MusicEngine.playSFX('chat_sound');
    // NEW: Save Suncat's replies to browser memory
    // Check if data is object (new style) or string (old style)
    let sender = data.sender || "Unknown";
    let text = data.text || data;
    
    if (sender === "Suncat") {
        saveInteraction("model", text);
    }
    // Debug
    console.log(`[CHAT] ${senderName}: ${messageText}`);
});
socket.on("load_dead_npcs", (serverDeadList) => {
    if (typeof Dungeon !== 'undefined') {
        for (let uniqueID in serverDeadList) {
            // Write to our local memory so loadMap will hide them
            Dungeon.memory[uniqueID] = { permanent: true };
        }
        // Optional: If we are currently on a map with dead NPCs, hide them now
        Dungeon.npcs.forEach(npc => {
             let uniqueID = Dungeon.mapID + "_" + npc.index;
             if (serverDeadList[uniqueID]) {
                 npc.isDead = true;
                 npc.visible = false;
             }
        });
    }
});

// 2. LIVE UPDATE: When another player kills an NPC while we are playing
socket.on("npc_died", (data) => {
    console.log(">>> NETWORK EVENT: NPC Died!", data);

    if (typeof Dungeon !== 'undefined') {
        // 1. Update Memory (So they stay dead if we leave/return)
        let uniqueID = data.mapID + "_" + data.index;
        Dungeon.memory[uniqueID] = { permanent: true };

        // 2. Check if we are on the SAME map
        if (Dungeon.mapID === data.mapID) {
            console.log("We are on the same map. Hunting for NPC index:", data.index);
            
            // Find the NPC in our list
            let npc = Dungeon.npcs.find(n => n.index === data.index);
            
            if (npc) {
                console.log("NPC Found! Killing it visually.");
                npc.isDead = true;
                npc.visible = false;
            } else {
                console.log("Could not find NPC with that index on this map.");
            }
        } else {
            console.log("Ignoring visual update (We are on map " + Dungeon.mapID + ", death was on " + data.mapID + ")");
        }
    }
});
// 1. Reset NPCs
socket.on("force_npc_reset", () => {
    if (typeof Dungeon !== 'undefined') {
        Dungeon.memory = {}; // Clear local memory of dead NPCs
        Dungeon.loadMap(Dungeon.mapID); // Reload map to spawn them
        if (typeof MessageBox !== 'undefined') {
            MessageBox.show(0.5, 8, 1, 9, 2, 'World Reset by Admin.', 'dialogue', 1, 0);
        }
    }
});

socket.on("admin_command", (data) => {
    console.log("Admin Command Received:", data.type);

    // 1. KICK (Soft Boot)
    if (data.type === 'kick') {
        alert("You have been kicked from the server.");
        window.location.href = "about:blank"; // Redirects them away effectively
    }

    // 2. BANISH (Permanent IP/Browser Ban)
    if (data.type === 'banish') {
        localStorage.setItem('battlemage_banned', 'true'); // Set the flag
        document.body.innerHTML = "<h1>BANISHED</h1>";
        socket.disconnect();
        setTimeout(() => location.reload(), 1000); // Trigger the check at the top
    }

    // 3. VANQUISH (Delete Save File)
    if (data.type === 'vanquish') {
        // Nuke all known storage keys
        localStorage.removeItem('battlemage_save'); 
        localStorage.removeItem('Suncat_Favor_v1');
        localStorage.removeItem('Suncat_Core_Facts');
        localStorage.removeItem('Suncat_Memory_v1');
        
        alert("Suncat has DELETED your save file. The timeline has been reset.");
        location.reload();
    }
});

socket.on("receive_card", (data) => {
    if (typeof Dungeon !== 'undefined') {
        // 1. Add the card (Existing logic)
        let newCard = new Card(data.cardIndex, 0);
        Dungeon.deck.push(newCard);
        
        // 2. Play Sound (Existing logic)
        if (typeof MusicEngine !== 'undefined') MusicEngine.playSFX('heal');
        
        // 3. [NEW] Visual Notification
        // So the player actually sees what they got in the chat log
        chatLog.push(`[SYSTEM]: You received a Gift! (Card ID: ${data.cardIndex})`);
        
        // 4. [CRITICAL] Auto-Save
        // If your save function is called 'saveGame()' or similar, call it here!
        // Otherwise, manually update the storage:
        if (typeof saveGame === 'function') {
            saveGame();
            chatLog.push(`[SYSTEM]: Game Saved.`);
        }
        
        console.log("Suncat Gift Received:", data.cardIndex);
    }
});
socket.on('remote_sfx', (data) => {
    // You might want a check here: "Is this sound close enough to hear?"
    // For now, we just play it using the coordinates sent from the server
    
    // Note: We use data.x + 1 and data.y + 1 to match your original logic
    MusicEngine.play3DSFX(
        data.sfxID, 
        data.x, 
        data.y, 
        Dungeon.x, 
        Dungeon.y, 
        Dungeon.dir
    );
    
    // Optional: Log it so players know what happened
    // chatLog.push(`[SYSTEM]: You hear a strange sound nearby...`);
});


//MUSIC ENGINE
const MusicEngine = {
  style: null,
  ctx: null,
  masterGain: null,
  currentSong: null,
  async init() {
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    if (!this.ctx) {
        this.ctx = new AudioCtx();
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.5;
        this.masterGain.connect(this.ctx.destination);
    }
    if (this.ctx.state === 'suspended') {
        await this.ctx.resume();
    }
    const buffer = this.ctx.createBuffer(1, 1, 22050);
    const source = this.ctx.createBufferSource();
    source.buffer = buffer;
    source.connect(this.ctx.destination);
    source.start(0);
    return true;
},
    
  playSFX(type) {
    if (!this.ctx) return;
    if (this.ctx.state === 'suspended') { this.ctx.resume(); }
    const t = this.ctx.currentTime;
    switch (type) {
      case 'click': default:
        this.createTone(t, 1500, 'sine', 1, 0.1, -200);
        break;
      case 'cancel':
        this.createTone(t, 150, 'sawtooth', 0.15, 0.2, -50);
        break;
      case 'chime':
        this.createTone(t, 1200, 'sine', 2, 0.5, 0);
        this.createTone(t, 2400, 'sine', 1, 0.5, 0);
        break;
      case 'fireball':
        this.createNoise(t, 'lowpass', 100, 2, 3, 800); // Filter sweeps up
        this.createTone(t, 100, 'sawtooth', 1.5, 3, -50); // Low rumble
        break;
      case 'warp':
        const oscW = this.ctx.createOscillator();
        const gainW = this.ctx.createGain();
        oscW.type = 'sine';
        oscW.frequency.setValueAtTime(200, t);
        oscW.frequency.exponentialRampToValueAtTime(2000, t + 0.2); // Zip up
        oscW.frequency.exponentialRampToValueAtTime(100, t + 0.4); // Zip down
        gainW.gain.setValueAtTime(0.2, t);
        gainW.gain.linearRampToValueAtTime(0, t + 0.4);
        oscW.connect(gainW); gainW.connect(this.ctx.destination);
        oscW.start(t); oscW.stop(t + 0.4);
        break;
      case 'heal':
        for (let i = 0; i < 5; i++) {
          setTimeout(() => {
            this.createTone(this.ctx.currentTime, 800 + (i * 200), 'sine', 0.1, 0.3, 0);
          }, i * 50);
        }
        break;
      case 'slash':
        this.createNoise(t, 'highpass', 1000, 1, 1, 0);
        break;
      case 'clang':
        const c = this.ctx.createOscillator();
        const cG = this.ctx.createGain();
        c.type = 'square';
        c.frequency.value = 400;
        const m = this.ctx.createOscillator();
        const mG = this.ctx.createGain();
        m.frequency.value = 567; // Non-integer ratio
        mG.gain.value = 2000;
        m.connect(mG); mG.connect(c.frequency);
        c.connect(cG); cG.connect(this.ctx.destination);
        cG.gain.setValueAtTime(1, t);
        cG.gain.exponentialRampToValueAtTime(0.01, t + 1);
        c.start(t); m.start(t);
        c.stop(t + 0.5); m.stop(t + 0.5);
        break;
      case 'death':
        const oscD = this.ctx.createOscillator();
        const gainD = this.ctx.createGain();
        oscD.type = 'sawtooth';
        oscD.frequency.setValueAtTime(150, t);
        oscD.frequency.exponentialRampToValueAtTime(40, t + 1.5);
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 300;
        gainD.gain.setValueAtTime(1, t);
        gainD.gain.linearRampToValueAtTime(0, t + 1.5);
        oscD.connect(filter); filter.connect(gainD); gainD.connect(this.ctx.destination);
        oscD.start(t); oscD.stop(t + 1.5);
        break;
      case 'lightning':
        this.createLightning(t);
        break;
      }
  },
  createTone(t, freq, type, vol, dur, slide) {
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, t);
    if (slide !== 0) osc.frequency.linearRampToValueAtTime(freq + slide, t + dur);
    gain.gain.setValueAtTime(vol, t);
    gain.gain.exponentialRampToValueAtTime(0.01, t + dur);

    osc.connect(gain); gain.connect(this.ctx.destination);
    osc.start(t); osc.stop(t + dur);
  },
  createNoise(t, filterType, filterFreq, vol, dur, sweep) {
    const bufSize = this.ctx.sampleRate * dur;
    const buffer = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufSize; i++) data[i] = Math.random() * 2 - 1;

    const noise = this.ctx.createBufferSource();
    noise.buffer = buffer;

    const filter = this.ctx.createBiquadFilter();
    filter.type = filterType;
    filter.frequency.setValueAtTime(filterFreq, t);
    if (sweep !== 0) filter.frequency.linearRampToValueAtTime(filterFreq + sweep, t + dur);

    const gain = this.ctx.createGain();
    gain.gain.setValueAtTime(vol, t);
    gain.gain.exponentialRampToValueAtTime(0.01, t + dur);

    noise.connect(filter); filter.connect(gain); gain.connect(this.ctx.destination);
    noise.start(t);
  },
  play(style) {
    if (!this.ctx) { console.warn("Call MusicEngine.init() first!"); return; }
    if (this.ctx.state === 'suspended') this.ctx.resume();
    
    this.stop();

    switch (style) {
      case 0: case 'Dungeon':
        this.currentSong = new ScaryM(this.ctx, this.masterGain);
        this.style = "Dungeon";
        break;
      case 1: case "Demon Lord's Castle":
        this.currentSong = new ScaryModule(this.ctx, this.masterGain);
        this.style = "Demon Lord's Castle";
        break;
      case 2: case 'Forest':
        this.currentSong = new SimpleModule(this.ctx, this.masterGain);
         this.style = "Forest";
        break;
       
      case 3: case 'Peace At Last':
        this.currentSong = new RoseModule(this.ctx, this.masterGain);
        this.style = "Peace At Last";
        break;
      case 4: case 'Dungeon 2':
        this.currentSong = new DungeonM(this.ctx, this.masterGain);
        this.style = "Dungeon";
        break;
      case 5: case 'Battle':
        this.currentSong = new DangerModule(this.ctx, this.masterGain);
        this.style = "Battle";
        break;
      case 6: case 'Spoils of War':
        this.currentSong = new SpoilsofWarModule(this.ctx, this.masterGain);
        this.style = "Spoils of War";
        break;
      case 7: case 'March':
        this.currentSong = new MarchModule(this.ctx, this.masterGain);
        this.style = "March";
        break;
      case 8: case 'Triumph':
        this.currentSong = new TriumphModule(this.ctx, this.masterGain);
        this.style = "Triumph";
        break;
      case 9: case 'Title':
        this.currentSong = new StartGameModule(this.ctx, this.masterGain);
        this.style = "Title Theme";
        break;
      case 10: case 'Lullaby':
        this.currentSong = new LullabyModule(this.ctx, this.masterGain);
        this.style = "Lullaby";
        break;
      case 11: case 'Castle':
        this.currentSong = new CastleModule(this.ctx, this.masterGain);
        this.style = "Castle";
        break;
      case 12: case 'Audience With the Queen':
        this.currentSong = new QueenModule(this.ctx, this.masterGain);
        this.style = "Audience with the Queen";
        break;
      case 13: case 'Audience With the King':
        this.currentSong = new KingModule(this.ctx, this.masterGain);
        this.style = "Audience with the King";
        break;
      case 14: case 'Royal Decree':
        this.currentSong = new RoyalDecreeModule(this.ctx, this.masterGain);
        this.style = "Royal Decree";
        break;
      case 15: case 'Battle2':
        this.currentSong = new Battle2Module(this.ctx, this.masterGain);
        this.style = "Battle 2";
        break;
      case 16: case 'Battle3':
        this.currentSong = new WorthyModule(this.ctx, this.masterGain);
        this.style = "Battle 3";
        break;
      case 17: case 'Crisis':
        this.currentSong = new CrisisModule(this.ctx, this.masterGain);
        this.style = "Crisis";
        break;
      case 18: case 'Underworld':
        this.currentSong = new UnderworldModule(this.ctx, this.masterGain);
        this.style = "Underworld";
        break;
      case 19: case 'Lament':
        this.currentSong = new LamentModule(this.ctx, this.masterGain);
        this.style = "Lament";
        break;
      case 20: case 'Tears':
        this.currentSong = new TearsModule(this.ctx, this.masterGain);
        this.style = "Ice Queen's Tears";
        break;
        case 21: case 'Ice Cave':
        this.currentSong = new HermesModule(this.ctx, this.masterGain);
        this.style = "Ice Cave";
        break;
        case 22: case 'Divine Intervention':
        this.currentSong = new DivineModule(this.ctx, this.masterGain);
        this.style = "Divine Intervention";
        break;
        case 23: case 'A Foreign Land':
        this.currentSong = new ForeignModule(this.ctx, this.masterGain);
        this.style = "A Foreign Land";
        break;
        case 24: case 'Dungeon Crawl':
        this.currentSong = new DungeonCrawlModule(this.ctx, this.masterGain);
        this.style = "Dungeon Crawl";
        break;
        case 25: case 'Battle4':
        this.currentSong = new Battle3Module(this.ctx, this.masterGain);
        this.style = "Battle 4";
        break;
        case 26: case 'Battle5':
        this.currentSong = new FateModule(this.ctx, this.masterGain);
        this.style = "Battle 5";
        break;
        case 27: case 'Battle6':
        this.currentSong = new Battle4Module(this.ctx, this.masterGain);
        this.style = "Battle 6";
        break;
        case 28: case 'Hubris':
        this.currentSong = new HubrisModule(this.ctx, this.masterGain);
        this.style = "The Price of Hubris";
        break;
        case 29: case "Fool":
        this.currentSong = new BardModule(this.ctx, this.masterGain);
        this.style = "Fool's Journey";
        break;
        case 30: case 'Goblin':
        this.currentSong = new HoneyModule(this.ctx, this.masterGain);
        this.style = "Goblin Caverns";
        break;
        case 31: case 'Harp':
        this.currentSong = new HarpModule(this.ctx, this.masterGain);
        this.style = "Harp";
        break;
        case 32: case 'Harp2':
        this.currentSong = new Harp2Module(this.ctx, this.masterGain);
        this.style = "Harp 2";
        break;
        case 33: case 'Prepare for Battle':
        this.currentSong = new HeroLyreModule(this.ctx, this.masterGain);
        this.style = "Prepare for Battle";
        break;
        case 34: case 'DarkCastle':
        this.currentSong = new DarkCastleModule(this.ctx, this.masterGain);
        this.style = "Storm the Castle";
        break;
        case 35: case 'KingBattle':
        this.currentSong = new KingBattleModule(this.ctx, this.masterGain);
        this.style = "King Battle";
        break;
        case 36: case 'Storm':
        this.currentSong = new StormModule(this.ctx, this.masterGain);
        this.style = 'Boreal Sea';
        break;
         case 37: case 'Otherworld':
        this.currentSong = new OtherworldModule(this.ctx, this.masterGain);
        this.style = "Otherworld";
        break;
        case 38: case 'Dragon':
        this.currentSong = new DragonLairModule(this.ctx, this.masterGain);
        this.style = "Dragon's Lair";
        break;
        case 39: case 'Tomb':
        this.currentSong = new TombModule(this.ctx, this.masterGain);
        this.style = "Tomb";
        break;
        case 40: case 'HighKingBattle':
        this.currentSong = new HighKingModule(this.ctx, this.masterGain);
        this.style = "Excalibur";
        break;
        case 41: case 'Storm':
        this.currentSong = new StormAbienceModule(this.ctx, this.masterGain);
        this.style = "Storm";
        break;
        case 42: case 'EmperorBattle':
        this.currentSong = new EmperorBattleModule(this.ctx, this.masterGain);
        this.style = "Emperor Battle";
        break;
        
      default:
        console.error("Unknown style:", style);
        return;
    }

    if (this.currentSong) {
      console.log(`Starting: ${style}`);
      this.currentSong.start();
    }
  },

  stop() {
    // 1. Cut the Master Volume immediately to kill lingering reverb tails
    if (this.masterGain) {
        this.masterGain.gain.cancelScheduledValues(this.ctx.currentTime);
        this.masterGain.gain.setValueAtTime(this.masterGain.gain.value, this.ctx.currentTime);
        this.masterGain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.05); // 50ms fade out
    }

    // 2. Stop the specific song logic
    if (this.currentSong) {
      if (this.currentSong.stop) this.currentSong.stop();
      this.currentSong = null;
    }

    // 3. Reset Master Volume for the next track (after a tiny delay)
    setTimeout(() => {
        if(this.masterGain){
            this.masterGain.gain.setValueAtTime(0.5, this.ctx.currentTime); 
        }
    }, 100);
  },
  isPlaying() {
    // 1. If context doesn't exist or is suspended, we aren't playing
    if (!this.ctx || this.ctx.state !== 'running') return false;
    
    // 2. If no song object is assigned, we aren't playing
    if (!this.currentSong) return false;
    
    return true;
  },
  setVolume(val) {
    if (this.masterGain) this.masterGain.gain.setTargetAtTime(val, this.ctx.currentTime, 0.1);
  },
  // 3. FAIRY CHIME (Lost Kingdoms / Zelda Style)
  createFairyChime(t, distGain, panner) {
    // Fairies are high frequency, so we skip the panner/distance if you want it 
    // to sound "in your head" (Global UI), but we keep it here for 3D placement.
    distGain.connect(panner);
    panner.connect(this.masterGain);

    // The "Magical" Chord: High C# Major 7 (C#, F, G#, C)
    // Frequencies in Hz:
    const notes = [1109, 1397, 1661, 2093, 2217]; 
    
    // Play each note in rapid succession
    notes.forEach((freq, index) => {
        // Stagger the start times (0.06s apart creates the "strum" or "arpeggio" effect)
        const startTime = t + (index * 0.06); 

        const osc = this.ctx.createOscillator();
        osc.type = 'sine'; // Sine = Pure Glass/Bell sound
        osc.frequency.setValueAtTime(freq, startTime);

        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0, startTime);
        
        // Fast Attack (Ping!)
        gain.gain.linearRampToValueAtTime(0.2, startTime + 0.02); 
        
        // Long, ringing decay (Glassy tail)
        gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.8); 

        osc.connect(gain);
        gain.connect(distGain);

        osc.start(startTime);
        osc.stop(startTime + 0.9);
    });
    
    // OPTIONAL: Add a "Sparkle" underneath
    // A very high, quiet tone that tremolos rapidly
    const sparkle = this.ctx.createOscillator();
    sparkle.type = 'triangle';
    sparkle.frequency.value = 3000;
    
    const sparkleGain = this.ctx.createGain();
    sparkleGain.gain.setValueAtTime(0, t);
    sparkleGain.gain.linearRampToValueAtTime(0.05, t + 0.1);
    sparkleGain.gain.linearRampToValueAtTime(0, t + 0.6);

    // Add Tremolo (AM Synthesis) to the sparkle
    const lfo = this.ctx.createOscillator();
    lfo.frequency.value = 15; // Fast flutter
    const lfoGain = this.ctx.createGain();
    lfoGain.gain.value = 500; 

    sparkle.connect(sparkleGain);
    sparkleGain.connect(distGain);
    
    sparkle.start(t);
    sparkle.stop(t + 0.6);
  },
  // 4. FAIRY VOICE ("Ahhhhh" with Pitch Drop)
  createFairyVoice(t, distGain, panner) {
    distGain.connect(panner);
    panner.connect(this.masterGain);

    const freqs = [880, 1320]; // High A and High E

    freqs.forEach((f) => {
        const osc = this.ctx.createOscillator();
        osc.type = 'triangle'; 
        
        // --- PITCH ENVELOPE (NEW) ---
        // Start at the base frequency
        osc.frequency.setValueAtTime(f, t);
        // Slide down to 70% of the pitch over 1.5 seconds
        // This creates that "falling sigh" effect
        osc.frequency.exponentialRampToValueAtTime(f * 1.5, t + .75);

        // --- VIBRATO ---
        const vib = this.ctx.createOscillator();
        vib.frequency.value = 6; 
        const vibGain = this.ctx.createGain();
        vibGain.gain.value = 10; 
        
        vib.connect(vibGain);
        vibGain.connect(osc.frequency);
        vib.start(t);
        vib.stop(t + .75);

        // --- VOLUME ENVELOPE ---
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(0.25, t + 0.4); // Fade In
        gain.gain.linearRampToValueAtTime(0, t + .75);    // Fade Out

        osc.connect(gain);
        gain.connect(distGain);

        osc.start(t);
        osc.stop(t + .75);
    });
  },
  play3DSFX(type, sourceX, sourceY, playerX, playerY, playerDirIdx) {
    if (!this.ctx) return;
    if (this.ctx.state === 'suspended') this.ctx.resume();

    // 1. Calculate Distance
    const dx = sourceX - playerX;
    const dy = sourceY - playerY;
    const dist = Math.sqrt(dx*dx + dy*dy);

    // --- SAFETY CHECK 1: Infinity/NaN Prevention ---
    // If distance is effectively zero, we can't calculate a direction vector.
    // We just assume the sound is "centered" (pan = 0) and proceed.
    let panVal = 0;

    if (dist > 0.001) {
        // Only do the division if dist is NOT zero
        const angle = playerDirIdx * Math.PI / 2;
        const pDirX = Math.sin(angle);
        const pDirY = -Math.cos(angle);
        
        const rightX = -pDirY;
        const rightY = pDirX;

        // Normalized vector (This was the crash point: 0/0)
        let nDx = dx / dist;
        let nDy = dy / dist;

        panVal = (nDx * rightX) + (nDy * rightY);
    }
    
    // --- SAFETY CHECK 2: Clamp Panning ---
    // Ensure pan is strictly between -1 and 1
    if (isNaN(panVal)) panVal = 0;
    if (panVal > 1) panVal = 1;
    if (panVal < -1) panVal = -1;

    // --- Volume Logic ---
    if (dist > 15) return; // Too far away

    let volume = 1 / (0.5 + (dist * 0.5));
    if (volume > 1) volume = 1;
    if (isNaN(volume)) volume = 1; // Safety fallback

    // 3. Audio Graph Setup
    const t = this.ctx.currentTime;
    const panner = this.ctx.createStereoPanner();
    panner.pan.value = panVal;

    const distGain = this.ctx.createGain();
    distGain.gain.value = volume;

    // 4. Switch
    switch(type) {
      case 'step':
        this.createStepSound(t, distGain, panner);
        break;
      case 0:case 'grunt':
        this.createGruntSound(t, distGain, panner);
        break;
      case 1:case 'musical':
        this.createMusicalMovement(t, distGain, panner);
        break;
      case 2:case 'fairy':
        this.createFairyVoice(t, distGain, panner);
        break;
      case 3:case 'ghost':
        this.createGhostSound(t, distGain, panner);
        break;
      case 4:case 'musical2':
        this.createMusicalMovement2(t, distGain, panner);
        break;
      case 5:case 'musical3':
        this.createMusicalMovement3(t, distGain, panner);
        break;
       case 6: case 'musical4':
        this.createMusicalMovement4(t, distGain, panner);
        break;
       case 7: case 'talk':
        // Pass a 'voiceType' if you want distinctive voices later
        // For now we default to a standard "Boy/Hero" sound
        this.createDialogueMumble(t, distGain, panner, 'mid'); 
        break;
        case 8:case 'scream': 
        this.createScream(t, distGain, panner);
        break;
    }
  },
  // 7. WOMAN SCREAM (Linguistics/Anatomy Simulation)
  createScream(t, distGain, panner) {
    distGain.connect(panner);
    panner.connect(this.masterGain);

    // DECISION LOGIC: 75% Random Scream, 25% "HELP"
    const choice = Math.random();

    // --- ANATOMY SETTINGS ---
    // Female vocal range typically centers around 200Hz-250Hz for speech,
    // but screams jump to 400Hz-1000Hz (Head voice/Whistle register).
    
    if (choice > 0.25) {
        // ============================================
        // TYPE A: THE "AHHH" SCREAM (Panic/Flight)
        // ============================================
        // Theory: High subglottal pressure + Open Vocal Tract (Formant F1 high)
        
        const duration = 0.8 + Math.random() * 0.8; // 0.8s to 1.6s

        // 1. SOURCE (The Glottis)
        const osc = this.ctx.createOscillator();
        osc.type = 'sawtooth'; // Sawtooth mimics the sharp closure of vocal folds
        
        // Pitch Envelope: Screams are rarely flat. They usually slide down (doppler/exhaustion)
        const startPitch = 500 + Math.random() * 300; // High pitch (C5 to F5)
        osc.frequency.setValueAtTime(startPitch, t);
        osc.frequency.exponentialRampToValueAtTime(startPitch * 0.8, t + duration);

        // 2. ROUGHNESS (Jitter/Shimmer)
        // When screaming, vocal folds vibrate irregularly due to over-pressure.
        // We simulate this with aggressive Vibrato (FM Synthesis).
        const jitter = this.ctx.createOscillator();
        jitter.type = 'sawtooth';
        jitter.frequency.value = 40 + Math.random() * 20; // Very fast flutter (Growl/Fry)
        
        const jitterGain = this.ctx.createGain();
        jitterGain.gain.value = 50; // Intensity of the roughness
        
        jitter.connect(jitterGain);
        jitterGain.connect(osc.frequency);
        jitter.start(t);
        jitter.stop(t + duration);

        // 3. FILTER (The Mouth/Vowel "Ah")
        // "Ah" vowel has a high First Formant (~800Hz).
        const mouth = this.ctx.createBiquadFilter();
        mouth.type = 'lowpass';
        mouth.frequency.value = 1200; // Wide open mouth
        mouth.Q.value = 1; // Resonance

        // 4. VOLUME (Breath Support)
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(0.8, t + 0.1); // Sudden onset
        gain.gain.linearRampToValueAtTime(0, t + duration); // Run out of breath

        osc.connect(mouth);
        mouth.connect(gain);
        gain.connect(distGain);

        osc.start(t);
        osc.stop(t + duration);

    } else {
        // ============================================
        // TYPE B: THE WORD "HELP" (Articulation)
        // ============================================
        // Phonemes: /h/ (Aspiration) -> // (Vowel) -> /l/ (Liquid) -> /p/ (Plosive)
        
        // --- 1. THE "H" (Glottal Fricative) ---
        // Mechanics: Vocal cords open, turbulent air passes through.
        this.createNoiseBurst(t, 'highpass', 1000, 0.4, 0.1, distGain);

        // --- 2. THE "E-L" (Vowel to Liquid Glide) ---
        // Mechanics: Vocal cords vibrate. 
        // "E" (as in Bet): Tongue mid-height, front. Formant ~1800Hz.
        // "L": Tongue tip touches alveolar ridge. Frequencies dampen.
        
        const voice = this.ctx.createOscillator();
        voice.type = 'sawtooth'; // Vocal folds
        // Pitch: starts high (panic), drops slightly
        voice.frequency.setValueAtTime(450, t + 0.05); 
        voice.frequency.linearRampToValueAtTime(400, t + 0.4);

        // FORMANT FILTER (The Mouth Shape)
        const mouth = this.ctx.createBiquadFilter();
        mouth.type = 'bandpass';
        mouth.Q.value = 2; // Narrower bandwidth for distinct vowel
        
        // Vowel Glide Logic:
        // Start: 1800Hz ("Eh" bright sound)
        // End: 800Hz ("L" dark/muffled sound as tongue blocks air)
        mouth.frequency.setValueAtTime(1800, t + 0.05);
        mouth.frequency.exponentialRampToValueAtTime(800, t + 0.4);

        const voiceGain = this.ctx.createGain();
        voiceGain.gain.setValueAtTime(0, t);
        voiceGain.gain.linearRampToValueAtTime(0.8, t + 0.1); // Attack "He-"
        voiceGain.gain.setValueAtTime(0.8, t + 0.35);         // Hold "-el-"
        voiceGain.gain.linearRampToValueAtTime(0, t + 0.4);   // Cut for "P" closure

        voice.connect(mouth);
        mouth.connect(voiceGain);
        voiceGain.connect(distGain);

        voice.start(t);
        voice.stop(t + 0.5);

        // --- 3. THE "P" (Bilabial Plosive) ---
        // Mechanics: Lips close completely (silence), pressure builds, lips burst open.
        // We create a tiny gap of silence after the vowel, then a noise burst.
        setTimeout(() => {
            // The "Pop" release
            this.createNoiseBurst(t + 0.42, 'lowpass', 800, 0.6, 0.05, distGain); 
        }, 0); // (Time logic handled inside arguments)
    }
  },
  createStepSound(t, distGain, panner) {
    distGain.connect(panner);
    panner.connect(this.masterGain);

    // We create a noise buffer manually here to control it better
    const dur = 0.1; // Very short duration
    const bufSize = this.ctx.sampleRate * dur;
    const buffer = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
    const data = buffer.getChannelData(0);
    
    // Fill with noise
    for (let i = 0; i < bufSize; i++) {
        data[i] = Math.random() * 2 - 1;
    }

    const noise = this.ctx.createBufferSource();
    noise.buffer = buffer;

    // BANDPASS FILTER: This is the secret to "Gravel"
    // We cut the lows (mud) and the super highs (hiss)
    // leaving only the middle "crunch" frequencies.
    const filter = this.ctx.createBiquadFilter();
    filter.type = 'bandpass';
    
    // Randomize the frequency slightly so every step sounds different
    // 800Hz - 1200Hz is the "gravel" sweet spot
    filter.frequency.setValueAtTime(400 + Math.random() * 200, t);
    filter.Q.value = 1; // Width of the band

    const gain = this.ctx.createGain();
    // Low volume for "softness"
    gain.gain.setValueAtTime(0.15, t); 
    gain.gain.exponentialRampToValueAtTime(0.001, t + dur);

    noise.connect(filter);
    filter.connect(gain);
    gain.connect(distGain);
    
    // Play slightly randomized speed for texture
    noise.playbackRate.value = 0.8 + Math.random() * 0.4;
    
    noise.start(t);
  },
  createGruntSound(t, distGain, panner) {
    distGain.connect(panner);
    panner.connect(this.masterGain);

    // --- SETTINGS ---
    const duration = .9; // CHANGE THIS: Length in seconds (was 0.4)
    
    // CARRIER (The Main Tone)
    const osc = this.ctx.createOscillator();
    osc.type = 'triangle'; 

    // MODULATOR (The "Roughness")
    const mod = this.ctx.createOscillator();
    mod.type = 'sawtooth';
    mod.frequency.value = 45; // Slower vibration for a longer growl
    
    const modGain = this.ctx.createGain();
    modGain.gain.value = 300; 

    mod.connect(modGain);
    modGain.connect(osc.frequency);

    // --- PITCH ENVELOPE (The "Rrrraaa-ow" shape) ---
    const startFreq = 150;
    osc.frequency.setValueAtTime(startFreq, t); 
    
    // Rise slower (takes 30% of the duration to peak)
    osc.frequency.linearRampToValueAtTime(300, t + (duration * 0.3)); 
    
    // Fall slower (takes until the end to drop)
    osc.frequency.exponentialRampToValueAtTime(60, t + duration); 

    // --- VOLUME ENVELOPE ---
    const gain = this.ctx.createGain();
    gain.gain.setValueAtTime(0, t);
    
    // Attack (Fade in quickly)
    gain.gain.linearRampToValueAtTime(0.4, t + 0.1); 
    
    // Sustain (Stay loud for a bit)
    gain.gain.setValueAtTime(0.4, t + (duration * 0.5));
    
    // Decay (Fade out slowly at the end)
    gain.gain.exponentialRampToValueAtTime(0.001, t + duration); 

    osc.connect(gain);
    gain.connect(distGain);

    osc.start(t);
    mod.start(t);
    
    // STOP EVERYTHING AT THE NEW DURATION
    osc.stop(t + duration);
    mod.stop(t + duration);
  },
  createGhostSound(t, distGain, panner) {
    distGain.connect(panner);
    panner.connect(this.masterGain);

    const osc = this.ctx.createOscillator();
    osc.type = 'sine';
    // Eerie wobble
    osc.frequency.setValueAtTime(400, t);
    osc.frequency.linearRampToValueAtTime(600, t + 1.0);
    osc.frequency.linearRampToValueAtTime(300, t + 2.0);

    const gain = this.ctx.createGain();
    gain.gain.setValueAtTime(0, t);
    gain.gain.linearRampToValueAtTime(0.3, t + 0.5); // Slow fade in
    gain.gain.linearRampToValueAtTime(0, t + 2.0);   // Slow fade out

    osc.connect(gain);
    gain.connect(distGain);
    osc.start(t);
    osc.stop(t + 2.0);
  },
  createNoiseBurst(t, type, freq, vol, dur, destNode) {
    // Helper to generate noise into a specific destination node
    const bufSize = this.ctx.sampleRate * dur;
    const buffer = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufSize; i++) data[i] = Math.random() * 2 - 1;

    const noise = this.ctx.createBufferSource();
    noise.buffer = buffer;

    const filter = this.ctx.createBiquadFilter();
    filter.type = type;
    filter.frequency.value = freq;

    const gain = this.ctx.createGain();
    gain.gain.setValueAtTime(vol, t);
    gain.gain.exponentialRampToValueAtTime(0.01, t + dur);

    noise.connect(filter);
    filter.connect(gain);
    gain.connect(destNode); // Connect to the Spatial Gain Node
    noise.start(t);
  },
// 5. RANDOM MUSICAL MOVEMENT (3D Spatialized)
  createMusicalMovement(t, distGain, panner) {
    distGain.connect(panner);
    panner.connect(this.masterGain);

    // --- 1. DEFINE SCALES ---
    // Frequencies for C Major / A Minor context
    // C4, D4, E4, F4, G4, A4, B4, C5...
    const scalePool = [
        [261.63, 293.66, 329.63, 392.00, 440.00, 523.25], // C Major Pentatonic (Happy/Magical)
        [220.00, 261.63, 293.66, 311.13, 329.63, 415.30], // A Harmonic Minor (Mysterious/Dark)
        [196.00, 261.63, 329.63, 392.00, 523.25, 659.25], // C Major Arpeggio (Fanfare)
    ];

    // Pick a random scale mood
    const selectedScale = scalePool[Math.floor(Math.random() * scalePool.length)];

    // --- 2. GENERATE MELODY ---
    // How many notes to play? (e.g., 3 to 6 notes)
    const noteCount = 3 + Math.floor(Math.random() * 4);
    
    // Speed of the melody (0.1s to 0.2s between notes)
    const speed = 0.12; 

    for (let i = 0; i < noteCount; i++) {
        const startTime = t + (i * speed);
        
        // Pick a random note from the selected scale
        const noteFreq = selectedScale[Math.floor(Math.random() * selectedScale.length)];

        // --- 3. SYNTHESIS (Harp/Pluck Sound) ---
        const osc = this.ctx.createOscillator();
        osc.type = 'triangle'; // Triangle is soft and flute/harp-like
        osc.frequency.setValueAtTime(noteFreq, startTime);

        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0, startTime);
        
        // Pluck Envelope: Fast attack, medium decay
        gain.gain.linearRampToValueAtTime(0.3, startTime + 0.02); 
        gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.6); 

        // Filter for "Dampening" (makes it sound more natural)
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(noteFreq * 4, startTime);
        filter.frequency.exponentialRampToValueAtTime(noteFreq, startTime + 0.4);

        // Connect
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(distGain); // Connect to the 3D panner

        osc.start(startTime);
        osc.stop(startTime + 0.6);
    }
  },
// 5. FAIRY SINGING (Continuous Glide Melody)
  createMusicalMovement2(t, distGain, panner) {
    distGain.connect(panner);
    panner.connect(this.masterGain);

    // --- 1. SETTINGS ---
    // High pitched scales for a fairy (Octave 5 and 6)
    // C Major Pentatonic: C, D, E, G, A
    const scale = [523.25, 587.33, 659.25, 783.99, 880.00, 1046.50, 1174.66, 1318.51];
    
    // How many notes in this phrase?
    const noteCount = 4 + Math.floor(Math.random() * 3); 
    const noteDuration = 0.25; // How long each note holds
    const glideTime = 0.1;     // How long it takes to slide to the next note
    const totalDuration = noteCount * noteDuration;

    // --- 2. THE VOICE (One Oscillator) ---
    // We use ONE oscillator for the whole melody to ensure smooth sliding
    const osc = this.ctx.createOscillator();
    osc.type = 'triangle'; // Triangle sounds like a flute/voice

    // --- 3. VIBRATO (The "Life") ---
    // A slight pitch wobble makes it sound like singing, not a computer
    const vib = this.ctx.createOscillator();
    vib.frequency.value = 6; // 6Hz wobble (typical singer speed)
    const vibGain = this.ctx.createGain();
    vibGain.gain.value = 15; // Depth of wobble
    
    vib.connect(vibGain);
    vibGain.connect(osc.frequency);
    vib.start(t);
    vib.stop(t + totalDuration + 1);

    // --- 4. THE MELODY (Scheduling the Slides) ---
    // Start at a random note
    let currentFreq = scale[Math.floor(Math.random() * scale.length)];
    osc.frequency.setValueAtTime(currentFreq, t);

    // Loop through and schedule the glides
    for (let i = 1; i < noteCount; i++) {
        const time = t + (i * noteDuration);
        const nextFreq = scale[Math.floor(Math.random() * scale.length)];

        // KEY: exponentialRampToValueAtTime creates the SLIDE
        // We start sliding 'glideTime' before the beat, arriving exactly on time
        osc.frequency.setTargetAtTime(nextFreq, time - glideTime, 0.05);
        
        currentFreq = nextFreq;
    }

    // --- 5. VOLUME ENVELOPE (Breath) ---
    const gain = this.ctx.createGain();
    gain.gain.setValueAtTime(0, t);
    
    // Fade in (Breath)
    gain.gain.linearRampToValueAtTime(0.25, t + 0.3);
    
    // Sustain mostly level, maybe slight swells
    gain.gain.setValueAtTime(0.25, t + totalDuration - 0.2);
    
    // Fade Out (Breath out)
    gain.gain.linearRampToValueAtTime(0, t + totalDuration);

    // Connect and Play
    osc.connect(gain);
    gain.connect(distGain);

    osc.start(t);
    osc.stop(t + totalDuration);
  },
  // 5. FAIRY CHORUS (Harmonized Singing with Slides)
  createMusicalMovement3(t, distGain, panner) {
    distGain.connect(panner);
    panner.connect(this.masterGain);

    // --- 1. SETTINGS ---
    // C Major Pentatonic (High Register)
    const scale = [523.25, 587.33, 659.25, 783.99, 880.00, 1046.50, 1174.66];
    
    // Melody Settings
    const noteCount = 4 + Math.floor(Math.random() * 3); 
    const noteDuration = 0.3; 
    const glideTime = 0.15;   
    const totalDuration = noteCount * noteDuration;

    // --- 2. THE CHORUS ENGINE ---
    // We create TWO voices to sing together (Main + Harmony)
    // This creates the "Chorus" texture.
    const voices = [
        { type: 'triangle', ratio: 1.0 },   // Main Voice
        { type: 'sine',     ratio: 1.5 }    // Harmony (Perfect 5th higher)
    ];

    voices.forEach(v => {
        const osc = this.ctx.createOscillator();
        osc.type = v.type;

        // --- VIBRATO (Shared LFO) ---
        const vib = this.ctx.createOscillator();
        vib.frequency.value = 6; 
        const vibGain = this.ctx.createGain();
        vibGain.gain.value = 15; 
        
        vib.connect(vibGain);
        vibGain.connect(osc.frequency);
        vib.start(t);
        vib.stop(t + totalDuration + 1);

        // --- MELODY SCHEDULING ---
        // Pick start note
        let baseFreq = scale[Math.floor(Math.random() * scale.length)];
        
        // Apply ratio (Main vs Harmony)
        osc.frequency.setValueAtTime(baseFreq * v.ratio, t);

        // Schedule the slides for this oscillator
        // We use a separate loop logic here, but seed random so it *could* differ
        // strictly speaking, for a "tight" harmony, they should follow the same notes.
        // Let's pre-calculate the melody so both voices sing the SAME tune.
        
    });
    
    // RE-DO: We need to pre-calculate the melody array first 
    // so both voices slide to the same notes at the same time.
    
    const melody = [];
    for (let i = 0; i < noteCount; i++) {
        melody.push(scale[Math.floor(Math.random() * scale.length)]);
    }

    // NOW create the voices loop
    voices.forEach(v => {
        const osc = this.ctx.createOscillator();
        osc.type = v.type;

        // Vibrato
        const vib = this.ctx.createOscillator();
        vib.frequency.value = 6; 
        const vibGain = this.ctx.createGain();
        vibGain.gain.value = 12; // Slight wobble
        vib.connect(vibGain);
        vibGain.connect(osc.frequency);
        vib.start(t);
        vib.stop(t + totalDuration + 1);

        // Initialize Start Pitch
        osc.frequency.setValueAtTime(melody[0] * v.ratio, t);

        // Schedule Slides
        for (let i = 1; i < noteCount; i++) {
            const time = t + (i * noteDuration);
            const targetFreq = melody[i] * v.ratio;
            
            // Slide to the next note
            osc.frequency.setTargetAtTime(targetFreq, time - glideTime, 0.08);
        }

        // Volume Envelope (Breath)
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0, t);
        // Fade In
        gain.gain.linearRampToValueAtTime(0.2, t + 0.4); 
        // Fade Out
        gain.gain.linearRampToValueAtTime(0, t + totalDuration);

        // Connect
        osc.connect(gain);
        gain.connect(distGain);

        osc.start(t);
        osc.stop(t + totalDuration);
    });
  },
  // 5. ETHEREAL FAIRY CHOIR (Detuned + Filtered)
  createMusicalMovement4(t, distGain, panner) {
    distGain.connect(panner);
    panner.connect(this.masterGain);

    // --- 1. SETTINGS ---
    // Use a slightly lower register so it's less piercing
    // C Major Pentatonic (C5 to A5 range)
    const scale = [523.25, 587.33, 659.25, 783.99, 880.00, 1046.50];
    
    const noteCount = 4 + Math.floor(Math.random() * 2); 
    const noteDuration = 0.4; // Slower, more legato
    const glideTime = 0.2;   
    const totalDuration = noteCount * noteDuration;

    // PRE-CALCULATE MELODY
    const melody = [];
    for (let i = 0; i < noteCount; i++) {
        melody.push(scale[Math.floor(Math.random() * scale.length)]);
    }

    // --- 2. THE VOICES (The "Ensemble") ---
    // 1. Main Voice
    // 2. Detuned Voice (Creates the "Chorus/Shimmer" effect)
    // 3. Harmony Voice (Adds the "Chord")
    const voices = [
        { ratio: 1.0, detune: 0 },    // Center
        { ratio: 1.0, detune: 8 },    // Slightly sharp (thickens sound)
        { ratio: 1.5, detune: -5 }    // Perfect 5th, slightly flat
    ];

    voices.forEach(v => {
        const osc = this.ctx.createOscillator();
        osc.type = 'triangle'; // Warm base

        // --- FILTER (The "Mouth") ---
        // This removes the "buzzy" high end, making it sound like "Oooo" not "Eeee"
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.Q.value = 1;
        // Filter Envelope: Opens slightly with each note, but stays soft
        filter.frequency.setValueAtTime(800, t); 
        filter.frequency.linearRampToValueAtTime(1200, t + (totalDuration/2));

        // --- VIBRATO ---
        const vib = this.ctx.createOscillator();
        vib.frequency.value = 5.5; // Slightly slower, more natural
        const vibGain = this.ctx.createGain();
        vibGain.gain.value = 10; 
        vib.connect(vibGain);
        vibGain.connect(osc.frequency);
        vib.start(t);
        vib.stop(t + totalDuration + 2);

        // --- PITCH LOGIC ---
        // Set initial pitch
        const startFreq = melody[0] * v.ratio;
        osc.frequency.setValueAtTime(startFreq, t);
        // Apply static detune (cents)
        osc.detune.value = v.detune;

        // Schedule Slides
        for (let i = 1; i < noteCount; i++) {
            const time = t + (i * noteDuration);
            const targetFreq = melody[i] * v.ratio;
            // Slower, smoother slide
            osc.frequency.setTargetAtTime(targetFreq, time - glideTime, 0.15);
        }

        // --- VOLUME ENVELOPE (Breath) ---
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0, t);
        
        // Swell In (Very slow attack = "Ethereal")
        gain.gain.linearRampToValueAtTime(0.15, t + 0.8); 
        
        // Sustain
        gain.gain.setValueAtTime(0.15, t + totalDuration - 0.5);
        
        // Long Release (Tail)
        gain.gain.linearRampToValueAtTime(0, t + totalDuration + 1.0);

        // --- CONNECT ---
        osc.connect(filter); // Oscillator -> Filter
        filter.connect(gain); // Filter -> Volume
        gain.connect(distGain); // Volume -> Distance/Pan

        osc.start(t);
        osc.stop(t + totalDuration + 1.0);
    });
  },
  createLightning(t) {
    // 1. RANDOMIZE PARAMETERS
    const intensity = Math.random(); 
    const mainDuration = 0.5 + (Math.random() * 1.5); // The active "strike" time
    const releaseTime = 0.8; // <--- NEW: Extra time for the fade out/tail
    const totalDuration = mainDuration + releaseTime; // Total buffer length

    const filterFreq = 400 + (intensity * 3000); 
    const volume = 0.01 + (intensity * 0.03); 

    // 2. CREATE NOISE BUFFER
    // We use totalDuration here so the source doesn't run out of data 
    // while we are trying to fade it out.
    const bufSize = this.ctx.sampleRate * totalDuration; 
    const buffer = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < bufSize; i++) {
        data[i] = Math.random() * 2 - 1;
    }

    const noise = this.ctx.createBufferSource();
    noise.buffer = buffer;

    // 3. FILTER 
    const filter = this.ctx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.setValueAtTime(filterFreq, t);
    // Sweep down over the main duration
    filter.frequency.linearRampToValueAtTime(filterFreq * 0.5, t + mainDuration);

    // 4. ENVELOPE 
    const gain = this.ctx.createGain();
    gain.gain.setValueAtTime(0, t);
    
    // Sharp Attack
    gain.gain.linearRampToValueAtTime(volume, t + 0.05);
    
    // Jagged Decay 
    // We keep the spikes within the 'mainDuration'
    const steps = 4;
    for(let i=0; i < steps; i++) {
        // Distribute steps over mainDuration only
        const nextTime = t + 0.05 + ((mainDuration/steps) * (i+1));
        const randomVol = (volume * 0.2) + (Math.random() * (volume * 0.5));
        gain.gain.exponentialRampToValueAtTime(randomVol, nextTime);
    }
    
    // --- THE FIX: SMOOTH FADE OUT ---
    // At (t + mainDuration), we start the final release.
    // We use linearRamp to 0. It is often safer than exponential for 
    // the very end to avoid the "infinite approach to zero" math issue.
    
    gain.gain.linearRampToValueAtTime(0, t + totalDuration);

    // 5. CONNECT
    noise.connect(filter);
    filter.connect(gain);
    gain.connect(this.ctx.destination); 
    
    noise.start(t);
    // Optional: garbage collect the node after it's done
    noise.stop(t + totalDuration + 0.1); 
},
  // 6. DIALOGUE MUMBLE ("Typewriter Text" Sound)
  createDialogueMumble(t, distGain, panner, voiceType = 'mid') {
    // Dialogue is usually "In your head" (UI), so we often skip 3D panning,
    // but connecting it allows you to have an NPC "mumble" from a corner of the room.
    distGain.connect(panner);
    panner.connect(this.masterGain);

    // --- SETTINGS ---
    const phraseLength = 8 + Math.floor(Math.random() * 6); // 8 to 14 "syllables"
    const speed = 0.08; // Gap between blips (0.08s is fast talking)
    
    // Voice Pitch Settings
    let baseFreq = 200; 
    let waveType = 'square'; // Square = Retro/Robot, Triangle = Soft/Cute
    
    if (voiceType === 'high') { baseFreq = 400; waveType = 'triangle'; } // Fairy/Kid
    if (voiceType === 'low')  { baseFreq = 100; waveType = 'sawtooth'; } // Monster/Guard
    if (voiceType === 'mid')  { baseFreq = 220; waveType = 'square'; }   // Hero/Villager

    // --- GENERATE THE SENTENCE ---
    for (let i = 0; i < phraseLength; i++) {
        // 1. TIMING (Rhythm)
        // Add tiny random offsets so it's not a machine gun
        const time = t + (i * speed) + (Math.random() * 0.02);

        // Occasional "Pause" (simulates punctuation or breath)
        // Skip 10% of beats
        if (Math.random() > 0.9) continue; 

        // 2. PITCH (Inflection)
        // Randomize pitch slightly (+/- 30Hz) to sound like "talking"
        const freq = baseFreq + (Math.random() * 60 - 30);

        // 3. SYNTHESIS (The Blip)
        const osc = this.ctx.createOscillator();
        osc.type = waveType;
        osc.frequency.setValueAtTime(freq, time);

        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0, time);
        
        // Very fast envelope (Staccato)
        gain.gain.linearRampToValueAtTime(0.15, time + 0.01); // Attack
        gain.gain.exponentialRampToValueAtTime(0.001, time + 0.06); // Decay

        osc.connect(gain);
        gain.connect(distGain);

        osc.start(time);
        osc.stop(time + 0.07);
    }
  },

};
//MODULE 0: Calm Before the Storm
class ScaryM {
      constructor(ctx, dest) {
        this.ctx = ctx;
        // Add a Master Compressor so the dissonance doesn't clip speakers
        this.masterGain = ctx.createGain();
        this.masterGain.gain.value = 0.8;

        // Create a Feedback Delay (The "Echo from the Well")
        this.delay = ctx.createDelay();
        this.delay.delayTime.value = 0.4; // 400ms delay
        this.feedback = ctx.createGain();
        this.feedback.gain.value = 0.6; // High feedback

        this.delay.connect(this.feedback);
        this.feedback.connect(this.delay);
        this.delay.connect(this.masterGain);
        this.masterGain.connect(dest);

        this.dest = this.masterGain; // Voices connect here
        this.destWithDelay = this.delay; // Some voices connect to delay

        this.voices = new Map();
        this.timer = null;
        this.conductor = null;
      }

      start() {
        // Lower ranges for a darker tone
        const vids = ['sop', 'alt', 'ten', 'bas'];
        const rngs = { sop: [60, 80], alt: [50, 70], ten: [40, 60], bas: [28, 48] };

        vids.forEach(vid => {
          // Pass the delay line to the voice
          this.voices.set(vid, new ScaryV(vid, rngs[vid], this.ctx, this.dest, this.destWithDelay));
        });

        this.conductor = {
          t: 0,
          tick: () => {
            this.conductor.t += 100;
            this.voices.forEach(vo => {
              if (this.conductor.t >= vo.nextTime) {
                // SCARY INTERVALS:
                // 1 = Minor 2nd (Jaws theme tension)
                // 6 = Tritone (The "Devil's Interval")
                // 11 = Major 7th (Unresolved, piercing)
                const intervals = [1, 6, 11, -1, -6, -13];

                const int = intervals[Math.floor(Math.random() * intervals.length)];

                // 20% chance to jump a huge distance (octave displacement)
                const octaveJump = Math.random() > 0.8 ? 12 : 0;
                const nextPitch = vo.currPitch ? vo.currPitch + int + octaveJump : 50;

                // Slower, agonizing durations (2 to 5 seconds)
                const duration = 2000 + Math.random() * 3000;

                if (nextPitch >= vo.range[0] && nextPitch <= vo.range[1]) {
                  vo.play(nextPitch, duration);
                  vo.currPitch = nextPitch;
                  // Overlap voices creates clusters
                  vo.nextTime = this.conductor.t + (duration * 0.7);
                }
              }
            });
          }
        };

        // Stagger starts
        this.voices.forEach(vo => vo.nextTime = Math.random() * 5000);
        this.timer = setInterval(() => this.conductor.tick(), 100);
      }

      stop() {
        clearInterval(this.timer);
        this.voices.forEach(v => v.silence());
        this.voices.clear();
      }
    }
class ScaryV {
      constructor(id, range, ctx, dest, delayNode) {
        this.id = id; this.range = range; this.ctx = ctx;
        this.dest = dest; this.delayNode = delayNode;
        this.osc = null; this.gain = null; this.filter = null;
        this.currPitch = null; this.nextTime = 0;
      }

      play(pitch, duration) {
        // Crossfade logic: don't kill the old note instantly, let it bleed
        const oldOsc = this.osc;
        const oldGain = this.gain;
        if (oldGain) {
          oldGain.gain.cancelScheduledValues(this.ctx.currentTime);
          oldGain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 3); // 3s fade out (Ghostly)
          if (oldOsc) oldOsc.stop(this.ctx.currentTime + 3.1);
        }

        // 1. FREQUENCY CALCULATION (With Detune)
        // Add random "drift" to the pitch so it's never perfectly in tune (Uncanny Valley)
        const detune = (Math.random() * 20) - 10; // +/- 10 cents
        const freq = 440 * Math.pow(2, ((pitch + (detune / 100)) - 69) / 12);

        // 2. OSCILLATOR (Sawtooth is too clean, let's filter it)
        this.osc = this.ctx.createOscillator();
        this.osc.type = Math.random() > 0.5 ? 'sawtooth' : 'triangle';
        this.osc.frequency.setValueAtTime(freq, this.ctx.currentTime);

        // 3. LOW PASS FILTER (The "Next Room" Effect)
        this.filter = this.ctx.createBiquadFilter();
        this.filter.type = 'lowpass';
        // Randomly open/close the filter for "breathing" texture
        this.filter.frequency.setValueAtTime(200, this.ctx.currentTime);
        this.filter.frequency.linearRampToValueAtTime(800 + Math.random() * 1000, this.ctx.currentTime + (duration / 1000));

        // 4. ENVELOPE (Slow Attack, Long Release)
        this.gain = this.ctx.createGain();
        this.gain.gain.setValueAtTime(0, this.ctx.currentTime);
        // Take 2 seconds to reach full volume (Creeping in)
        this.gain.gain.linearRampToValueAtTime(0.08, this.ctx.currentTime + 2);

        // 5. CONNECTIONS
        this.osc.connect(this.filter);
        this.filter.connect(this.gain);

        // 50% chance to send to Delay (Echo) or Direct
        if (Math.random() > 0.5) {
          this.gain.connect(this.delayNode);
        } else {
          this.gain.connect(this.dest);
        }

        this.osc.start();

        // 6. MICRO-GLISSANDO (Slide slightly to the note)
        // This simulates a violinist searching for the pitch
        this.osc.frequency.setValueAtTime(freq * 0.98, this.ctx.currentTime);
        this.osc.frequency.exponentialRampToValueAtTime(freq, this.ctx.currentTime + 1);
      }

      silence() {
    if (this.gain) {
        this.gain.gain.cancelScheduledValues(this.ctx.currentTime);
        this.gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.1); // Instant kill
    }
    if (this.osc) {
        this.osc.stop(this.ctx.currentTime + 0.1);
        this.osc = null;
    }
    }
    }
//MODULE 1: Demon Lord's Castle
class ScaryModule {
      constructor(ctx, dest) {
        this.ctx = ctx;
        this.dest = dest;
        this.voices = new Map();
        this.timer = null;
        this.conductor = null;
      }

      start() {
        const vids = ['sop', 'alt', 'ten', 'bas'];
        const rngs = { sop: [60, 79], alt: [55, 74], ten: [48, 67], bas: [36, 55] };

        vids.forEach(vid => {
          this.voices.set(vid, new ScaryVoice(vid, rngs[vid], this.ctx, this.dest));
        });

        this.conductor = {
          t: 0,
          tick: () => {
            this.conductor.t += 100;
            this.voices.forEach(vo => {
              if (this.conductor.t >= vo.nextTime) {
                const intervals = [0, 2, 4, 5, 7, -3, -5];
                const int = intervals[Math.floor(Math.random() * intervals.length)];
                const nextPitch = vo.currPitch ? vo.currPitch + int : 60;
                const duration = 500 + Math.random() * 500;

                if (nextPitch >= vo.range[0] && nextPitch <= vo.range[1]) {
                  vo.play(nextPitch);
                  vo.currPitch = nextPitch;
                  vo.nextTime = this.conductor.t + duration;
                }
              }
            });
          }
        };

        this.voices.forEach(vo => vo.nextTime = Math.random() * 2000);
        this.timer = setInterval(() => this.conductor.tick(), 100);
      }

      stop() {
        clearInterval(this.timer);
        this.voices.forEach(v => v.silence());
        this.voices.clear();
      }
    }
class ScaryVoice {
      constructor(id, range, ctx, dest) {
        this.id = id; this.range = range; this.ctx = ctx; this.dest = dest;
        this.osc = null; this.gain = null; this.currPitch = null; this.nextTime = 0;
      }
      play(pitch) {
        if (this.osc) this.silence();
        const freq = 440 * Math.pow(2, (pitch - 69) / 12);
        this.osc = this.ctx.createOscillator();
        this.osc.type = 'sawtooth';
        this.osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        this.gain = this.ctx.createGain();
        this.gain.gain.setValueAtTime(0, this.ctx.currentTime);
        this.gain.gain.linearRampToValueAtTime(0.1, this.ctx.currentTime + 0.1);
        this.osc.connect(this.gain);
        this.gain.connect(this.dest);
        this.osc.start();
        if (this.currPitch) this.osc.frequency.linearRampToValueAtTime(freq, this.ctx.currentTime + 0.05);
      }
      silence() {
        if (this.gain) this.gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.05);
        if (this.osc) { this.osc.stop(this.ctx.currentTime + 0.1); this.osc = null; }
      }
    }
//MODULE 2: Simple Dungeon Music
class SimpleModule {
      constructor(ctx, dest) {
        this.ctx = ctx;
        this.mainOut = dest;
        this.timer = null;
        this.tempo = 100;

        this.fxInput = ctx.createGain();
        this.fxInput.gain.value = 0.5;
        this.comp = ctx.createDynamicsCompressor();
        this.comp.threshold.value = -20;
        this.comp.ratio.value = 4;
        this.eq = ctx.createBiquadFilter();
        this.eq.type = 'highshelf'; this.eq.frequency.value = 2000; this.eq.gain.value = 3;
        this.revNode = ctx.createConvolver();
        this.setupReverb();
        this.revGain = ctx.createGain(); this.revGain.gain.value = 0.35;
        this.dryGain = ctx.createGain(); this.dryGain.gain.value = 0.65;

        this.fxInput.connect(this.comp);
        this.comp.connect(this.eq);
        this.eq.connect(this.dryGain);
        this.eq.connect(this.revNode);
        this.revNode.connect(this.revGain);
        this.dryGain.connect(this.mainOut);
        this.revGain.connect(this.mainOut);

        this.cfg = {
          scales: { ionian: [0, 2, 4, 5, 7, 9, 11], dorian: [0, 2, 3, 5, 7, 9, 10], aeolian: [0, 2, 3, 5, 7, 8, 10], phrygian: [0, 1, 3, 5, 7, 8, 10] },
          voices: {
            soprano: { p: 0.8, type: 'sawtooth', range: [1, 3, 5, 7], role: 'upper' },
            alto: { p: 0.7, type: 'triangle', range: [1, 2, 4, 5], role: 'lower' }
          }
        };

        this.st = { tickCount: 0, activeVoices: [], scaleName: 'dorian', scaleIntervals: [], rootFreqs: {}, rootNoteIndex: 0 };
      }

      setupReverb() {
        const len = this.ctx.sampleRate * 2.0;
        const buf = this.ctx.createBuffer(2, len, this.ctx.sampleRate);
        for (let c = 0; c < 2; c++) {
          const d = buf.getChannelData(c);
          for (let i = 0; i < len; i++) d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / len, 2.5);
        }
        this.revNode.buffer = buf;
      }

      start() {
        this.st.activeVoices = [];
        this.st.tickCount = 0;
        this.updateKey();
        this.addVoice('soprano');
        const tickRate = (60 / this.tempo) * 250;
        this.timer = setInterval(() => this.tick(), tickRate);
      }

      stop() {
        if (this.timer) clearInterval(this.timer);
        this.fxInput.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.3);
        setTimeout(() => { this.fxInput.disconnect(); this.revNode.disconnect(); this.comp.disconnect(); }, 400);
      }

      updateKey() {
        const scaleKeys = Object.keys(this.cfg.scales);
        this.st.scaleName = scaleKeys[Math.floor(Math.random() * scaleKeys.length)];
        this.st.scaleIntervals = this.cfg.scales[this.st.scaleName];
        this.st.rootNoteIndex = Math.floor(Math.random() * 12);
        this.st.rootFreqs = {};
        for (let i = 0; i < 36; i++) {
          const noteNum = 48 + i + this.st.rootNoteIndex;
          const freq = 440 * Math.pow(2, (noteNum - 69) / 12);
          this.st.rootFreqs[i] = freq;
        }
      }

      addVoice(id) {
        const def = this.cfg.voices[id];
        this.st.activeVoices.push({ id: id, ...def, momentum: 5, active: true });
      }

      tick() {
        this.st.tickCount++;
        if (this.st.tickCount === 20) this.addVoice('alto');
        if (this.st.tickCount % 64 === 0) this.updateKey();
        this.st.activeVoices.forEach(v => this.processVoice(v));
      }

      processVoice(v) {
        let chance = v.p + (v.momentum * 0.1);
        if (v.role === 'upper') chance *= 1.1;
        if (Math.random() < chance) {
          this.playNote(v);
          v.momentum = Math.max(-2, v.momentum - (2 + Math.random()));
        } else {
          v.momentum = Math.min(10, v.momentum + 1);
        }
      }

      playNote(v) {
        const scale = this.st.scaleIntervals;
        const scaleDegree = Math.floor(Math.random() * scale.length);
        const pitchClass = scale[scaleDegree];
        let octaveBase = v.role === 'upper' ? 12 : 0;
        const noteIndex = octaveBase + pitchClass;
        const freq = this.st.rootFreqs[noteIndex];
        if (!freq) return;

        const r = Math.random();
        let dur = 0.5;
        if (r < 0.3) dur = 0.25; else if (r > 0.8) dur = 1.0;

        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gn = this.ctx.createGain();
        osc.type = v.type;
        osc.frequency.setValueAtTime(freq, t);
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(600 + (Math.random() * 1000), t);

        osc.connect(filter); filter.connect(gn); gn.connect(this.fxInput);
        gn.gain.setValueAtTime(0, t);
        gn.gain.linearRampToValueAtTime(0.2, t + 0.02);
        gn.gain.exponentialRampToValueAtTime(0.01, t + dur);
        gn.gain.linearRampToValueAtTime(0, t + dur + 0.1);
        osc.start(t);
        osc.stop(t + dur + 0.2);
      }
    }
// MODULE 3: Stop and Smell the Roses
class RoseModule {
      constructor(ctx, dest) {
        this.ctx = ctx;
        this.dest = dest;
        this.timer = null;

        // --- EMOTIONAL STATS ---
        this.tempo = 60; // Very Slow (Adagio)
        this.keyBase = 155.56; // Eb3 (Eb Major - The key of "Heroic Love")

        // Eb Major Scale: Eb, F, G, Ab, Bb, C, D
        this.scale = [0, 2, 4, 5, 7, 9, 11];

        // --- STATE ---
        this.tickCount = 0;
        this.startTime = 0;

        // Timeline: 'explosion' -> 'silence' -> 'piano_solo' -> 'tutti'
        this.phase = 'explosion';

        // --- GLOBAL FX: THE "CATHEDRAL" REVERB ---
        // We need a ConvolverNode to simulate a massive space
        this.reverb = ctx.createConvolver();
        this.reverb.buffer = this.createImpulseResponse(3.0, 2.0); // 3 seconds reverb

        // Master Gain for Fade Out
        this.masterGain = ctx.createGain();
        this.masterGain.gain.value = 1.0;

        // Chain: Instruments -> Reverb -> Master -> Dest
        this.reverb.connect(this.masterGain);
        this.masterGain.connect(dest);

        // Direct signal mix (Dry/Wet)
        this.dryGain = ctx.createGain();
        this.dryGain.gain.value = 0.6;
        this.dryGain.connect(this.masterGain);

        // This is where instruments connect
        this.input = ctx.createGain();
        this.input.connect(this.reverb); // Wet
        this.input.connect(this.dryGain); // Dry
      }

      createImpulseResponse(duration, decay) {
        const rate = this.ctx.sampleRate;
        const length = rate * duration;
        const impulse = this.ctx.createBuffer(2, length, rate);
        const left = impulse.getChannelData(0);
        const right = impulse.getChannelData(1);

        for (let i = 0; i < length; i++) {
          // Exponential decay noise
          const n = i / length;
          const env = Math.pow(1 - n, decay);
          left[i] = (Math.random() * 2 - 1) * env;
          right[i] = (Math.random() * 2 - 1) * env;
        }
        return impulse;
      }

      start() {
        this.tickCount = 0;
        this.startTime = this.ctx.currentTime;
        this.phase = 'explosion';

        // Trigger the blinding light immediately
        this.playExplosion();

        // Start the loop
        this.loop();
      }

      stop() {
        if (this.timer) clearTimeout(this.timer);
        this.masterGain.gain.cancelScheduledValues(this.ctx.currentTime);
        this.masterGain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.1);
      }

      loop() {
        const secondsPerBeat = 60 / this.tempo;
        const interval = (secondsPerBeat / 4) * 1000; // 16th notes

        this.timer = setTimeout(() => this.loop(), interval);

        const t = this.ctx.currentTime - this.startTime;
        const step = this.tickCount % 32;

        // --- CINEMATIC TIMELINE ---

        // 0s - 4s: The Explosion (Handled in start(), we just wait)
        if (t < 4.0) {
          // Do nothing, let the noise fade
        }
        // 4s - 12s: The "Glimpse" (Lonely Piano)
        else if (t >= 4.0 && t < 16.0) {
          this.phase = 'piano_solo';
          if (step % 4 === 0) this.playPianoMelody(step);
          if (step % 16 === 0) this.playBassPad(0); // Root
        }
        // 16s+: The "Walk Away" (Strings + Sparkles)
        else {
          this.phase = 'tutti';

          // Piano continues
          if (step % 4 === 0) this.playPianoMelody(step);

          // Strings Swell (New chord every 2 bars)
          if (step % 32 === 0) {
            // Progression: I -> IV -> I -> V
            const chord = (this.tickCount % 64 === 0) ? 0 : 5; // I or IV
            this.playStringSection(chord);
          }

          // The "Repair" Sparkles (Magic fixing the world)
          if (step % 2 === 0) this.playSparkle(step);
        }

        this.tickCount++;
      }

      // --- INSTRUMENTS ---

      playExplosion() {
        const t = this.ctx.currentTime;

        // 1. White Noise Burst (The "Flash")
        const buf = this.ctx.createBuffer(1, 44100 * 4, this.ctx.sampleRate);
        const data = buf.getChannelData(0);
        for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
        const src = this.ctx.createBufferSource();
        src.buffer = buf;

        // Lowpass Filter sweep (Opening up the sound)
        const f = this.ctx.createBiquadFilter();
        f.type = 'lowpass';
        f.frequency.setValueAtTime(100, t);
        f.frequency.exponentialRampToValueAtTime(10000, t + 0.5); // Flash

        const g = this.ctx.createGain();
        g.gain.setValueAtTime(0, t);
        g.gain.linearRampToValueAtTime(0.8, t + 0.1);
        g.gain.exponentialRampToValueAtTime(0.001, t + 3.5); // Long fade out

        src.connect(f); f.connect(g); g.connect(this.input);
        src.start(t);

        // 2. Sub Bass Drop (The "Impact")
        const osc = this.ctx.createOscillator();
        osc.frequency.setValueAtTime(100, t);
        osc.frequency.exponentialRampToValueAtTime(20, t + 2.0);

        const g2 = this.ctx.createGain();
        g2.gain.setValueAtTime(0.5, t);
        g2.gain.exponentialRampToValueAtTime(0.001, t + 2.0);

        osc.connect(g2); g2.connect(this.input);
        osc.start(t);
      }

      playPianoMelody(step) {
        // Procedural "Hope" Melody
        // Keeps it simple, mostly stepwise motion
        const t = this.ctx.currentTime;

        // Random note from scale (Pentatonic-ish for safety)
        // 0, 1, 2, 4, 5 (Eb, F, G, Bb, C)
        const safeNotes = [0, 2, 4, 7, 9, 11];
        const noteIndex = safeNotes[Math.floor(Math.random() * safeNotes.length)];

        // Octave: Middle range
        const freq = this.keyBase * Math.pow(2, (this.scale[noteIndex % 7] + 12) / 12);

        // SOUND: Soft Piano (Sine + Triangle)
        const osc = this.ctx.createOscillator();
        osc.type = 'triangle'; // Triangle has a nice hollow wood sound
        osc.frequency.value = freq;

        const g = this.ctx.createGain();
        g.gain.setValueAtTime(0, t);
        g.gain.linearRampToValueAtTime(0.2, t + 0.05); // Soft attack
        g.gain.exponentialRampToValueAtTime(0.001, t + 3.0); // Long ring

        osc.connect(g); g.connect(this.input);
        osc.start(t); osc.stop(t + 3.0);
      }

      playStringSection(rootIndex) {
        // Lush Pad
        const t = this.ctx.currentTime;
        const chordOffsets = [0, 2, 4, 6]; // Major 7th Chord (Lush/Nostalgic)

        chordOffsets.forEach((offset, i) => {
          const idx = (rootIndex + offset) % 7;
          const semitone = this.scale[idx];
          const freq = this.keyBase * Math.pow(2, semitone / 12);

          // Dual Oscillator for width
          this.createPadVoice(t, freq);
          // Add a lower octave for the root
          if (i === 0) this.createPadVoice(t, freq / 2);
        });
      }

      createPadVoice(t, freq) {
        const osc = this.ctx.createOscillator();
        osc.type = 'sawtooth';
        osc.frequency.value = freq;
        osc.detune.value = (Math.random() * 10) - 5; // Detuned

        const f = this.ctx.createBiquadFilter();
        f.type = 'lowpass';
        f.frequency.value = 600; // Very warm, muffled

        const g = this.ctx.createGain();
        g.gain.setValueAtTime(0, t);
        g.gain.linearRampToValueAtTime(0.05, t + 2.0); // Slow swell (2 seconds)
        g.gain.setTargetAtTime(0, t + 6.0, 1.0); // Slow release

        osc.connect(f); f.connect(g); g.connect(this.input);
        osc.start(t); osc.stop(t + 8.0);
      }

      playSparkle(step) {
        // High pitched sine waves panning around
        // Represents "light" or "magic"
        const t = this.ctx.currentTime;

        // Ascending run
        const noteIndex = step % 7;
        const freq = (this.keyBase * 4) * Math.pow(2, this.scale[noteIndex] / 12);

        const osc = this.ctx.createOscillator();
        osc.type = 'sine';
        osc.frequency.value = freq;

        const panner = this.ctx.createStereoPanner();
        panner.pan.value = Math.sin(t * 2); // Pan back and forth

        const g = this.ctx.createGain();
        g.gain.setValueAtTime(0, t);
        g.gain.linearRampToValueAtTime(0.05, t + 0.1);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.5);

        osc.connect(g); g.connect(panner); panner.connect(this.input);
        osc.start(t); osc.stop(t + 0.5);
      }

      playBassPad(rootIndex) {
        const t = this.ctx.currentTime;
        const freq = (this.keyBase / 2) * Math.pow(2, this.scale[rootIndex] / 12);

        const osc = this.ctx.createOscillator();
        osc.type = 'sine'; // Sub bass
        osc.frequency.value = freq;

        const g = this.ctx.createGain();
        g.gain.setValueAtTime(0, t);
        g.gain.linearRampToValueAtTime(0.3, t + 1.0);
        g.gain.setTargetAtTime(0, t + 3.0, 1.0);

        osc.connect(g); g.connect(this.input);
        osc.start(t); osc.stop(t + 5.0);
      }
    }
//MODULE 4: Dungeon
class DungeonM {
      constructor(ctx, dest) {
        this.ctx = ctx;
        this.mainOut = dest;
        this.timer = null;
        this.tempo = 60; // Slower tempo for heaviness

        // 1. THE FX CHAIN (Compressor -> Dark Reverb)
        this.masterGain = ctx.createGain();
        this.masterGain.gain.value = 0.7;

        this.comp = ctx.createDynamicsCompressor();
        this.comp.threshold.value = -30;
        this.comp.ratio.value = 12; // Heavy compression to sustain the tails

        // "Stone Wall" EQ - Cut the highs, boost the low-mids
        this.eq = ctx.createBiquadFilter();
        this.eq.type = 'lowpass';
        this.eq.frequency.value = 3000;

        // 2. CONVOLUTION REVERB (The "Great Hall")
        this.revNode = ctx.createConvolver();
        this.setupDarkReverb();

        this.revGain = ctx.createGain(); this.revGain.gain.value = 0.6; // Wet
        this.dryGain = ctx.createGain(); this.dryGain.gain.value = 0.4; // Dry

        // Connect Chain
        this.masterGain.connect(this.comp);
        this.comp.connect(this.eq);
        this.eq.connect(this.dryGain);
        this.eq.connect(this.revNode);
        this.revNode.connect(this.revGain);
        this.dryGain.connect(this.mainOut);
        this.revGain.connect(this.mainOut);

        // 3. CONFIGURATION
        this.cfg = {
          // Darker, "Ancient" Scales
          scales: {
            phrygianDom: [0, 1, 4, 5, 7, 8, 10], // "Desert Temple"
            hungarian: [0, 2, 3, 6, 7, 8, 11], // "Vampire Castle"
            locrian: [0, 1, 3, 5, 6, 8, 10]  // "Unsettling/Wrong"
          },
          voices: {
            // FM Bell sound
            chime: { p: 0.6, type: 'sine', range: [12, 14, 24], modIndex: 12, decay: 3.0 },
            // Deep resonant pad
            bass: { p: 0.4, type: 'triangle', range: [-12, -24], modIndex: 2, decay: 2.0 }
          }
        };

        this.st = {
          tickCount: 0,
          scaleIntervals: this.cfg.scales.phrygianDom,
          rootFreq: 55 // Low A (A1) as absolute anchor
        };

        this.droneOsc = null;
        this.droneGain = null;
      }

      setupDarkReverb() {
        // Generate a 4-second reverb tail (Massive space)
        const duration = 4.0;
        const len = this.ctx.sampleRate * duration;
        const buf = this.ctx.createBuffer(2, len, this.ctx.sampleRate);
        for (let c = 0; c < 2; c++) {
          const d = buf.getChannelData(c);
          for (let i = 0; i < len; i++) {
            // Exponential decay for realistic "room" fade
            // Multiplied by random noise
            d[i] = (Math.random() * 2 - 1) * Math.pow(1 - (i / len), 4.0);
          }
        }
        this.revNode.buffer = buf;
      }

      start() {
        this.st.tickCount = 0;
        this.startDrone(); // The constant background hum

        // Randomly tick between 0.5s and 2s
        const tickLoop = () => {
          this.tick();
          // Randomize timing for "Human" feel (not robotic)
          const nextTick = 500 + Math.random() * 1500;
          this.timer = setTimeout(tickLoop, nextTick);
        };
        tickLoop();
      }

      stop() {
        if (this.timer) clearTimeout(this.timer);

        // Fade out everything
        this.masterGain.gain.setTargetAtTime(0, this.ctx.currentTime, 0.5);

        // Kill drone specifically
        if (this.droneGain) {
          this.droneGain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 1);
          setTimeout(() => {
            if (this.droneOsc) this.droneOsc.stop();
            this.masterGain.disconnect();
          }, 1500);
        }
      }

      startDrone() {
        // A low, detuned saw wave that plays forever (The "Room Tone")
        const t = this.ctx.currentTime;
        this.droneOsc = this.ctx.createOscillator();
        this.droneOsc.type = 'sawtooth';
        this.droneOsc.frequency.value = 55; // Low A

        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 120; // Muffled

        this.droneGain = this.ctx.createGain();
        this.droneGain.gain.value = 0.05; // Quiet rumble

        this.droneOsc.connect(filter);
        filter.connect(this.droneGain);
        this.droneGain.connect(this.masterGain); // Goes through reverb!
        this.droneOsc.start(t);
      }

      tick() {
        this.st.tickCount++;

        // 10% chance to change scale for a "room change" feel
        if (Math.random() < 0.1) {
          const keys = Object.keys(this.cfg.scales);
          const key = keys[Math.floor(Math.random() * keys.length)];
          this.st.scaleIntervals = this.cfg.scales[key];
        }

        // Try to play Chime
        if (Math.random() > 0.4) this.playFMVoice('chime');

        // Try to play Bass swell
        if (Math.random() > 0.7) this.playFMVoice('bass');
      }

      // FM SYNTHESIS ENGINE
      playFMVoice(type) {
        const v = this.cfg.voices[type];
        const t = this.ctx.currentTime;

        // 1. Pitch Selection
        const scale = this.st.scaleIntervals;
        const degree = scale[Math.floor(Math.random() * scale.length)];
        const octaveOffset = v.range[Math.floor(Math.random() * v.range.length)];
        // Calculate frequency from root (55Hz)
        const noteValue = degree + octaveOffset;
        const freq = this.st.rootFreq * Math.pow(2, noteValue / 12);

        // 2. The Setup (Carrier + Modulator)
        const carrier = this.ctx.createOscillator();
        const modulator = this.ctx.createOscillator();
        const modGain = this.ctx.createGain();
        const masterVol = this.ctx.createGain();

        // 3. FM Configuration
        carrier.type = v.type;
        carrier.frequency.value = freq;

        // "Metallic" Ratio: Non-integer ratios create bell sounds
        const ratio = 2.0 + (Math.random() * 0.5);
        modulator.type = 'sine';
        modulator.frequency.value = freq * ratio;

        // The "Clang" intensity
        modGain.gain.value = freq * v.modIndex;

        // 4. Envelope (ADSR)
        masterVol.gain.setValueAtTime(0, t);
        masterVol.gain.linearRampToValueAtTime(0.2, t + 0.1); // Fast attack
        masterVol.gain.exponentialRampToValueAtTime(0.001, t + v.decay); // Long, ringing tail

        // Modulator Envelope (Brightness fades faster than volume -> "Pluck" sound)
        modGain.gain.setValueAtTime(freq * v.modIndex, t);
        modGain.gain.exponentialRampToValueAtTime(0.01, t + (v.decay * 0.5));

        // 5. Wiring
        modulator.connect(modGain);
        modGain.connect(carrier.frequency); // This is the FM magic
        carrier.connect(masterVol);
        masterVol.connect(this.masterGain);

        // 6. Start/Stop
        carrier.start(t);
        modulator.start(t);
        carrier.stop(t + v.decay + 1);
        modulator.stop(t + v.decay + 1);
      }
    }
// MODULE 5: Danger
class DangerModule {
  constructor(ctx, dest) {
    this.ctx = ctx;
    this.dest = dest;
    this.timer = null;
    this.isStopped = false; // SAFETY FLAG

    // 1. GLOBAL FX
    this.master = ctx.createGain();
    this.master.gain.value = 0.5;

    this.limiter = ctx.createDynamicsCompressor();
    this.limiter.threshold.value = -12;
    this.limiter.ratio.value = 12;
    this.limiter.attack.value = 0.005;

    this.eq = ctx.createBiquadFilter();
    this.eq.type = 'highshelf';
    this.eq.frequency.value = 3000;
    this.eq.gain.value = -10; 

    this.revNode = ctx.createConvolver();
    this.setupReverb(); // Creates buffer ONCE
    this.revGain = ctx.createGain();
    this.revGain.gain.value = 0.35; 

    this.limiter.connect(this.eq);
    this.eq.connect(this.master); 
    this.eq.connect(this.revNode); 
    this.revNode.connect(this.revGain);
    this.revGain.connect(this.master); 
    this.master.connect(this.dest);

    this.input = this.limiter;

    // --- OPTIMIZATION: Create Noise Buffers ONCE here, not in the loop ---
    this.snareBuffer = this.createNoiseBuffer(0.15); 
    
    // 2. BATTLE STATE
    this.tempo = 175;
    this.tickCount = 0;
    this.currentScale = [];
    this.rootFreq = 110; 
    this.progression = [0, 5, 3, 4];
    this.currentChordIndex = 0;
    this.momentum = 5;
  }

  // Optimized buffer creator
  createNoiseBuffer(duration) {
    const bufferSize = this.ctx.sampleRate * duration;
    const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
    const output = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
      output[i] = Math.random() * 2 - 1;
    }
    return buffer;
  }

  setupReverb() {
    const len = this.ctx.sampleRate * 1.5; 
    const buf = this.ctx.createBuffer(2, len, this.ctx.sampleRate);
    for (let c = 0; c < 2; c++) {
      const d = buf.getChannelData(c);
      for (let i = 0; i < len; i++) {
        d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / len, 3);
      }
    }
    this.revNode.buffer = buf;
  }

  start() {
    this.isStopped = false;
    this.generateScale('harmonicMinor');
    const noteDuration = (60 / this.tempo) / 4;
    // Use setTimeout loop instead of setInterval for better stability
    this.schedule();
  }

  stop() {
    this.isStopped = true;
    if (this.timer) clearTimeout(this.timer);
    this.master.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.2);
    setTimeout(() => {
        this.master.disconnect();
    }, 250);
  }

  schedule() {
    if (this.isStopped) return;
    const noteDuration = (60 / this.tempo) / 4;
    this.timer = setTimeout(() => this.schedule(), noteDuration * 1000);
    this.tick();
  }

  generateScale(type) {
    const intervals = [0, 2, 3, 5, 7, 8, 11];
    this.currentScale = intervals.map(i => this.rootFreq * Math.pow(2, i / 12));
  }

  tick() {
    if (this.isStopped) return;
    const t = this.ctx.currentTime;
    const barStep = this.tickCount % 16;

    this.playDrums(t, barStep);

    if (barStep % 2 === 0 || Math.random() > 0.3) {
      this.playBass(t);
    }

    if (barStep === 0 || (barStep === 6 && Math.random() > 0.5)) {
      this.playHit(t);
    }

    if (Math.random() < (this.momentum / 10)) {
      this.playLead(t);
    }

    if (barStep === 15) {
      this.currentChordIndex = (this.currentChordIndex + 1) % this.progression.length;
      this.tickCount = -1;
      this.momentum = Math.floor(Math.random() * 8) + 2;
    }

    this.tickCount++;
  }

  playDrums(t, step) {
    if (step % 4 === 0) { // Kick
      const osc = this.ctx.createOscillator();
      const g = this.ctx.createGain();
      osc.frequency.setValueAtTime(150, t);
      osc.frequency.exponentialRampToValueAtTime(0.01, t + 0.1);
      g.gain.setValueAtTime(1.0, t);
      g.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
      osc.connect(g); g.connect(this.input);
      osc.start(t); osc.stop(t + 0.1);
    }

    if (step === 4 || step === 12) { // Snare
      const noise = this.ctx.createBufferSource();
      noise.buffer = this.snareBuffer; // USE PRE-GENERATED BUFFER
      const g = this.ctx.createGain();
      const filter = this.ctx.createBiquadFilter();

      filter.type = 'highpass'; filter.frequency.value = 600;
      g.gain.setValueAtTime(0.5, t); 
      g.gain.exponentialRampToValueAtTime(0.01, t + 0.15);

      noise.connect(filter); filter.connect(g); g.connect(this.input);
      noise.start(t); 
    }
  }

  playBass(t) {
    if (this.isStopped) return;
    const degree = this.progression[this.currentChordIndex];
    const freq = this.currentScale[degree] / 2;

    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    const f = this.ctx.createBiquadFilter();

    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(freq, t);

    f.type = 'lowpass';
    f.frequency.setValueAtTime(100, t);
    f.frequency.linearRampToValueAtTime(600, t + 0.01);
    f.frequency.exponentialRampToValueAtTime(100, t + 0.15);

    g.gain.setValueAtTime(0.6, t);
    g.gain.linearRampToValueAtTime(0, t + 0.15);

    osc.connect(f); f.connect(g); g.connect(this.input);
    osc.start(t); osc.stop(t + 0.15);
  }

  playHit(t) {
    if (this.isStopped) return;
    const rootIdx = this.progression[this.currentChordIndex];
    const chord = [rootIdx, rootIdx + 2, rootIdx + 4];

    chord.forEach(idx => {
      const noteFreq = this.currentScale[idx % this.currentScale.length] * (idx >= 7 ? 2 : 1);
      const osc = this.ctx.createOscillator();
      const g = this.ctx.createGain();
      const f = this.ctx.createBiquadFilter(); 

      osc.type = 'sawtooth'; 
      osc.frequency.value = noteFreq;

      f.type = 'lowpass';
      f.frequency.setValueAtTime(300, t);
      f.frequency.linearRampToValueAtTime(2000, t + 0.05); 
      f.frequency.exponentialRampToValueAtTime(500, t + 0.3); 

      g.gain.setValueAtTime(0.2, t); 
      g.gain.exponentialRampToValueAtTime(0.01, t + 0.3);

      osc.connect(f); f.connect(g); g.connect(this.input);
      osc.start(t); osc.stop(t + 0.3);
    });
  }

  playLead(t) {
    if (this.isStopped) return;
    const scaleIdx = Math.floor(Math.random() * this.currentScale.length);
    const octave = Math.random() > 0.5 ? 2 : 4;
    const freq = this.currentScale[scaleIdx] * octave;

    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    const f = this.ctx.createBiquadFilter(); 

    osc.type = 'triangle'; 
    osc.frequency.setValueAtTime(freq, t);

    if (Math.random() > 0.5) {
      osc.frequency.setValueAtTime(freq * 0.9, t);
      osc.frequency.linearRampToValueAtTime(freq, t + 0.05);
    }

    f.type = 'lowpass';
    f.frequency.value = 3000;

    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(0.3, t + 0.02);
    g.gain.linearRampToValueAtTime(0, t + 0.2);

    osc.connect(f); f.connect(g); g.connect(this.input);
    osc.start(t); osc.stop(t + 0.2);
  }
}
    //MODULE 6: Spoils of War
class SpoilsofWarModule {
      constructor(ctx, dest) {
        this.ctx = ctx;
        this.dest = dest;
        this.timer = null;

        // 1. THE "GRAND HALL" FX CHAIN
        this.master = ctx.createGain();
        this.master.gain.value = 0.5;

        // A heavy compressor to make the drums "thud" against the choir
        this.comp = ctx.createDynamicsCompressor();
        this.comp.threshold.value = -24;
        this.comp.ratio.value = 12;
        this.comp.attack.value = 0.003;

        // Dark Reverb (The Raid Zone)
        this.revNode = ctx.createConvolver();
        this.setupReverb();
        this.revGain = ctx.createGain(); this.revGain.gain.value = 0.5;

        // Connect
        this.master.connect(this.comp);
        this.comp.connect(this.dest);
        this.comp.connect(this.revNode);
        this.revNode.connect(this.revGain);
        this.revGain.connect(this.dest);

        // 2. MUSICAL STATE
        this.tempo = 75; // Slow, marching tempo
        this.tickCount = 0;

        // C Minor / Eb Major (Epic, Serious)
        this.scale = [
          130.81, // C3
          146.83, // D3
          155.56, // Eb3
          174.61, // F3
          196.00, // G3
          207.65, // Ab3
          233.08  // Bb3
        ];

        // Chord Progressions (The "Loop")
        // i - VI - III - VII (Classic Epic Progression)
        this.chords = [
          [0, 2, 4], // Cm
          [5, 7, 9], // Ab (VI) - Note: indices wrap around
          [2, 4, 6], // Eb (III)
          [6, 8, 10] // Bb (VII)
        ];
        this.currentChord = 0;
      }

      setupReverb() {
        // Generate a 3-second dark impulse
        const len = this.ctx.sampleRate * 3;
        const buf = this.ctx.createBuffer(2, len, this.ctx.sampleRate);
        for (let c = 0; c < 2; c++) {
          const d = buf.getChannelData(c);
          for (let i = 0; i < len; i++) {
            // Low-pass noise for "muddy/stone" sound
            d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / len, 2);
          }
        }
        this.revNode.buffer = buf;
      }

      start() {
        this.tickCount = 0;
        this.currentChord = 0;

        // Calculate 8th note duration
        const interval = (60 / this.tempo) / 2 * 1000;

        // Start the loop
        this.timer = setInterval(() => this.tick(), interval);
      }

      stop() {
        if (this.timer) clearInterval(this.timer);
        this.master.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.5);
      }

      // --- THE CONDUCTOR ---
      tick() {
        const t = this.ctx.currentTime;
        const step = this.tickCount % 16; // 2 bars of 4/4

        // 1. WAR DRUMS (Orchestral Percussion)
        // Pattern: BOOM ... BOOM-boom ... (The March)
        if (step === 0 || step === 8) this.playTimpani(t, 'high'); // Downbeat
        if (step === 10 || step === 14) this.playTimpani(t, 'low'); // Fill

        // 2. SNARE/CLASH (The Accent)
        if (step === 4 || step === 12) this.playSnare(t);

        // 3. THE CHOIR (Pads)
        // Change chord every 16 steps (2 bars)
        if (step === 0) {
          this.playChoir(t);
          // Advance chord progression for next time
          if (this.tickCount > 0 && this.tickCount % 32 === 0) {
            this.currentChord = (this.currentChord + 1) % this.chords.length;
          }
        }

        // 4. THE BRASS LEADS (Melody)
        // Slow, majestic notes. Not fast.
        // Play on beat 0, 3, 6, etc. (Polyrhythmic feel)
        if (step % 4 === 0 || (step === 2 && Math.random() > 0.6)) {
          this.playBrass(t, step === 0); // Accentuate downbeat
        }

        this.tickCount++;
      }

      // --- INSTRUMENTS ---

      playTimpani(t, tone) {
        // Deep, resonant sine wave + noise burst
        const osc = this.ctx.createOscillator();
        const g = this.ctx.createGain();

        osc.frequency.setValueAtTime(tone === 'high' ? 80 : 60, t);
        osc.frequency.exponentialRampToValueAtTime(30, t + 0.3); // Pitch drop

        g.gain.setValueAtTime(0.8, t);
        g.gain.exponentialRampToValueAtTime(0.01, t + 0.5);

        osc.connect(g); g.connect(this.master);
        osc.start(t); osc.stop(t + 0.5);
      }

      playSnare(t) {
        // A wash of noise, low-passed (Orchestral Snare/Cymbal swell)
        const bufSize = this.ctx.sampleRate * 0.5;
        const buf = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
        const data = buf.getChannelData(0);
        for (let i = 0; i < bufSize; i++) data[i] = Math.random() * 2 - 1;

        const noise = this.ctx.createBufferSource();
        noise.buffer = buf;

        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 1500; // Dark snare

        const g = this.ctx.createGain();
        g.gain.setValueAtTime(0.4, t);
        g.gain.exponentialRampToValueAtTime(0.01, t + 0.3);

        noise.connect(filter); filter.connect(g); g.connect(this.master);
        noise.start(t);
      }

      playChoir(t) {
        // Play the triad of the current chord
        const indices = this.chords[this.currentChord];

        indices.forEach(idx => {
          // Map index to frequency (wrapping scale)
          let freq = this.scale[idx % this.scale.length];
          if (idx >= 7) freq *= 2; // Octave up

          // Create "Choir" voice (2 oscillators slightly detuned)
          const osc1 = this.ctx.createOscillator();
          const osc2 = this.ctx.createOscillator();
          osc1.type = 'triangle';
          osc2.type = 'sine'; // Sine adds "breath"

          osc1.frequency.value = freq;
          osc2.frequency.value = freq + (Math.random() * 2 - 1); // Detune

          const g = this.ctx.createGain();
          // Long Attack (Fade in) -> Long Sustain -> Long Release
          g.gain.setValueAtTime(0, t);
          g.gain.linearRampToValueAtTime(0.15, t + 1.0); // 1s attack
          g.gain.setValueAtTime(0.15, t + 3.0); // Hold
          g.gain.linearRampToValueAtTime(0, t + 4.0); // Release

          osc1.connect(g); osc2.connect(g);
          g.connect(this.master);

          osc1.start(t); osc1.stop(t + 4.5);
          osc2.start(t); osc2.stop(t + 4.5);
        });

        // Add a Bass Root note
        const rootFreq = this.scale[indices[0] % 7] / 2; // Octave down
        const bass = this.ctx.createOscillator();
        bass.type = 'sawtooth';
        bass.frequency.value = rootFreq;
        const bg = this.ctx.createGain();
        const bf = this.ctx.createBiquadFilter();
        bf.type = 'lowpass'; bf.frequency.value = 100; // Sub bass

        bg.gain.setValueAtTime(0, t);
        bg.gain.linearRampToValueAtTime(0.3, t + 1);
        bg.gain.linearRampToValueAtTime(0, t + 4);

        bass.connect(bf); bf.connect(bg); bg.connect(this.master);
        bass.start(t); bass.stop(t + 4.5);
      }

      playBrass(t, isStrong) {
        // Procedural melody logic
        const indices = this.chords[this.currentChord];
        // Pick a note from the chord (Consonant) or scale (Passing note)
        const noteIdx = Math.random() > 0.3 ?
          indices[Math.floor(Math.random() * indices.length)] :
          Math.floor(Math.random() * this.scale.length);

        let freq = this.scale[noteIdx % this.scale.length];
        // Brass plays high
        freq *= 2;

        const osc = this.ctx.createOscillator();
        osc.type = 'sawtooth';
        osc.frequency.value = freq;

        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.Q.value = 2; // Resonance for "brassy" sound

        const g = this.ctx.createGain();

        // Brass Envelope: swell into the note
        const dur = isStrong ? 1.5 : 0.8;

        // Filter Envelope (The "Wah" of the brass)
        filter.frequency.setValueAtTime(200, t);
        filter.frequency.linearRampToValueAtTime(2000, t + 0.1); // Bite
        filter.frequency.exponentialRampToValueAtTime(500, t + dur);

        // Volume Envelope
        g.gain.setValueAtTime(0, t);
        g.gain.linearRampToValueAtTime(0.15, t + 0.1);
        g.gain.linearRampToValueAtTime(0, t + dur);

        osc.connect(filter); filter.connect(g); g.connect(this.master);
        osc.start(t); osc.stop(t + dur + 0.1);
      }
    }
//MODULE 7: March
class MarchModule {
      constructor(ctx, dest) {
        this.ctx = ctx;
        this.dest = dest;
        this.timer = null;

        // 1. DYNAMIC LAYERING (The Card Game Logic)
        this.intensity = 1; // 1 = Setup, 2 = Mid, 3 = Lethal

        // 2. GLOBAL MIX
        this.master = ctx.createGain();
        this.master.gain.value = 0.5;
        this.master.connect(this.dest);

        // 3. STATE
        this.tempo = 110; // March tempo
        this.tickCount = 0;
        this.keyBase = 146.83; // D3 (D Dorian - classic fantasy strategy key)

        // D Dorian Scale: D, E, F, G, A, B, C
        this.scale = [0, 2, 3, 5, 7, 9, 10];

        // Snare Pattern (1 = Hit, 0 = Rest, 2 = Accent)
        // "Ratta-tat-tat" military cadence
        this.snareGrid = [2, 0, 1, 0, 2, 1, 1, 0, 2, 0, 1, 0, 1, 1, 0, 1];
      }

      start() {
        this.tickCount = 0;
        // 16th note interval
        const interval = (60 / this.tempo) / 4 * 1000;
        this.timer = setInterval(() => this.tick(), interval);
      }

      stop() {
        if (this.timer) clearInterval(this.timer);
        this.master.gain.setTargetAtTime(0, this.ctx.currentTime, 0.1);
      }

      setIntensity(level) {
        // Smooth transition between game phases
        this.intensity = level;
      }

      // --- THE SEQUENCER ---
      tick() {
        const t = this.ctx.currentTime;
        const step = this.tickCount % 16; // 1 bar loop
        const bar = Math.floor(this.tickCount / 16) % 4; // 4 bar phrase

        // LAYER 1: THE FOUNDATION (Always On)
        // Military Snare
        const snareType = this.snareGrid[step];
        if (snareType > 0) this.playSnare(t, snareType === 2);

        // Kick Drum (On beats 1 and 3)
        if (step === 0 || step === 8) this.playKick(t);

        // LAYER 2: THE INTELLECT (Intensity 2+)
        // Staccato Strings (The "Clockwork" of strategy)
        if (this.intensity >= 2) {
          // Play on off-beats to create forward momentum
          if (step % 2 === 0) {
            // Arpeggiate current chord
            this.playStrings(t, step, bar);
          }
        }

        // LAYER 3: THE RESOLVE (Intensity 3 Only)
        // Low Brass / Horns (The "Army" has arrived)
        if (this.intensity >= 3) {
          // Long, swelling notes on the 1st beat of the bar
          if (step === 0) {
            this.playBrass(t, bar);
          }
        }

        this.tickCount++;
      }

      // --- INSTRUMENTS ---

      playSnare(t, accent) {
        // White noise burst
        const bufSize = this.ctx.sampleRate * 0.1; // Short
        const buffer = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufSize; i++) data[i] = Math.random() * 2 - 1;

        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;

        // Filter: High pass to make it crisp (Military style, not Rock style)
        const filt = this.ctx.createBiquadFilter();
        filt.type = 'highpass';
        filt.frequency.value = 1000;

        const gain = this.ctx.createGain();
        // Envelope: Very sharp snap
        const vol = accent ? 0.4 : 0.15; // Dynamics!
        gain.gain.setValueAtTime(vol, t);
        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.08);

        noise.connect(filt); filt.connect(gain); gain.connect(this.master);
        noise.start(t);
      }

      playKick(t) {
        // Orchestral Bass Drum (Deep and boom-y)
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();

        osc.frequency.setValueAtTime(100, t);
        osc.frequency.exponentialRampToValueAtTime(30, t + 0.3); // Pitch dive

        gain.gain.setValueAtTime(0.5, t);
        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);

        osc.connect(gain); gain.connect(this.master);
        osc.start(t); osc.stop(t + 0.3);
      }

      playStrings(t, step, bar) {
        // Logic: Walk up and down the Dorian scale
        // Bar 0: i (Dm), Bar 1: III (F), Bar 2: VII (C), Bar 3: V (Am)
        const chordRoots = [0, 3, 6, 4];
        const root = chordRoots[bar];

        // Arpeggiator pattern: Root -> 3rd -> 5th -> 3rd
        const arp = [0, 2, 4, 2];
        const noteIndex = (root + arp[(step / 2) % 4]) % this.scale.length;

        const freq = this.keyBase * Math.pow(2, this.scale[noteIndex] / 12);

        // Sound: Sawtooth wave with Low Pass (Spiccato Strings)
        const osc = this.ctx.createOscillator();
        osc.type = 'sawtooth';
        osc.frequency.value = freq * 2; // Octave up

        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 600;

        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(0.15, t + 0.02);
        gain.gain.linearRampToValueAtTime(0, t + 0.1); // Short "Pluck"

        osc.connect(filter); filter.connect(gain); gain.connect(this.master);
        osc.start(t); osc.stop(t + 0.2);
      }

      playBrass(t, bar) {
        // Logic: Play the Root note of the chord
        const chordRoots = [0, 3, 6, 4];
        const noteIndex = chordRoots[bar];
        const freq = this.keyBase * Math.pow(2, this.scale[noteIndex] / 12);

        // Sound: Detuned Sawtooth (French Horn swell)
        const osc = this.ctx.createOscillator();
        osc.type = 'sawtooth';
        osc.frequency.value = freq / 2; // Octave down (Low mid)

        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';

        const gain = this.ctx.createGain();

        // The "Swell" Envelope (Brass doesn't hit instantly, it grows)
        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(0.3, t + 1.0); // Slow attack
        gain.gain.linearRampToValueAtTime(0, t + 3.0);   // Slow release

        // The "Brighten" Envelope (As it gets louder, it gets brassier)
        filter.frequency.setValueAtTime(200, t);
        filter.frequency.linearRampToValueAtTime(1500, t + 1.0);

        osc.connect(filter); filter.connect(gain); gain.connect(this.master);
        osc.start(t); osc.stop(t + 3.5);
      }
    }
//MODULE 8: Triumph
class TriumphModule {
      constructor(ctx, dest) {
        this.ctx = ctx;
        this.dest = dest;
        this.timer = null;

        // 1. MIXER
        this.master = ctx.createGain();
        this.master.gain.value = 0.5;

        // Large Reverb is essential for that "City Gate" feel
        this.revNode = ctx.createConvolver();
        this.setupReverb();
        this.revGain = ctx.createGain(); this.revGain.gain.value = 0.4;

        this.master.connect(this.dest);
        this.master.connect(this.revNode);
        this.revNode.connect(this.revGain);
        this.revGain.connect(this.dest);

        // 2. MUSICAL STATE
        this.tempo = 95; // A stately, walking tempo
        this.tickCount = 0;

        // C Mixolydian (Major scale w/ Flat 7) - The "Adventure" Scale
        // C, D, E, F, G, A, Bb
        this.scale = [0, 2, 4, 5, 7, 9, 10];
        this.rootFreq = 261.63; // Middle C

        // Melody Logic
        this.currentChordIndex = 0;
        this.chordProgression = [0, 5, 3, 4]; // I - bVII - IV - V
        this.melodyNote = null; // Track current note to slide from
      }

      setupReverb() {
        // 2.5 second tail
        const len = this.ctx.sampleRate * 2.5;
        const buf = this.ctx.createBuffer(2, len, this.ctx.sampleRate);
        for (let c = 0; c < 2; c++) {
          const d = buf.getChannelData(c);
          for (let i = 0; i < len; i++) d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / len, 2);
        }
        this.revNode.buffer = buf;
      }

      start() {
        this.tickCount = 0;
        // 16th notes
        const interval = (60 / this.tempo) / 4 * 1000;
        this.timer = setInterval(() => this.tick(), interval);
      }

      stop() {
        if (this.timer) clearInterval(this.timer);
        this.master.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 1);
      }

      // --- SEQUENCER ---
      tick() {
        const t = this.ctx.currentTime;
        const step = this.tickCount % 16;
        const bar = Math.floor(this.tickCount / 16) % 4;

        // 1. THE MARCHING SNARE (The backbone)
        // A standard march pattern: ONE-e-and-a TWO...
        const marchPattern = [1, 0.3, 0.5, 0.3, 1, 0, 0.5, 0, 1, 0.3, 0.5, 0.3, 1, 0, 1, 0];
        if (marchPattern[step] > 0) {
          this.playSnare(t, marchPattern[step]);
        }

        // 2. ORCHESTRAL CRASH (Transitions)
        // Hit a crash cymbal at the start of every 4-bar cycle
        if (bar === 0 && step === 0) {
          this.playCymbal(t);
        }

        // 3. THE STRING BED (Pad)
        // Change chords every Bar (16 ticks)
        if (step === 0) {
          this.currentChordIndex = bar; // Sync chord to bar
          this.playStringPad(t, bar);
        }

        // 4. THE HEROIC HORN (Melody)
        // This is the "Baldur's Gate" element.
        // It plays slow, long notes. We check every Quarter Note (step % 4 === 0)
        // But we only play if the 'dice roll' says so, to leave gaps.
        if (step % 4 === 0) {
          // High chance to play on beat 1 (step 0), lower on others
          const chance = step === 0 ? 0.9 : 0.6;

          if (Math.random() < chance) {
            // Determine duration: 1 beat, 2 beats, or 4 beats (Long!)
            const r = Math.random();
            let beats = 1;
            if (r > 0.6) beats = 2;
            if (r > 0.9 && step === 0) beats = 4; // Heroic long note

            this.playFrenchHorn(t, beats);
          }
        }

        this.tickCount++;
      }

      // --- INSTRUMENTS ---

      playSnare(t, velocity) {
        // Filtered noise for a warmer "Marching Snare"
        const bufSize = this.ctx.sampleRate * 0.1;
        const buffer = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufSize; i++) data[i] = Math.random() * 2 - 1;

        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;

        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 2000; // Cut the harsh high end

        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0.3 * velocity, t);
        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);

        noise.connect(filter); filter.connect(gain); gain.connect(this.master);
        noise.start(t);
      }

      playStringPad(t, chordIdx) {
        // Play a triad (Root + 3rd + 5th)
        // C Mixolydian Chords
        const roots = [0, 10, 5, 7]; // I (C), bVII (Bb), IV (F), V (G)
        const rootNote = roots[chordIdx];

        // Build Chord (1, 3, 5)
        const chord = [rootNote, rootNote + 2, rootNote + 4];

        chord.forEach((note, i) => {
          const osc = this.ctx.createOscillator();
          const g = this.ctx.createGain();

          // Sawtooth + Lowpass = Strings
          osc.type = 'sawtooth';
          const freq = this.rootFreq * Math.pow(2, (this.scale[note % 7] + (note >= 7 ? 12 : 0)) / 12);
          osc.frequency.value = freq / 2; // Lower octave for body

          const filter = this.ctx.createBiquadFilter();
          filter.type = 'lowpass';
          filter.frequency.value = 400 + (i * 100); // Spread filters

          // ADSR: Slow Attack (The "Swell")
          g.gain.setValueAtTime(0, t);
          g.gain.linearRampToValueAtTime(0.1, t + 0.5); // 0.5s fade in
          g.gain.setValueAtTime(0.1, t + 2.0); // Sustain
          g.gain.linearRampToValueAtTime(0, t + 2.5); // Fade out

          osc.connect(filter); filter.connect(g); g.connect(this.master);
          osc.start(t); osc.stop(t + 2.6);
        });
      }

      playFrenchHorn(t, durationInBeats) {
        const beatSec = 60 / this.tempo;
        const duration = beatSec * durationInBeats;

        // 1. SELECT NOTE
        // Pick a note from the chord or a passing tone
        const chordRoot = [0, 10, 5, 7][this.currentChordIndex];
        // Prefer chord tones: Root, 3rd, 5th
        const tones = [chordRoot, chordRoot + 2, chordRoot + 4, chordRoot + 7];
        const noteIdx = tones[Math.floor(Math.random() * tones.length)];

        let freq = this.rootFreq * Math.pow(2, (this.scale[noteIdx % 7] + (noteIdx >= 7 ? 12 : 0)) / 12);

        // French Horn plays in the mid-range
        if (Math.random() > 0.5) freq /= 2;

        // 2. SYNTHESIS
        const osc = this.ctx.createOscillator();
        osc.type = 'sawtooth'; // Brass is Sawtooth
        osc.frequency.setValueAtTime(freq, t);

        // Slide from previous note (Legato)
        if (this.melodyNote) {
          osc.frequency.setValueAtTime(this.melodyNote, t);
          osc.frequency.exponentialRampToValueAtTime(freq, t + 0.1);
        }
        this.melodyNote = freq;

        // 3. THE "BRASSY" FILTER
        // Brass gets brighter as it gets louder
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.Q.value = 2; // Resonance simulates the bell of the horn

        // Filter Envelope
        filter.frequency.setValueAtTime(300, t);
        filter.frequency.linearRampToValueAtTime(1200, t + (duration * 0.3)); // Swell brightness
        filter.frequency.linearRampToValueAtTime(300, t + duration); // Mellow out

        // 4. AMPLITUDE ENVELOPE
        const g = this.ctx.createGain();
        g.gain.setValueAtTime(0, t);
        g.gain.linearRampToValueAtTime(0.25, t + (duration * 0.2)); // Softer attack than trumpet
        g.gain.linearRampToValueAtTime(0.2, t + (duration * 0.8));
        g.gain.linearRampToValueAtTime(0, t + duration);

        osc.connect(filter); filter.connect(g); g.connect(this.master);
        osc.start(t); osc.stop(t + duration + 0.1);
      }

      playCymbal(t) {
        // Metallic noise
        const bufSize = this.ctx.sampleRate * 2;
        const buffer = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufSize; i++) data[i] = Math.random() * 2 - 1;

        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;

        const filter = this.ctx.createBiquadFilter();
        filter.type = 'highpass';
        filter.frequency.value = 3000;

        const g = this.ctx.createGain();
        g.gain.setValueAtTime(0.3, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 2);

        noise.connect(filter); filter.connect(g); g.connect(this.master);
        noise.start(t);
      }
    }
//MODULE 9: Start Game
class StartGameModule {
      constructor(ctx, dest) {
        this.ctx = ctx;
        this.dest = dest;
        this.timer = null;

        // 1. MASTER GAIN (Volume Control)
        this.master = ctx.createGain();
        this.master.gain.value = 0.4;
        this.master.connect(this.dest);

        // 2. STATE
        this.tempo = 160; // High speed battle
        this.tickCount = 0;
        this.state = 'INTRO'; // INTRO -> LOOP

        // Scale: G Harmonic Minor (The "Serious Battle" Scale)
        // G, A, Bb, C, D, Eb, F#
        this.baseFreq = 196.00; // G3
        this.scale = [0, 2, 3, 5, 7, 8, 11];

        // Game Boy "Noise" Buffer (Static for drums)
        this.noiseBuffer = this.createNoiseBuffer();
      }

      createNoiseBuffer() {
        const bufSize = this.ctx.sampleRate * 1;
        const buffer = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufSize; i++) {
          // Math.random() is too clean. We need digital static.
          // This threshold creates a "crackle" rather than "hiss"
          data[i] = Math.random() > 0.5 ? 1 : -1;
        }
        return buffer;
      }

      start() {
        this.tickCount = 0;
        this.state = 'INTRO';
        // 16th note interval
        const interval = (60 / this.tempo) / 4 * 1000;
        this.timer = setInterval(() => this.tick(), interval);
      }

      stop() {
        if (this.timer) clearInterval(this.timer);
        this.master.gain.setTargetAtTime(0, this.ctx.currentTime, 0.1);
      }

      // --- THE SEQUENCER ---
      tick() {
        const t = this.ctx.currentTime;

        if (this.state === 'INTRO') {
          this.playIntro(t);
        } else {
          this.playLoop(t);
        }

        this.tickCount++;
      }

      playIntro(t) {
        // The Classic "Encounter" Sound: Rapid ascending chromatic scale
        // Intro lasts 32 ticks (2 bars)
        const step = this.tickCount;

        // 1. The "Screech" (High pitch slide)
        if (step === 0) {
          this.playPulse(t, 880, 0.5, 0.1, 'lead'); // High A
          this.playNoise(t, 'open'); // Crash
        }

        // 2. The "Tension" (Rapid triplets)
        if (step < 28) {
          // Play chromatically rising notes every 2 ticks
          if (step % 2 === 0) {
            const freq = 220 + (step * 20);
            this.playPulse(t, freq, 0.05, 0.05, 'arp');
            this.playNoise(t, 'closed');
          }
        }
        // 3. The Drop (Silence before loop)
        else if (step === 30) {
          // Silence...
        }
        // 4. Switch to Loop
        else if (step === 32) {
          this.state = 'LOOP';
          this.tickCount = 0; // Reset for loop
        }
      }

      playLoop(t) {
        const step = this.tickCount % 16;
        const bar = Math.floor(this.tickCount / 16) % 8; // 8 bar phrases

        // CHANNEL 3: WAVE (Bass)
        // Driving eighth notes (0, 2, 4, 6...)
        if (step % 2 === 0) {
          this.playBass(t, bar);
        }

        // CHANNEL 4: NOISE (Percussion)
        // Basic Rock Beat: Kick (0, 8), Snare (4, 12), HiHat (every 2)
        if (step === 4 || step === 12) this.playNoise(t, 'snare');
        else if (step === 0 || step === 8) this.playNoise(t, 'kick');
        else if (step % 2 === 0) this.playNoise(t, 'closed');

        // CHANNEL 1: PULSE 1 (Lead Melody)
        // Complex logic to simulate "Pokemon" phrasing
        if (step % 2 === 0) { // Play mainly on 8th notes
          this.playMelody(t, step, bar);
        }

        // CHANNEL 2: PULSE 2 (Arpeggios/Support)
        // Fast 16th note runs
        this.playArp(t, step, bar);
      }

      // --- INSTRUMENTS ---

      playBass(t, bar) {
        // Chord Progression: i - VI - V - i (Gm - Eb - D - Gm)
        const progression = [0, 0, 5, 5, 4, 4, 0, 0]; // Root scale degrees
        const degree = progression[bar];
        const freq = this.baseFreq * Math.pow(2, (this.scale[degree] - 12) / 12); // Octave down

        const osc = this.ctx.createOscillator();
        osc.type = 'triangle'; // Game Boy "Wave" channel was often roughly triangular
        osc.frequency.setValueAtTime(freq, t);

        const g = this.ctx.createGain();
        g.gain.setValueAtTime(0.6, t);
        g.gain.linearRampToValueAtTime(0, t + 0.15); // Short, staccato bass

        osc.connect(g); g.connect(this.master);
        osc.start(t); osc.stop(t + 0.15);
      }

      playMelody(t, step, bar) {
        // "Lead" usually plays distinct phrases
        // Phrase A: Bars 0-3 (Intense)
        // Phrase B: Bars 4-7 (Resolve)

        // Pseudo-random but deterministic melody based on bar/step
        const seed = (bar * 16) + step;
        const isNote = (seed * 9301 + 49297) % 233280 > 100000; // 50% density

        if (isNote) {
          const progression = [0, 0, 5, 5, 4, 4, 0, 0];
          const root = progression[bar];

          // Pick a note from the scale (High octave)
          const scaleIndex = Math.floor(Math.random() * 5); // Bottom 5 notes of scale
          const note = root + this.scale[scaleIndex];
          const freq = this.baseFreq * Math.pow(2, (note + 12) / 12); // Up 1 octave

          this.playPulse(t, freq, 0.15, 0.2, 'lead');
        }
      }

      playArp(t, step, bar) {
        // "Arpeggios" are the secret sauce of 8-bit music.
        // They fill the silence and create urgency.

        const progression = [0, 0, 5, 5, 4, 4, 0, 0];
        const root = progression[bar];

        // Cycle: Root -> 3rd -> 5th -> Octave
        const arpPattern = [0, 2, 4, 7];
        const noteOffset = arpPattern[step % 4];

        // Map to scale
        const scaleDeg = (root + noteOffset) % 7; // Wrap scale
        // Check if index exists in scale, simplified logic:
        const freq = this.baseFreq * Math.pow(2, (this.scale[scaleDeg]) / 12);

        // Arps are quieter
        this.playPulse(t, freq, 0.05, 0.08, 'arp');
      }

      playPulse(t, freq, vol, dur, type) {
        const osc = this.ctx.createOscillator();
        osc.type = 'square';
        osc.frequency.setValueAtTime(freq, t);

        const g = this.ctx.createGain();
        g.gain.setValueAtTime(vol, t);

        // Envelope: Game Boy sound had no "attack", instant on, linear decay
        g.gain.setValueAtTime(vol, t);
        g.gain.linearRampToValueAtTime(0, t + dur);

        // "Duty Cycle" hack:
        // Web Audio square is 50%. Game Boy leads were often 12.5% or 25% (nasal).
        // We can mimic this with a Highpass filter to thin it out.
        if (type === 'lead') {
          const f = this.ctx.createBiquadFilter();
          f.type = 'highpass';
          f.frequency.value = 800; // Removes the "body", leaves the "buzz"
          osc.connect(f); f.connect(g);
        } else {
          osc.connect(g);
        }

        g.connect(this.master);
        osc.start(t); osc.stop(t + dur);
      }

      playNoise(t, type) {
        const src = this.ctx.createBufferSource();
        src.buffer = this.noiseBuffer;

        const filter = this.ctx.createBiquadFilter();
        const g = this.ctx.createGain();

        if (type === 'kick') {
          filter.type = 'lowpass';
          filter.frequency.value = 200; // Low rumble
          g.gain.setValueAtTime(0.8, t);
          g.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
          src.playbackRate.value = 0.5; // Pitch down noise
        }
        else if (type === 'snare') {
          filter.type = 'bandpass'; // "Crunchy" mid-range
          filter.frequency.value = 1000;
          g.gain.setValueAtTime(0.6, t);
          g.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
        }
        else { // Hi-hat / closed
          filter.type = 'highpass'; // Hissy
          filter.frequency.value = 3000;
          g.gain.setValueAtTime(0.3, t);
          g.gain.exponentialRampToValueAtTime(0.01, t + 0.05);
        }

        src.connect(filter); filter.connect(g); g.connect(this.master);
        src.start(t);
      }
    }
// MODULE 10: Moonlight Lullaby
class LullabyModule {
    constructor(ctx, dest) {
        this.ctx = ctx;
        this.dest = dest;
        this.timer = null;

        // --- 1. AUDIO GRAPH (The "Anti-Pop" Chain) ---
        // Chain: Voices -> Master -> Compressor -> Reverb -> Dest
        
        this.master = ctx.createGain();
        this.master.gain.value = 0.6;

        // COMPRESSOR: The secret ingredient to stop popping
        this.compressor = ctx.createDynamicsCompressor();
        this.compressor.threshold.value = -20;
        this.compressor.knee.value = 40;
        this.compressor.ratio.value = 12;
        this.compressor.attack.value = 0;
        this.compressor.release.value = 0.25;

        // REVERB: Essential for the "Dreamy" sound
        this.revNode = ctx.createConvolver();
        this.setupReverb();
        this.revGain = ctx.createGain();
        this.revGain.gain.value = 0.5; 

        // Connect the graph
        this.master.connect(this.compressor);
        this.compressor.connect(this.dest);          // Dry signal
        this.compressor.connect(this.revNode);       // Send to reverb
        this.revNode.connect(this.revGain);
        this.revGain.connect(this.dest);             // Wet signal

        // --- State ---
        // We use C# Minor (The actual Moonlight Sonata key) for that deep mood
        // But we stick to the softer intervals.
        this.rootFreq = 277.18; // C#4
        this.scale = [0, 2, 3, 5, 7, 8, 10, 12]; // Minor Scale

        this.tempo = 50; // Very slow, Adagio
        this.isPlaying = false;
        
        // The "Moonlight" Texture: Rolling Triplets
        // We count in 12s (4 beats * 3 triplets)
        this.tick = 0; 
        
        // Mode: 'adagio' (Slow rolling) or 'flow' (Faster arpeggios)
        this.mode = 'adagio'; 
        this.barCount = 0;
     
    // ... existing code ...
    this.keyShift = 0; // Starts at 0 (C# Minor)

    }

    setupReverb() {
        // A longer, darker tail for that "Large Hall" feel
        const len = this.ctx.sampleRate * 4.0; 
        const buf = this.ctx.createBuffer(2, len, this.ctx.sampleRate);
        for (let c = 0; c < 2; c++) {
            const d = buf.getChannelData(c);
            for (let i = 0; i < len; i++) {
                // Exponential decay prevents the "noise" sound at the end
                d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / len, 4);
            }
        }
        this.revNode.buffer = buf;
    }

    start() {
        this.isPlaying = true;
        this.master.gain.setValueAtTime(0.6, this.ctx.currentTime);
        this.tick = 0;
        this.loop();
    }

    stop() {
        this.isPlaying = false;
        if (this.timer) clearTimeout(this.timer);
        
        // Smooth fade out to prevent the final "Pop"
        const t = this.ctx.currentTime;
        this.master.gain.cancelScheduledValues(t);
        this.master.gain.setValueAtTime(this.master.gain.value, t);
        this.master.gain.linearRampToValueAtTime(0, t + 0.5);
    }

    loop() {
        if (!this.isPlaying) return;

        // Calculate timing
        // In Adagio, we tick triplets. In Flow, we tick 16ths (faster).
        let subdivision = this.mode === 'adagio' ? 3 : 4; 
        const beatsPerSec = this.tempo / 60;
        const tickInterval = ((1 / beatsPerSec) / subdivision) * 1000;

        // Logic
        this.playTick();

        this.tick++;
        // Cycle change logic
        if (this.tick >= (4 * subdivision)) {
            this.tick = 0;
            this.barCount++;
            
            // Switch modes occasionally (Slow part vs Fast part)
            if (this.barCount % 8 === 0) {
                this.mode = this.mode === 'adagio' ? 'flow' : 'adagio';
                // Slight tempo adjustment for the "Fast" part
                this.tempo = this.mode === 'flow' ? 55 : 50; 
                // == NEW: MODULATION LOGIC ==
        // If we are going back to "Adagio" (Slow), change the key to keep it fresh.
        if (this.mode === 'adagio') {
             // Move up a Perfect 5th (+7 semitones) or down a 4th (-5)
             // This is the most common, pleasant key change in history.
             this.keyShift += 7; 
             
             // Safety: If we get too high, drop an octave (-12)
             if (this.keyShift > 12) this.keyShift -= 12;
        }
            }
        }

        // Slight humanization (Rubato)
        const rubato = Math.random() * 15;
        this.timer = setTimeout(() => this.loop(), tickInterval + rubato);
    }

    playTick() {
        const t = this.ctx.currentTime;

        // 1. BASS (The Foundation)
        // Plays only on Beat 1 (Tick 0)
        if (this.tick === 0) {
            // Play a low Octave C# or A or E
            const bassNote = this.getProgressionRoot(this.barCount);
            this.playSound(bassNote - 24, t, 3.0, 'bass'); // Deep bass
            this.playSound(bassNote - 12, t + 0.05, 3.0, 'bass'); // Octave up slightly delayed
        }

        // 2. THE TRIPLET ARPEGGIO (The "Moonlight" texture)
        // Plays constantly
        let arpNote = this.getArpeggioNote(this.barCount, this.tick);
        // Randomly skip some notes in Adagio mode for "breath"
        if (this.mode === 'flow' || Math.random() > 0.2) {
             // Velocity (volume) waves up and down slightly
             let vel = 0.1 + (Math.sin(this.tick) * 0.05);
             this.playSound(arpNote, t, 1.5, 'piano', vel);
        }

        // 3. MELODY (High and Sparse)
        // Only plays occasionally, mostly on strong beats
        if (this.tick % 3 === 0 && Math.random() > 0.6) {
             const melNote = this.getScaleNote(this.barCount);
             // Play high melody
             this.playSound(melNote + 12, t, 2.5, 'bell', 0.15);
        }
    }

    // --- Theory Helpers ---
getProgressionRoot(bar) {
    // Standard progression
    const seq = [0, -2, -4, -5]; 
    
    // Return the base note + the current Key Shift
    return seq[bar % 4] + this.keyShift;
}

    getArpeggioNote(bar, tick) {
        const root = this.getProgressionRoot(bar);
        // Create a chord shape (Root, Minor 3rd, 5th)
        const chord = [root, root + 3, root + 7, root + 12, root + 15, root + 19];
        
        // Oscillate through the chord based on the tick
        // This creates that "up and down" wave motion
        const index = tick % 6; 
        // 0-1-2-3-4-5 pattern
        return chord[index]; 
    }

    getScaleNote(bar) {
        const root = this.getProgressionRoot(bar);
        // Pick a random valid note from the scale relative to the root
        const intervals = [0, 3, 7, 12]; // Chord tones sound safest
        const interval = intervals[Math.floor(Math.random() * intervals.length)];
        return root + interval;
    }

    // --- Audio Synthesis (The "Soft" Upgrade) ---

    playSound(noteIndex, time, duration, type, vol = 0.2) {
        // Convert scale index to frequency
        // Base is middle C# (MIDI 61) approx 277.18Hz
        const semitone = Math.pow(2, 1/12);
        const freq = this.rootFreq * Math.pow(semitone, noteIndex);

        // -- FM SYNTHESIS SETUP --
        // This creates a "Tine" / Electric Piano sound (Glassy, not harsh)
        
        const osc = this.ctx.createOscillator();
        const modulator = this.ctx.createOscillator();
        const modGain = this.ctx.createGain();
        const mainGain = this.ctx.createGain();

        // 1. Carrier (The main tone)
        osc.type = 'sine'; // Sine is the smoothest waveform
        osc.frequency.setValueAtTime(freq, time);

        // 2. Modulator (Adds the "bell" character)
        modulator.type = 'sine';
        // Ratio 2:1 gives a hollow, woody sound. Ratio 14:1 gives a bell.
        // We blend them based on instrument type.
        const ratio = type === 'bass' ? 0.5 : (type === 'bell' ? 3.5 : 2.0);
        modulator.frequency.setValueAtTime(freq * ratio, time);

        // FM Depth (How "bright" the sound is)
        const modulationIndex = type === 'bass' ? 100 : 300; 
        
        // Envelope for FM amount (Brightness fades over time)
        modGain.gain.setValueAtTime(modulationIndex, time);
        modGain.gain.exponentialRampToValueAtTime(0.1, time + 0.5);

        // Wiring FM
        modulator.connect(modGain);
        modGain.connect(osc.frequency);

        // 3. Amplitude Envelope (Volume shape)
        // Prevent clicking by starting at 0
        mainGain.gain.setValueAtTime(0, time);
        // Quick attack
        mainGain.gain.linearRampToValueAtTime(vol, time + 0.05);
        // Exponential decay (Natural fade)
        mainGain.gain.exponentialRampToValueAtTime(0.001, time + duration);

        // Connect to Master
        osc.connect(mainGain);
        mainGain.connect(this.master);

        // Start/Stop logic
        osc.start(time);
        modulator.start(time);
        
        // Stop oscillators slightly after the volume hits near-zero
        // to ensure we don't clip the audio engine
        osc.stop(time + duration + 0.1);
        modulator.stop(time + duration + 0.1);
    }
}
    // MODULE 11: Castle
class CastleModule {
      constructor(ctx, dest) {
        this.ctx = ctx;
        this.dest = dest;
        this.timer = null;

        // --- State ---
        this.keys = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
        this.keyFreqs = { 'C': 261.63, 'D': 293.66, 'E': 329.63, 'F': 349.23, 'G': 392.00, 'A': 440.00, 'B': 493.88 };
        this.currentKey = 'C';
        this.tempos = [60, 70, 80, 90];
        this.currentTempo = 60;
        this.timeSignatures = [[4, 4], [3, 4], [6, 8]];
        this.currentTimeSignature = [4, 4];

        // --- Runtime ---
        this.barCount = 1;
        this.beatsInBar = 0;
        this.eighthCount = 0;

        this.momentum = { melody: 0, harmony: 0, bass: 0 };
        this.activeNotes = { melody: [], harmony: [], bass: [], metronome: [] };
        this.scaleIntervals = { 1: 0, 2: 2, 3: 4, 4: 5, 5: 7, 6: 9, 7: 11, 8: 12 };

        this.bassNodes = null;
      }

      start() {
        this.resetState();
        this.loop();
      }

      stop() {
        if (this.timer) clearTimeout(this.timer);
        this.stopBass();
        this.activeNotes = { melody: [], harmony: [], bass: [], metronome: [] };
      }

      resetState() {
        this.barCount = 1;
        this.beatsInBar = 0;
        this.eighthCount = 0;
        this.momentum = { melody: 0, harmony: 0, bass: 0 };
      }

      loop() {
        const beatsPerSec = this.currentTempo / 60;
        const eighthInterval = (1 / beatsPerSec) / 2 * 1000;

        this.timer = setTimeout(() => this.loop(), eighthInterval);

        if (this.eighthCount % 2 === 0) {
          this.playMetronome();
          this.processVoice('bass');

          this.beatsInBar++;
          if (this.beatsInBar >= this.currentTimeSignature[0]) {
            this.beatsInBar = 0;
            this.barCount++;
            if (this.barCount % 12 === 1 && this.barCount > 1) {
              this.changeKeyAndRhythm();
            }
          }
        }

        this.processVoice('melody');
        this.processVoice('harmony');
        this.eighthCount++;
      }

      changeKeyAndRhythm() {
        this.currentKey = this.keys[Math.floor(Math.random() * this.keys.length)];
        this.currentTimeSignature = this.timeSignatures[Math.floor(Math.random() * this.timeSignatures.length)];
        this.currentTempo = this.tempos[Math.floor(Math.random() * this.tempos.length)];
        console.log(`Lyre: Modulating to ${this.currentKey} at ${this.currentTempo}bpm`);
      }

      processVoice(type) {
        if (type === 'bass' && this.eighthCount % 2 !== 0) return;

        const prob = 0.5 + (this.momentum[type] * 0.05);
        if (Math.random() < prob) {
          const note = this.getValidNote(type);
          if (note !== null) {
            this.playNote(note, type);
            this.momentum[type] = Math.max(-5, this.momentum[type] - 1);
          } else {
            this.momentum[type] = Math.min(5, this.momentum[type] + 1);
          }
        } else {
          this.momentum[type] = Math.min(5, this.momentum[type] + 1);
        }
      }

      getValidNote(type) {
        let attempts = 0;
        while (attempts < 8) {
          const note = Math.floor(Math.random() * 8) + 1;
          if (!this.checkConflicts(note, type)) {
            return note;
          }
          attempts++;
        }
        return null;
      }

      checkConflicts(newNote, myType) {
        const now = Date.now();
        ['melody', 'harmony', 'bass', 'metronome'].forEach(t => {
          this.activeNotes[t] = this.activeNotes[t].filter(n => n.endTime > now);
        });

        let others = [];
        ['melody', 'harmony', 'bass'].forEach(t => {
          if (t !== myType) others = others.concat(this.activeNotes[t]);
        });

        for (let other of others) {
          const allowed = this.getConsonantNotes(other.note);
          if (!allowed.includes(newNote)) return true;
        }
        return false;
      }

      getConsonantNotes(note) {
        const map = {
          1: [1, 3, 4, 5, 6], 2: [2, 4, 5, 6, 7], 3: [1, 3, 5, 6, 7],
          4: [1, 2, 4, 6, 7], 5: [1, 2, 3, 5, 7], 6: [1, 2, 3, 4, 6],
          7: [2, 3, 4, 5, 7], 8: [1, 3, 4, 5, 6]
        };
        return map[note] || [];
      }

      // --- SOUND ENGINE: THE REALISTIC HARPSICHORD ---

      playMetronome() {
        // Silent
      }

      stopBass() {
        if (this.bassNodes) {
          // Harpsichord dampers stop sound abruptly
          this.bassNodes.gain.gain.setTargetAtTime(0, this.ctx.currentTime, 0.02);
          this.bassNodes.osc1.stop(this.ctx.currentTime + 0.1);
          this.bassNodes.osc2.stop(this.ctx.currentTime + 0.1);
          this.bassNodes = null;
        }
      }

      playNote(degree, type) {
        const t = this.ctx.currentTime;
        const interval = this.scaleIntervals[degree];
        const base = this.keyFreqs[this.currentKey];
        let freq = base * Math.pow(2, interval / 12);

        let dur = (60 / this.currentTempo);
        let volume = 0.1;

        // VOICE CONFIGURATION
        if (type === 'bass') {
          this.stopBass();
          freq = freq / 2;
          volume = 0.15;
        }
        else if (type === 'harmony') {
          volume = 0.06;
        }

        // 1. The "Plectrum" (Mechanical Click)
        // This is a tiny burst of noise to simulate the quill hitting the string
        const noiseBuf = this.ctx.createBuffer(1, 1000, this.ctx.sampleRate);
        const noiseData = noiseBuf.getChannelData(0);
        for (let i = 0; i < 1000; i++) noiseData[i] = Math.random() * 2 - 1;

        const click = this.ctx.createBufferSource();
        click.buffer = noiseBuf;
        const clickGain = this.ctx.createGain();
        clickGain.gain.setValueAtTime(0.05, t);
        clickGain.gain.exponentialRampToValueAtTime(0.001, t + 0.01); // ultra short
        click.connect(clickGain); clickGain.connect(this.dest);
        click.start(t);


        // 2. The String (Oscillators)
        const osc1 = this.ctx.createOscillator();
        osc1.type = 'sawtooth';
        osc1.frequency.value = freq;
        // Random detune for realism (strings are never perfect)
        osc1.detune.value = (Math.random() * 4) - 2;

        const osc2 = this.ctx.createOscillator();
        osc2.type = 'sawtooth';
        osc2.frequency.value = freq * 2; // Octave up
        osc2.detune.value = (Math.random() * 6) - 3;

        // 3. The "Pluck" Filter
        // This is the secret sauce. The filter starts OPEN and snaps CLOSED.
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.Q.value = 1; // Slight resonance for the "twang"

        // Filter Envelope
        filter.frequency.setValueAtTime(5000, t); // Start Bright
        // Snap down quickly to dull (mimics energy loss)
        filter.frequency.exponentialRampToValueAtTime(800, t + 0.2);

        // 4. The Amplitude Envelope (Poor Sustain)
        const gain = this.ctx.createGain();

        // Attack is instant
        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(volume, t + 0.005);

        // Decay is fast and exponential. Harpsichord notes die away quickly.
        // Even if the note duration (dur) is long, the volume drops off.
        gain.gain.exponentialRampToValueAtTime(volume * 0.01, t + 1.5);

        // Wiring
        const osc2Gain = this.ctx.createGain();
        osc2Gain.gain.value = 0.3; // Octave is quieter

        osc1.connect(filter);
        osc2.connect(osc2Gain); osc2Gain.connect(filter);

        filter.connect(gain);
        gain.connect(this.dest);

        osc1.start(t); osc1.stop(t + 2.0); // Stop slightly after decay
        osc2.start(t); osc2.stop(t + 2.0);

        if (type === 'bass') {
          this.bassNodes = { osc1, osc2, gain };
          this.activeNotes.bass.push({ note: degree, endTime: Date.now() + 2000 });
        } else {
          this.activeNotes[type].push({ note: degree, endTime: Date.now() + (dur * 1000) });
        }
      }
    }/////////////////////[MAIN GAME LOOP]//////////////////////////
// MODULE 12: Audience with the Queen
class QueenModule {
      constructor(ctx, dest) {
        this.ctx = ctx;
        this.dest = dest;
        this.timer = null;

        // --- Musical State ---
        this.tempo = 90; // Standard Baroque Allegro
        this.keyBase = 261.63; // Middle C

        // C Major Scale (extended range for runs)
        // 0=C, 1=D, 2=E, 3=F, 4=G, 5=A, 6=B, 7=C...
        this.scale = [0, 2, 4, 5, 7, 9, 11];

        // --- The "Composer" State ---
        this.tickCount = 0;   // 16th note counter
        this.measureCount = 0;

        // Harmony: 0=I, 1=ii, 2=iii, 3=IV, 4=V, 5=vi, 6=vii
        this.currentChordRoot = 0;

        // The "Subject" (The Motif)
        // This is a shape: [0, 1, 2, 4] means "Root, Step Up, Step Up, Skip Up"
        this.subject = [0, 1, 2, 0]; // A simple "Turn" motif (C-D-E-C)

        // Who has the melody? 'right' or 'left'
        this.activeHand = 'right';

        // Panning Nodes (for stereo separation)
        this.panL = ctx.createStereoPanner();
        this.panL.pan.value = -0.3; // Bass slightly left
        this.panL.connect(dest);

        this.panR = ctx.createStereoPanner();
        this.panR.pan.value = 0.3; // Treble slightly right
        this.panR.connect(dest);
      }

      start() {
        this.tickCount = 0;
        this.measureCount = 0;
        this.loop();
      }

      stop() {
        if (this.timer) clearTimeout(this.timer);
      }

      loop() {
        const secondsPerBeat = 60 / this.tempo;
        const interval = (secondsPerBeat / 4) * 1000; // 16th notes

        this.timer = setTimeout(() => this.loop(), interval);

        // --- COMPOSITION LOGIC (The Brain) ---

        const beat = Math.floor(this.tickCount / 4);
        const step = this.tickCount % 16; // Step within the measure (0-15)

        // 1. New Measure Logic (Harmony & Role Swap)
        if (step === 0) {
          // Every 2 measures, swap hands (The "Switching Off")
          if (this.measureCount % 2 === 0) {
            this.activeHand = (this.activeHand === 'right') ? 'left' : 'right';
            // Mutate the subject slightly for variety
            if (Math.random() > 0.5) this.mutateSubject();
          }

          this.progressHarmony();
          this.measureCount++;
        }

        // 2. Play The Voices
        this.playVoice('right', this.tickCount);
        this.playVoice('left', this.tickCount);

        this.tickCount++;
      }

      mutateSubject() {
        // Change the melodic shape slightly
        const shapes = [
          [0, 1, 2, 0], // Turn
          [0, 2, 4, 7], // Arpeggio Up
          [7, 4, 2, 0], // Arpeggio Down
          [0, 1, 0, -1], // Neighbor tone
          [0, 2, 1, 3]  // Broken thirds
        ];
        this.subject = shapes[Math.floor(Math.random() * shapes.length)];
      }

      progressHarmony() {
        // Classic Cycle of Fifths / Tonal Logic
        const r = Math.random();
        // 0=I, 1=ii, 3=IV, 4=V, 5=vi
        if (this.currentChordRoot === 0) this.currentChordRoot = (r < 0.5) ? 3 : 4; // I -> IV or V
        else if (this.currentChordRoot === 3) this.currentChordRoot = (r < 0.5) ? 4 : 1; // IV -> V or ii
        else if (this.currentChordRoot === 4) this.currentChordRoot = (r < 0.7) ? 0 : 5; // V -> I (Resolve) or vi (Deceptive)
        else if (this.currentChordRoot === 5) this.currentChordRoot = 1; // vi -> ii
        else this.currentChordRoot = 4; // ii -> V
      }

      playVoice(hand, tick) {
        const stepInBar = tick % 16;
        const subBeat = tick % 4; // 0, 1, 2, 3 (16th notes inside a beat)

        let noteToPlay = null; // Null means rest
        let octave = (hand === 'right') ? 1 : -1; // Treble vs Bass range

        // --- COUNTERPOINT LOGIC ---

        // Scenario A: This hand is ACTIVE (Playing the Subject/Run)
        if (this.activeHand === hand) {
          // Play continuous 16th notes (The Motor)

          // Map the current "Subject" shape onto the current Harmony
          // We loop through the subject array (mod 4)
          const subjectNoteIndex = this.subject[subBeat];

          // Calculate scale degree relative to Chord Root
          // e.g., if Chord is V (G), and subject is 0 (Root), we play G.
          noteToPlay = this.currentChordRoot + subjectNoteIndex;
        }

        // Scenario B: This hand is PASSIVE (Accompaniment)
        else {
          // Play sparse notes (Quarters or Eighths) to let the other hand shine
          // This creates the "Switching Off" effect

          // Only play on the beat (0, 4, 8, 12) OR off-beat (8) for syncopation
          if (stepInBar === 0 || stepInBar === 8) {
            // Just play the Root or 3rd of the chord
            if (stepInBar === 0) noteToPlay = this.currentChordRoot; // Root on 1
            if (stepInBar === 8) noteToPlay = this.currentChordRoot + 2; // 3rd on 3
          }

          // MIRRORING TRICK:
          // Sometimes, mimic the active hand in slow motion (Canon style)
          // (If we wanted complex canon, we'd store history, but simple harmony works best for procedurals)
        }

        // --- EXECUTE NOTE ---
        if (noteToPlay !== null) {
          this.soundEngine(noteToPlay, octave, hand);
        }
      }

      soundEngine(scaleDegree, octaveShift, hand) {
        const t = this.ctx.currentTime;

        // 1. Quantize to Scale (C Major)
        // Handle negative scale degrees correctly
        let normDegree = scaleDegree;
        let octAdjust = 0;

        while (normDegree < 0) { normDegree += 7; octAdjust -= 1; }
        while (normDegree >= 7) { normDegree -= 7; octAdjust += 1; }

        const semitone = this.scale[normDegree];
        const totalOctave = octaveShift + octAdjust;

        const freq = this.keyBase * Math.pow(2, (semitone + (totalOctave * 12)) / 12);

        // 2. Harpsichord Physics (The "Plectrum Pluck")

        // Destination based on Hand (Pan Left or Right)
        const destNode = (hand === 'left') ? this.panL : this.panR;

        // Oscillators (Sawtooth for brightness)
        const osc = this.ctx.createOscillator();
        osc.type = 'sawtooth';
        osc.frequency.value = freq;

        // Random micro-detune for realism
        osc.detune.value = (Math.random() * 6) - 3;

        // Filter (The "Twang")
        // Key tracking: Higher notes are brighter
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.Q.value = 1.5; // Resonant pluck
        const baseCutoff = (hand === 'right') ? 5000 : 3000;
        filter.frequency.setValueAtTime(baseCutoff, t);
        filter.frequency.exponentialRampToValueAtTime(600, t + 0.2); // Snap shut

        // Amplitude (No sustain)
        const gain = this.ctx.createGain();
        const vol = (hand === 'left') ? 0.12 : 0.1; // Bass slightly louder to carry rhythm

        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(vol, t + 0.005); // Instant attack
        gain.gain.exponentialRampToValueAtTime(0.001, t + 0.8); // Short decay

        // Mechanical Click (The Quill)
        this.playClick(t, destNode);

        // Connect
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(destNode); // Connect to Panner, not Master directly

        osc.start(t);
        osc.stop(t + 1.0);
      }

      playClick(t, dest) {
        // Tiny burst of high-pass noise
        const buf = this.ctx.createBuffer(1, 400, this.ctx.sampleRate);
        const data = buf.getChannelData(0);
        for (let i = 0; i < 400; i++) data[i] = Math.random() * 0.5;

        const src = this.ctx.createBufferSource();
        src.buffer = buf;
        const g = this.ctx.createGain();
        g.gain.value = 0.05;

        src.connect(g); g.connect(dest);
        src.start(t);
      }
    }
// MODULE 13: Audience with the King
class KingModule {
      constructor(ctx, dest) {
        this.ctx = ctx;
        this.dest = dest;
        this.timer = null;

        // --- Battle Settings ---
        this.tempo = 130; // Fast!
        this.keyBase = 293.66; // D (D Minor is the classic "Epic" key)
        this.currentKeyName = 'D';

        // Harmonic Minor (The "Dramatic" Scale)
        // 0, 2, 3, 5, 7, 8, 11 (The 11 is the major 7th, creating tension)
        this.scale = [0, 2, 3, 5, 7, 8, 11];

        // --- State ---
        this.tickCount = 0;
        this.measureCount = 0;

        // Modes: 'bariolage' (alternating), 'run' (scale runs), 'chords' (heavy hits)
        this.currentMode = 'bariolage';

        // Harmony State
        this.currentRoot = 0; // Start on Tonic (i)

        // Bariolage State (The "Static" note we bounce off of)
        this.staticNoteOffset = 12; // Octave up

        // Panning
        this.panL = ctx.createStereoPanner(); this.panL.pan.value = -0.3; this.panL.connect(dest);
        this.panR = ctx.createStereoPanner(); this.panR.pan.value = 0.3; this.panR.connect(dest);
      }

      start() {
        this.tickCount = 0;
        this.measureCount = 0;
        this.loop();
      }

      stop() {
        if (this.timer) clearTimeout(this.timer);
      }

      loop() {
        const secondsPerBeat = 60 / this.tempo;
        const interval = (secondsPerBeat / 4) * 1000; // 16th notes

        this.timer = setTimeout(() => this.loop(), interval);

        const step = this.tickCount % 16;

        // --- TACTICAL DECISIONS (Every Bar) ---
        if (step === 0) {
          // 1. Change Harmony
          this.progressHarmony();

          // 2. Change Battle Tactic (Mode)
          const roll = Math.random();
          if (roll < 0.5) this.currentMode = 'bariolage';
          else if (roll < 0.8) this.currentMode = 'run';
          else this.currentMode = 'pedal_point'; // Epic sustained bass

          // Reset Bariolage Anchor (The static note)
          // Usually the 5th (Dominant) or the Octave of the current chord
          this.staticNoteOffset = (Math.random() > 0.5) ? 7 : 12;
        }

        // --- PLAY THE NOTES ---
        this.playToccata(step);

        this.tickCount++;
      }

      progressHarmony() {
        // Dramatic Minor Key Progression
        // 0=i, 3=iv, 4=V (Major), 5=VI (Epic Chord), 6=vii dim
        const r = Math.random();

        if (this.currentRoot === 0) { // From i
          this.currentRoot = (r < 0.5) ? 4 : 5; // Go to V (Tension) or VI (Epic)
        }
        else if (this.currentRoot === 4) { // From V
          this.currentRoot = (r < 0.8) ? 0 : 5; // Resolve to i or Deceptive to VI
        }
        else if (this.currentRoot === 5) { // From VI
          this.currentRoot = (r < 0.5) ? 3 : 4; // Go iv or V
        }
        else {
          this.currentRoot = 4; // Push to V
        }
      }

      playToccata(step) {
        // Logic for the different "Battle Modes"

        if (this.currentMode === 'bariolage') {
          // MODE A: BARIOLAGE (The "Alternating Thing")
          // Even steps: Play the MOVING note (changing melody)
          // Odd steps: Play the STATIC note (The pedal tone)

          if (step % 2 !== 0) {
            // The Static Anchor (High Pedal)
            // Plays on right hand
            this.soundEngine(this.currentRoot + this.staticNoteOffset, 1, 'right');
          } else {
            // The Moving Line (Melody)
            // Walks up or down scale degrees around the root
            const melodyNote = this.currentRoot + (step % 4);
            this.soundEngine(melodyNote, 0, 'left'); // Left hand plays moving line
          }
        }

        else if (this.currentMode === 'run') {
          // MODE B: UNISON RUN (The "Chase")
          // Both hands play a fast scale run in unison

          // Create a run pattern: 0, 1, 2, 3, 2, 1, 0, -1...
          const runOffset = (step < 8) ? step : (14 - step);
          const note = this.currentRoot + runOffset;

          // Play BOTH hands (Octave apart)
          this.soundEngine(note, 0, 'right');
          this.soundEngine(note, -1, 'left');
        }

        else if (this.currentMode === 'pedal_point') {
          // MODE C: PEDAL POINT (The "Heroic Stand")
          // Left hand holds a LOW thunderous note
          // Right hand does arpeggios above it

          // Bass: Only play on beat 1
          if (step === 0) {
            this.soundEngine(this.currentRoot, -2, 'left', 2.0); // Long sustain
          }

          // Treble: Continuous Arpeggio
          // Pattern: Root, 3rd, 5th, Octave
          const arp = [0, 2, 4, 7];
          const arpNote = this.currentRoot + arp[step % 4];
          this.soundEngine(arpNote, 1, 'right');
        }
      }

      soundEngine(scaleDegree, octaveShift, hand, forcedDuration = null) {
        const t = this.ctx.currentTime;

        // 1. Quantize to Harmonic Minor
        let normDegree = scaleDegree;
        let octAdjust = 0;

        while (normDegree < 0) { normDegree += 7; octAdjust -= 1; }
        while (normDegree >= 7) { normDegree -= 7; octAdjust += 1; }

        const semitone = this.scale[normDegree];
        const totalOctave = octaveShift + octAdjust;

        const freq = this.keyBase * Math.pow(2, (semitone + (totalOctave * 12)) / 12);

        // 2. Harpsichord Physics
        const destNode = (hand === 'left') ? this.panL : this.panR;

        const osc = this.ctx.createOscillator();
        osc.type = 'sawtooth';
        osc.frequency.value = freq;
        // Detune: Battle music needs grit. More detune!
        osc.detune.value = (Math.random() * 8) - 4;

        // Filter: Brighter/Harsher for battle
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.Q.value = 2.0; // Sharp resonance

        // If left hand bass, make it growl
        const cutoffStart = (hand === 'left' && octaveShift < 0) ? 3000 : 6000;

        filter.frequency.setValueAtTime(cutoffStart, t);
        filter.frequency.exponentialRampToValueAtTime(400, t + 0.3); // Fast pluck

        // Amplitude
        const gain = this.ctx.createGain();
        const duration = forcedDuration || 0.6;

        // Louder volume for intensity
        const vol = (hand === 'left') ? 0.15 : 0.12;

        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(vol, t + 0.005);
        gain.gain.exponentialRampToValueAtTime(0.001, t + duration);

        // Mechanical Click (The Quill) - Louder/Sharper
        this.playClick(t, destNode);

        osc.connect(filter);
        filter.connect(gain);
        gain.connect(destNode);

        osc.start(t);
        osc.stop(t + duration + 0.1);
      }

      playClick(t, dest) {
        const buf = this.ctx.createBuffer(1, 400, this.ctx.sampleRate);
        const data = buf.getChannelData(0);
        for (let i = 0; i < 400; i++) data[i] = (Math.random() * 2 - 1) * 0.1; // Harder click

        const src = this.ctx.createBufferSource();
        src.buffer = buf;
        const g = this.ctx.createGain();
        g.gain.value = 0.1;

        src.connect(g); g.connect(dest);
        src.start(t);
      }
    }
// MODULE 14: Royal Decree 
class RoyalDecreeModule {
  constructor(ctx, dest) {
    this.ctx = ctx;
    this.dest = dest;
    this.timer = null;
    this.isStopped = false; // SAFETY FLAG

    // --- Battle Settings ---
    this.tempo = 130;
    this.keyBase = 293.66; 
    this.scale = [0, 2, 3, 5, 7, 8, 11]; 

    // --- State ---
    this.tickCount = 0;
    this.measureCount = 0;
    this.currentMode = 'bariolage';
    this.currentRoot = 0;
    this.staticNoteOffset = 12;

    // --- OPTIMIZATION: Create Timpani Buffer ONCE ---
    this.timpaniBuffer = this.createNoiseBuffer(1.0);

    // --- GLOBAL MIXING ---
    this.masterBus = ctx.createDynamicsCompressor();
    this.masterBus.threshold.value = -10;
    this.masterBus.knee.value = 40;
    this.masterBus.ratio.value = 12;
    this.masterBus.connect(dest);
  }

  // Helper to create noise buffer once
  createNoiseBuffer(duration) {
    const buf = this.ctx.createBuffer(1, this.ctx.sampleRate * duration, this.ctx.sampleRate);
    const data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
    return buf;
  }

  start() {
    this.isStopped = false;
    this.tickCount = 0;
    this.measureCount = 0;
    this.loop();
  }

  stop() {
    this.isStopped = true; // KILL SWITCH
    if (this.timer) clearTimeout(this.timer);
    
    // Soft Fade to prevent clicking
    // (We can't easily fade a Compressor, so we create a dummy gain if needed, 
    // but just disconnecting slightly later is usually fine for this context)
    setTimeout(() => {
        this.masterBus.disconnect();
    }, 200);
  }

  loop() {
    if (this.isStopped) return; // Zombie Check

    const secondsPerBeat = 60 / this.tempo;
    const interval = (secondsPerBeat / 4) * 1000;

    this.timer = setTimeout(() => this.loop(), interval);

    const step = this.tickCount % 16;

    if (step === 0) {
      this.progressHarmony();
      const roll = Math.random();
      if (roll < 0.4) this.currentMode = 'bariolage'; 
      else if (roll < 0.7) this.currentMode = 'run'; 
      else this.currentMode = 'pedal_point'; 

      this.staticNoteOffset = (Math.random() > 0.5) ? 7 : 12;
      this.playTimpani();
    }

    this.playToccata(step);
    this.tickCount++;
  }

  progressHarmony() {
    const r = Math.random();
    if (this.currentRoot === 0) this.currentRoot = (r < 0.5) ? 4 : 5;
    else if (this.currentRoot === 4) this.currentRoot = (r < 0.8) ? 0 : 5;
    else if (this.currentRoot === 5) this.currentRoot = (r < 0.5) ? 3 : 4;
    else this.currentRoot = 4;
  }

  playToccata(step) {
    if (this.isStopped) return;
    
    if (this.currentMode === 'bariolage') {
      if (step % 2 !== 0) {
        this.playSection(this.currentRoot + this.staticNoteOffset, 1, 'strings');
      } else {
        const melodyNote = this.currentRoot + (step % 4);
        this.playSection(melodyNote, 0, 'strings');
      }
    }
    else if (this.currentMode === 'run') {
      const runOffset = (step < 8) ? step : (14 - step);
      const note = this.currentRoot + runOffset;
      this.playSection(note, 1, 'strings'); 
      this.playSection(note, -1, 'brass');  
    }
    else if (this.currentMode === 'pedal_point') {
      if (step === 0) {
        this.playSection(this.currentRoot, -2, 'brass_low');
      }
      const arp = [0, 2, 4, 7];
      const arpNote = this.currentRoot + arp[step % 4];
      this.playSection(arpNote, 1, 'strings');
    }
  }

  playSection(scaleDegree, octaveShift, section) {
    if (this.isStopped) return;
    const t = this.ctx.currentTime;
    let normDegree = scaleDegree;
    let octAdjust = 0;
    while (normDegree < 0) { normDegree += 7; octAdjust -= 1; }
    while (normDegree >= 7) { normDegree -= 7; octAdjust += 1; }

    const semitone = this.scale[normDegree];
    const totalOctave = octaveShift + octAdjust;
    const freq = this.keyBase * Math.pow(2, (semitone + (totalOctave * 12)) / 12);

    if (section === 'strings') {
      this.createSynth(t, freq, 'sawtooth', {
        attack: 0.02, decay: 0.3, sustain: 0.1, release: 0.4, 
        filter: 2000, Q: 1, detune: 5, vol: 0.15
      });
    }
    else if (section === 'brass') {
      this.createSynth(t, freq, 'sawtooth', {
        attack: 0.05, decay: 0.2, sustain: 0.4, release: 0.6,
        filter: 1500, Q: 2, detune: 8, vol: 0.12
      });
    }
    else if (section === 'brass_low') {
      this.createSynth(t, freq, 'sawtooth', {
        attack: 0.4, decay: 0.5, sustain: 0.8, release: 1.5,
        filter: 400, Q: 0, detune: 4, vol: 0.3
      });
    }
  }

  createSynth(t, freq, type, p) {
    if (this.isStopped) return;
    const osc1 = this.ctx.createOscillator();
    const osc2 = this.ctx.createOscillator();
    osc1.type = type; osc2.type = type;
    osc1.frequency.value = freq; osc2.frequency.value = freq;
    osc1.detune.value = -p.detune;
    osc2.detune.value = p.detune;

    const filter = this.ctx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.Q.value = p.Q;
    filter.frequency.setValueAtTime(p.filter, t);
    if (p.attack > 0.1) {
      filter.frequency.linearRampToValueAtTime(p.filter * 2, t + p.attack);
    } else {
      filter.frequency.exponentialRampToValueAtTime(p.filter * 0.5, t + p.decay);
    }

    const gain = this.ctx.createGain();
    gain.gain.setValueAtTime(0, t);
    gain.gain.linearRampToValueAtTime(p.vol, t + p.attack);
    gain.gain.setTargetAtTime(p.sustain * p.vol, t + p.attack, p.decay);
    gain.gain.setTargetAtTime(0, t + p.attack + 0.2, p.release); 

    osc1.connect(filter); osc2.connect(filter);
    filter.connect(gain);
    gain.connect(this.masterBus);

    osc1.start(t); 
    osc2.start(t);

    const stopTime = t + 2.0;
    osc1.stop(stopTime);
    osc2.stop(stopTime);

    // CRITICAL FIX: Garbage Collection
    osc1.onended = () => {
        osc1.disconnect();
        osc2.disconnect();
        filter.disconnect();
        gain.disconnect();
    };
  }

  playTimpani() {
    if (this.isStopped) return;
    const t = this.ctx.currentTime;
    
    // Tone
    const osc = this.ctx.createOscillator();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(120, t);
    osc.frequency.exponentialRampToValueAtTime(40, t + 0.2); 

    const gain = this.ctx.createGain();
    gain.gain.setValueAtTime(0.6, t); 
    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);

    // Noise (USING PRE-GENERATED BUFFER)
    const noise = this.ctx.createBufferSource();
    noise.buffer = this.timpaniBuffer; 
    const noiseGain = this.ctx.createGain();
    noiseGain.gain.value = 0.2;

    osc.connect(gain);
    noise.connect(noiseGain); noiseGain.connect(gain);
    gain.connect(this.masterBus);

    osc.start(t); osc.stop(t + 0.5);
    noise.start(t);

    // CRITICAL FIX: Garbage Collection
    osc.onended = () => {
        osc.disconnect();
        noise.disconnect();
        noiseGain.disconnect();
        gain.disconnect();
    };
  }
} 
// MODULE 15: Battle 2
class Battle2Module {
      constructor(ctx, dest) {
        this.ctx = ctx;
        this.dest = dest;
        this.timer = null;

        // --- BATTLE SETTINGS ---
        this.tempo = 160;

        // KEY POOL (Dark/Epic Keys)
        this.keys = {
          'D': 293.66, 'Eb': 311.13, 'E': 329.63,
          'F': 349.23, 'G': 392.00, 'A': 440.00, 'Bb': 466.16
        };
        this.currentKey = 'D';
        this.keyBase = this.keys['D'];

        // MODE POOL (Musical Flavors)
        this.modes = {
          'Harmonic Minor': [0, 2, 3, 5, 7, 8, 11], // The "Dracula" sound
          'Phrygian': [0, 1, 3, 5, 7, 8, 10],       // The "Dark Tension" sound
          'Natural Minor': [0, 2, 3, 5, 7, 8, 10]   // The "Sad/Tragic" sound
        };
        this.currentScaleName = 'Harmonic Minor';
        this.scale = this.modes['Harmonic Minor'];

        // --- STATE ---
        this.tickCount = 0;
        this.barCount = 0;

        // Improviser State
        this.lastMelodyNote = 0; // Tracks where the melody "is" so it can walk
        this.bassPattern = 'gallop'; // 'gallop', 'walk', 'octaves'

        // Global Mix
        this.masterBus = ctx.createDynamicsCompressor();
        this.masterBus.threshold.value = -12;
        this.masterBus.ratio.value = 12;
        this.masterBus.connect(dest);
      }

      start() {
        this.tickCount = 0;
        this.barCount = 0;
        this.loop();
      }

      stop() {
        if (this.timer) clearTimeout(this.timer);
      }

      loop() {
        const secondsPerBeat = 60 / this.tempo;
        const interval = (secondsPerBeat / 4) * 1000; // 16th notes

        this.timer = setTimeout(() => this.loop(), interval);

        const step = this.tickCount % 16;

        // --- 1. THE "DIRECTOR" (Macro Changes) ---
        if (step === 0) {
          this.barCount++;

          // Every 8 bars: PHASE SHIFT (Key Change)
          if (this.barCount % 8 === 0) {
            this.modulateKey();
          }

          // Every 4 bars: CHANGE TACTICS (Bass/Scale)
          if (this.barCount % 4 === 0) {
            this.changeBassPattern();
            // Randomly swap scales (e.g. Minor to Phrygian)
            const modeNames = Object.keys(this.modes);
            this.currentScaleName = modeNames[Math.floor(Math.random() * modeNames.length)];
            this.scale = this.modes[this.currentScaleName];
          }
        }

        // --- 2. THE "DRUMMER" (Fills & Beats) ---
        const isFillBar = (this.barCount % 4 === 3); // 4th bar is a fill
        if (isFillBar && step > 8) {
          // Play Drum Fill (Snare rolls)
          if (step % 2 === 0) this.playDrum('snare');
          if (step === 15) this.playDrum('crash');
        } else {
          // Standard Beat
          this.playDrumSequencer(step);
        }

        // --- 3. THE "BASSIST" (Variations) ---
        this.playBassline(step);

        // --- 4. THE "LEAD" (Procedural Walker) ---
        this.playImprovisedSolo(step);

        this.tickCount++;
      }

      // --- DIRECTOR LOGIC ---
      modulateKey() {
        const keyNames = Object.keys(this.keys);
        // Pick a new key that isn't the current one
        let newKey = this.currentKey;
        while (newKey === this.currentKey) {
          newKey = keyNames[Math.floor(Math.random() * keyNames.length)];
        }
        this.currentKey = newKey;
        this.keyBase = this.keys[newKey];
        // Reset melody to root so it doesn't sound jarring
        this.lastMelodyNote = 0;
      }

      changeBassPattern() {
        const patterns = ['gallop', 'walk', 'octaves'];
        this.bassPattern = patterns[Math.floor(Math.random() * patterns.length)];
      }

      // --- IMPROVISER LOGIC ---
      playImprovisedSolo(step) {
        // We use a "Random Walker" algorithm.
        // Instead of picking a random note, we step Up or Down from the previous note.

        // RHYTHM VARIATION:
        // Sometimes play 16th notes (fast), sometimes 8ths (slow)
        const density = Math.random();
        if (density > 0.7 && step % 2 !== 0) return; // Skip some 16ths for gaps

        // 1. Decide Direction
        // 40% Step Up, 40% Step Down, 20% Big Jump
        const r = Math.random();
        let move = 0;
        if (r < 0.4) move = 1;
        else if (r < 0.8) move = -1;
        else move = (Math.random() > 0.5) ? 3 : -3; // Jump a 4th/5th

        this.lastMelodyNote += move;

        // 2. Constraints (Don't go too high/low)
        if (this.lastMelodyNote > 14) this.lastMelodyNote -= 2;
        if (this.lastMelodyNote < -7) this.lastMelodyNote += 2;

        // 3. Play Note
        // Play in High Octave (+1)
        this.playNote(this.lastMelodyNote, 1, 'lead');
      }

      playBassline(step) {
        let note = 0; // Root by default

        if (this.bassPattern === 'gallop') {
          // Dun-dun-dun-dun (Classic)
          if (step % 2 === 0) this.playNote(0, -2, 'bass');
        }
        else if (this.bassPattern === 'octaves') {
          // Low-High-Low-High
          if (step % 2 === 0) {
            const oct = (step % 4 === 0) ? -2 : -1;
            this.playNote(0, oct, 'bass');
          }
        }
        else if (this.bassPattern === 'walk') {
          // Moves around the scale: Root -> Flat 2 -> Flat 6 -> 5th
          if (step === 0) note = 0;
          else if (step === 4) note = 1; // Tension note
          else if (step === 8) note = 5; // The 6th
          else if (step === 12) note = 4; // The 5th

          if (step % 4 === 0) this.playNote(note, -2, 'bass');
        }
      }

      // --- SOUND ENGINE ---
      playNote(scaleDegree, octaveShift, type) {
        const t = this.ctx.currentTime;

        // Quantize
        let normDegree = scaleDegree;
        let octAdjust = 0;
        while (normDegree < 0) { normDegree += 7; octAdjust -= 1; }
        while (normDegree >= 7) { normDegree -= 7; octAdjust += 1; }

        const semitone = this.scale[normDegree];
        const freq = this.keyBase * Math.pow(2, (semitone + ((octaveShift + octAdjust) * 12)) / 12);

        if (type === 'lead') {
          // BOSS LEAD: Square Wave with Slide
          const osc = this.ctx.createOscillator();
          osc.type = 'square';
          osc.frequency.setValueAtTime(freq, t);

          // "Legato" Slide effect randomly
          if (Math.random() > 0.7) {
            osc.frequency.setValueAtTime(freq * 0.9, t);
            osc.frequency.linearRampToValueAtTime(freq, t + 0.05);
          }

          const filter = this.ctx.createBiquadFilter();
          filter.type = 'lowpass';
          filter.frequency.value = 3000;
          filter.Q.value = 2; // Resonant beep

          const gain = this.ctx.createGain();
          gain.gain.setValueAtTime(0.1, t);
          gain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);

          osc.connect(filter); filter.connect(gain); gain.connect(this.masterBus);
          osc.start(t); osc.stop(t + 0.2);
        }
        else if (type === 'bass') {
          // DRIVING BASS: Sawtooth
          const osc = this.ctx.createOscillator();
          osc.type = 'sawtooth';
          osc.frequency.value = freq;

          const filter = this.ctx.createBiquadFilter();
          filter.type = 'lowpass';
          filter.frequency.setValueAtTime(800, t);
          filter.frequency.exponentialRampToValueAtTime(100, t + 0.2); // Pluck envelope

          const gain = this.ctx.createGain();
          gain.gain.setValueAtTime(0.3, t);
          gain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);

          osc.connect(filter); filter.connect(gain); gain.connect(this.masterBus);
          osc.start(t); osc.stop(t + 0.2);
        }
      }

      playDrumSequencer(step) {
        if (step % 2 === 0) this.playDrum('hihat');
        if (step === 4 || step === 12) this.playDrum('snare');
        if (step === 0 || step === 10) this.playDrum('kick');
        // Occasional double kick
        if (step === 2 && Math.random() > 0.5) this.playDrum('kick');
      }

      playDrum(type) {
        const t = this.ctx.currentTime;
        const gn = this.ctx.createGain();
        gn.connect(this.masterBus);

        if (type === 'kick') {
          const osc = this.ctx.createOscillator();
          osc.frequency.setValueAtTime(150, t);
          osc.frequency.exponentialRampToValueAtTime(40, t + 0.1);
          gn.gain.setValueAtTime(0.8, t);
          gn.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
          osc.connect(gn); osc.start(t); osc.stop(t + 0.1);
        }
        else if (type === 'snare') {
          const buf = this.ctx.createBuffer(1, 1000, this.ctx.sampleRate);
          const data = buf.getChannelData(0);
          for (let i = 0; i < 1000; i++) data[i] = Math.random() * 2 - 1;
          const src = this.ctx.createBufferSource();
          src.buffer = buf;
          const filt = this.ctx.createBiquadFilter();
          filt.type = 'highpass'; filt.frequency.value = 1000;
          gn.gain.setValueAtTime(0.4, t);
          gn.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
          src.connect(filt); filt.connect(gn); src.start(t);
        }
        else if (type === 'hihat') {
          const buf = this.ctx.createBuffer(1, 300, this.ctx.sampleRate);
          const data = buf.getChannelData(0);
          for (let i = 0; i < 300; i++) data[i] = Math.random() * 2 - 1;
          const src = this.ctx.createBufferSource();
          src.buffer = buf;
          const filt = this.ctx.createBiquadFilter();
          filt.type = 'highpass'; filt.frequency.value = 8000;
          gn.gain.setValueAtTime(0.1, t);
          gn.gain.exponentialRampToValueAtTime(0.01, t + 0.05);
          src.connect(filt); filt.connect(gn); src.start(t);
        }
        else if (type === 'crash') {
          const buf = this.ctx.createBuffer(1, 20000, this.ctx.sampleRate);
          const data = buf.getChannelData(0);
          for (let i = 0; i < 20000; i++) data[i] = Math.random() * 2 - 1;
          const src = this.ctx.createBufferSource();
          src.buffer = buf;
          const filt = this.ctx.createBiquadFilter();
          filt.type = 'highpass'; filt.frequency.value = 4000;
          gn.gain.setValueAtTime(0.3, t);
          gn.gain.exponentialRampToValueAtTime(0.01, t + 1.5);
          src.connect(filt); filt.connect(gn); src.start(t);
        }
      }
    }
// MODULE 16: A Worthy Foe
class WorthyModule {
  constructor(ctx, dest) {
    this.ctx = ctx;
    this.dest = dest;
    this.timer = null;
    this.activeNodes = []; // TRACKER: Keeps track of playing sounds

    // --- BOSS STATS ---
    this.tempo = 165; 
    this.basePitch = 293.66; 

    this.scale = [0, 1, 4, 5, 7, 8, 10];

    // --- STATE ---
    this.tickCount = 0;
    this.barCount = 0;
    this.phase = 1; 
    this.currentRoot = 0;

    // --- MIXING ---
    this.masterBus = ctx.createDynamicsCompressor();
    this.masterBus.threshold.value = -10;
    this.masterBus.ratio.value = 20; 
    this.masterBus.attack.value = 0.001;

    // OUTPUT GAIN: The final gate
    this.outputGain = ctx.createGain();
    this.outputGain.gain.value = 1.0;

    this.masterBus.connect(this.outputGain);
    this.outputGain.connect(dest);
  }

  start() {
    this.stop(); // clear any ghosts first
    this.tickCount = 0;
    this.barCount = 0;
    this.tempo = 165; 
    this.activeNodes = []; // Reset tracker

    // Un-mute
    this.outputGain.gain.cancelScheduledValues(this.ctx.currentTime);
    this.outputGain.gain.setValueAtTime(1.0, this.ctx.currentTime);
    this.outputGain.connect(this.dest);
    
    this.playIntro(); 
    this.timer = setTimeout(() => this.loop(), 2000);
  }

  stop() {
    // 1. Stop the loop logic
    if (this.timer) clearTimeout(this.timer);

    // 2. FORCE STOP ALL ACTIVE OSCILLATORS
    this.activeNodes.forEach(node => {
        try {
            node.stop(); 
            node.disconnect();
        } catch (e) { /* ignore already stopped */ }
    });
    this.activeNodes = [];

    // 3. Mute the output gain instantly
    if (this.outputGain) {
        this.outputGain.gain.cancelScheduledValues(this.ctx.currentTime);
        this.outputGain.gain.setValueAtTime(this.outputGain.gain.value, this.ctx.currentTime);
        this.outputGain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.01); // 10ms fade
        
        // Disconnect after a tiny moment to prevent clicks
        setTimeout(() => {
             // Only disconnect if we haven't started again
             if(this.outputGain.gain.value === 0) this.outputGain.disconnect(); 
        }, 50);
    }
  }

  // --- THE "WARNING" INTRO ---
  playIntro() {
    const t = this.ctx.currentTime;
    // Siren Alarms
    this.createSiren(t, this.basePitch * 2);
    this.createSiren(t + 0.5, this.basePitch * 2 * 1.414); 
    this.createSiren(t + 1.0, this.basePitch * 2);
    this.createSiren(t + 1.5, this.basePitch * 2 * 1.414);

    this.playDrum('reverse_cymbal', t);
    this.playDrum('crash', t + 1.9); 
  }

  createSiren(t, freq) {
    const osc = this.ctx.createOscillator();
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(freq, t);
    osc.frequency.linearRampToValueAtTime(freq * 0.9, t + 0.5); 

    const gain = this.ctx.createGain();
    gain.gain.setValueAtTime(0.3, t);
    gain.gain.linearRampToValueAtTime(0, t + 0.5);

    osc.connect(gain); gain.connect(this.masterBus);
    
    osc.start(t); osc.stop(t + 0.5);
    
    // Add to tracker so we can kill it
    this.activeNodes.push(osc);
  }

  // --- MAIN LOOP ---
  loop() {
    const secondsPerBeat = 60 / this.tempo;
    const interval = (secondsPerBeat / 4) * 1000; 

    this.timer = setTimeout(() => this.loop(), interval);
    const step = this.tickCount % 16;

    if (step === 0) {
      this.barCount++;
      if (this.barCount % 4 === 0) this.progressHarmony();
      if (this.barCount % 32 === 0) {
        this.tempo += 5; 
        this.phase = 2;
        console.log("BOSS ENRAGED: Tempo " + this.tempo);
      }
      if (this.barCount % 4 === 1) this.playChoirChord();
    }

    this.playMetalDrums(step);
    this.playPowerBass(step);

    if (this.phase === 1) this.playThemeMelody(step);
    else this.playShredArp(step);

    this.tickCount++;
  }

  progressHarmony() {
    const moves = [1, 4, 1, -2]; 
    const move = moves[Math.floor(Math.random() * moves.length)];
    this.currentRoot += move;
    if (this.currentRoot > 3) this.currentRoot -= 7;
    if (this.currentRoot < -3) this.currentRoot += 7;
  }

  // --- INSTRUMENTS ---

  playMetalDrums(step) {
    if (step % 2 === 0) this.playDrum('kick');
    if (step === 4 || step === 12) this.playDrum('snare');
    if (this.phase === 2 && step % 4 === 0) this.playDrum('hihat_open');
    else if (step % 2 === 0) this.playDrum('hihat_closed');
  }

  playPowerBass(step) {
    const chugGrid = [1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0];
    if (chugGrid[step] === 1) {
      this.playNote(this.currentRoot, -2, 'dist_bass'); 
      this.playNote(this.currentRoot + 4, -2, 'dist_bass'); 
    }
  }

  playChoirChord() {
    const notes = [0, 2, 4]; 
    notes.forEach(n => {
      this.playNote(this.currentRoot + n, 0, 'choir');
      this.playNote(this.currentRoot + n, -1, 'choir'); 
    });
  }

  playThemeMelody(step) {
    if (step % 4 === 0) {
      const tones = [0, 1, 4, 7];
      const tone = this.currentRoot + tones[Math.floor(Math.random() * tones.length)];
      this.playNote(tone, 1, 'lead_saw');
    }
  }

  playShredArp(step) {
    const arpPattern = [0, 2, 4, 7, 4, 2, 0, -1];
    const note = this.currentRoot + arpPattern[step % 8];
    this.playNote(note, 2, 'lead_saw');
  }

  // --- SYNTH ENGINE ---

  playNote(degree, octave, type) {
    const t = this.ctx.currentTime;
    
    let normDegree = degree;
    let octAdjust = 0;
    while (normDegree < 0) { normDegree += 7; octAdjust -= 1; }
    while (normDegree >= 7) { normDegree -= 7; octAdjust += 1; }
    const freq = this.basePitch * Math.pow(2, (this.scale[normDegree] + ((octave + octAdjust) * 12)) / 12);

    if (type === 'dist_bass') {
      this.createVoice(t, freq, 'sawtooth', {
        att: 0.01, dec: 0.1, sus: 0.5, rel: 0.1,
        filt: 800, Q: 5, vol: 0.3
      });
    }
    else if (type === 'lead_saw') {
      this.createVoice(t, freq, 'square', {
        att: 0.05, dec: 0.1, sus: 0.8, rel: 0.3,
        filt: 4000, Q: 2, vol: 0.15
      });
    }
    else if (type === 'choir') {
      const osc = this.ctx.createOscillator();
      osc.type = 'sawtooth';
      osc.frequency.value = freq;
      osc.detune.value = (Math.random() * 20) - 10; 

      const filter = this.ctx.createBiquadFilter();
      filter.type = 'bandpass'; filter.frequency.value = 1200; filter.Q.value = 4;

      const gain = this.ctx.createGain();
      gain.gain.setValueAtTime(0, t);
      gain.gain.linearRampToValueAtTime(0.2, t + 0.5); 
      gain.gain.setTargetAtTime(0, t + 2.0, 0.5); 

      osc.connect(filter); filter.connect(gain); gain.connect(this.masterBus);
      osc.start(t); osc.stop(t + 3.0);
      
      this.activeNodes.push(osc); // Track choir
    }
  }

  createVoice(t, freq, wave, p) {
    const osc = this.ctx.createOscillator();
    osc.type = wave;
    osc.frequency.value = freq;

    const filter = this.ctx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.value = p.filt;
    filter.Q.value = p.Q;

    filter.frequency.exponentialRampToValueAtTime(p.filt * 0.2, t + p.dec);

    const gain = this.ctx.createGain();
    gain.gain.setValueAtTime(0, t);
    gain.gain.linearRampToValueAtTime(p.vol, t + p.att);
    gain.gain.setTargetAtTime(p.vol * p.sus, t + p.att, p.dec);
    gain.gain.setTargetAtTime(0, t + p.att + 0.1, p.rel);

    osc.connect(filter); filter.connect(gain); gain.connect(this.masterBus);
    osc.start(t); osc.stop(t + 1.0);
    
    this.activeNodes.push(osc); // Track voice
  }

  playDrum(type, time) {
    const t = time || this.ctx.currentTime;
    const gn = this.ctx.createGain();
    gn.connect(this.masterBus);
    
    let osc = null; // Track kick osc

    if (type === 'kick') {
      osc = this.ctx.createOscillator();
      osc.frequency.setValueAtTime(100, t);
      osc.frequency.exponentialRampToValueAtTime(20, t + 0.1);
      gn.gain.setValueAtTime(1.0, t); 
      gn.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
      osc.connect(gn); osc.start(t); osc.stop(t + 0.1);
      this.activeNodes.push(osc);
    }
    else if (type === 'snare') {
      const buf = this.ctx.createBuffer(1, 1000, this.ctx.sampleRate);
      const data = buf.getChannelData(0);
      for (let i = 0; i < 1000; i++) data[i] = Math.random() * 2 - 1;
      const src = this.ctx.createBufferSource();
      src.buffer = buf;
      const f = this.ctx.createBiquadFilter();
      f.type = 'highpass'; f.frequency.value = 800;
      gn.gain.setValueAtTime(0.6, t);
      gn.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
      src.connect(f); f.connect(gn); src.start(t);
      this.activeNodes.push(src);
    }
    else if (type === 'reverse_cymbal') {
      const buf = this.ctx.createBuffer(1, 44100 * 2, this.ctx.sampleRate);
      const data = buf.getChannelData(0);
      for (let i = 0; i < data.length; i++) data[i] = Math.random() * 0.5;
      const src = this.ctx.createBufferSource();
      src.buffer = buf;
      const f = this.ctx.createBiquadFilter();
      f.type = 'bandpass'; f.frequency.value = 5000;
      gn.gain.setValueAtTime(0, t);
      gn.gain.linearRampToValueAtTime(0.4, t + 1.8);
      gn.gain.linearRampToValueAtTime(0, t + 1.9); 
      src.connect(f); f.connect(gn); src.start(t);
      this.activeNodes.push(src);
    }
    else if (type === 'crash') {
      const buf = this.ctx.createBuffer(1, 44100, this.ctx.sampleRate);
      const data = buf.getChannelData(0);
      for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
      const src = this.ctx.createBufferSource();
      src.buffer = buf;
      const f = this.ctx.createBiquadFilter();
      f.type = 'lowpass'; f.frequency.value = 8000;
      gn.gain.setValueAtTime(0.5, t);
      gn.gain.exponentialRampToValueAtTime(0.01, t + 2.0);
      src.connect(f); f.connect(gn); src.start(t);
      this.activeNodes.push(src);
    }
  }
}
// MODULE 17: Crisis
class CrisisModule {
  constructor(ctx, dest) {
    this.ctx = ctx;
    this.dest = dest;
    this.timer = null;
    this.isStopped = false; // SAFETY FLAG
    this.longRunningNodes = []; // TRACKER for long sounds (Tinnitus)

    // --- COSMIC STATS ---
    this.tempo = 175; 
    this.basePitch = 146.83; 
    this.scale = [0, 1, 3, 4, 6, 7, 9, 10];
    this.tickCount = 0;
    this.barCount = 0;
    this.gameState = 'transform'; 
    this.currentRoot = 0;

    // --- GLOBAL FX CHAIN ---
    this.dist = ctx.createWaveShaper();
    this.dist.curve = this.makeDistortionCurve(50); 
    this.dist.oversample = 'none'; // '4x' is too heavy for mobile! Changed to 'none'

    this.comp = ctx.createDynamicsCompressor();
    this.comp.threshold.value = -15;
    this.comp.ratio.value = 20;
    this.comp.attack.value = 0.001;

    this.dist.connect(this.comp);
    this.comp.connect(dest);
    this.mixBus = this.dist;
  }

  makeDistortionCurve(amount) {
    const k = typeof amount === 'number' ? amount : 50,
      n_samples = 44100,
      curve = new Float32Array(n_samples),
      deg = Math.PI / 180;
    for (let i = 0; i < n_samples; ++i) {
      let x = i * 2 / n_samples - 1;
      curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
    }
    return curve;
  }

  start() {
    this.isStopped = false;
    this.longRunningNodes = [];
    this.tickCount = 0;
    this.barCount = 0;
    this.gameState = 'transform';
    this.loop();
  }

  stop() {
    this.isStopped = true; // KILL SWITCH
    if (this.timer) clearTimeout(this.timer);
    
    // 1. KILL THE LONG SOUNDS (The Tinnitus Fix)
    this.longRunningNodes.forEach(node => {
        try { node.stop(); } catch(e){}
    });
    this.longRunningNodes = [];

    // 2. Kill Master Volume
    this.comp.disconnect();
    this.dist.disconnect();
  }

  loop() {
    if (this.isStopped) return; // Zombie prevention

    const secondsPerBeat = 60 / this.tempo;
    const interval = (secondsPerBeat / 4) * 1000; 

    this.timer = setTimeout(() => this.loop(), interval);

    // Audio Logic
    if (this.gameState === 'transform') {
      this.playTransformationSequence();
    } else {
      this.playApocalypse();
    }
    this.tickCount++;
  }

  playTransformationSequence() {
    const t = this.ctx.currentTime;
    const step = this.tickCount;

    if (step % 16 === 0 || step % 16 === 2) this.playDrum('heartbeat');

    // --- THE TINNITUS FIX ---
    if (step === 0) {
      const osc = this.ctx.createOscillator();
      osc.frequency.setValueAtTime(8000, t);
      const gn = this.ctx.createGain();
      gn.gain.setValueAtTime(0, t);
      gn.gain.linearRampToValueAtTime(0.05, t + 4.0); 
      
      osc.connect(gn); gn.connect(this.mixBus);
      osc.start(t); 
      osc.stop(t + 5.0);
      
      // TRACK THIS NODE SO WE CAN KILL IT
      this.longRunningNodes.push(osc); 
    }

    if (step === 32) {
      this.playDrum('crash');
      this.gameState = 'battle';
      this.tickCount = -1; 
    }
  }

  
  playApocalypse() {
     if (this.isStopped) return;
     // ... copy your existing logic here ...
     const step = this.tickCount % 16;
     if (step === 0) {
          this.barCount++;
          if (this.barCount % 2 === 0) this.currentRoot = (Math.random() > 0.5) ? 0 : 6;
          this.playChoirCluster();
     }
     this.playBlastBeat(step);
     if (step % 2 === 0) {
          const oct = (step % 4 === 0) ? -2 : -1;
          this.playNote(this.currentRoot, oct, 'dist_bass');
     }
     const arpIndex = step % 8;
     const note = this.currentRoot + this.scale[arpIndex];
     const randOct = (Math.random() > 0.7) ? 2 : 1;
     this.playNote(note, randOct, 'glitch_lead');
     if (step % 4 === 0 && Math.random() > 0.3) {
          const hopeNote = this.currentRoot + 4; 
          this.playNote(hopeNote, 2, 'piano');
     }
  }
  
  playBlastBeat(step) {
    if (step % 4 === 0) this.playDrum('kick');
    if (step % 4 === 1 && Math.random() > 0.5) this.playDrum('kick'); 
    if (step % 4 === 2) this.playDrum('snare');
    if (step === 0 || step === 8) this.playDrum('open_hat');
  }
  
  playChoirCluster() {
    const t = this.ctx.currentTime;
    const notes = [0, 1, 3]; 
    notes.forEach(n => {
      this.playNote(this.currentRoot + n, 0, 'choir');
      this.playNote(this.currentRoot + n, 1, 'choir');
    });
  }

  playNote(degree, octave, type) {
    if (this.isStopped) return; // Safety check
    const t = this.ctx.currentTime;
    let idx = degree;
    while (idx < 0) idx += 8;
    const noteIndex = idx % 8;
    const semitone = this.scale[noteIndex];
    const freq = this.basePitch * Math.pow(2, (semitone + (octave * 12)) / 12);

    if (type === 'dist_bass') {
      this.createVoice(t, freq, 'sawtooth', { att: 0.01, dec: 0.2, sus: 0.8, rel: 0.1, filt: 600, Q: 10, vol: 0.4 });
    }
    else if (type === 'glitch_lead') {
      const osc = this.ctx.createOscillator();
      osc.type = 'square';
      osc.frequency.setValueAtTime(freq, t);
      if (Math.random() > 0.5) osc.frequency.linearRampToValueAtTime(freq * 1.5, t + 0.1);
      const gain = this.ctx.createGain();
      gain.gain.setValueAtTime(0.1, t);
      gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1); 
      osc.connect(gain); gain.connect(this.mixBus);
      osc.start(t); osc.stop(t + 0.1);
    }
    else if (type === 'choir') {
      const osc = this.ctx.createOscillator();
      osc.type = 'sawtooth';
      osc.frequency.value = freq;
      osc.detune.value = (Math.random() * 20) - 10; 
      const filt = this.ctx.createBiquadFilter();
      filt.type = 'highpass'; filt.frequency.value = 800; 
      const gain = this.ctx.createGain();
      gain.gain.setValueAtTime(0, t);
      gain.gain.linearRampToValueAtTime(0.15, t + 0.5); 
      gain.gain.setTargetAtTime(0, t + 1.5, 0.5);
      osc.connect(filt); filt.connect(gain); gain.connect(this.mixBus);
      osc.start(t); osc.stop(t + 3.0);
    }
    else if (type === 'piano') {
      const osc = this.ctx.createOscillator();
      osc.type = 'triangle';
      osc.frequency.value = freq;
      const gain = this.ctx.createGain();
      gain.gain.setValueAtTime(0, t);
      gain.gain.linearRampToValueAtTime(0.3, t + 0.01); 
      gain.gain.exponentialRampToValueAtTime(0.01, t + 0.8);
      osc.connect(gain); gain.connect(this.mixBus); 
      osc.start(t); osc.stop(t + 0.8);
    }
  }

  createVoice(t, freq, wave, p) {
    if (this.isStopped) return;
    const osc = this.ctx.createOscillator();
    osc.type = wave;
    osc.frequency.value = freq;
    const filter = this.ctx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.value = p.filt;
    filter.Q.value = p.Q;
    const gain = this.ctx.createGain();
    gain.gain.setValueAtTime(0, t);
    gain.gain.linearRampToValueAtTime(p.vol, t + p.att);
    gain.gain.setTargetAtTime(p.vol * p.sus, t + p.att, p.dec);
    gain.gain.setTargetAtTime(0, t + p.att + 0.1, p.rel);
    osc.connect(filter); filter.connect(gain); gain.connect(this.mixBus);
    osc.start(t); osc.stop(t + 0.5);
  }

  playDrum(type) {
    if (this.isStopped) return;
    const t = this.ctx.currentTime;
    const gn = this.ctx.createGain();
    gn.connect(this.mixBus);

    if (type === 'kick') {
      const osc = this.ctx.createOscillator();
      osc.frequency.setValueAtTime(100, t);
      osc.frequency.exponentialRampToValueAtTime(20, t + 0.1);
      gn.gain.setValueAtTime(1.0, t); 
      gn.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
      osc.connect(gn); osc.start(t); osc.stop(t + 0.1);
    }
    else if (type === 'heartbeat') {
      const osc = this.ctx.createOscillator();
      osc.frequency.setValueAtTime(60, t);
      osc.frequency.exponentialRampToValueAtTime(10, t + 0.3); 
      gn.gain.setValueAtTime(0.8, t);
      gn.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
      const filt = this.ctx.createBiquadFilter();
      filt.type = 'lowpass'; filt.frequency.value = 100; 
      osc.connect(filt); filt.connect(gn);
      osc.start(t); osc.stop(t + 0.3);
    }
    else if (type === 'snare') {
      const buf = this.ctx.createBuffer(1, 1000, this.ctx.sampleRate);
      const data = buf.getChannelData(0);
      for (let i = 0; i < 1000; i++) data[i] = Math.random() * 2 - 1;
      const src = this.ctx.createBufferSource();
      src.buffer = buf;
      const f = this.ctx.createBiquadFilter();
      f.type = 'highpass'; f.frequency.value = 800;
      gn.gain.setValueAtTime(0.6, t);
      gn.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
      src.connect(f); f.connect(gn); src.start(t);
    }
    else if (type === 'open_hat') {
      const buf = this.ctx.createBuffer(1, 10000, this.ctx.sampleRate);
      const data = buf.getChannelData(0);
      for (let i = 0; i < 10000; i++) data[i] = Math.random() * 2 - 1;
      const src = this.ctx.createBufferSource();
      src.buffer = buf;
      const f = this.ctx.createBiquadFilter();
      f.type = 'highpass'; f.frequency.value = 4000;
      gn.gain.setValueAtTime(0.2, t);
      gn.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
      src.connect(f); f.connect(gn); src.start(t);
    }
  }
}
// MODULE 18: Underworld 
class UnderworldModule {
  constructor(ctx, dest) {
    this.ctx = ctx;
    this.dest = dest;
    this.timer = null;

    // --- TUNING OF THE SPHERES ---
    // C Minor Pentatonic + Added 9th/Flat 6th (The "Tragic" Scale)
    // C, D, Eb, G, Ab, Bb
    this.baseFreq = 130.81; // C3 (Low C)
    this.scale = [0, 2, 3, 7, 8, 10, 12, 14, 15]; 

    // --- ACOUSTIC SPACE ---
    // The Underworld is a large, damp cave. We need massive reverb.
    this.convolver = ctx.createConvolver();
    this.convolver.buffer = this.createCaveImpulse(5.0); // 5 Seconds tail
    this.master = ctx.createGain();
    this.master.gain.value = 0.6;

    // Signal Chain: Source -> Master -> Destination
    //                       |-> Reverb -> Destination
    this.reverbGain = ctx.createGain();
    this.reverbGain.gain.value = 0.5; // Very Wet

    this.master.connect(dest);
    this.master.connect(this.convolver);
    this.convolver.connect(this.reverbGain);
    this.reverbGain.connect(dest);

    // --- STATE ---
    this.mood = 'SORROW'; // 'SORROW' or 'HOPE'
    this.nextNoteTime = 0;
  }

  start() {
    this.nextNoteTime = this.ctx.currentTime;
    this.playNextPhrase();
  }

  stop() {
    if (this.timer) clearTimeout(this.timer);
  }

  // --- THE IMPROVISER ---
  playNextPhrase() {
    const t = this.ctx.currentTime;
    
    // DECISION TREE: What does Orpheus do?
    const r = Math.random();

    // 1. The Heavy Strum (The weight of grief) - 20% chance
    if (r < 0.2) {
        this.strumChord(4); 
        this.scheduleNext(1.5, 2.5); // Long pause after strum
    } 
    // 2. The Arpeggio (Looking back at Eurydice) - 40% chance
    else if (r < 0.6) {
        this.playArpeggio();
    } 
    // 3. The Lonely Melody (Wandering) - 40% chance
    else {
        this.playMelodyNote();
        this.scheduleNext(0.3, 0.8); // Quicker notes
    }
  }

  scheduleNext(min, max) {
      // RUBATO: Random timing variation
      const duration = (Math.random() * (max - min)) + min;
      this.timer = setTimeout(() => this.playNextPhrase(), duration * 1000);
  }

  // --- TECHNIQUES ---

  strumChord(density) {
      // A strum is just multiple notes played quickly in sequence
      const rootIndex = Math.floor(Math.random() * 3); // Low notes
      let delay = 0;
      
      for (let i = 0; i < density; i++) {
          // Select notes skipping up the scale (Root, 3rd, 5th...)
          const noteIndex = rootIndex + (i * 2); 
          if (noteIndex < this.scale.length) {
              const degree = this.scale[noteIndex];
              // Strum speed: 40ms to 70ms between strings
              const strumSpeed = 0.04 + (Math.random() * 0.03); 
              
              this.playString(degree, -1, delay, 0.4);
              delay += strumSpeed;
          }
      }
  }

  playArpeggio() {
      // 3 or 4 rising notes
      const len = 3 + Math.floor(Math.random() * 2);
      const start = Math.floor(Math.random() * 4);
      let timeOffset = 0;

      for (let i = 0; i < len; i++) {
          const degree = this.scale[start + i];
          // Ebb and flow timing
          timeOffset += 0.2 + (Math.random() * 0.1);
          this.playString(degree, 0, timeOffset, 0.3);
      }
      this.scheduleNext(timeOffset + 1.0, timeOffset + 2.0);
  }

  playMelodyNote() {
      // Pick a random note, biased towards the middle range
      const idx = Math.floor(Math.random() * (this.scale.length - 2)) + 2;
      const degree = this.scale[idx];
      
      // Occasional "Grace Note" (Hammer-on)
      if (Math.random() > 0.7) {
          this.playString(degree - 1, 0, 0, 0.2); // Pre-note
          this.playString(degree, 0, 0.1, 0.4);   // Main note
      } else {
          this.playString(degree, 0, 0, 0.4);
      }
  }

  // --- SYNTHESIS (The Gut String) ---
  playString(degree, octaveOffset, delay, vol) {
      const t = this.ctx.currentTime + delay;
      
      // Calculate Frequency
      const octave = Math.floor(degree / 7) + octaveOffset;
      const noteInScale = degree % 7; // simplified for pentatonic array
      // Re-map to our custom scale array
      // (This is a bit hacky but works for procedural indexing)
      const semitone = this.scale[degree % this.scale.length] || 0;
      
      const freq = this.baseFreq * Math.pow(2, (semitone + (octave * 12)) / 12);

      // 1. The Oscillator (Source)
      const osc = this.ctx.createOscillator();
      // Triangle is warmer, Sawtooth is brighter. Let's mix them.
      // Actually, a filtered Sawtooth sounds most like a plucked string.
      osc.type = 'sawtooth';
      osc.frequency.value = freq;

      // 2. The Filter (The Pluck)
      const filter = this.ctx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.Q.value = 3; // Resonance mimics the instrument body
      
      // Filter Envelope: Opens fast, closes fast
      filter.frequency.setValueAtTime(200, t);
      filter.frequency.exponentialRampToValueAtTime(3000, t + 0.02); // Attack
      filter.frequency.exponentialRampToValueAtTime(freq, t + 0.4);  // Decay to fundamental

      // 3. Amplitude Envelope (Sustain)
      const g = this.ctx.createGain();
      g.gain.setValueAtTime(0, t);
      g.gain.linearRampToValueAtTime(vol, t + 0.02); // Pluck sound
      // Long exponential decay (strings ring for a long time)
      g.gain.exponentialRampToValueAtTime(0.001, t + 3.0); 

      // Connect
      osc.connect(filter);
      filter.connect(g);
      g.connect(this.master);

      osc.start(t);
      osc.stop(t + 3.1);
  }

  // --- IMPULSE RESPONSE (The Cave) ---
  createCaveImpulse(duration) {
      const rate = this.ctx.sampleRate;
      const length = rate * duration;
      const impulse = this.ctx.createBuffer(2, length, rate);
      const L = impulse.getChannelData(0);
      const R = impulse.getChannelData(1);

      for (let i = 0; i < length; i++) {
          // Exponential decay function
          const n = i / length;
          // A bit of noise for texture
          const noise = (Math.random() * 2 - 1);
          // Darker decay (simulating stone walls absorbing high freq)
          const decay = Math.pow(1 - n, 4); 
          
          L[i] = noise * decay;
          R[i] = noise * decay;
      }
      return impulse;
  }
}
//MODULE 19: Lament
class LamentModule {
    constructor(ctx, dest) {
        this.ctx = ctx;
        this.dest = dest;
        this.timer = null;

        // --- VOLUME CONTROLS ---
        // Adjust these to mix your voices
        this.vol = {
            master: 0.5,      // Global Volume
            
            // BASS CONTROLS
            bassRaw: 0.8,     // The constant "buzz" (Direct sawtooth volume)
            bassSwell: .3,   // The rhythmic "swell" on top of the buzz
            
            // UPPER VOICES
            violin: .15,     // The high harmony voice
            viola: .3,      // The middle counterpoint voice
            
            reverb: 0.6       // Reverb Wetness
        };

        // --- AUDIO GRAPH ---
        this.master = ctx.createGain();
        this.master.gain.value = this.vol.master;

        // FILTER
        this.filter = ctx.createBiquadFilter();
        this.filter.type = 'lowpass';
        this.filter.frequency.value = 800;

        // REVERB
        this.revNode = ctx.createConvolver();
        this.setupChamberReverb();
        this.revGain = ctx.createGain();
        this.revGain.gain.value = this.vol.reverb;

        this.master.connect(this.filter);
        this.filter.connect(this.dest);
        this.filter.connect(this.revNode);
        this.revNode.connect(this.revGain);
        this.revGain.connect(this.dest);

        // --- STATE ---
        this.tempo = 60;
        this.tick = 0;
        this.isPlaying = false;

        // KEY
        this.originalFreq = 196.00; // G3
        this.currentBaseFreq = 196.00;

        this.groundBass = [
        { note: 0,  dur: 4 }, // Root
        { note: -1, dur: 4 }, // Major 7 (clash!)
        { note: -2, dur: 4 }, // Minor 7
        { note: -3, dur: 4 }, // Major 6
        { note: -4, dur: 4 }, // Minor 6
        { note: -5, dur: 8 }  // 5th (Resolution)
    ];
    }

    setupChamberReverb() {
        const len = this.ctx.sampleRate * 2.5;
        const buf = this.ctx.createBuffer(2, len, this.ctx.sampleRate);
        for (let c = 0; c < 2; c++) {
            const d = buf.getChannelData(c);
            for (let i = 0; i < len; i++) {
                d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / len, 3);
            }
        }
        this.revNode.buffer = buf;
    }

    start() {
        if (this.isPlaying) return;
        this.isPlaying = true;
        
        // FIX: Use the variable volume, not hardcoded 0.5
        this.master.gain.setValueAtTime(this.vol.master, this.ctx.currentTime);
        
        this.tick = 0;
        this.currentBaseFreq = this.originalFreq;
        this.loop();
    }

    stop() {
        this.isPlaying = false;
        if (this.timer) clearTimeout(this.timer);
        const t = this.ctx.currentTime;
        this.master.gain.linearRampToValueAtTime(0, t + 2.0);
    }

    modulateKey() {
        const possibleShifts = [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6];
        const shift = possibleShifts[Math.floor(Math.random() * possibleShifts.length)];
        this.currentBaseFreq = this.originalFreq * Math.pow(2, shift / 12);
    }

    loop() {
        if (!this.isPlaying) return;

        const interval = 60 / this.tempo;
        this.timer = setTimeout(() => this.loop(), interval * 1000);
        const t = this.ctx.currentTime;

        if (this.tick > 0 && this.tick % 8 === 0) {
            this.modulateKey();
        }

        const loopTick = this.tick % 16;

        // 1. PLAY BASS
        const bassStep = this.getBassNote(loopTick);
        if (bassStep) {
            this.playVoice(t, this.currentBaseFreq / 2, bassStep.note, 2.0, 'cello');

            // Harmony (Violin)
            const harmonyOffset = this.getHarmonyOffset(bassStep.note);
            this.playVoice(t, this.currentBaseFreq * 2, bassStep.note + harmonyOffset, 2.0, 'violin');
        }

        // 2. COUNTERPOINT
        if (this.tick % 2 === 0) {
            this.generateCounterpoint(t, loopTick);
        }

        this.tick++;
    }

    getBassNote(tick) {
        if (tick === 0) return this.groundBass[0];
        if (tick === 2) return this.groundBass[1];
        if (tick === 4) return this.groundBass[2];
        if (tick === 6) return this.groundBass[3];
        if (tick === 8) return this.groundBass[4];
        if (tick === 10) return this.groundBass[5];
        return null;
    }

    getHarmonyOffset(bassNoteRelative) {
        if (bassNoteRelative === 0) return 3;  
        if (bassNoteRelative === -3) return 3; 
        return 4; 
    }

  generateCounterpoint(t, loopTick) {
    // Determine current bass note from your loop logic...
    // (Assuming you have access to the current bass interval here)
    
    // Only play suspensions on the "heavy" beats
    if (Math.random() > 0.3) {
        // 4-3 Suspension Logic:
        // Start 4 semitones above the bass (The 3rd) -> Hold it ->
        // But the bass moves, creating a 4th -> Resolve down to 3rd.
        
        // Simpler approach for this code:
        // Pick a note that clashes, then slides down 1 or 2 semitones.
        const startNote = 7; // A 5th above root
        const endNote = 5;   // Slide down to 4th (or 3rd relative to key)
        
        this.playSuspension(t, this.currentBaseFreq, startNote, endNote);
    }
}
    playVoice(t, base, semitones, duration, type) {
    const freq = base * Math.pow(2, semitones / 12);
    
    // Create two oscillators for "Ensemble" thickness (beating)
    const osc1 = this.ctx.createOscillator();
    const osc2 = this.ctx.createOscillator();
    const voiceFilter = this.ctx.createBiquadFilter();
    const envGain = this.ctx.createGain();

    // Subtle detuning creates "sadness" via interference beats
    const detune = (Math.random() * 6) - 3; // +/- 3 cents
    osc1.frequency.value = freq;
    osc2.frequency.value = freq;
    osc2.detune.value = detune; 
    
    osc1.type = 'sawtooth';
    osc2.type = 'sawtooth';

    // FILTER ENVELOPE (The "Bow Stroke")
    // Real strings get brighter as they get louder.
    // We map the filter cutoff to the volume envelope.
    voiceFilter.type = 'lowpass';
    voiceFilter.Q.value = 1; // Slight resonance
    
    // Start dark, open up, then close (Swell)
    voiceFilter.frequency.setValueAtTime(200, t);
    voiceFilter.frequency.exponentialRampToValueAtTime(1800, t + (duration * 0.3)); // Attack
    voiceFilter.frequency.exponentialRampToValueAtTime(400, t + duration); // Decay

    // VOLUME ENVELOPE (The "Pianto" / Sigh)
    envGain.gain.setValueAtTime(0, t);
    
    if (type === 'cello') {
        // Heavy, slow swell
        envGain.gain.linearRampToValueAtTime(this.vol.bassRaw, t + 0.3);
        envGain.gain.exponentialRampToValueAtTime(0.01, t + duration);
    } else {
        // Upper voices: "Crying" shape (Fast attack, slow sorrowful decay)
        const peak = type === 'violin' ? this.vol.violin : this.vol.viola;
        // Humanize start time slightly (players aren't robots)
        const humanize = Math.random() * 0.05;
        
        envGain.gain.setValueAtTime(0, t + humanize);
        envGain.gain.linearRampToValueAtTime(peak, t + 0.4 + humanize);
        envGain.gain.exponentialRampToValueAtTime(0.001, t + duration + 1.0); // Long tail
    }

    // Routing
    osc1.connect(voiceFilter);
    osc2.connect(voiceFilter);
    voiceFilter.connect(envGain);
    envGain.connect(this.master);

    osc1.start(t);
    osc2.start(t);
    osc1.stop(t + duration + 2);
    osc2.stop(t + duration + 2);

    // GC
    osc1.onended = () => { envGain.disconnect(); };
}
    playSuspension(t, base, startSemi, endSemi) {
        const startFreq = base * Math.pow(2, startSemi / 12);
        const endFreq = base * Math.pow(2, endSemi / 12);

        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(startFreq, t);
        osc.frequency.setTargetAtTime(endFreq, t + 0.8, 0.2);

        // Vibrato
        const lfo = this.ctx.createOscillator();
        const lfoGain = this.ctx.createGain();
        lfo.frequency.value = 4.5;
        lfoGain.gain.setValueAtTime(0, t);
        lfoGain.gain.linearRampToValueAtTime(3, t + 1.2);
        lfo.connect(lfoGain);
        lfoGain.connect(osc.frequency);
        lfo.start(t);

        // Suspension uses its own volume logic (Viola volume)
        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(this.vol.viola, t + 0.5);
        gain.gain.linearRampToValueAtTime(0, t + 3.0);

        osc.connect(gain);
        gain.connect(this.master);

        osc.start(t);
        osc.stop(t + 3.1);
        lfo.stop(t + 3.1);
        
        osc.onended = () => { gain.disconnect(); };
    }
}
// MODULE 20: Ice Queen's Tears
class TearsModule {
  constructor(ctx, dest) {
    this.ctx = ctx;
    this.dest = dest;
    this.timer = null;

    // --- EMOTIONAL SETTINGS ---
    this.tempo = 40; // Extremely Slow (Adagio)
    // G Minor (The key of "Air") -> but we use extended voicings
    this.rootFreq = 196.00; 

    // --- STATE ---
    this.tickCount = 0;
    this.chordIndex = 0;
    
    // Tracks the current melody note for sliding (Portamento)
    this.lastMelodyFreq = null; 

    // --- THE "SILK" MIXER ---
    // We need a very smooth reverb, almost infinite
    this.masterGain = ctx.createGain();
    this.masterGain.gain.value = 0.0; // Fade in

    this.convolver = ctx.createConvolver();
    this.setupLushReverb();

    // Compressor to glue the "Orchestra"
    this.comp = ctx.createDynamicsCompressor();
    this.comp.threshold.value = -20;
    this.comp.ratio.value = 10;
    this.comp.attack.value = 0.1; // Slow attack for smoothness

    // Wiring: Source -> Comp -> Reverb -> Dest
    this.masterGain.connect(this.comp);
    this.comp.connect(this.convolver);
    this.convolver.connect(dest);
    
    // Also connect dry signal for definition
    this.dryGain = ctx.createGain();
    this.dryGain.gain.value = 0.2;
    this.comp.connect(this.dryGain);
    this.dryGain.connect(dest);
    
    // HARMONY STATE
    // i - VI - III - VII (The "Heroic/Tragic" Loop)
    // Gmin - EbMaj - BbMaj - FMaj
    this.progression = [
        { root: 0, type: 'minor', name: 'Gm' },
        { root: 8, type: 'major', name: 'Eb' }, // Up a minor 6th
        { root: 3, type: 'major', name: 'Bb' }, // Up a minor 3rd
        { root: 10, type: 'major', name: 'F' }  // Up a minor 7th
    ];
  }

  setupLushReverb() {
    // 5-second tail, very dense
    const len = this.ctx.sampleRate * 5.0;
    const buf = this.ctx.createBuffer(2, len, this.ctx.sampleRate);
    for (let c = 0; c < 2; c++) {
      const d = buf.getChannelData(c);
      for (let i = 0; i < len; i++) {
        // Linear fade is smoother than exponential for "pads"
        d[i] = (Math.random() * 2 - 1) * (1 - i / len);
      }
    }
    this.convolver.buffer = buf;
  }

  start() {
    this.tickCount = 0;
    this.masterGain.gain.linearRampToValueAtTime(0.7, this.ctx.currentTime + 4); // 4s Fade in
    this.loop();
  }

  stop() {
    if (this.timer) clearTimeout(this.timer);
    // 4s Fade out (Don't cut the emotion)
    this.masterGain.gain.cancelScheduledValues(this.ctx.currentTime);
    this.masterGain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 4);
  }

  loop() {
    const secondsPerBeat = 60 / this.tempo;
    const interval = (secondsPerBeat / 4) * 1000; // 16th notes

    this.timer = setTimeout(() => this.loop(), interval);

    const step = this.tickCount % 64; // Long phrases (4 bars of 4/4)

    // --- 1. THE BED (Orchestral Pads) ---
    // Change chord every bar (16 ticks)
    if (step % 16 === 0) {
        const chordIdx = Math.floor(step / 16);
        this.playChordPad(this.progression[chordIdx]);
        
        // Play a deep bass root on the change
        this.playBassRoot(this.progression[chordIdx].root);
    }

    // --- 2. THE SOLOIST (The Crying Violin) ---
    // Plays intuitively, not on grid.
    // Logic: Mostly long notes, occasional runs.
    
    // Try to play a note?
    if (step % 4 === 0) { // Check every beat
        const currentChord = this.progression[Math.floor(step / 16)];
        
        // Higher probability on beat 1, lower on others
        let prob = (step % 16 === 0) ? 0.9 : 0.4;
        
        // If we just played a note, lower chance (give it space to breathe)
        if (Math.random() < prob) {
            this.playSoloNote(currentChord);
        }
    }

    this.tickCount++;
  }

  // --- MUSIC THEORY ENGINE ---

  playChordPad(chord) {
    // Play a lush 3-note chord in the mid-range
    // Spread the voicing: Root, 5th, 3rd (Open voicing sounds "bigger")
    
    const rootPitch = this.rootFreq * Math.pow(2, chord.root / 12);
    
    // Voicing intervals relative to root
    let intervals;
    if (chord.type === 'minor') intervals = [0, 7, 15]; // Root, 5th, 10th (High min 3rd)
    else intervals = [0, 7, 16]; // Root, 5th, 10th (High maj 3rd)

    intervals.forEach((interval, i) => {
        // Stagger entries slightly so it doesn't sound like a block
        const delay = i * 0.1; 
        const freq = rootPitch * Math.pow(2, interval / 12);
        this.createPadVoice(freq, delay);
    });
  }

  playBassRoot(semitone) {
    const freq = (this.rootFreq / 2) * Math.pow(2, semitone / 12); // Octave down
    this.createPadVoice(freq, 0, 'bass');
  }

  playSoloNote(chord) {
    // Pick a "Beautiful" note relative to the chord
    // Target: 9th, 3rd, or 5th. Avoid Root (too boring).
    
    const rootPitch = this.rootFreq * Math.pow(2, chord.root / 12);
    
    // Intervals: 
    // 2 (9th) -> Very wistful
    // 3/4 (3rd) -> Emotional
    // 7 (5th) -> Soaring
    const options = (chord.type === 'minor') ? [2, 3, 7, 10] : [2, 4, 7, 11];
    const interval = options[Math.floor(Math.random() * options.length)];
    
    // Play high (Octave up)
    let freq = (rootPitch * 2) * Math.pow(2, interval / 12);

    // Duration: 1 to 3 beats
    const duration = 1.5 + Math.random() * 3.0;

    this.createSoloVoice(freq, duration);
  }

  // --- SOUND GENERATION (The "Beautiful" Part) ---

  createPadVoice(freq, delay, type = 'pad') {
    const t = this.ctx.currentTime + delay;
    const dur = 4.0; // Whole note + sustain

    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    const filter = this.ctx.createBiquadFilter();

    // SOUND DESIGN: TRIANGLE + DETUNE
    // Triangles are much softer/sadder than Saws
    osc.type = 'triangle';
    osc.frequency.value = freq;
    
    // Slight detune for "ensemble" feel
    osc.detune.value = (Math.random() * 10) - 5; 

    // Filter swells to simulate bowing intensity
    filter.type = 'lowpass';
    filter.frequency.value = 200; // Start dark
    filter.frequency.linearRampToValueAtTime(type === 'bass' ? 400 : 800, t + 2.0); // Swell
    filter.frequency.linearRampToValueAtTime(200, t + 4.0); // Fade

    // Envelope: Very slow attack (The "Pad" sound)
    gain.gain.setValueAtTime(0, t);
    gain.gain.linearRampToValueAtTime(type === 'bass' ? 0.3 : 0.1, t + 1.5); // 1.5s Attack
    gain.gain.linearRampToValueAtTime(0, t + dur); // Slow release

    osc.connect(filter);
    filter.connect(gain);
    gain.connect(this.masterGain);

    osc.start(t);
    osc.stop(t + dur + 1);
  }

  createSoloVoice(targetFreq, duration) {
    const t = this.ctx.currentTime;
    
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    const vibrato = this.ctx.createOscillator();
    const vibratoGain = this.ctx.createGain();

    // SOUND DESIGN: SOLO VIOLIN
    // Sawtooth filtered heavily creates a "reed/string" tone
    osc.type = 'sawtooth';
    
    // PORTAMENTO (The "Cry")
    // If we have a previous note, slide from it. If not, slide from slightly below.
    let startFreq = this.lastMelodyFreq || (targetFreq * 0.9); 
    osc.frequency.setValueAtTime(startFreq, t);
    // Emotional Slide: Takes 0.3s to reach pitch (Legato)
    osc.frequency.exponentialRampToValueAtTime(targetFreq, t + 0.3);
    
    this.lastMelodyFreq = targetFreq; // Remember for next time

    // VIBRATO (The "Human" Shiver)
    vibrato.frequency.value = 5.0; // 5Hz
    vibratoGain.gain.value = 0; // Start with no vibrato
    // Delay vibrato: Musicians usually play the note straight, then add vibrato
    vibratoGain.gain.setTargetAtTime(10, t + 0.5, 0.5); 
    
    vibrato.connect(vibratoGain);
    vibratoGain.connect(osc.frequency);
    vibrato.start(t);

    // FILTER (Formant-ish)
    const filter = this.ctx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.Q.value = 3; // Resonance emphasizes the pitch center
    filter.frequency.value = targetFreq * 2; // Harmonics

    // AMPLITUDE ENVELOPE
    gain.gain.setValueAtTime(0, t);
    gain.gain.linearRampToValueAtTime(0.2, t + 0.4); // Soft attack
    gain.gain.setValueAtTime(0.2, t + duration - 0.5); // Sustain
    gain.gain.linearRampToValueAtTime(0, t + duration); // Release

    osc.connect(filter);
    filter.connect(gain);
    gain.connect(this.masterGain);

    osc.start(t);
    osc.stop(t + duration + 0.2);
    vibrato.stop(t + duration + 0.2);
  }
}
// MODULE 21: Messenger of the Gods
class HermesModule {
  constructor(ctx, output) {
    this.ctx = ctx;
    this.output = output;
    this.isPlaying = false;
    this.intervalId = null;
    
    // -- Audio Bus (Softening & Effects) --
    this.mainBus = this.ctx.createGain();
    this.mainBus.gain.value = 0.6;
    
    this.delayNode = this.ctx.createDelay();
    this.delayNode.delayTime.value = 0.35; 
    this.delayFeedback = this.ctx.createGain();
    this.delayFeedback.gain.value = 0.4;
    this.delayFilter = this.ctx.createBiquadFilter();
    this.delayFilter.type = "lowpass";
    this.delayFilter.frequency.value = 2000; 
    
    this.mainBus.connect(this.delayNode);
    this.delayNode.connect(this.delayFilter);
    this.delayFilter.connect(this.delayFeedback);
    this.delayFeedback.connect(this.delayNode);
    
    this.mainBus.connect(this.output);
    this.delayFilter.connect(this.output);

    // -- MUSIC THEORY ENGINE --
    
    // 1. The 12 Chromatic Notes
    this.chromaticScale = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    
    // 2. Base Interval Patterns (Semintones)
    this.patterns = {
        diatonic: [2, 2, 1, 2, 2, 2, 1], // Major Scale Pattern (W W H W W W H)
        pentatonic: [2, 2, 3, 2, 3]      // Major Pentatonic Pattern
    };

    // 3. Mode Names for Display
    this.modeNames = {
        diatonic: ["Ionian (Major)", "Dorian", "Phrygian", "Lydian", "Mixolydian", "Aeolian (Minor)", "Locrian"],
        pentatonic: ["Major Pentatonic", "Suspended Pentatonic", "Man Gong (Blues Minor)", "Ritsusen", "Minor Pentatonic"]
    };

    // 4. Runtime State
    this.currentScaleNotes = []; // Will hold frequencies [261.6, 293.6, ...]
    this.currentModeName = "";
    this.currentTempo = 60;
    this.beatCount = 0;
    
    // Momentum
    this.melodyMomentum = 0;
    this.harmonyMomentum = 0;
    this.bassMomentum = 0;

    // Initial Setup (Start in C Major)
    this.generateScale('C', 0, 'diatonic');
  }

  // --- THEORY FUNCTIONS ---

  // Calculates the frequency of any note name (e.g., "F#") in the 4th octave
  getFreq(noteName) {
    const semitonesFromA4 = this.getSemitoneDistance(noteName);
    // A4 is 440Hz. Formula: f = 440 * 2^(n/12)
    return 440 * Math.pow(2, semitonesFromA4 / 12);
  }

  getSemitoneDistance(noteName) {
    // Distance from A (Index 9 in chromaticScale)
    const targetIndex = this.chromaticScale.indexOf(noteName);
    const aIndex = 9; 
    // This is a simplified relative calc for the 4th octave
    return targetIndex - aIndex; 
  }

  // The Magic Function: Generates the full scale based on Key + Mode
  generateScale(rootKey, modeIndex, scaleType) {
    // 1. Get the base pattern
    let pattern = [...this.patterns[scaleType]];

    // 2. Find the root note index in the chromatic scale
    let rootIndex = this.chromaticScale.indexOf(rootKey);

    // 3. "Rotate" the pattern based on the mode
    // If we are in C Major (Ionian), pattern is [2,2,1...]. 
    // If we want D Dorian (start on ii), we rotate pattern to start from the 2nd interval.
    // However, your request is "Key of C, start on E". 
    // That means we keep the C Major notes, but treat E as the "1".
    
    // Let's generate the PARENT scale notes first (e.g., C Major: C D E F G A B)
    let parentNotes = [];
    let currentIndex = rootIndex;
    
    for (let i = 0; i < pattern.length; i++) {
        parentNotes.push(this.chromaticScale[currentIndex % 12]);
        currentIndex += pattern[i];
    }

    // 4. Now perform the Modal Shift
    // If modeIndex is 2 (iii), we slice the array to start at index 2 and wrap around.
    // Parent: [C, D, E, F, G, A, B]
    // Mode 2: [E, F, G, A, B, C, D]
    
    let modeNotes = [];
    // Handle array rotation
    for (let i = 0; i < parentNotes.length; i++) {
        let index = (i + modeIndex) % parentNotes.length;
        modeNotes.push(parentNotes[index]);
    }

    // 5. Convert Note Names to Frequencies (Base Octave 4)
    // We also handle the "octave wrapping" (if the scale goes from B to C, C must be higher)
    this.currentScaleNotes = [];
    let previousFreq = 0;
    
    modeNotes.forEach((note) => {
        let freq = this.getFreq(note);
        // If this note is lower than the previous one (e.g. B -> C), bump it up an octave
        while (freq < previousFreq) {
            freq *= 2;
        }
        this.currentScaleNotes.push(freq);
        previousFreq = freq;
    });

    // 6. Set the Name
    this.currentModeName = `${modeNotes[0]} ${this.modeNames[scaleType][modeIndex]}`;
    console.log(`AutoLyre: Mode switched to ${this.currentModeName}`);
  }

  changeKey() {
    // 1. Pick a random Root Key (1 of 12)
    const newRoot = this.chromaticScale[Math.floor(Math.random() * 12)];
    
    // 2. Decide: Diatonic or Pentatonic? (70% Diatonic)
    const type = Math.random() > 0.3 ? 'diatonic' : 'pentatonic';
    
    // 3. Pick a random Mode
    // Diatonic has 7 modes, Pentatonic has 5
    const maxModes = type === 'diatonic' ? 7 : 5;
    const newMode = Math.floor(Math.random() * maxModes);

    this.generateScale(newRoot, newMode, type);
    
    // Randomize Tempo slightly
    this.currentTempo = [60, 70, 80, 90][Math.floor(Math.random() * 4)];
  }

  // --- SOUND GENERATION (Same Soft Synth Engine) ---

  playTone(freq, type, duration) {
    const t = this.ctx.currentTime;
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    const filter = this.ctx.createBiquadFilter();

    osc.frequency.value = freq;
    osc.connect(filter);
    filter.connect(gain);
    gain.connect(this.mainBus);

    switch(type) {
        case 'melody': // Pluck
            osc.type = 'triangle';
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(freq * 4, t);
            filter.frequency.exponentialRampToValueAtTime(freq, t + 0.3);
            gain.gain.setValueAtTime(0, t);
            gain.gain.linearRampToValueAtTime(0.3, t + 0.01);
            gain.gain.exponentialRampToValueAtTime(0.001, t + duration); 
            break;
        case 'harmony': // Pad
            osc.type = 'sine';
            gain.gain.setValueAtTime(0, t);
            gain.gain.linearRampToValueAtTime(0.15, t + 0.5); 
            gain.gain.linearRampToValueAtTime(0, t + duration + 0.5); 
            break;
        case 'bass': // Sub
            osc.type = 'triangle';
            filter.type = 'lowpass';
            filter.frequency.value = 200; 
            gain.gain.setValueAtTime(0, t);
            gain.gain.linearRampToValueAtTime(0.4, t + 0.1);
            gain.gain.linearRampToValueAtTime(0, t + duration);
            break;
    }

    osc.start(t);
    osc.stop(t + duration + 1);
  }

  tick() {
    if (!this.isPlaying) return;

    // Get array length for the current scale (7 for Diatonic, 5 for Pentatonic)
    const len = this.currentScaleNotes.length;

    // 1. Bass (Roots)
    if (this.beatCount % 2 === 0) {
        if (Math.random() > 0.4 - (this.bassMomentum * 0.05)) {
            // Pick a stable note (Root, 3rd, or 5th usually)
            const indices = [0, 0, 0, 2, 4]; // Weighted towards root
            const noteIdx = indices[Math.floor(Math.random() * indices.length)] % len;
            const freq = this.currentScaleNotes[noteIdx] / 4; // Drop 2 octaves
            this.playTone(freq, 'bass', 2.0);
            this.bassMomentum--;
        } else { this.bassMomentum++; }
    }

    // 2. Harmony
    if (this.beatCount % 4 === 0) {
        if (Math.random() > 0.3) {
            const noteIdx = Math.floor(Math.random() * len);
            const freq = this.currentScaleNotes[noteIdx] / 2; // Drop 1 octave
            this.playTone(freq, 'harmony', 3.0);
        }
    }

    // 3. Melody
    if (Math.random() < (0.5 + (this.melodyMomentum * 0.05))) {
        // Pick any note in the current mode
        const noteIdx = Math.floor(Math.random() * len);
        let freq = this.currentScaleNotes[noteIdx];
        
        // Randomly go up an octave for flair
        if (Math.random() > 0.7) freq *= 2; 

        const dur = Math.random() > 0.8 ? 0.5 : 0.25; 
        this.playTone(freq, 'melody', dur);
        this.melodyMomentum--;
    } else { this.melodyMomentum++; }

    // Loop & Key Change Logic
    this.beatCount++;
    if (this.beatCount > 32) {
        this.beatCount = 0;
        if (Math.random() > 0.6) this.changeKey();
    }
  }

  start() {
    this.isPlaying = true;
    this.beatCount = 0;
    // Recalculate timing in case tempo changed
    const run = () => {
        if (!this.isPlaying) return;
        this.tick();
        const ms = (60 / this.currentTempo) * 0.5 * 1000;
        setTimeout(run, ms);
    };
    run();
  }

  stop() {
    this.isPlaying = false;
    this.mainBus.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.5);
    setTimeout(() => {
        this.mainBus.disconnect();
        this.delayNode.disconnect();
    }, 600);
  }
}
// MODULE 22: Divine Intervention
class DivineModule {
    constructor(ctx, output) {
        this.ctx = ctx;
        this.masterOutput = output;
        this.isPlaying = false;
        this.intervalId = null;

        // --- DQ STYLE SETTINGS ---
        this.tempo = 145; // March tempo
        this.tickCount = 0;
        this.globalBar = 0;

        // Musical State
        this.keyRoot = 9; // A Minor (Classic RPG key)
        this.scaleType = 'harmonic'; // Harmonic minor = Classical feel
        this.currentChord = null;
        this.nextChordTime = 0;

        // "The Director" - Controls the flow so it doesn't get boring
        this.sectionState = 'INTRO'; // INTRO, MARCH, HEROIC, TENSION, CLIMAX
        this.sectionBar = 0;
        
        // Phrase Buffers (We generate 4 bars at a time, not 1)
        this.melodyBuffer = [];
        this.bassBuffer = [];
        this.drumBuffer = [];
        this.compBuffer = [];

        // Theory Maps
        this.scales = {
            harmonic: [0, 2, 3, 5, 7, 8, 11], // The "Sugiyama" Scale
            natural: [0, 2, 3, 5, 7, 8, 10],
            major: [0, 2, 4, 5, 7, 9, 11] // For the "Hopeful" B section
        };

        this.setupAudioGraph();
        this.updateScale(this.keyRoot, 'harmonic');
    }

    setupAudioGraph() {
        this.mixerGain = this.ctx.createGain();
        this.mixerGain.gain.value = 0.45;

        // Classical EQ (Boost High-Mids for Brass, Cuts Mud)
        const lowCut = this.ctx.createBiquadFilter();
        lowCut.type = 'highpass';
        lowCut.frequency.value = 40;

        const midBoost = this.ctx.createBiquadFilter();
        midBoost.type = 'peaking';
        midBoost.frequency.value = 1500; // Trumpet shine
        midBoost.Q.value = 1;
        midBoost.gain.value = 3;

        const compressor = this.ctx.createDynamicsCompressor();
        compressor.threshold.value = -16;
        compressor.ratio.value = 4;
        compressor.attack.value = 0.01;

        // Orchestral Hall Reverb
        this.reverb = this.ctx.createConvolver();
        this.reverbGain = this.ctx.createGain();
        this.reverbGain.gain.value = 0.35; // Lush reverb
        this.generateImpulse(2.0);

        this.mixerGain.connect(lowCut);
        lowCut.connect(midBoost);
        midBoost.connect(compressor);
        compressor.connect(this.masterOutput);

        // Reverb Send
        midBoost.connect(this.reverb);
        this.reverb.connect(this.reverbGain);
        this.reverbGain.connect(compressor);
    }

    generateImpulse(duration) {
        const len = this.ctx.sampleRate * duration;
        const buff = this.ctx.createBuffer(2, len, this.ctx.sampleRate);
        for (let i = 0; i < 2; i++) {
            const ch = buff.getChannelData(i);
            for (let j = 0; j < len; j++) {
                ch[j] = (Math.random() * 2 - 1) * Math.pow(1 - j / len, 2);
            }
        }
        this.reverb.buffer = buff;
    }

    updateScale(root, type) {
        this.keyRoot = root;
        this.scaleType = type;
        const rootFreq = 440 * Math.pow(2, (root - 9) / 12);
        const intervals = this.scales[type];
        
        this.scaleMap = [];
        // Map 4 octaves (Bass to High Strings)
        for (let oct = 0; oct < 4; oct++) {
            intervals.forEach(interval => {
                this.scaleMap.push(rootFreq * Math.pow(2, oct - 2 + interval / 12));
            });
        }
    }

    // --- ORCHESTRATION ---

    createVoice(freq, type, duration, vol) {
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();

        // Voice Definitions (NES/SNES hybrid style)
        switch (type) {
            case 'brass': // The Heroic Lead
                osc.type = 'sawtooth';
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(freq * 2, t);
                filter.frequency.linearRampToValueAtTime(freq * 1.5, t + duration); // Brass "blare" decay
                // Envelope: Sharp attack, strong sustain
                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(vol, t + 0.05);
                gain.gain.linearRampToValueAtTime(vol * 0.8, t + 0.1);
                gain.gain.linearRampToValueAtTime(0, t + duration);
                break;

            case 'strings': // High Arpeggios / Counterpoint
                osc.type = 'square'; // Pulse wave often simulated strings on NES
                filter.type = 'bandpass';
                filter.frequency.value = freq * 3;
                filter.Q.value = 1;
                // Soft attack
                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(vol * 0.7, t + 0.1);
                gain.gain.linearRampToValueAtTime(0, t + duration * 1.1);
                break;

            case 'bass': // The Cello/Tuba
                osc.type = 'triangle';
                filter.type = 'lowpass';
                filter.frequency.value = freq * 3;
                // Punchy
                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(vol, t + 0.02);
                gain.gain.exponentialRampToValueAtTime(0.01, t + duration);
                break;
        }

        osc.frequency.value = freq;
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.mixerGain);
        osc.start(t);
        osc.stop(t + duration + 0.2);
        osc.onended = () => {
        osc.disconnect();
        filter.disconnect();
        gain.disconnect();
    };
    }

    createPercussion(type) {
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const noise = this.ctx.createBufferSource(); // For snare

        if (type === 'kick') { // Timpani/Orchestral Bass Drum
            osc.frequency.setValueAtTime(120, t);
            osc.frequency.exponentialRampToValueAtTime(30, t + 0.3);
            gain.gain.setValueAtTime(0.8, t);
            gain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
            osc.connect(gain);
            osc.start(t);
            osc.stop(t + 0.3);
            osc.onended = () => {
        osc.disconnect();
        gain.disconnect();
    };
        } else if (type === 'snare') { // Marching Snare
            const len = this.ctx.sampleRate * 0.15;
            const buff = this.ctx.createBuffer(1, len, this.ctx.sampleRate);
            const d = buff.getChannelData(0);
            for(let i=0; i<len; i++) d[i] = (Math.random()*2-1);
            noise.buffer = buff;
            
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'highpass';
            filter.frequency.value = 800;
            
            gain.gain.setValueAtTime(0.4, t);
            gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
            
            noise.connect(filter);
            filter.connect(gain);
            noise.start(t);
            noise.onended = () => {
            noise.disconnect();
            if (typeof filter !== 'undefined') filter.disconnect();
            gain.disconnect();
        };
        } else if (type === 'crash') { // Orchestral Crash
            const len = this.ctx.sampleRate * 1.0;
            const buff = this.ctx.createBuffer(1, len, this.ctx.sampleRate);
            const d = buff.getChannelData(0);
            for(let i=0; i<len; i++) d[i] = (Math.random()*2-1);
            noise.buffer = buff;
            
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(8000, t);
            filter.frequency.linearRampToValueAtTime(200, t + 1); // Darken
            
            gain.gain.setValueAtTime(0.3, t);
            gain.gain.exponentialRampToValueAtTime(0.01, t + 1);
            
            noise.connect(filter);
            filter.connect(gain);
            noise.start(t);
            noise.onended = () => {
            noise.disconnect();
            filter.disconnect();
            gain.disconnect();
        };
        }
        gain.connect(this.mixerGain);
    }

    // --- COMPOSITION BRAIN ---

    getChordTone(degree, offsetIndex = 0) {
        // degree 1-7. Returns frequency.
        // Simple logic: return index from scaleMap
        // We look in the middle of the array (approx index 10-17)
        const rootIdx = (degree - 1) % 7;
        const scaleIdx = 14 + rootIdx + offsetIndex; // 14 puts us in the tenor/alto range
        return this.scaleMap[scaleIdx];
    }

    generateSection() {
        // Clear buffers
        this.melodyBuffer = new Array(64).fill(null); // 4 bars * 16 ticks
        this.bassBuffer = new Array(64).fill(null);
        this.drumBuffer = new Array(64).fill(null);
        this.compBuffer = new Array(64).fill(null);

        // 1. Determine Chord Progression based on Section State
        let progression = [];
        
        if (this.sectionState === 'INTRO') {
            // Dramatic stabs: i - i - VI - V
            progression = [1, 1, 6, 5]; 
            this.tempo = 140;
        } else if (this.sectionState === 'MARCH') {
            // Walking: i - iv - V - i
            progression = [1, 4, 5, 1];
        } else if (this.sectionState === 'HEROIC') {
            // Modulation to relative Major or VI emphasis
            // VI - VII - i - i
            progression = [6, 7, 1, 1];
        } else {
            // CLIMAX / TENSION
            // Circle of 5ths sequence: iv - VII - III - VI
            progression = [4, 7, 3, 6];
        }

        // 2. FILL BUFFERS
        for (let bar = 0; bar < 4; bar++) {
            const chordDegree = progression[bar];
            const barOffset = bar * 16;

            // --- BASS (The Foundation) ---
            // Rhythm: DQ uses a lot of "1... 2... 3-and-4-and" or straight marching
            const bassRhythm = (this.sectionState === 'INTRO') 
                ? [1,0,0,0, 1,0,0,0, 1,0,0,0, 1,0,1,0] // Heavy quarters + triplet feel end
                : [1,0,1,0, 1,0,1,0, 1,1,0,1, 1,0,1,0]; // The Gallop
            
            for (let i = 0; i < 16; i++) {
                if (bassRhythm[i]) {
                    // Alternating Root and Fifth (Classic March)
                    const isRoot = (i < 8) || (i % 4 === 0);
                    const noteIdx = (chordDegree - 1) + (isRoot ? 0 : 4); // +4 index is approx fifth
                    // Force low octave (indices 0-7)
                    const bassFreq = this.scaleMap[(noteIdx % 7)]; 
                    this.bassBuffer[barOffset + i] = { freq: bassFreq, dur: 0.2, vol: 0.6 };
                }
            }

            // --- MELODY (The Hero) ---
            // We use a "Motif" approach. 
            // Create a motif for bar 0, vary it for bar 1, vary for 2, resolve for 3.
            
            if (bar === 0 || bar === 2) {
                // Generate a motif (Rhythm + Shape)
                this.currentMotif = this.generateMotif(chordDegree);
            } else {
                // Mutate the motif (Sequence)
                this.currentMotif = this.mutateMotif(this.currentMotif, chordDegree);
            }
            
            // Apply Motif to buffer
            this.currentMotif.forEach(note => {
                this.melodyBuffer[barOffset + note.tick] = { 
                    freq: note.freq, 
                    dur: note.dur, 
                    vol: (bar === 3 && note.tick > 12) ? 0 : 0.45 // Cutoff at end of phrase?
                };
            });

            // --- DRUMS (The March) ---
            if (this.sectionState !== 'INTRO') {
                // Kick on 1, 3. Snare on 2, 4. Classic.
                this.drumBuffer[barOffset + 0] = 'kick';
                this.drumBuffer[barOffset + 4] = 'snare';
                this.drumBuffer[barOffset + 8] = 'kick';
                this.drumBuffer[barOffset + 12] = 'snare';
                // Fills at end of every even bar
                if (bar % 2 !== 0) {
                     this.drumBuffer[barOffset + 14] = 'snare';
                     this.drumBuffer[barOffset + 15] = 'snare';
                }
            } else {
                // Intro is timpani rolls
                if (barOffset % 4 === 0) this.drumBuffer[barOffset] = 'kick';
                if (bar === 3 && barOffset % 2 === 0) this.drumBuffer[barOffset] = 'snare'; // Roll
            }

            // --- COMP/STRINGS (The Texture) ---
            // On off-beats to drive momentum
            if (this.sectionState === 'HEROIC' || this.sectionState === 'CLIMAX') {
                const cRoot = this.getChordTone(chordDegree, 7); // Mid range
                const cThird = this.getChordTone(chordDegree + 2, 7);
                for(let i=2; i<16; i+=4) { // Hits on beat 1.5, 2.5, etc
                    this.compBuffer[barOffset + i] = { 
                        freq: cRoot, freq2: cThird, dur: 0.1 
                    };
                }
            }
        }
    }

    generateMotif(chordDegree) {
        // Returns array of { tick: 0-15, freq: float, dur: float }
        const motif = [];
        const scaleBase = (chordDegree - 1) + 14; // Start in mid range
        
        // 3 Common RPG Rhythmic structures
        const rhythms = [
            [0, 2, 4, 8, 10, 12], // Da-da-DAAA... da-da-DAAA
            [0, 4, 6, 8, 12],     // Bom... Bom-ba-Bom... Bom
            [0, 1, 2, 4, 8, 12]   // Trill run... Bam... Bam
        ];
        const rhythm = rhythms[Math.floor(Math.random() * rhythms.length)];

        rhythm.forEach(tick => {
            // Arpeggiate or Step?
            // Heavy bias towards chord tones (1, 3, 5) for "Heroic" feel
            const interval = [0, 2, 4, 7][Math.floor(Math.random()*4)]; 
            const freq = this.scaleMap[scaleBase + interval];
            if(freq) motif.push({ tick, freq, dur: 0.2 });
        });
        return motif;
    }

    mutateMotif(motif, newChordDegree) {
        // Transpose the rhythm to the new chord
        // This creates "Thematic consistency" instead of random noodling
        const intervalDiff = (newChordDegree - 1) * 2; // Rough transposition
        
        return motif.map(note => {
            // Find current index in scaleMap and shift it
            // Simplified: Just recalc frequency based on new root + same offsets
            // (In a real engine we'd store scale degrees, but this is a hacky fix)
            return {
                tick: note.tick,
                freq: note.freq * (note.tick % 2 === 0 ? 1 : 1.1), // Slight variation
                dur: note.dur
            };
        });
        // Actually, let's just generate a fresh one that is similar
        return this.generateMotif(newChordDegree);
    }

    processSixteenth() {
        // 1. Check for Section Change (Every 4 bars / 64 ticks)
        if (this.tickCount % 64 === 0) {
            // State Machine for Drama
            if (this.sectionState === 'INTRO') this.sectionState = 'MARCH';
            else if (this.sectionState === 'MARCH') this.sectionState = (Math.random() > 0.5) ? 'HEROIC' : 'TENSION';
            else if (this.sectionState === 'HEROIC') this.sectionState = 'CLIMAX';
            else if (this.sectionState === 'CLIMAX') this.sectionState = 'MARCH'; // Loop back
            else if (this.sectionState === 'TENSION') this.sectionState = 'MARCH';

            // Crash cymbal on section change
            this.createPercussion('crash');
            
            // Generate the next 4 bars based on the new state
            this.generateSection(); 
        }

        const idx = this.tickCount % 64;

        // 2. Play Buffered Sounds
        // Bass
        if (this.bassBuffer[idx]) {
            const b = this.bassBuffer[idx];
            this.createVoice(b.freq, 'bass', b.dur, b.vol);
        }
        // Melody
        if (this.melodyBuffer[idx]) {
            const m = this.melodyBuffer[idx];
            this.createVoice(m.freq, 'brass', m.dur, m.vol);
        }
        // Drums
        if (this.drumBuffer[idx]) {
            this.createPercussion(this.drumBuffer[idx]);
        }
        // Comp/Strings
        if (this.compBuffer[idx]) {
            const c = this.compBuffer[idx];
            this.createVoice(c.freq, 'strings', c.dur, 0.2);
            this.createVoice(c.freq2, 'strings', c.dur, 0.2);
        }

        this.tickCount++;
    }

    start() {
        if (this.isPlaying) return;
        this.isPlaying = true;
        this.tickCount = 0;
        this.sectionState = 'INTRO';
        this.generateSection();
        
        const secondsPerBeat = 60 / this.tempo;
        const sixteenthTime = (secondsPerBeat / 4) * 1000;

        this.intervalId = setInterval(() => {
            if (this.isPlaying) this.processSixteenth();
        }, sixteenthTime);
    }

    stop() {
        this.isPlaying = false;
        clearInterval(this.intervalId);
        // Quick fade out
        const t = this.ctx.currentTime;
        this.mixerGain.gain.setValueAtTime(this.mixerGain.gain.value, t);
        this.mixerGain.gain.linearRampToValueAtTime(0, t + 0.2);
        setTimeout(() => { this.mixerGain.disconnect(); }, 250);
    }
}
// MODULE 23: A Foreign Land
class ForeignModule {
    constructor(ctx, output) {
        this.ctx = ctx;
        this.masterOutput = output;
        this.activeNotes = [];
        this.isPlaying = false;
        this.intervalId = null;

        // --- MUSICAL STATE ---
        this.keys = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        this.keyFrequencies = {
            'C': 306.45, 'C#': 316.04, 'D': 313.10, 'D#': 321.86,
            'E': 316.65, 'F': 341.70, 'F#': 472.30, 'G': 447.11,
            'G#': 453.49, 'A': 404.01, 'A#': 327.10, 'B': 316.04
        };

        this.currentKey = 'C';
        this.currentMode = 'Ionian';
        this.currentKeyType = 'diatonic';
        this.currentTempo = 75.46;
        this.currentTimeSignature = [4, 4];
        this.currentBarCount = 1;
        this.beatsInCurrentBar = 0;
        this.currentMetronomeNote = 1;
        this.techniqueDisplay = ['Moon', 'Earth', 'Jupiter', 'Mercury', 'Venus', 'Milky Way', 'Sidereal-All'];
        this.techniqueText = `  Suncat`;

        // Scale Data
        this.chromatic = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        this.majorScale = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
        this.modeOffsets = { Ionian: 0, Dorian: 1, Phrygian: 2, Lydian: 3, Mixolydian: 4, Aeolian: 5, Locrian: 6 };
        this.exoticModes = {
            'Hirajoshi': [0, 2, 3, 7, 8], 'Iwato': [0, 1, 5, 6, 10], 'Chinese': [0, 2, 4, 7, 9],
            'Raga Bhairav': [0, 1, 4, 5, 7, 8, 11], 'Raga Yaman': [0, 2, 4, 6, 7, 9, 11],
            'Hijaz': [0, 1, 4, 5, 7, 8, 10], 'Turkish Makam': [0, 1, 3, 5, 7, 8, 10],
            'Hungarian': [0, 2, 3, 6, 7, 8, 11], 'Persian': [0, 1, 4, 5, 6, 8, 11], 'Gypsy': [0, 2, 3, 6, 7, 8, 11]
        };
        this.pentatonicKeys = {
            'C': ['C', 'D', 'E', 'G', 'A'], 'G': ['G', 'A', 'B', 'D', 'E'], 'D': ['D', 'E', 'F#', 'A', 'B'],
            'A': ['A', 'B', 'C#', 'E', 'F#'], 'E': ['E', 'F#', 'G#', 'B', 'C#']
        };

        // Initialize Scale
        this.currentScaleNotes = this.getScaleNotes(this.currentKey, this.currentMode);
        this.currentScaleIntervals = this.getScaleIntervals(this.currentScaleNotes);

        // --- BACH ENGINE STATE ---
        this.melodicMotifs = [];
        this.canonDelay = 4;
        this.lastMelodyInterval = 0;
        this.inversionActive = false;
        this.inversionPivot = 4;
        this.choraleMode = false;
        this.currentChordProgression = [];
        this.chordProgressionIndex = 0;
        this.chordProgressions = {
            diatonic: [[1, 4, 5, 1], [1, 6, 4, 5], [1, 5, 6, 4], [1, 2, 5, 1]],
            pentatonic: [[1, 3, 5, 1], [1, 5, 3, 1]],
            exotic: [[1, 2, 1], [1, 3, 1]]
        };

        // Note Tracking
        this.activeMelodyNotes = [];
        this.activeHarmonyNotes = [];
        this.activeBassNotes = [];
        this.activeMetronomeNotes = [];
        this.lastMelodyNote = null;
        this.melodyMomentum = 0;
        this.harmonyMomentum = 0;
        this.bassMomentum = 0;
        this.currentBassOscillator = null;
        this.currentBassGain = null;
        this.eighthNoteCount = 0;

        // Init Logic
        this.initializeChordProgression();
        this.setupAudioGraph();
    }

    setupAudioGraph() {
        // Output mixer gain
        this.mixerGain = this.ctx.createGain();
        this.mixerGain.gain.value = 0.4; // Reduced slightly to prevent clipping

        // Warmth Enhancer (gentle saturation)
        this.harmonicEnhancer = this.ctx.createWaveShaper();
        const curve = new Float32Array(4096);
        for (let i = 0; i < 4096; i++) {
            const x = (i - 2048) / 2048;
            curve[i] = Math.tanh(x * 0.5) * 0.9; // Softer curve
        }
        this.harmonicEnhancer.curve = curve;

        // EQ to cut mud and harsh highs
        const lowCut = this.ctx.createBiquadFilter();
        lowCut.type = 'highpass';
        lowCut.frequency.value = 60;

        const highShelf = this.ctx.createBiquadFilter();
        highShelf.type = 'highshelf';
        highShelf.frequency.value = 5000;
        highShelf.gain.value = -3; // Tame the highs

        // Reverb
        this.reverb = this.ctx.createConvolver();
        this.reverbGain = this.ctx.createGain();
        this.reverbGain.gain.value = 0.35;
        this.generateReverbImpulse(2.5);

        // Compression
        this.compressor = this.ctx.createDynamicsCompressor();
        this.compressor.threshold.setValueAtTime(-20, this.ctx.currentTime);
        this.compressor.ratio.setValueAtTime(4, this.ctx.currentTime);
        this.compressor.attack.setValueAtTime(0.01, this.ctx.currentTime);
        this.compressor.release.setValueAtTime(0.2, this.ctx.currentTime);

        // Chain
        this.mixerGain.connect(this.harmonicEnhancer);
        this.harmonicEnhancer.connect(lowCut);
        lowCut.connect(highShelf);
        highShelf.connect(this.compressor);
        
        // Reverb Send
        highShelf.connect(this.reverb);
        this.reverb.connect(this.reverbGain);
        this.reverbGain.connect(this.compressor);

        this.compressor.connect(this.masterOutput);
    }

    generateReverbImpulse(duration) {
        const rate = this.ctx.sampleRate;
        const length = rate * duration;
        const impulse = this.ctx.createBuffer(2, length, rate);
        for (let i = 0; i < 2; i++) {
            const ch = impulse.getChannelData(i);
            for (let j = 0; j < length; j++) {
                ch[j] = (Math.random() * 2 - 1) * Math.pow(1 - j / length, 2) * 0.5;
            }
        }
        this.reverb.buffer = impulse;
    }

    // --- OSCILLATOR CREATION (Improved Sound) ---
    createLyreOscillator(frequency, voiceType) {
        if (!isFinite(frequency) || frequency <= 0) return null;

        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();

        filter.type = 'lowpass';
        filter.Q.value = 1;

        switch (voiceType) {
            case 'metronome':
                osc.type = 'sine'; // Pure sine for click
                filter.frequency.value = frequency * 4;
                break;

            case 'bass':
                osc.type = 'triangle'; // Triangle for clearer bass definition
                filter.frequency.value = frequency * 3; // Allow some harmonics
                filter.Q.value = 0.5;
                break;

            case 'harmony':
                osc.type = 'sine'; // Sine for subtle backing
                filter.frequency.value = frequency * 2.5;
                break;

            case 'melody':
                osc.type = 'triangle'; // Triangle for flute-like melody
                filter.frequency.value = frequency * 2; // Warm cutoff
                break;
        }

        osc.frequency.value = frequency;
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.mixerGain);

        return { oscillator: osc, gainNode: gain, filterNode: filter };
    }

    // --- LOGIC HELPERS ---

    noteToIndex(note) { return this.chromatic.indexOf(note); }

    rotateScale(scale, offset) {
        return [...scale.slice(offset), ...scale.slice(0, offset)];
    }

    getScaleNotes(keyRoot, modeName) {
        if (this.exoticModes[modeName]) {
            const rootIndex = this.noteToIndex(keyRoot);
            return this.exoticModes[modeName].map(i => this.chromatic[(rootIndex + i) % 12]);
        }
        const transposed = this.majorScale.map(n => this.chromatic[(this.noteToIndex(n) + this.noteToIndex(keyRoot)) % 12]);
        return this.rotateScale(transposed, this.modeOffsets[modeName]);
    }

    getScaleIntervals(scaleNotes) {
        const tonicIndex = this.noteToIndex(scaleNotes[0]);
        return scaleNotes.map(n => (this.noteToIndex(n) - tonicIndex + 12) % 12);
    }

    initializeChordProgression() {
        const prog = this.chordProgressions[this.currentKeyType] || this.chordProgressions.diatonic;
        this.currentChordProgression = prog[Math.floor(Math.random() * prog.length)];
        this.chordProgressionIndex = 0;
    }

    rollD6() { return Math.floor(Math.random() * 6) + 1; }
    rollD4() { return Math.floor(Math.random() * 4) + 1; }

    getDurationBeats(roll) {
        switch(roll) {
            case 1: return 4;
            case 2: return 2;
            case 3: return 1;
            case 4: return 0.5;
            case 5: return 0.25;
            case 6: return 0.125;
            default: return 1;
        }
    }

    getMusicalProbability(voiceType) {
        let m = 0;
        if (voiceType === 'melody') m = this.melodyMomentum;
        else if (voiceType === 'harmony') m = this.harmonyMomentum;
        else if (voiceType === 'bass') m = this.bassMomentum;
        return 0.5 + (m * 0.005);
    }

    // --- BACH ENGINE LOGIC ---

    addMelodyMotif(scaleDegree, timeStamp) {
        this.melodicMotifs.push({ note: scaleDegree, timestamp: timeStamp, barNumber: this.currentBarCount });
        const beatDur = (60 / this.currentTempo) * 1000;
        const keepTime = Date.now() - (8 * beatDur);
        this.melodicMotifs = this.melodicMotifs.filter(m => m.timestamp > keepTime);
    }

    getCanonImitation() {
        if (this.melodicMotifs.length === 0) return null;
        const beatDur = (60 / this.currentTempo) * 1000;
        const target = Date.now() - (this.canonDelay * beatDur);
        
        let closest = null, minDist = Infinity;
        for (let m of this.melodicMotifs) {
            const dist = Math.abs(m.timestamp - target);
            if (dist < minDist) { minDist = dist; closest = m; }
        }
        return closest ? closest.note : null;
    }

    getInvertedNote(originalNote, interval) {
        if (!this.inversionActive || interval === 0) return null;
        const inv = this.inversionPivot - interval;
        if (inv >= 1 && inv <= this.currentScaleIntervals.length) return inv;
        return null;
    }

    getChoraleNote(voiceType) {
        if (!this.choraleMode || this.currentChordProgression.length === 0) return null;
        const root = this.currentChordProgression[this.chordProgressionIndex % this.currentChordProgression.length];
        const tones = [root, Math.min(root+2, 7), Math.min(root+4, 7)];

        if (voiceType === 'melody') return tones[2] || tones[1];
        if (voiceType === 'harmony') return tones[1] || tones[0];
        if (voiceType === 'bass') return tones[0];
        return tones[0];
    }

    advanceChordProgression() {
        this.chordProgressionIndex++;
        if (this.chordProgressionIndex >= this.currentChordProgression.length) {
            if (Math.random() < 0.3) this.initializeChordProgression();
            else this.chordProgressionIndex = 0;
        }
    }

    getConsonantHarmonyNotes(melodyNote) {
        switch(melodyNote) {
            case 1: return [1,3,4,5,6];
            case 2: return [2,4,5,6,7];
            case 3: return [1,3,5,6,7];
            case 4: return [1,2,4,6,7];
            case 5: return [1,2,3,5,7];
            case 6: return [1,2,3,4,6];
            case 7: return [2,3,4,5,7];
            default: return [1];
        }
    }

    checkActiveNoteConflicts(newNote, voiceType) {
        const now = Date.now();
        // Cleanup
        [this.activeMelodyNotes, this.activeHarmonyNotes, this.activeBassNotes].forEach(arr => {
            for(let i=arr.length-1; i>=0; i--) if(now > arr[i].endTime) arr.splice(i,1);
        });

        let others = [];
        if(voiceType !== 'melody') others = others.concat(this.activeMelodyNotes);
        if(voiceType !== 'harmony') others = others.concat(this.activeHarmonyNotes);
        if(voiceType !== 'bass') others = others.concat(this.activeBassNotes);

        for(let n of others) {
            if(!this.getConsonantHarmonyNotes(n.note).includes(newNote)) return true;
        }
        return false;
    }

    getValidNote(voiceType) {
        const max = this.currentScaleIntervals.length;
        for(let i=0; i<8; i++) {
            const n = Math.floor(Math.random() * max) + 1;
            if(!this.checkActiveNoteConflicts(n, voiceType)) return n;
        }
        return Math.floor(Math.random() * max) + 1;
    }

    // --- PLAYBACK ---

    playNote(scaleDegree, isHarmony, isBass, durationBeats) {
        const validDegree = Math.min(scaleDegree, this.currentScaleIntervals.length);
        const interval = this.currentScaleIntervals[validDegree - 1];
        const baseFreq = this.keyFrequencies[this.currentKey];
        let freq = baseFreq * Math.pow(2, interval / 12);

        if (!isFinite(freq)) return;

        if (isBass) freq /= 2;
        else if (!isHarmony && scaleDegree > 5) freq *= 2;

        const voiceType = isBass ? 'bass' : (isHarmony ? 'harmony' : 'melody');
        const now = this.ctx.currentTime;
        const actualDur = (durationBeats * 60) / this.currentTempo;

        // BASS HANDLING
        if (isBass) {
            if (this.currentBassOscillator) {
                try {
                    this.currentBassGain.gain.linearRampToValueAtTime(0, now + 0.1);
                    this.currentBassOscillator.stop(now + 0.15);
                } catch(e){}
            }

            const sound = this.createLyreOscillator(freq, 'bass');
            if(!sound) return;

            sound.gainNode.gain.setValueAtTime(0, now);
            sound.gainNode.gain.linearRampToValueAtTime(0.8, now + 0.1); // Softer attack
            sound.oscillator.start(now);

            this.currentBassOscillator = sound.oscillator;
            this.currentBassGain = sound.gainNode;
            
            this.activeBassNotes.push({ note: scaleDegree, endTime: Date.now() + 4000 });

            // Auto-off for bass
            setTimeout(() => {
                if (this.currentBassOscillator === sound.oscillator) {
                    try {
                        const t = this.ctx.currentTime;
                        sound.gainNode.gain.linearRampToValueAtTime(0, t + 0.5);
                        sound.oscillator.stop(t + 0.6);
                    } catch(e){}
                }
            }, actualDur * 1000);
            return;
        }

        // MELODY/HARMONY HANDLING
        const sound = this.createLyreOscillator(freq, voiceType);
        if(!sound) return;

        // Softer Envelope
        sound.gainNode.gain.setValueAtTime(0, now);
        sound.gainNode.gain.linearRampToValueAtTime(0.6, now + 0.05); // Attack
        sound.gainNode.gain.exponentialRampToValueAtTime(0.4, now + actualDur * 0.5); // Decay
        sound.gainNode.gain.linearRampToValueAtTime(0, now + actualDur); // Release

        // Filter movement for pluck
        sound.filterNode.frequency.setValueAtTime(freq * 1.5, now);
        sound.filterNode.frequency.exponentialRampToValueAtTime(freq, now + 0.2);

        sound.oscillator.start(now);
        sound.oscillator.stop(now + actualDur + 0.1);

        const info = { note: scaleDegree, endTime: Date.now() + actualDur*1000 };
        if(isHarmony) this.activeHarmonyNotes.push(info);
        else {
            this.activeMelodyNotes.push(info);
            this.lastMelodyNote = scaleDegree;
        }
    }

    playMetronome() {
        // Wooden click sound
        const valid = Math.min(this.currentMetronomeNote, this.currentScaleIntervals.length);
        const interval = this.currentScaleIntervals[valid-1];
        const freq = this.keyFrequencies[this.currentKey] * Math.pow(2, interval/12);
        
        const sound = this.createLyreOscillator(freq, 'metronome');
        if(!sound) return;

        const now = this.ctx.currentTime;
        sound.gainNode.gain.setValueAtTime(0, now);
        sound.gainNode.gain.linearRampToValueAtTime(0.4, now + 0.01);
        sound.gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        
        sound.oscillator.start(now);
        sound.oscillator.stop(now + 0.15);
    }

    // --- MAIN LOOP ---

    processEighthNote() {
        // Logic copied from source
        const barInCycle = ((this.currentBarCount - 1) % 12) + 1;
        this.choraleMode = (this.beatsInCurrentBar === 0 && Math.random() < 0.4);
        this.inversionActive = (barInCycle >= 5 && barInCycle <= 8);
        this.canonDelay = (barInCycle <= 4) ? 2 : 4;

        // MELODY
        if (Math.random() < this.getMusicalProbability('melody')) {
            let note = null;
            if (this.choraleMode) note = this.getChoraleNote('melody');
            if (!note) note = this.getValidNote('melody');

            if (note) {
                const dur = this.getDurationBeats(this.rollD6());
                this.playNote(note, false, false, dur);
                this.addMelodyMotif(note, Date.now());
                if (this.lastMelodyNote !== null) this.lastMelodyInterval = note - this.lastMelodyNote;
                this.lastMelodyNote = note;
                this.melodyMomentum = Math.max(-5, this.melodyMomentum - 1);
            } else this.melodyMomentum++;
        } else this.melodyMomentum++;

        // HARMONY
        if (Math.random() < this.getMusicalProbability('harmony')) {
            let note = null;
            if (this.choraleMode) note = this.getChoraleNote('harmony');
            else if (Math.random() < 0.6) note = this.getCanonImitation();
            else if (this.inversionActive && this.lastMelodyInterval !== 0) note = this.getInvertedNote(this.lastMelodyNote, this.lastMelodyInterval);
            
            if (!note) note = this.getValidNote('harmony');

            if (note) {
                const dur = this.getDurationBeats(this.rollD6());
                this.playNote(note, true, false, dur);
                this.harmonyMomentum--;
            } else this.harmonyMomentum++;
        } else this.harmonyMomentum++;
    }

    processQuarterNote() {
        if (Math.random() < this.getMusicalProbability('bass')) {
            let note = null;
            if (this.choraleMode) note = this.getChoraleNote('bass');
            if (!note) note = this.getValidNote('bass');

            if (note) {
                const dur = this.getDurationBeats(this.rollD6());
                this.playNote(note, false, true, dur);
                this.bassMomentum--;
            } else this.bassMomentum++;
        } else this.bassMomentum++;

        if (this.choraleMode && this.beatsInCurrentBar > 0 && this.beatsInCurrentBar % 2 === 0) {
            this.advanceChordProgression();
        }
    }

    changeKeyAndRhythm() {
        // Logic from source
        const pR = Math.floor(Math.random() * 6);
        const f = this.keyFrequencies;

        // Apply Planetary Tunings
        if (pR === 0) { f.C=113.81; f['C#']=163.92; f.D=226.18; f['D#']=283.8; f.E=341.1; f.F=398.1; f.G=512.1; this.currentTempo=120; } 
        else if (pR === 1) { f.C=97.36*7; f.D=127.48*2; f.E=131.47*3; f.G=135.55*4.5; this.currentTempo=167; }
        // ... (Simplified for brevity, logic remains) ...
        
        // Mode Change
        const scaleType = Math.random();
        if(scaleType < 0.33) {
            this.currentKeyType = 'diatonic';
            this.currentKey = this.keys[Math.floor(Math.random()*12)];
            this.currentMode = Object.keys(this.modeOffsets)[Math.floor(Math.random()*7)];
            this.currentScaleNotes = this.getScaleNotes(this.currentKey, this.currentMode);
        } else if (scaleType < 0.66) {
            this.currentKeyType = 'pentatonic';
            this.currentKey = Object.keys(this.pentatonicKeys)[Math.floor(Math.random()*5)];
            this.currentScaleNotes = this.pentatonicKeys[this.currentKey];
        } else {
            this.currentKeyType = 'exotic';
            this.currentMode = Object.keys(this.exoticModes)[Math.floor(Math.random()*10)];
            this.currentKey = this.keys[Math.floor(Math.random()*12)];
            const base = this.noteToIndex(this.currentKey);
            this.currentScaleNotes = this.exoticModes[this.currentMode].map(i => this.chromatic[(base+i)%12]);
        }
        this.currentScaleIntervals = this.getScaleIntervals(this.currentScaleNotes);
        this.initializeChordProgression();
    }

    // --- PUBLIC METHODS ---

    start() {
        if (this.isPlaying) return;
        this.isPlaying = true;
        this.currentBarCount = 1;
        this.beatsInCurrentBar = 0;
        this.eighthNoteCount = 0;

        const loop = () => {
            if (!this.isPlaying) return;
            
            if (this.eighthNoteCount % 2 === 0) {
                this.playMetronome();
                this.processQuarterNote();
                this.beatsInCurrentBar++;
                
                if (this.beatsInCurrentBar >= this.currentTimeSignature[0]) {
                    this.beatsInCurrentBar = 0;
                    this.currentBarCount++;
                    if (this.currentBarCount % 3 === 1) this.currentMetronomeNote = Math.floor(Math.random()*5)+1;
                    if (this.currentBarCount % 12 === 1 && this.currentBarCount > 1) {
                        this.changeKeyAndRhythm();
                        clearInterval(this.intervalId);
                        const newRate = (60 / this.currentTempo) * 500;
                        this.intervalId = setInterval(loop, newRate);
                        return;
                    }
                }
            }
            this.processEighthNote();
            this.eighthNoteCount++;
        };

        const rate = (60 / this.currentTempo) * 500;
        this.intervalId = setInterval(loop, rate);
    }

    stop() {
        this.isPlaying = false;
        clearInterval(this.intervalId);
        if (this.currentBassOscillator) {
            try { this.currentBassOscillator.stop(); } catch(e){}
        }
        // Disconnect main output
        setTimeout(() => this.mixerGain.disconnect(), 100);
    }
}
// MODULE 24: Dungeon Crawl
class DungeonCrawlModule {
    constructor(ctx, output) {
        this.ctx = ctx;
        this.masterOutput = output;
        this.isPlaying = false;
        this.intervalId = null;

        // --- MIXER & LIMITER ---
        // We need a limiter so the volume doesn't explode when everything plays at once
        this.limiter = ctx.createDynamicsCompressor();
        this.limiter.threshold.value = -10;
        this.limiter.knee.value = 40;
        this.limiter.ratio.value = 20; // Hard limiting
        this.limiter.attack.value = 0.005;
        this.limiter.release.value = 0.25;

        this.mixer = ctx.createGain();
        this.mixer.gain.value = 0.5; // Safety volume

        this.mixer.connect(this.limiter);
        this.limiter.connect(this.masterOutput);

        // --- MUSICAL STATE ---
        this.tempo = 145; // slightly slower to let notes breathe
        this.tick = 0;
        this.bar = 0;
        
        // A Minor Pentatonic (The "Rock" Scale) - much safer notes
        // A, C, D, E, G
        this.scaleIntervals = [0, 3, 5, 7, 10, 12, 15, 17]; 
        
        // Progression: Am - F - G - Am
        this.progression = [0, -4, -2, 0]; // Relative semitones to A
        this.currentRoot = 0;
    }

    getFreq(semitoneOffset) {
        // Base is A3 (220Hz)
        return 220 * Math.pow(2, semitoneOffset / 12);
    }

    // --- INSTRUMENTS (Refined) ---

    playKick(t) {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.frequency.setValueAtTime(100, t);
        osc.frequency.exponentialRampToValueAtTime(0.01, t + 0.1); // Faster drop = punchier
        
        gain.gain.setValueAtTime(0.8, t);
        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
        
        osc.connect(gain); gain.connect(this.mixer);
        osc.start(t); osc.stop(t + 0.1);
    }

    playSnare(t) {
        // White noise burst
        const bufSize = this.ctx.sampleRate * 0.1;
        const buffer = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for(let i=0; i<bufSize; i++) data[i] = (Math.random() * 2 - 1);

        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        
        const filt = this.ctx.createBiquadFilter();
        filt.type = 'highpass';
        filt.frequency.value = 800; // Remove mud

        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0.4, t);
        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);

        noise.connect(filt); filt.connect(gain); gain.connect(this.mixer);
        noise.start(t);
    }

    playHiHat(t, open) {
        const osc = this.ctx.createOscillator();
        osc.type = 'square'; // Metallic
        // Extremely high frequency random modulation for texture
        osc.frequency.setValueAtTime(8000, t); 

        const filt = this.ctx.createBiquadFilter();
        filt.type = 'highpass';
        filt.frequency.value = 6000;

        const gain = this.ctx.createGain();
        const vol = open ? 0.1 : 0.05; // Very quiet
        const dur = open ? 0.1 : 0.03;

        gain.gain.setValueAtTime(vol, t);
        gain.gain.exponentialRampToValueAtTime(0.01, t + dur);

        osc.connect(filt); filt.connect(gain); gain.connect(this.mixer);
        osc.start(t); osc.stop(t + dur);
    }

    playBass(t, root) {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'triangle'; // Clean bass
        
        const freq = this.getFreq(root - 12); // Octave down
        osc.frequency.setValueAtTime(freq, t);
        
        gain.gain.setValueAtTime(0.6, t);
        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.2); // Short & Plucky
        
        osc.connect(gain); gain.connect(this.mixer);
        osc.start(t); osc.stop(t + 0.25);
    }

    playOstinato(t, root) {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'square'; // NES Classic sound
        
        // Play high up
        const freq = this.getFreq(root + 12); 
        osc.frequency.setValueAtTime(freq, t);
        
        // Very short blips
        gain.gain.setValueAtTime(0.08, t); // Quiet backing
        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.08);
        
        osc.connect(gain); gain.connect(this.mixer);
        osc.start(t); osc.stop(t + 0.1);
    }

    playGuitar(t, semitones) {
        // This is the "Lead" - needs to be the loudest and cleanest
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();

        // 25% Pulse wave simulation (sounds like NES lead)
        // Since we can't do PWM easily, we use a Sawtooth + Highpass trick or just a Square
        osc.type = 'square'; 
        
        const freq = this.getFreq(semitones);
        osc.frequency.setValueAtTime(freq, t);

        // THE FILTER ENVELOPE (The "Wah" sound)
        filter.type = 'lowpass';
        filter.Q.value = 5; // Resonant peak
        filter.frequency.setValueAtTime(freq * 1.5, t);
        filter.frequency.exponentialRampToValueAtTime(freq * 3, t + 0.05); // Zip up
        filter.frequency.exponentialRampToValueAtTime(freq, t + 0.3);     // Zip down

        gain.gain.setValueAtTime(0.15, t); // Keep it reasonable
        gain.gain.linearRampToValueAtTime(0.15, t + 0.1);
        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);

        osc.connect(filter); filter.connect(gain); gain.connect(this.mixer);
        osc.start(t); osc.stop(t + 0.4);
    }

    playOrchHit(t, root) {
        // A stack of 3 oscillators to simulate a "Hit"
        const intervals = [0, 7, 12];
        const now = t;
        
        intervals.forEach(i => {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = 'sawtooth';
            osc.frequency.value = this.getFreq(root + i);
            
            // Detune slightly for thickness
            osc.detune.value = Math.random() * 20 - 10;

            gain.gain.setValueAtTime(0.1, now); // Low volume per voice!
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);

            osc.connect(gain); gain.connect(this.mixer);
            osc.start(now); osc.stop(now + 0.35);
        });
    }

    // --- SEQUENCER ---

    start() {
        if (this.isPlaying) return;
        this.isPlaying = true;
        this.tick = 0; 
        this.bar = 0;

        const loop = () => {
            if (!this.isPlaying) return;
            
            // Schedule slightly in future to prevent jitter
            const t = this.ctx.currentTime + 0.05; 
            
            const chordIndex = Math.floor(this.tick / 16) % 4;
            const currentRoot = this.progression[chordIndex];
            
            const beat16 = this.tick % 16;
            const beat8  = this.tick % 8;
            const beat4  = this.tick % 4;

            // 1. DRUMS (Kick on 0, 10; Snare on 4, 12)
            if (beat16 === 0 || beat16 === 10) this.playKick(t);
            if (beat16 === 4 || beat16 === 12) this.playSnare(t);
            if (beat16 % 2 === 0) this.playHiHat(t, beat16 % 4 === 2);

            // 2. BASS (Running 8ths)
            if (beat16 % 2 === 0) this.playBass(t, currentRoot);

            // 3. OSTINATO (Arpeggio Background) - 16th notes
            // Pattern: Root, 5th, Octave, 5th
            const arp = [0, 7, 12, 7];
            this.playOstinato(t, currentRoot + arp[beat16 % 4]);

            // 4. LEAD GUITAR (Pentatonic Melody)
            // Play mostly on strong beats, sometimes 8ths
            // Only play 60% of the time to leave space
            if (beat16 % 2 === 0 && Math.random() > 0.4) {
                const scaleNote = this.scaleIntervals[Math.floor(Math.random() * this.scaleIntervals.length)];
                this.playGuitar(t, currentRoot + scaleNote);
            }

            // 5. ORCHESTRA HIT (Start of every 4th bar)
            if (this.tick % 64 === 0) {
                 this.playOrchHit(t, currentRoot);
            }

            this.tick++;
        };

        const interval = (60 / this.tempo) / 4 * 1000;
        this.intervalId = setInterval(loop, interval);
    }

    stop() {
        this.isPlaying = false;
        clearInterval(this.intervalId);
        setTimeout(() => {
            try { this.mixer.disconnect(); } catch(e){}
        }, 200);
    }
}
// MODULE 25: Battle 4
class Battle3Module {
    constructor(ctx, output) {
        this.ctx = ctx;
        this.masterOutput = output;
        this.isPlaying = false;
        
        // --- CONFIG ---
        this.tempo = 178; // The authentic "Big Bridge" tempo
        this.lookahead = 25.0;
        this.scheduleAheadTime = 0.1;
        
        // --- STATE ---
        this.nextNoteTime = 0.0;
        this.current16thNote = 0;
        this.totalTicks = 0; // Total 16th notes played
        this.section = 'INTRO'; // INTRO, MAIN_A, MAIN_B, SOLO
        this.keyRoot = 5; // F (The classic key)

        // --- SCALES & PATTERNS ---
        // The "Gilgamesh" Scale (Harmonic Minor with a sharp 4 for bluesy tension)
        this.scale = [0, 2, 3, 6, 7, 8, 11]; 
        
        // Bass Progression (Chromatic Descent: F -> E -> Eb -> D)
        this.bassProgression = [0, -1, -2, -3]; 

        this.setupAudioGraph();
    }

    setupAudioGraph() {
        // Main Bus
        this.mainBus = this.ctx.createGain();
        this.mainBus.gain.value = 0.6;

        // 1. DISTORTION (For the Bass)
        this.dist = this.ctx.createWaveShaper();
        this.dist.curve = this.makeDistortionCurve(50);
        this.dist.oversample = '4x';

        // 2. REVERB (For the Organ/Snare)
        this.reverb = this.ctx.createConvolver();
        this.generateImpulse();
        this.reverbGain = this.ctx.createGain();
        this.reverbGain.gain.value = 0.4;

        // Routing
        this.mainBus.connect(this.masterOutput);
        this.mainBus.connect(this.reverb);
        this.reverb.connect(this.reverbGain);
        this.reverbGain.connect(this.masterOutput);
    }

    makeDistortionCurve(amount) {
        const k = amount, n_samples = 44100, curve = new Float32Array(n_samples);
        const deg = Math.PI / 180;
        for (let i = 0; i < n_samples; ++i) {
            let x = i * 2 / n_samples - 1;
            curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
        }
        return curve;
    }

    generateImpulse() {
        // Quick dirty reverb impulse
        const rate = this.ctx.sampleRate;
        const len = rate * 1.5;
        const buffer = this.ctx.createBuffer(2, len, rate);
        for (let c = 0; c < 2; c++) {
            const data = buffer.getChannelData(c);
            for (let i = 0; i < len; i++) {
                data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / len, 3);
            }
        }
        this.reverb.buffer = buffer;
    }

    // --- SCHEDULING ---

    start() {
        if (this.isPlaying) return;
        this.isPlaying = true;
        this.current16thNote = 0;
        this.totalTicks = 0;
        this.section = 'INTRO';
        this.nextNoteTime = this.ctx.currentTime + 0.1;
        this.scheduler();
    }

    stop() {
        this.isPlaying = false;
        window.clearTimeout(this.timerID);
        // Quick Fade
        this.mainBus.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.2);
        setTimeout(() => {
            this.mainBus.disconnect(); 
            this.reverbGain.disconnect();
        }, 300);
    }

    scheduler() {
        while (this.nextNoteTime < this.ctx.currentTime + this.scheduleAheadTime) {
            this.scheduleNote(this.current16thNote, this.nextNoteTime);
            this.advanceNote();
        }
        if (this.isPlaying) this.timerID = setTimeout(() => this.scheduler(), this.lookahead);
    }

    advanceNote() {
        const secondsPerBeat = 60.0 / this.tempo;
        this.nextNoteTime += 0.25 * secondsPerBeat;
        this.current16thNote = (this.current16thNote + 1) % 16;
        this.totalTicks++;

        // STATE MACHINE
        // Intro is 2 bars (32 ticks)
        if (this.totalTicks < 32) this.section = 'INTRO';
        // Then loop Main A (8 bars) and Main B (8 bars)
        else {
            const loopTick = (this.totalTicks - 32) % 256;
            if (loopTick < 128) this.section = 'MAIN_A';
            else this.section = 'MAIN_B';
        }
    }

    // --- COMPOSITION ENGINE ---

    scheduleNote(beat, t) {
        const sixteenthDur = (60 / this.tempo) / 4;

        // 1. DRUMS (Driving Rock)
        if (beat % 4 === 0) this.playKick(t);
        if (beat % 8 === 4) this.playSnare(t);
        if (beat % 2 === 0) this.playHiHat(t, beat % 4 === 2); // Open hat on off-beats

        // 2. BASS (Chromatic Gallop)
        // Determines current root note based on bar number
        const barIndex = Math.floor((this.totalTicks - 32) / 16) % 4;
        const currentRootOffset = (this.section === 'INTRO') ? 0 : this.bassProgression[barIndex];
        
        // The Gallop Pattern: X-X- -X-X- -X- -X-X- -X-X-
        const isBassHit = [1,1,0,1,1,0,1,0,1,1,0,1,1,0,1,0][beat];
        
        if (isBassHit) {
            // Intro bass stays on root, Main bass moves down
            this.playBass(this.getFreq(this.keyRoot + currentRootOffset, -2), t, sixteenthDur);
        }

        // 3. ORGAN LEAD (The Melody)
        this.playMelody(beat, t, sixteenthDur, currentRootOffset);
    }

    playMelody(beat, t, dur, rootOffset) {
        let note = null;
        let octave = 1;

        if (this.section === 'INTRO') {
            // Rapid Triplets run: 0, 2, 3, 0, 2, 3...
            const introNotes = [0, 2, 3, 5, 3, 2];
            note = introNotes[this.totalTicks % 6];
            if (this.totalTicks > 24) note += 12; // Go up an octave at end of intro
        } 
        else if (this.section === 'MAIN_A') {
            // The "Hook" - Arpeggios outlining the chord
            // Pattern: Root - 5th - Octave - 5th - Root
            const arp = [0, 4, 7, 4, 0, -5, 0, 4]; // Using relative intervals
            // Only play on 8th notes to leave space
            if (beat % 2 === 0) {
                note = arp[(beat/2) % 8] + rootOffset;
            }
        }
        else if (this.section === 'MAIN_B') {
            // The "Solo" - High speed random-ish runs
            if (beat % 2 === 0 || Math.random() > 0.3) {
                const scale = [0, 2, 3, 5, 7, 8, 10, 12];
                // Sine wave shape for melody contour
                const contour = Math.floor(Math.sin(this.totalTicks * 0.1) * 4) + 4;
                note = scale[contour] + rootOffset;
                octave = 2; // High pitch
            }
        }

        if (note !== null) {
            this.playOrgan(this.getFreq(this.keyRoot + note, octave), t, dur);
        }
    }

    // --- SYNTH PATCHES ---

    getFreq(note, octave) {
        // 12-TET
        return 261.63 * Math.pow(2, (note + (octave * 12)) / 12);
    }

    playOrgan(freq, t, dur) {
        // ADDITIVE SYNTHESIS: Stack oscillators to mimic Hammond Organ
        const createOsc = (ratio, vol) => {
            const osc = this.ctx.createOscillator();
            const g = this.ctx.createGain();
            osc.type = 'sine'; // Organs are stacked sines
            osc.frequency.value = freq * ratio;
            g.gain.setValueAtTime(vol, t);
            g.gain.linearRampToValueAtTime(0, t + dur); // Percussive organ envelope
            osc.connect(g);
            g.connect(this.mainBus);
            osc.start(t);
            osc.stop(t + dur + 0.05);
        };

        createOsc(1, 0.4);   // Fundamental
        createOsc(2, 0.2);   // Octave
        createOsc(1.498, 0.1); // Fifth (approx)
        createOsc(4, 0.05);  // 2 Octaves
    }

    playBass(freq, t, dur) {
        const osc = this.ctx.createOscillator();
        const filter = this.ctx.createBiquadFilter();
        const gain = this.ctx.createGain();

        osc.type = 'sawtooth'; // Aggressive saw
        osc.frequency.value = freq;

        // "Wow" filter envelope
        filter.type = 'lowpass';
        filter.Q.value = 5;
        filter.frequency.setValueAtTime(freq * 2, t);
        filter.frequency.exponentialRampToValueAtTime(freq, t + 0.15);

        gain.gain.setValueAtTime(0.7, t);
        gain.gain.exponentialRampToValueAtTime(0.01, t + dur);

        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.dist); // Send to Distortion Node
        this.dist.connect(this.mainBus);

        osc.start(t);
        osc.stop(t + dur + 0.05);
    }

    playKick(t) {
        const osc = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        osc.frequency.setValueAtTime(120, t);
        osc.frequency.exponentialRampToValueAtTime(0.01, t + 0.4);
        g.gain.setValueAtTime(0.8, t);
        g.gain.exponentialRampToValueAtTime(0.01, t + 0.4);
        osc.connect(g); g.connect(this.mainBus);
        osc.start(t); osc.stop(t + 0.4);
    }

    playSnare(t) {
        // Noise Burst + Tone
        const noise = this.ctx.createBufferSource();
        const buf = this.ctx.createBuffer(1, 44100 * 0.2, 44100);
        const data = buf.getChannelData(0);
        for(let i=0; i<data.length; i++) data[i] = Math.random()*2-1;
        noise.buffer = buf;

        const filt = this.ctx.createBiquadFilter();
        filt.type = 'highpass';
        filt.frequency.value = 1000;
        
        const g = this.ctx.createGain();
        g.gain.setValueAtTime(0.5, t);
        g.gain.exponentialRampToValueAtTime(0.01, t + 0.2);

        noise.connect(filt); filt.connect(g); g.connect(this.mainBus);
        noise.start(t);
    }

    playHiHat(t, isOpen) {
        // High frequency metal
        const osc = this.ctx.createOscillator();
        osc.type = 'square';
        // FM Synthesis for metallic sound
        const mod = this.ctx.createOscillator();
        mod.type = 'square';
        mod.frequency.value = 412;
        const modG = this.ctx.createGain();
        modG.gain.value = 1000;
        
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'highpass';
        filter.frequency.value = 8000;

        const g = this.ctx.createGain();
        const dur = isOpen ? 0.3 : 0.05;

        mod.connect(modG); modG.connect(osc.frequency);
        osc.connect(filter); filter.connect(g); g.connect(this.mainBus);

        g.gain.setValueAtTime(0.2, t);
        g.gain.exponentialRampToValueAtTime(0.01, t + dur);
        
        osc.start(t); mod.start(t);
        osc.stop(t + dur); mod.stop(t + dur);
    }
}
// MODULE 26: Test of Fate
class FateModule {
    constructor(ctx, output) {
        this.ctx = ctx;
        this.masterOutput = output;
        this.isPlaying = false;
        
        // --- CONFIG ---
        this.tempo = 165; // Allegro Molto
        this.lookahead = 25.0;
        this.scheduleAheadTime = 0.1;

        // --- STATE ---
        this.nextNoteTime = 0.0;
        this.current16thNote = 0;
        this.barCount = 0;
        
        // --- MUSICAL THEORY ---
        this.keyRoot = 2; // D Minor (The saddest/most epic key)
        this.scale = [0, 2, 3, 5, 7, 8, 11]; // Harmonic Minor (Essential for Bach)
        
        // CHORD PROGRESSION (Circle of Fifths / Falling Fifths)
        // i -> iv -> VII -> III -> VI -> ii -> V -> i
        this.chordProgression = [0, 3, 6, 2, 5, 1, 4, 0]; // Index in scale
        
        this.setupAudioGraph();
    }

    setupAudioGraph() {
        this.mainBus = this.ctx.createGain();
        this.mainBus.gain.value = 0.5;

        // 1. REVERB (Cathedral style)
        this.reverb = this.ctx.createConvolver();
        this.generateImpulse();
        this.reverbGain = this.ctx.createGain();
        this.reverbGain.gain.value = 0.3; // Wet mix

        // 2. EQ (Brighten the Harpsichord)
        this.highBoost = this.ctx.createBiquadFilter();
        this.highBoost.type = 'highshelf';
        this.highBoost.frequency.value = 4000;
        this.highBoost.gain.value = 4;

        // Routing
        this.mainBus.connect(this.highBoost);
        this.highBoost.connect(this.masterOutput);
        this.highBoost.connect(this.reverb);
        this.reverb.connect(this.reverbGain);
        this.reverbGain.connect(this.masterOutput);
    }

    generateImpulse() {
        // Long decay for cathedral sound
        const rate = this.ctx.sampleRate;
        const len = rate * 2.5;
        const buffer = this.ctx.createBuffer(2, len, rate);
        for (let i = 0; i < len; i++) {
            const decay = Math.pow(1 - i / len, 2);
            buffer.getChannelData(0)[i] = (Math.random() * 2 - 1) * decay;
            buffer.getChannelData(1)[i] = (Math.random() * 2 - 1) * decay;
        }
        this.reverb.buffer = buffer;
    }

    // --- SCHEDULING ---
    start() {
        if (this.isPlaying) return;
        this.isPlaying = true;
        this.current16thNote = 0;
        this.barCount = 0;
        this.nextNoteTime = this.ctx.currentTime + 0.1;
        this.scheduler();
    }

    stop() {
        this.isPlaying = false;
        window.clearTimeout(this.timerID);
        this.mainBus.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.1);
        setTimeout(() => {
            this.mainBus.disconnect();
            this.reverbGain.disconnect();
        }, 200);
    }

    scheduler() {
        while (this.nextNoteTime < this.ctx.currentTime + this.scheduleAheadTime) {
            this.scheduleNote(this.current16thNote, this.nextNoteTime);
            this.advanceNote();
        }
        if (this.isPlaying) this.timerID = setTimeout(() => this.scheduler(), this.lookahead);
    }

    advanceNote() {
        const secondsPerBeat = 60.0 / this.tempo;
        this.nextNoteTime += 0.25 * secondsPerBeat;
        this.current16thNote++;
        if (this.current16thNote === 16) {
            this.current16thNote = 0;
            this.barCount++;
        }
    }

    // --- THE COMPOSER (Invention Engine) ---

    scheduleNote(beat, t) {
        const sixteenthDur = (60 / this.tempo) / 4;
        
        // DETERMINE HARMONY
        // We cycle through the progression every bar
        const chordIndex = this.barCount % 8;
        const scaleDegree = this.chordProgression[chordIndex]; // The root of current chord
        
        // 1. BASSO CONTINUO (Cello)
        // Constant 8th note motion ("Walking Bass")
        if (beat % 2 === 0) {
            this.playBassoContinuo(beat, t, sixteenthDur * 2, scaleDegree);
        }

        // 2. VOICE 1: SOPRANO (Harpsichord High)
        // Uses "Sequencing" - repeating a melodic shape at different pitches
        this.playSoprano(beat, t, sixteenthDur, scaleDegree);

        // 3. VOICE 2: ALTO (Harpsichord Mid/Counterpoint)
        // Plays complementary rhythm or harmony
        this.playAlto(beat, t, sixteenthDur, scaleDegree);
    }

    playBassoContinuo(beat, t, dur, rootDegree) {
        // Arpeggiate the current chord: Root -> 5th -> Octave -> 5th
        // or Walk: Root -> 2nd -> 3rd -> 5th
        let note = 0;
        const b = (beat / 2) % 4; // 0, 1, 2, 3
        
        if (this.barCount % 2 === 0) {
            // Alberti Bass Style (Root - 5 - 3 - 5)
            if (b === 0) note = 0;
            if (b === 1) note = 4; // 5th
            if (b === 2) note = 2; // 3rd
            if (b === 3) note = 4;
        } else {
            // Walking Scale
            note = b; // 0, 1, 2, 3 (steps up the scale)
        }
        
        const freq = this.getFreq(rootDegree + note, -2); // Low octave
        this.playCello(freq, t, dur);
    }

    playSoprano(beat, t, dur, rootDegree) {
        // MOTIF A: The "Pedal Point" (Bach loves this)
        // Alternating between a moving note and a static note
        // Ex: C-G-D-G-E-G
        
        // MOTIF B: 16th Note Runs
        
        let note = 0;
        let octave = 1;

        if (this.barCount % 4 < 2) {
            // Motif A: Pedal Point
            if (beat % 2 === 1) {
                // The "Pedal" (The Dominant of the chord)
                note = 4; 
            } else {
                // The Moving Line (Descending scale)
                note = 7 - (beat / 2); 
            }
        } else {
            // Motif B: Arpeggio Run
            const arp = [0, 2, 4, 7, 4, 2, 0, -1, 0, 2, 4, 7, 8, 7, 4, 2];
            note = arp[beat];
        }

        // Add ornamentation (Trills) on the first beat of a bar
        if (beat === 0 && Math.random() > 0.5) {
            this.playTrill(this.getFreq(rootDegree + note, octave), t, dur);
        } else {
            this.playHarpsichord(this.getFreq(rootDegree + note, octave), t, dur, 0.4);
        }
    }

    playAlto(beat, t, dur, rootDegree) {
        // Counterpoint Rule: If Soprano is fast, Alto is slow (and vice versa)
        // Or play parallel thirds (very Mozart)
        
        // Parallel Thirds below the root
        let note = 0;
        const octave = 0; // Mid range

        if (this.barCount % 4 < 2) {
            // Harmonize the pedal point melody
            if (beat % 2 === 0) {
               // Only play on the moving notes, leave space on the pedal
               note = (7 - (beat / 2)) - 2; // A third below
               this.playHarpsichord(this.getFreq(rootDegree + note, octave), t, dur, 0.25);
            }
        } else {
            // Staggered canon (play same arp but offset or slower)
            if (beat % 2 === 0) { // 8th notes
                const arp = [0, 4, 2, 0, -2, 0, 2, 0];
                note = arp[(beat/2)%8];
                this.playHarpsichord(this.getFreq(rootDegree + note, octave), t, dur*2, 0.25);
            }
        }
    }

    // --- INSTRUMENTS ---

    getFreq(degree, octaveOffset) {
        const len = this.scale.length;
        // Handle negative degrees wrapping
        const safeDegree = ((degree % len) + len) % len;
        const octaveShift = Math.floor(degree / len);
        
        const semitone = this.scale[safeDegree];
        const noteIndex = this.keyRoot + semitone + ((octaveOffset + octaveShift) * 12);
        
        return 261.63 * Math.pow(2, (noteIndex - 9) / 12); // Base C4
    }

    playHarpsichord(freq, t, dur, vol) {
        // Harpsichord = Sawtooth + Sharp Pluck + No Sustain
        const osc = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        
        osc.type = 'sawtooth';
        osc.frequency.value = freq;

        // Envelope: Instant attack, rapid decay to silence (Plucked string)
        g.gain.setValueAtTime(0, t);
        g.gain.linearRampToValueAtTime(vol, t + 0.005); // Snap attack
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.4); // Decay (ignore duration mostly)

        // Filter: Bright
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'highpass';
        filter.frequency.value = freq; // Remove mud

        osc.connect(filter); filter.connect(g); g.connect(this.mainBus);
        osc.start(t); osc.stop(t + 0.5);
    }

    playCello(freq, t, dur) {
        // Cello = Sawtooth + Lowpass + Sustained Bow
        const osc = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();

        osc.type = 'sawtooth';
        osc.frequency.value = freq;

        filter.type = 'lowpass';
        filter.frequency.value = freq * 3;

        // Envelope: Softer attack (Bowed), Full sustain
        g.gain.setValueAtTime(0, t);
        g.gain.linearRampToValueAtTime(0.4, t + 0.05);
        g.gain.setValueAtTime(0.4, t + dur - 0.05);
        g.gain.linearRampToValueAtTime(0, t + dur);

        osc.connect(filter); filter.connect(g); g.connect(this.mainBus);
        osc.start(t); osc.stop(t + dur);
    }

    playTrill(freq, t, dur) {
        // Rapid oscillation between note and note+1
        const osc = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.value = freq;
        
        // Trill logic using LFO on frequency
        const lfo = this.ctx.createOscillator();
        lfo.frequency.value = 15; // Fast trill
        lfo.type = 'square'; // Snap between notes
        const lfoG = this.ctx.createGain();
        lfoG.gain.value = freq * 0.059; // Approx 1 semitone
        
        lfo.connect(lfoG);
        lfoG.connect(osc.frequency);
        
        g.gain.setValueAtTime(0.4, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.5);

        osc.connect(g); g.connect(this.mainBus);
        osc.start(t); osc.stop(t + 0.5);
        lfo.start(t); lfo.stop(t + 0.5);
    }
}
// MODULE 27: Imminent Crisis
class Battle4Module {
  constructor(ctx, dest) {
    this.ctx = ctx;
    this.dest = dest;
    this.timer = null;
    this.isStopped = false; // SAFETY FLAG

    // --- GLOBAL SETTINGS ---
    this.tempo = 168; 
    this.keyBase = 293.66; 
    this.scale = [0, 2, 3, 5, 7, 8, 11]; 
    
    // --- MIXER & FX ---
    this.master = ctx.createGain();
    this.master.gain.value = 0.4; 
    
    this.convolver = ctx.createConvolver();
    this.convolver.buffer = this.createReverbImpulse(2.5); 
    this.reverbMix = ctx.createGain();
    this.reverbMix.gain.value = 0.4; 

    this.comp = ctx.createDynamicsCompressor();
    this.comp.threshold.value = -15;
    this.comp.ratio.value = 10;
    
    // --- OPTIMIZATION 1: THE NOISE BUS ---
    // Instead of creating a filter for every hi-hat, we make ONE here.
    this.noiseFilter = ctx.createBiquadFilter();
    this.noiseFilter.type = 'highpass';
    this.noiseFilter.frequency.value = 5000;

    // Routing: Noise Source -> NoiseFilter -> Compressor -> ...
    this.noiseFilter.connect(this.comp);
    
    this.comp.connect(this.master);
    this.comp.connect(this.reverbMix);
    this.reverbMix.connect(this.master);
    this.master.connect(dest);

    // --- OPTIMIZATION 2: Pre-create Noise Buffers ---
    this.hatBuffer = this.createNoiseBuffer(0.05);
    this.snareBuffer = this.createNoiseBuffer(0.2);
    this.crashBuffer = this.createNoiseBuffer(1.5);

    // --- STATE ---
    this.tick = 0;
    this.bar = 0;
    this.currentRoot = 0; 
    this.composer = 'BACH'; 
  }

  createNoiseBuffer(dur) {
    const buf = this.ctx.createBuffer(1, this.ctx.sampleRate * dur, this.ctx.sampleRate);
    const data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
    return buf;
  }

  createReverbImpulse(duration) {
    const rate = this.ctx.sampleRate;
    const length = rate * duration;
    const impulse = this.ctx.createBuffer(2, length, rate);
    const left = impulse.getChannelData(0);
    const right = impulse.getChannelData(1);
    for (let i = 0; i < length; i++) {
        const n = i / length;
        const noise = (Math.random() * 2 - 1) * Math.pow(1 - n, 2);
        left[i] = noise;
        right[i] = noise;
    }
    return impulse;
  }

  start() {
    this.isStopped = false;
    this.tick = 0;
    this.bar = 0;
    this.schedule();
  }

  stop() {
    this.isStopped = true; // KILL SWITCH
    if (this.timer) clearTimeout(this.timer);
    
    // Kill the output
    this.master.gain.cancelScheduledValues(this.ctx.currentTime);
    this.master.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.1);
    
    setTimeout(() => {
        this.master.disconnect(); 
        // Disconnect busses to free memory
        if (this.noiseFilter) this.noiseFilter.disconnect();
        if (this.reverbMix) this.reverbMix.disconnect();
        if (this.convolver) this.convolver.disconnect(); 
        if (this.comp) this.comp.disconnect();
    }, 200);
  }

  schedule() {
    if (this.isStopped) return;

    const secondsPerBeat = 60 / this.tempo;
    const stepTime = secondsPerBeat / 4; 
    this.timer = setTimeout(() => this.schedule(), stepTime * 1000);

    const step = this.tick % 16;
    
    if (step === 0) {
        if (this.tick % 64 === 0) this.bar++; 
        this.progressHarmony();
        if (this.bar % 1 === 0 && this.tick % 64 === 0) {
            this.switchComposer();
        }
    }

    this.playDrums(step);
    this.playBass(step);
    this.playLead(step);
    this.tick++;
  }

  progressHarmony() {
      const progression = [0, 8, 10, 7]; 
      const barInLoop = Math.floor(this.tick / 64) % 4;
      this.currentRoot = progression[barInLoop];
  }

  switchComposer() {
      const styles = ['BACH', 'PAGANINI', 'VIVALDI', 'BEETHOVEN'];
      this.composer = styles[Math.floor(Math.random() * styles.length)];
      this.playCrash(); 
  }

  playDrums(step) {
      if (this.isStopped) return;
      const k = (step === 0 || step === 2 || step === 8 || step === 10);
      const s = (step === 4 || step === 12);
      const h = (step % 2 === 0);

      if (k) this.createDrum('kick');
      if (s) this.createDrum('snare');
      if (h) this.createDrum('hat');
  }

  playBass(step) {
      if (this.isStopped) return;
      const isStrong = (step % 4 === 0);
      let octave = -2;
      let vol = isStrong ? 0.6 : 0.4;
      if (step % 4 === 3) return; 
      this.createSuperSaw(this.currentRoot, octave, 0.1, vol * 0.8, 400); 
  }

  playLead(step) {
      if (this.isStopped) return;
      let note = null;
      let dur = 0.15;

      if (this.composer === 'BACH') {
          const contour = Math.floor(Math.sin(this.tick * 0.5) * 4);
          note = this.currentRoot + contour; 
          if (step % 2 !== 0) note = this.currentRoot + 7; 
      }
      else if (this.composer === 'PAGANINI') {
          const arp = [0, 2, 4, 7, 11, 7, 4, 2];
          note = this.currentRoot + arp[step % 8];
          dur = 0.1; 
      }
      else if (this.composer === 'VIVALDI') {
          if (step % 2 === 0) {
              note = this.currentRoot; 
          } else {
              note = this.currentRoot + 7 + Math.floor(step / 4);
          }
      }
      else if (this.composer === 'BEETHOVEN') {
          const motif = [0, 0, 0, -2]; 
          if (step < 4) {
              note = this.currentRoot + motif[step];
              dur = (step === 3) ? 0.8 : 0.15; 
          }
      }

      if (note !== null) {
          const octave = (Math.random() > 0.8) ? 1 : 0;
          this.createSuperSaw(note, octave, dur, 0.4, 2500);
      }
  }

  createSuperSaw(degree, octave, dur, vol, filterCutoff) {
    if (this.isStopped) return;
    const t = this.ctx.currentTime;
    let n = degree;
    let o = octave;
    while (n < 0) { n += 7; o--; }
    while (n >= 7) { n -= 7; o++; }
    const freq = this.keyBase * Math.pow(2, (this.scale[n] + (o * 12)) / 12);

    const gain = this.ctx.createGain();
    gain.gain.setValueAtTime(0, t);
    gain.gain.linearRampToValueAtTime(vol, t + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.001, t + dur + 0.1);

    const filter = this.ctx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.setValueAtTime(filterCutoff, t);
    filter.frequency.exponentialRampToValueAtTime(filterCutoff * 0.5, t + dur);

    // --- OPTIMIZATION 3: Reduced Oscillators ---
    // Reduced from 3 to 2. (Left and Right only). 
    // This reduces CPU load by 33% per note.
    [-8, 8].forEach(detune => {
        const osc = this.ctx.createOscillator();
        osc.type = 'sawtooth';
        osc.frequency.value = freq;
        osc.detune.value = detune; 
        osc.connect(filter);
        osc.start(t);
        osc.stop(t + dur + 0.15); 
        
        // Explicitly disconnect after stop to help Garbage Collector
        osc.onended = () => { osc.disconnect(); };
    });

    filter.connect(gain);
    gain.connect(this.comp); 
    
    // Cleanup Gain/Filter after sound ends
    setTimeout(() => {
        gain.disconnect();
        filter.disconnect();
    }, (dur + 0.2) * 1000);
  }

  createDrum(type) {
    if (this.isStopped) return;
    const t = this.ctx.currentTime;
    
    if (type === 'kick') {
        const g = this.ctx.createGain();
        g.connect(this.comp);
        
        const o = this.ctx.createOscillator();
        o.frequency.setValueAtTime(150, t);
        o.frequency.exponentialRampToValueAtTime(0.01, t + 0.5);
        g.gain.setValueAtTime(0.8, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
        o.connect(g);
        o.start(t); o.stop(t + 0.5);
        
        // Cleanup
        o.onended = () => { o.disconnect(); g.disconnect(); };
    } 
    else if (type === 'snare') {
        // Tone part
        const g = this.ctx.createGain();
        g.connect(this.comp);
        const o = this.ctx.createOscillator();
        o.frequency.setValueAtTime(250, t);
        o.type = 'triangle';
        g.gain.setValueAtTime(0.5, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
        o.connect(g);
        o.start(t); o.stop(t + 0.2);
        o.onended = () => { o.disconnect(); g.disconnect(); };
        
        // Noise part - Uses Shared Filter!
        this.playNoiseBuffer(this.snareBuffer, 0.4); 
    } 
    else if (type === 'hat') {
        // Uses Shared Filter!
        this.playNoiseBuffer(this.hatBuffer, 0.1);
    }
  }

  playCrash() {
    this.playNoiseBuffer(this.crashBuffer, 0.6);
  }

  // OPTIMIZED: Uses the shared 'noiseFilter'
  playNoiseBuffer(buffer, vol) {
      if (this.isStopped) return;
      const t = this.ctx.currentTime;
      const noise = this.ctx.createBufferSource();
      noise.buffer = buffer;
      const g = this.ctx.createGain();
      
      // Removed: createBiquadFilter() 
      // Replaced with: Shared noiseFilter

      g.gain.setValueAtTime(vol, t);
      g.gain.exponentialRampToValueAtTime(0.001, t + buffer.duration);
      
      // Connect: Buffer -> Gain -> SharedFilter
      noise.connect(g);
      g.connect(this.noiseFilter); 
      
      noise.start(t);
      
      // Cleanup
      noise.onended = () => {
          noise.disconnect();
          g.disconnect();
      };
  }
}
// MODULE 28: The Price of Hubris
class HubrisModule {
  constructor(ctx, dest) {
    this.ctx = ctx;
    this.dest = dest;
    this.timer = null;

    // 1. DYNAMIC LAYERING
    this.intensity = 1;

    // 2. GLOBAL MIX
    this.master = ctx.createGain();
    this.master.gain.value = 0.5;
    
    // Create a reverb/delay bus for the Arabic melody (essential for vibe)
    this.melodyBus = ctx.createGain();
    this.melodyBus.gain.value = 0.4;
    this.melodyBus.connect(this.master);
    
    // Simple Delay effect for the melody
    const delay = ctx.createDelay();
    delay.delayTime.value = 0.3; // 300ms delay
    const delayFb = ctx.createGain();
    delayFb.gain.value = 0.4;
    delay.connect(delayFb);
    delayFb.connect(delay);
    delay.connect(this.master);
    this.melodyBus.connect(delay);

    this.master.connect(this.dest);

    // 3. STATE
    this.baseTempo = 110; 
    this.tempo = 110; 
    this.tickCount = 0;
    this.keyBase = 146.83; // D3
    
    // Modulation State
    this.barCount = 0;
    this.currentTransposition = 0; // In semitones

    // SCALES
    // Background: D Dorian (Fantasy Strategy Standard)
    this.dorianScale = [0, 2, 3, 5, 7, 9, 10];
    
    // Melody: D Phrygian Dominant (The "Arabic" Hijaz sound)
    // 1, b2, 3, 4, 5, b6, b7
    this.arabicScale = [0, 1, 4, 5, 7, 8, 10]; 

    this.snareGrid = [2, 0, 1, 0, 2, 1, 1, 0, 2, 0, 1, 0, 1, 1, 0, 1];

    // 4. GENERATIVE VOICES (The "Suncat" Engine)
    // We create 2 independent voices
    this.voices = [
        new GenVoice(this, 0), // Voice 1 (Lead)
        new GenVoice(this, 1)  // Voice 2 (Harmony)
    ];
  }

  start() {
    this.tickCount = 0;
    this.runTick(); // Start the loop
  }

  // Recursive timeout allows for dynamic Tempo changes per tick
  runTick() {
    // Calculate interval based on CURRENT tempo
    const interval = (60 / this.tempo) / 4 * 1000; // 16th note
    
    this.tick();
    
    this.timer = setTimeout(() => {
        if(this.master.gain.value > 0.001) this.runTick();
    }, interval);
  }

  stop() {
    if (this.timer) clearTimeout(this.timer);
    this.master.gain.setTargetAtTime(0, this.ctx.currentTime, 0.1);
  }

  setIntensity(level) {
    this.intensity = level;
  }

  // --- THE SEQUENCER ---
  tick() {
    const t = this.ctx.currentTime;
    const step = this.tickCount % 16; 
    const isBarStart = step === 0;

    // --- GLOBAL MODULATION (The "Dao" Flow) ---
    // Every 4 bars, shift the world slightly
    if (isBarStart) {
        this.barCount++;
        if (this.barCount % 4 === 0) {
            this.modulate();
        }
    }

    // --- STANDARD LAYERS ---
    const snareType = this.snareGrid[step];
    if (snareType > 0) this.playSnare(t, snareType === 2);
    if (step === 0 || step === 8) this.playKick(t);

    if (this.intensity >= 2 && step % 2 === 0) {
      this.playStrings(t, step, Math.floor(this.tickCount / 16) % 4);
    }
    
    if (this.intensity >= 3 && step === 0) {
      this.playBrass(t, Math.floor(this.tickCount / 16) % 4);
    }

    // --- THE GENERATIVE ARABIC VOICES ---
    // Only play if Intensity is high enough (or remove check to always play)
    if (this.intensity >= 1) {
        this.voices.forEach(voice => voice.process(t, step));
    }

    this.tickCount++;
  }

  modulate() {
      // 1. Drift the Tempo (Organic feeling)
      // Fluctuate between 90% and 110% of base tempo
      const drift = (Math.random() * 20) - 10;
      this.tempo = this.baseTempo + drift;

      // 2. Modulate Key (Circle of Fifths or Random)
      // We roll a d3: 0=Stay, 1=Up Fifth, 2=Down Fifth
      const roll = Math.floor(Math.random() * 3);
      if (roll === 1) this.currentTransposition += 7; // Up perfect 5th
      else if (roll === 2) this.currentTransposition -= 5; // Down perfect 4th (inv 5th)
      
      // Constraint: Don't let it go too high/low (-12 to +12 semitones)
      if (this.currentTransposition > 12) this.currentTransposition -= 12;
      if (this.currentTransposition < -12) this.currentTransposition += 12;
      
      // console.log(`Modulated: Tempo ${Math.floor(this.tempo)}, KeyOffset ${this.currentTransposition}`);
  }

  // --- STANDARD INSTRUMENTS (Abbreviated for space) ---
  playSnare(t, accent) { /* ... same as your code ... */ 
    const osc = this.ctx.createOscillator();
    osc.type = 'triangle'; // Placeholder for snare noise logic
    // (Keep your original snare code here, I'm simplifying to focus on the Gen logic)
  }
  playKick(t) { /* ... same as your code ... */ }
  playStrings(t, step, bar) { /* ... same as your code ... */ }
  playBrass(t, bar) { /* ... same as your code ... */ }
}
// MODULE 29: The bard
class BardModule {
  constructor(ctx, dest) {
    this.ctx = ctx;
    this.dest = dest;
    this.timer = null;

    // --- 1. THE "DARK REGAL" SETTINGS ---
    this.tempo = 120; // Stately, not too fast
    // A Harmonic Minor: The sound of "Ancient Royalty"
    // Notes: A, B, C, D, E, F, G# (The G# creates the "Dark" tension)
    this.keyRoot = 220.00; // A3
    this.scale = [0, 2, 3, 5, 7, 8, 11]; 

    // --- 2. THE COMPOSER BRAIN ---
    this.tick = 0;
    this.bar = 0;
    
    // The "Chord Sheet" (Functional Harmony)
    // The code will cycle through this progression, improvising over each chord.
    // i (Am) -> iv (Dm) -> V (E Major) -> i (Am)
    this.progression = [0, 3, 4, 0]; 
    this.currentChord = 0; // Relative to root

    // "The Motif" - We generate a shape and reuse it to sound "composed"
    this.currentMotif = []; 
    
    // --- 3. THE CASTLE ACOUSTICS ---
    this.master = ctx.createGain();
    this.master.gain.value = 0.45;

    // Bright Reverb (Stone Hall)
    this.convolver = ctx.createConvolver();
    this.convolver.buffer = this.createImpulse(2.5); // 2.5s tail
    this.revGain = ctx.createGain();
    this.revGain.gain.value = 0.35; 

    this.master.connect(dest);
    this.master.connect(this.convolver);
    this.convolver.connect(this.revGain);
    this.revGain.connect(dest);
  }

  createImpulse(duration) {
    const rate = this.ctx.sampleRate;
    const len = rate * duration;
    const buf = this.ctx.createBuffer(2, len, rate);
    for (let i = 0; i < len; i++) {
        // Linear decay is cleaner for classical
        const decay = 1 - (i / len);
        buf.getChannelData(0)[i] = (Math.random() * 2 - 1) * decay;
        buf.getChannelData(1)[i] = (Math.random() * 2 - 1) * decay;
    }
    return buf;
  }

  start() {
    this.tick = 0;
    this.bar = 0;
    this.generateNewMotif(); // Start with a fresh idea
    this.scheduler();
  }

  stop() {
    if (this.timer) clearTimeout(this.timer);
    // Courtly fade out
    this.master.gain.cancelScheduledValues(this.ctx.currentTime);
    this.master.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 1.0);
    setTimeout(() => { this.master.disconnect(); this.revGain.disconnect(); }, 1200);
  }

  // --- THE CLOCK (Strict 16th Notes) ---
  scheduler() {
    const secondsPerBeat = 60 / this.tempo;
    const stepTime = secondsPerBeat / 4; // 16th note
    
    this.timer = setTimeout(() => this.scheduler(), stepTime * 1000);

    const step = this.tick % 16; // 0-15 steps in a bar
    const beat = Math.floor(step / 4);

    // BAR START: Change Harmony
    if (step === 0) {
        // Move to next chord in progression
        const chordIdx = this.bar % this.progression.length;
        this.currentChord = this.progression[chordIdx];
        
        // Every 2 bars, change the melodic idea (Motif)
        if (this.bar % 2 === 0) this.generateNewMotif();
        
        this.bar++;
    }

    // PLAY VOICES
    const t = this.ctx.currentTime;
    
    // 1. THE BASS (Cello/Left Hand)
    // Strict quarter notes on the beat. No random rhythm.
    if (step % 4 === 0) {
        this.playBass(t, this.currentChord);
    }

    // 2. THE MELODY (Harpsichord/Right Hand)
    // Applies the generated Motif to the current Chord
    this.playMelody(t, step);

    this.tick++;
  }

  // --- THE BAROQUE GENERATOR ---

  generateNewMotif() {
    // Instead of random notes, we generate a SHAPE.
    // 0 = Chord Tone, 1 = Step Up, -1 = Step Down
    // "Regal" music uses lots of arpeggios (skips) and turns.
    
    const shapes = [
    // --- HEROIC / REGAL (The "Castle" Sound) ---
    [0, 2, 4, 7],    // 1. Arpeggio Up (The standard "Hero" fanfare)
    [7, 4, 2, 0],    // 2. Arpeggio Down (Resolving, confident finish)
    [0, 0, 4, 4],    // 3. Stately Steps (Dignified, slow movement)
    [0, 4, 7, 11],   // 4. The "Quest" Reach (Reaches for the high 7th note, yearning)
    [0, -3, 0, 2],   // 5. The "Dip" (Dips down into the bass and returns, grounding)

    // --- ORNAMENTAL / BAROQUE (The "Fancy" Sound) ---
    [0, 1, 0, -1],   // 6. The Turn (Classic trill, very sophisticated)
    [2, 1, 0, 1],    // 7. The Neighbor (Dancing around the main note)
    [0, 2, 1, 3],    // 8. The Weave (Skips up, steps down - complex melody)
    [4, 3, 2, 1],    // 9. The Cascade (Falling scale run, like water or a harp)
    [0, 1, 2, 3],    // 10. Scale Run Up (Building energy)

    // --- DARK / TENSION (The "Vampire/Dungeon" Sound) ---
    [0, 1, 0, 1],    // 11. The Trill (Rapid alternation, creates anxiety)
    [0, 6, 5, 0],    // 12. The Tritone Jump (Jumps to the "Devil's Interval" and resolves)
    [7, 6, 5, 4],    // 13. Chromatic Descent (Falling into darkness)
    [0, -1, -2, -4], // 14. The Plunge (Rapid drop into the low register)
    [0, 0, 1, 0],    // 15. The Stutter (Hesitant, repeating the root)

    // --- MYSTIC / XIANXIA (The "Cultivation" Sound) ---
    [0, 2, 5, 7],    // 16. Open 5ths (Hollow, spacious sound)
    [0, 4, 0, 7],    // 17. The Bell (Wide intervals, sounds like ringing)
    [7, 9, 7, 4],    // 18. Falling Leaf (Gentle pentatonic descent)
    [0, 2, 0, -2],   // 19. The Balance (Symmetric movement up and down)
    [0, 5, 2, 7]     // 20. The Leap (Large jumps that feel airy/flying)
];
    const scales = [
        [0, 2, 3, 5, 7, 8, 11], // Arpeggio Up (Heroic)
        [0, 2, 3, 6, 7, 8, 11], // Arpeggio Down (Resolving)
        [0, 1, 4, 5, 7, 8, 10], // The "Turn" (Ornamental)
        [0, 2, 3, 5, 7, 9, 10],  // Stately Steps
        [0, 2, 4, 5, 7, 9, 10],
        [0, 2, 4, 6, 7, 9, 11],
        [0, 2, 3, 5, 7, 8, 10],
        [0, 2, 3, 7, 8],
        [0, 1, 5, 7, 10],
        [0, 2, 4, 7, 9],
        [0, 2, 5, 7, 9],
        [0, 1, 3, 5, 6, 8, 10],
        [0, 2, 4, 6, 8, 10],
        [0, 1, 3, 4, 6, 7, 9, 10]

           // Scale Run
    ];
    
     this.scale = scales[Math.floor(Math.random() * scales.length)]; 
    
    this.progression =shapes[Math.floor(Math.random() * shapes.length)];
    // Pick a shape
    
    let shape = shapes[Math.floor(Math.random() * shapes.length)];
    //if (Math.random() < .061391) {this.tempo =rnd(60,220);}

    // 2. The "Variation" Math (Mutation)
    // 50% chance to play the shape backwards (Retrograde)
    if (Math.random() > 0.5) shape = shape.reverse();
    // 20% chance to flip it upside down (Inversion)
    if (Math.random() > 0.8) shape = shape.map(n => -n);

    // 3. The "Rhythm" Math
    // Define how "busy" this specific phrase will be (0.0 to 1.0)
    const density = Math.random(); 
    
    this.currentMotif = [];
    let noteIndex = 0;

    for(let i=0; i<16; i++) {
        // LOGIC:
        // Always play the first note (i===0) so the loop feels grounded.
        // Otherwise, use Math.random() against our 'density'.
        
        // "On the grid" (8th notes: 0, 2, 4...)
        const isStrongBeat = (i % 2 === 0);
        
        // DECISION:
        // If we are on a strong beat, play 80% of the time.
        // If we are on a weak beat (16th), only play if this phrase is "Dense".
        const playNote = (i === 0) || 
                         (isStrongBeat && Math.random() > 0.2) || 
                         (!isStrongBeat && Math.random() > (1.2 - density));

        if (playNote) {
            this.currentMotif[i] = shape[noteIndex % shape.length];
            noteIndex++; // Move to next note in the shape
        } else {
            this.currentMotif[i] = null; // Rest
        }
    }
  }

  playBass(t, chordRoot) {
    // Play the Root of the chord in the low octave
    // This grounds the music ("Dark tone")
    const freq = this.getFreq(chordRoot, -2); // Low octave
    
    // Reuse the "Cello" patch logic from Case 26
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    osc.type = 'sawtooth';
    osc.frequency.value = freq;
    
    // Lowpass filter to make it "Dark"
    const f = this.ctx.createBiquadFilter();
    f.type = 'lowpass';
    f.frequency.value = freq * 3;

    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(0.5, t + 0.05); // Bow attack
    g.gain.linearRampToValueAtTime(0, t + 0.5); // Release

    osc.connect(f); f.connect(g); g.connect(this.master);
    osc.start(t); osc.stop(t + 0.6);
  }

  playMelody(t, step) {
    // Check our generated motif for instructions
    const instruction = this.currentMotif[step];
    
    if (instruction !== null && instruction !== undefined) {
        // MAGIC TRICK: "Sequencing"
        // We take the instruction (e.g., "Arpeggio Up") and apply it 
        // starting from the CURRENT CHORD.
        
        // If chord is Am (0) and instruction is 2, we play C (3rd).
        // If chord is E (4) and instruction is 2, we play G# (3rd of E).
        
        const scaleIndex = this.currentChord + instruction;
        const freq = this.getFreq(scaleIndex, 0); // Middle octave

        // Harpsichord Sound (Case 11 Style)
        this.playHarpsichord(t, freq);
    }
  }

  // --- SOUND ENGINE (The "Castle" Tone) ---

getFreq(scaleIndex, octaveOffset) {
    let idx = scaleIndex;
    let oct = octaveOffset;
    
    // Use the CURRENT scale's length, not a hardcoded 7
    const len = this.scale.length;

    // Wrap correctly for any length (5, 7, or 8)
    // This prevents undefined values and silence
    while (idx < 0) { idx += len; oct -= 1; }
    while (idx >= len) { idx -= len; oct += 1; }
    
    // Safety check: if somehow idx is still invalid, fallback to root
    const interval = this.scale[idx] !== undefined ? this.scale[idx] : 0;
    
    return this.keyRoot * Math.pow(2, (interval + (oct * 12)) / 12);
  }

  playHarpsichord(t, freq) {
    // 1. The Quill (Pluck Noise) - Essential for realism
    const noise = this.ctx.createBufferSource();
    const b = this.ctx.createBuffer(1, 400, this.ctx.sampleRate);
    const d = b.getChannelData(0);
    for(let i=0; i<400; i++) d[i] = (Math.random() * 2 - 1) * 0.1;
    noise.buffer = b;
    const ng = this.ctx.createGain();
    ng.gain.value = 0.1;
    noise.connect(ng); ng.connect(this.master);
    noise.start(t);

    // 2. The String (Sawtooth)
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    const f = this.ctx.createBiquadFilter();

    osc.type = 'sawtooth'; // The classic 8-bit "String"
    osc.frequency.value = freq;

    // Filter Envelope: "Twang"
    f.type = 'lowpass';
    f.frequency.setValueAtTime(freq * 8, t); // Start Bright
    f.frequency.exponentialRampToValueAtTime(freq * 2, t + 0.1); // Decay quickly

    // Amp Envelope: No Sustain (Plucked)
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(0.25, t + 0.01); // Snap attack
    g.gain.exponentialRampToValueAtTime(0.001, t + 0.6); // Short decay

    osc.connect(f); f.connect(g); g.connect(this.master);
    osc.start(t); osc.stop(t + 0.7);
  }
}
// MODULE 30: honey
class HoneyModule {
  constructor(ctx, dest) {
    this.ctx = ctx;
    this.dest = dest;
    this.timer = null;

    // --- SETTINGS ---
    this.tempo = 140; // Bouncy and fast
    this.tickCount = 0;

    // --- MIXER ---
    // We need a compressor because the "twangs" have high peaks
    this.master = ctx.createGain();
    this.master.gain.value = 0.6;

    this.comp = ctx.createDynamicsCompressor();
    this.comp.threshold.value = -12;
    this.comp.ratio.value = 12;
    this.comp.attack.value = 0.005;

    // A slight "Slapback" delay adds to the disorienting feel
    this.delay = ctx.createDelay();
    this.delay.delayTime.value = 0.12; // 120ms slap
    this.delayGain = ctx.createGain();
    this.delayGain.gain.value = 0.2;

    this.master.connect(this.comp);
    this.comp.connect(this.dest);
    this.comp.connect(this.delay);
    this.delay.connect(this.delayGain);
    this.delayGain.connect(this.dest);

    // --- MUSICAL DATA ---
    // The "Wrong" Chord Progression: G -> F -> E -> Eb (Chromatic descent)
    // It feels like falling down stairs.
    this.chords = [
        { root: 196.00, name: 'G' }, 
        { root: 174.61, name: 'F' }, 
        { root: 164.81, name: 'E' }, 
        { root: 155.56, name: 'Eb' } 
    ];
  }

  start() {
    this.tickCount = 0;
    this.loop();
  }

  stop() {
    if (this.timer) clearTimeout(this.timer);
    this.master.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.2);
    setTimeout(() => {
        this.master.disconnect();
        this.comp.disconnect();
    }, 300);
  }

  loop() {
    const secondsPerBeat = 60 / this.tempo;
    const interval = (secondsPerBeat / 4) * 1000; // 16th notes

    this.timer = setTimeout(() => this.loop(), interval);

    const t = this.ctx.currentTime;
    const step = this.tickCount % 16;
    const bar = Math.floor(this.tickCount / 16);
    
    // Change chord every 2 bars to let the weirdness settle in
    const chordIdx = Math.floor(bar / 2) % 4; 
    const rootFreq = this.chords[chordIdx].root;

    // --- 1. THE "BOING" GUITARS (Rhythm) ---
    // Pattern: X-x-X-x (Constant down-up strumming feel)
    // We vary the pitch bend amount to simulate human error
    if (step % 2 === 0) {
        const isAccent = (step % 4 === 0);
        // Play Root and Fifth
        this.playTwang(t, rootFreq, isAccent); 
        this.playTwang(t, rootFreq * 1.5, isAccent); // The Fifth
    }

    // --- 2. THE "WAIL" (Voice/Lead) ---
    // This mimics the "Honnnney Piiiiie" scream.
    // It creates a layer of "voices" that slide around.
    if (step === 0 || step === 8) {
        if (Math.random() > 0.3) {
            // Pick a target note (3rd or 7th of the chord)
            const interval = (Math.random() > 0.5) ? 1.25 : 1.8; // Major 3rd or 7th approx
            this.playWail(t, rootFreq * interval);
        }
    }

    // --- 3. THE THUMP (Percussion) ---
    // Very dead, dry kick
    if (step % 4 === 0) {
        this.playThump(t);
    }

    this.tickCount++;
  }

  // --- SYNTHESIS ENGINES ---

  // The "Rubber Band" Guitar Sound
  playTwang(t, freq, accent) {
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    const f = this.ctx.createBiquadFilter();

    osc.type = 'sawtooth';
    
    // PITCH BEND: This is the secret sauce.
    // Start slightly sharp and bend down quickly.
    // This simulates the string stretching when plucked hard.
    const bendAmount = accent ? 15 : 5; // Hz
    osc.frequency.setValueAtTime(freq + bendAmount, t);
    osc.frequency.exponentialRampToValueAtTime(freq, t + 0.1);

    // DETUNE: Randomly detune every note slightly for that "broken" feel
    osc.detune.value = (Math.random() * 20) - 10;

    // FILTER: The "Pluck"
    f.type = 'lowpass';
    f.Q.value = 2; // Resonance adds the "twang"
    f.frequency.setValueAtTime(3000, t);
    f.frequency.exponentialRampToValueAtTime(100, t + 0.15); // Fast decay

    // GAIN
    const vol = accent ? 0.3 : 0.15;
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(vol, t + 0.005);
    g.gain.exponentialRampToValueAtTime(0.001, t + 0.2);

    osc.connect(f);
    f.connect(g);
    g.connect(this.master);

    osc.start(t);
    osc.stop(t + 0.25);
  }

  // The "Weird Voice" Sound
  playWail(t, targetFreq) {
    // We stack 2 oscillators to sound like a chorus of voices
    for (let i = 0; i < 2; i++) {
        const osc = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        
        // Triangle waves sound hollow/flute-like (or vocal-ish)
        osc.type = 'triangle';

        // PORTAMENTO (The Slide)
        // Start from a random pitch nearby and slide to the target
        const startFreq = targetFreq * (0.8 + (Math.random() * 0.4)); 
        osc.frequency.setValueAtTime(startFreq, t);
        // Long, slow slide (0.4 seconds)
        osc.frequency.exponentialRampToValueAtTime(targetFreq, t + 0.4);

        // VIBRATO
        // Add wobble to the frequency
        const vib = this.ctx.createOscillator();
        vib.frequency.value = 6; // Fast wobble
        const vibGain = this.ctx.createGain();
        vibGain.gain.value = 15; // Wide wobble
        vib.connect(vibGain);
        vibGain.connect(osc.frequency);
        vib.start(t);
        vib.stop(t + 1.0);

        g.gain.setValueAtTime(0, t);
        g.gain.linearRampToValueAtTime(0.15, t + 0.2); // Swell in
        g.gain.linearRampToValueAtTime(0, t + 1.0); // Long fade

        osc.connect(g);
        g.connect(this.master);

        osc.start(t);
        osc.stop(t + 1.1);
    }
  }

  playThump(t) {
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    
    // A dead thud (Sine wave dropping fast)
    osc.frequency.setValueAtTime(100, t);
    osc.frequency.exponentialRampToValueAtTime(40, t + 0.1);

    g.gain.setValueAtTime(0.5, t);
    g.gain.exponentialRampToValueAtTime(0.001, t + 0.1);

    osc.connect(g);
    g.connect(this.master);
    
    osc.start(t);
    osc.stop(t + 0.15);
  }
}
// MODULE 31: harp
class HarpModule {
  constructor(ctx, dest) {
    this.ctx = ctx;
    this.dest = dest;
    this.timer = null;
    this.playHead = 0; 

    // --- MODULATION SETTINGS (Ported from Harp2) ---
    this.keySequence = [196.00, 136.63, 316.09, 160.93]; // G3, C4, Bb3, D3
    this.keyIndex = 0;
    this.baseFreq = this.keySequence[0]; 
    this.loopCount = 0; 
    this.loopsPerModulation = 2; // How many times to play composition before changing key
    
    // THE COMPOSITION (Unchanged)
    this.composition = [
        // Phrase 1: The Question
        { offset: 0,  dur: 0.5 },
        { offset: 7,  dur: 0.5 },
        { offset: 10, dur: 1.5, chord: [0, 7, 10, 14] }, // Gm7
        { offset: 14, dur: 0.5 },
        { offset: 15, dur: 2.0 },
        
        // Phrase 2: The Reflection
        { offset: 19, dur: 0.5, chord: [-4, 3, 7, 12] }, // EbM7
        { offset: 15, dur: 0.5 },
        { offset: 12, dur: 0.5 },
        { offset: 10, dur: 2.5 },

        // Phrase 3: The Turn
        { offset: 8,  dur: 0.5, chord: [-7, 0, 3, 8] },  // Cm
        { offset: 7,  dur: 0.5 },
        { offset: 3,  dur: 1.5 },
        
        // The Hope Lift
        { offset: 2,  dur: 0.5, chord: [2, 6, 9, 14] },  // D7
        { offset: 6,  dur: 0.5 },
        { offset: 9,  dur: 3.0 },

        // Loop Tail
        { offset: null, dur: 2.0 } 
    ];

    // AUDIO GRAPH
    this.master = ctx.createGain();
    this.master.gain.value = 0.5;

    this.convolver = ctx.createConvolver();
    this.convolver.buffer = this.createImpulse(3.5);
    this.reverbGain = ctx.createGain();
    this.reverbGain.gain.value = 0.45;

    this.padGain = ctx.createGain();
    this.padGain.gain.value = 0.15;
    this.activePadOscs = [];

    this.master.connect(dest);
    this.master.connect(this.convolver);
    this.convolver.connect(this.reverbGain);
    this.reverbGain.connect(dest);
    this.padGain.connect(dest);
  }

  start() {
    // RESET STATE
    this.playHead = 0;
    this.loopCount = 0;
    this.keyIndex = 0;
    this.baseFreq = this.keySequence[0];
    
    this.playStep();
  }

  stop() {
    if (this.timer) clearTimeout(this.timer);
    this.killPad();
  }

  playStep() {
    const event = this.composition[this.playHead];
    const t = this.ctx.currentTime;

    // Play Melody
    if (event.offset !== null) {
        const velocity = 0.2 + (Math.random() * 0.1); 
        this.playVoice(event.offset, t, velocity);
    }

    // Play Chords
    if (event.chord) {
        this.updatePad(event.chord);
    }

    // --- LOOP & MODULATION LOGIC ---
    this.playHead++;
    
    // Check if we reached the end of the composition
    if (this.playHead >= this.composition.length) {
        this.playHead = 0; // Wrap around
        this.loopCount++;

        // Check if it's time to modulate
        if (this.loopCount >= this.loopsPerModulation) {
            this.loopCount = 0; // Reset loop counter
            
            // Move to next key
            this.keyIndex++;
            if (this.keyIndex >= this.keySequence.length) {
                this.keyIndex = 0;
            }
            
            // Apply new frequency
            this.baseFreq = this.keySequence[this.keyIndex];
            
            // Optional: Kill previous pads so chords don't clash during transition
            this.killPad(); 
        }
    }
    
    // Rubato
    const humanize = 1.0 + ((Math.random() * 0.1) - 0.05); 
    const nextTime = (event.dur * humanize) * 1000; 

    this.timer = setTimeout(() => this.playStep(), nextTime);
  }

  playVoice(semitone, t, vol) {
    // Calculates freq based on current baseFreq (which changes now!)
    const freq = this.baseFreq * Math.pow(2, semitone / 12);

    const carrier = this.ctx.createOscillator();
    const modulator = this.ctx.createOscillator();
    const modGain = this.ctx.createGain();
    const env = this.ctx.createGain();

    carrier.type = 'sine';
    carrier.frequency.value = freq;

    modulator.type = 'sine';
    modulator.frequency.value = freq * 2; 
    
    modGain.gain.setValueAtTime(freq * 1.5, t); 
    modGain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);

    modulator.connect(modGain);
    modGain.connect(carrier.frequency);
    
    carrier.connect(env);
    env.connect(this.master);

    env.gain.setValueAtTime(0, t);
    env.gain.linearRampToValueAtTime(vol, t + 0.02); 
    env.gain.exponentialRampToValueAtTime(vol * 0.5, t + 0.3); 
    env.gain.exponentialRampToValueAtTime(0.001, t + 3.0); 

    carrier.start(t);
    modulator.start(t);
    carrier.stop(t + 3.1);
    modulator.stop(t + 3.1);
  }

  updatePad(chordOffsets) {
      const t = this.ctx.currentTime;
      
      // Clean up old pad notes
      this.activePadOscs.forEach(item => {
          if (item.g) item.g.gain.setTargetAtTime(0, t, 0.5);
          if (item.osc) item.osc.stop(t + 2.0);
      });
      this.activePadOscs = [];

      chordOffsets.forEach(offset => {
          // Calculates freq based on current baseFreq
          const freq = (this.baseFreq * 0.5) * Math.pow(2, offset / 12);
          
          const osc = this.ctx.createOscillator();
          const g = this.ctx.createGain();
          
          osc.type = 'triangle'; 
          osc.frequency.value = freq;
          osc.detune.value = (Math.random() * 6) - 3;

          g.gain.setValueAtTime(0, t);
          g.gain.linearRampToValueAtTime(0.06, t + 1.5); 

          osc.connect(g);
          g.connect(this.padGain);
          osc.start(t);

          this.activePadOscs.push({osc: osc, g: g});
      });
  }

  killPad() {
      const t = this.ctx.currentTime;
      this.activePadOscs.forEach(item => {
          if (item.g) {
             item.g.gain.cancelScheduledValues(t);
             item.g.gain.setValueAtTime(item.g.gain.value, t);
             item.g.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
          }
          if (item.osc) {
             item.osc.stop(t + 0.5);
          }
      });
      this.activePadOscs = [];
  }

  createImpulse(duration) {
    const rate = this.ctx.sampleRate;
    const len = rate * duration;
    const buff = this.ctx.createBuffer(2, len, rate);
    const L = buff.getChannelData(0);
    const R = buff.getChannelData(1);
    for (let i = 0; i < len; i++) {
        const decay = Math.pow(1 - (i / len), 3);
        L[i] = (Math.random() * 2 - 1) * decay;
        R[i] = (Math.random() * 2 - 1) * decay;
    }
    return buff;
  }
}
// MODULE 32: harp2
class Harp2Module {
  constructor(ctx, dest) {
    this.ctx = ctx;
    this.dest = dest;
    this.timer = null;
    this.isStopped = false; // <--- 1. SAFETY FLAG

    // --- 1. SETTINGS ---
    this.tempo = 72; 
    
    // --- KEY MODULATION SETTINGS ---
    this.keyIndex = 0;
    this.keySequence = [196.00, 261.63, 233.08, 146.83];
    
    this.baseFreq = this.keySequence[0]; 
    this.cycleCount = 0; 
    this.scale = [0, 2, 3, 5, 7, 8, 11]; 

    // --- 2. MIXER ---
    this.master = ctx.createGain();
    this.master.gain.value = 0.6; 

    this.reverb = ctx.createConvolver();
    try {
        this.reverb.buffer = this.createImpulse(3.0);
    } catch(e) { console.log("Reverb buffer error", e); } // Safety catch

    this.reverbGain = ctx.createGain();
    this.reverbGain.gain.value = 0.45; 

    this.master.connect(this.dest);
    this.master.connect(this.reverb);
    this.reverb.connect(this.reverbGain);
    this.reverbGain.connect(this.dest);

    // --- 3. STATE ---
    this.tick = 0;
    this.phraseBar = 0;
    this.section = 'THEME'; 

    // Melody Logic
    this.melodyNoteIndex = 4; 
    this.isRunning = false;
  }

  createImpulse(duration) {
    const rate = this.ctx.sampleRate;
    const len = rate * duration;
    const buf = this.ctx.createBuffer(2, len, rate);
    for (let i = 0; i < len; i++) {
        const decay = Math.pow(1 - (i / len), 3); 
        buf.getChannelData(0)[i] = (Math.random() * 2 - 1) * decay;
        buf.getChannelData(1)[i] = (Math.random() * 2 - 1) * decay;
    }
    return buf;
  }

  start() {
    this.isStopped = false; // Reset flag
    this.tick = 0;
    this.phraseBar = 0;
    this.section = 'THEME';
    this.keyIndex = 0;
    this.baseFreq = this.keySequence[0];
    this.cycleCount = 0;
    
    // Reset volume in case it was faded out previously
    this.master.gain.cancelScheduledValues(this.ctx.currentTime);
    this.master.gain.setValueAtTime(0.6, this.ctx.currentTime);
    
    this.schedule();
  }

  stop() {
    this.isStopped = true; // <--- 2. ACTIVATE KILL SWITCH
    
    if (this.timer) {
        clearTimeout(this.timer);
        this.timer = null;
    }

    // Fade out to avoid clicking
    const t = this.ctx.currentTime;
    this.master.gain.cancelScheduledValues(t);
    this.master.gain.setValueAtTime(this.master.gain.value, t);
    this.master.gain.linearRampToValueAtTime(0, t + 0.5);

    // Hard disconnect after fade
    setTimeout(() => { 
        this.master.disconnect(); 
        this.reverbGain.disconnect(); 
    }, 600);
  }

  schedule() {
    // <--- 3. CHECK KILL SWITCH IMMEDIATELY
    // If stop() was called, abort this function instantly.
    if (this.isStopped) return; 

    const secondsPerBeat = 60 / this.tempo;
    const stepTime = secondsPerBeat / 4; 
    
    // Recursive loop
    this.timer = setTimeout(() => this.schedule(), stepTime * 1000);

    const step = this.tick % 16;
    const t = this.ctx.currentTime;

    const cycleLength = 80; 
    const cyclePos = this.tick % cycleLength;

    if (cyclePos === 64) {
        this.section = 'CHORDS';
        this.phraseBar = 0; 
    }
    else if (cyclePos === 0) {
        this.section = 'THEME';
        this.phraseBar = 0;

        // --- KEY CHANGE LOGIC ---
        if (this.tick > 0) {
          this.cycleCount++; // <--- Added missing increment
          
          if (this.cycleCount >= 3) { // Changed == to >= for safety
            this.cycleCount = 0; // <--- FIXED: Added 'this.'
            
            this.keyIndex++;
            if (this.keyIndex >= this.keySequence.length) {
                this.keyIndex = 0; 
            }
            this.baseFreq = this.keySequence[this.keyIndex];
            this.melodyNoteIndex = 4; 
          }
        }
    }

    // --- BACKGROUND STRINGS ---
    // Safety check: Only play if not stopped
    if (!this.isStopped) {
        if (step === 0) {
            this.playStringPad(t, this.section === 'THEME' ? 0 : 5); 
        }

        if (this.section === 'THEME') {
            this.playThemeSection(t, step);
        } else {
            this.playChordSection(t, step);
        }
    }

    this.tick++;
  }

  // ... rest of your methods (playThemeSection, playChordSection, etc) remain the same ...
  // Be sure to include the helper methods below:

  playThemeSection(t, step) {
    if (step % 4 === 0) this.playHarp(t, 0, 0.25, 'backing'); 
    if (step % 4 === 2) this.playHarp(t, 4, 0.15, 'backing'); 

    if (step === 0) {
        this.phraseBar++;
        this.isRunning = (this.phraseBar % 4 === 3); 
        if (!this.isRunning) {
            this.melodyNoteIndex += Math.floor(Math.random() * 3) - 1; 
        }
    }

    if (this.isRunning) {
        this.melodyNoteIndex += (this.phraseBar % 2 === 0 ? 1 : -1); 
        if (this.melodyNoteIndex > 14) this.melodyNoteIndex -= 7;
        if (this.melodyNoteIndex < 0) this.melodyNoteIndex += 7;

        this.playHarp(t, this.melodyNoteIndex + 7, 0.3, 'lead'); 
    } 
    else {
        if (step === 0 || step === 8) {
            if (Math.random() > 0.8) {
                this.playHarp(t, this.melodyNoteIndex + 7, 0.3, 'lead');
                this.playHarp(t + 0.12, this.melodyNoteIndex + 8, 0.2, 'lead');
                this.playHarp(t + 0.24, this.melodyNoteIndex + 7, 0.3, 'lead');
            } else {
                this.playHarp(t, this.melodyNoteIndex + 7, 0.4, 'lead');
            }
        }
    }
  }

  playChordSection(t, step) {
    const arpPattern = [0, 2, 4, 7, 9, 7, 4, 2]; 
    const idx = arpPattern[step % 8];
    this.playHarp(t, idx + 7, 0.2, 'lead');
  }

  getFreq(index) {
    let idx = index;
    let oct = 0;
    const len = this.scale.length;
    while(idx < 0) { idx += len; oct--; }
    while(idx >= len) { idx -= len; oct++; }
    const semitone = this.scale[idx];
    return this.baseFreq * Math.pow(2, (semitone + (oct * 12)) / 12);
  }

  playHarp(t, index, vol, type) {
    if (this.isStopped) return; // Extra audio safety

    const freq = this.getFreq(index); 
    
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    const filter = this.ctx.createBiquadFilter();
    
    osc.type = 'triangle'; 
    osc.frequency.value = freq;

    filter.type = 'lowpass';
    filter.frequency.setValueAtTime(type === 'lead' ? 4000 : 2000, t);
    filter.frequency.exponentialRampToValueAtTime(300, t + 0.3); 

    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(vol, t + 0.01); 
    const decay = (type === 'lead') ? 1.2 : 0.6;
    g.gain.exponentialRampToValueAtTime(0.001, t + decay); 

    osc.connect(filter);
    filter.connect(g);
    g.connect(this.master);
    
    osc.start(t);
    osc.stop(t + decay + 0.1);
  }

  playStringPad(t, rootIndex) {
    if (this.isStopped) return;

    const offsets = [0, 2, 4];
    
    offsets.forEach(o => {
        const freq = this.getFreq(rootIndex + o);
        
        const osc = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        
        osc.type = 'sawtooth';
        osc.frequency.value = freq;
        osc.detune.value = (Math.random() * 10) - 5; 

        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 600; 

        g.gain.setValueAtTime(0, t);
        g.gain.linearRampToValueAtTime(0.08, t + 1.0); 
        g.gain.linearRampToValueAtTime(0, t + 3.5); 

        osc.connect(filter);
        filter.connect(g);
        g.connect(this.master);
        
        osc.start(t);
        osc.stop(t + 4.0);
    });
  }
}// MODULE 33: 
//Module 33: hero
class HeroLyreModule {
  constructor(ctx, dest) {
    this.ctx = ctx;
    this.dest = dest;
    this.timer = null;
    this.beatDuration = 0.6; // 100 BPM - A marching pace

    // --- TUNING OF THE HEROES ---
    // D Dorian Mode (The "Spartan" Scale)
    // Brave, ancient, slightly somber but strong.
    // D, E, F, G, A, B, C
    this.baseFreq = 146.83; // D3 (Open low string)
    // Intervals in semitones
    this.scale = [0, 2, 3, 5, 7, 9, 10, 12, 14, 15, 17]; 

    // --- ACOUSTIC SPACE ---
    // The Campfire: Outdoors, near trees. 
    // Sound doesn't ring forever like a cave; it slaps back once or twice.
    this.convolver = ctx.createConvolver();
    this.convolver.buffer = this.createCampfireImpulse(1.5); // Short, distinct echo
    this.master = ctx.createGain();
    this.master.gain.value = 0.6;

    // Signal Chain
    this.reverbGain = ctx.createGain();
    this.reverbGain.gain.value = 0.3; // Drier than the cave, more intimate

    this.master.connect(dest);
    this.master.connect(this.convolver);
    this.convolver.connect(this.reverbGain);
    this.reverbGain.connect(dest);

    // --- STATE ---
    this.measureCount = 0;
  }

  start() {
    this.measureCount = 0;
    this.playNextMeasure();
  }

  stop() {
    if (this.timer) clearTimeout(this.timer);
  }

  // --- THE BARD'S BRAIN ---
  playNextMeasure() {
    const t = this.ctx.currentTime;
    
    // We cycle through a "Song Structure" to make it feel composed
    // 1. The Drone (Rhythmic base)
    // 2. The Call (Melody)
    // 3. The Response (Chords)
    
    // Every measure has a strong downbeat
    this.playStrongBass(t);

    const r = Math.random();

    // VARIATION 1: The "March" (Rhythmic Chugging) - 40%
    if (r < 0.4) {
        this.playMarchingRhythm(t);
        this.timer = setTimeout(() => this.playNextMeasure(), this.beatDuration * 4 * 1000);
    } 
    // VARIATION 2: The "Epic Tale" (Rising Melody) - 40%
    else if (r < 0.8) {
        this.playHeroicMelody(t);
        this.timer = setTimeout(() => this.playNextMeasure(), this.beatDuration * 4 * 1000);
    } 
    // VARIATION 3: The "Rally" (Big Strum) - 20%
    else {
        this.strumFullChord(t);
        // Pause for effect
        this.timer = setTimeout(() => this.playNextMeasure(), this.beatDuration * 6 * 1000);
    }

    this.measureCount++;
  }

  // --- TECHNIQUES ---

  playStrongBass(t) {
      // The "Drone" note that grounds the army. Low D.
      // Played with a harder attack (more "twang")
      this.playString(0, -1, 0, 0.5, 'hard'); 
      // Add the Fifth (A) for a "Power Chord" feel
      this.playString(4, -1, 0.05, 0.4, 'hard');
  }

  playMarchingRhythm(t) {
      // Play a rhythmic pattern: Bum-ba-dum-dum
      // Eighth notes
      const beat = this.beatDuration;
      
      // Muted strikes (shorter duration)
      // Note index 4 is the Fifth (A), which sounds heroic over the D root
      this.playString(4, -1, beat * 1.5, 0.3, 'mute'); 
      this.playString(0, 0, beat * 2.0, 0.3, 'mute'); 
      this.playString(4, -1, beat * 2.5, 0.3, 'mute'); 
      this.playString(7, 0, beat * 3.0, 0.4, 'hard'); // Accent the end
  }

  playHeroicMelody(t) {
      // Ascending intervals inspire courage (moving up!)
      const beat = this.beatDuration;
      
      // Pick a starting note in the mid-range
      let noteIdx = 2 + Math.floor(Math.random()*3); 
      
      // Play 3 or 4 notes rising
      for(let i=0; i<4; i++) {
          const degree = this.scale[noteIdx + i];
          // Use syncopation (off-beats) to make it catchy
          const time = t + (beat * (0.5 + i)); 
          
          if (degree !== undefined) {
             this.playString(noteIdx + i, 0, beat * i, 0.4, 'soft');
          }
      }
      
      // End on a high, long ringing note (The "Victory" note)
      setTimeout(() => {
          this.playString(noteIdx + 4, 0, 0, 0.5, 'hard');
      }, beat * 3.5 * 1000);
  }

  strumFullChord(t) {
      // Rapid sweep across all strings
      // D Minor / Dorian Chord
      const notes = [0, 2, 4, 7, 9]; // Root, 3rd, 5th, 8ve, 9th
      let delay = 0;
      notes.forEach(n => {
          this.playString(n, 0, delay, 0.35, 'hard');
          delay += 0.05; // Fast strum
      });
  }

  // --- SYNTHESIS (The Kithara/Lyre) ---
  playString(degree, octaveOffset, delay, vol, style) {
      const t = this.ctx.currentTime + delay;
      
      // Freq Calc
      const octave = Math.floor(degree / 7) + octaveOffset;
      const semitone = this.scale[degree % this.scale.length] || 0;
      const freq = this.baseFreq * Math.pow(2, (semitone + (octave * 12)) / 12);

      const osc = this.ctx.createOscillator();
      // Sawtooth is richer/buzzier than Triangle -> sounds like gut strings
      osc.type = 'sawtooth'; 
      osc.frequency.value = freq;

      const filter = this.ctx.createBiquadFilter();
      filter.type = 'lowpass';
      
      // --- ARTICULATION HANDLING ---
      let attackTime = 0.02;
      let decayTime = 2.5; // Standard ring
      let filterMax = 3000;

      if (style === 'hard') {
          filterMax = 5000; // Brighter snap
          vol *= 1.2;
      } else if (style === 'mute') {
          decayTime = 0.2; // Palm mute! Very short.
          filterMax = 1000; // Dull sound
      }

      // Filter Envelope (The "Pluck")
      filter.frequency.setValueAtTime(200, t);
      filter.frequency.exponentialRampToValueAtTime(filterMax, t + attackTime);
      filter.frequency.exponentialRampToValueAtTime(freq, t + 0.5);

      // Amplitude Envelope
      const g = this.ctx.createGain();
      g.gain.setValueAtTime(0, t);
      g.gain.linearRampToValueAtTime(vol, t + attackTime);
      g.gain.exponentialRampToValueAtTime(0.001, t + decayTime);

      osc.connect(filter);
      filter.connect(g);
      g.connect(this.master);

      osc.start(t);
      osc.stop(t + decayTime + 0.1);
  }

  // --- IMPULSE RESPONSE (The Forest Campfire) ---
  createCampfireImpulse(duration) {
      const rate = this.ctx.sampleRate;
      const length = rate * duration;
      const impulse = this.ctx.createBuffer(2, length, rate);
      const L = impulse.getChannelData(0);
      const R = impulse.getChannelData(1);

      for (let i = 0; i < length; i++) {
          // Linear decay (outdoors), not exponential (cave)
          const n = i / length;
          const noise = (Math.random() * 2 - 1);
          
          // Introduce a "Slapback" echo (reflection off a tree)
          // Echo at 0.3 seconds
          let echo = 0;
          if (i > rate * 0.3 && i < rate * 0.35) {
              echo = 0.5; 
          }

          // Combined shape
          const shape = (1 - n) + echo;
          
          // Muffle the tail quickly (dirt floor absorbs sound)
          L[i] = noise * shape * 0.5;
          R[i] = noise * shape * 0.5;
      }
      return impulse;
  }
}

// MODULE 34: Dark Castle
class DarkCastleModule {
    constructor(ctx, dest) {
        this.ctx = ctx;
        this.dest = dest;
        this.timer = null;
        this.isPlaying = false;

        this.tempo = 160; 
        this.nextNoteTime = 0.0;
        this.tick = 0;
        this.scheduleAheadTime = 0.1;
        this.lookahead = 25.0;
        
        
        this.baseRoot = 220.00; // A3
        this.movements = [
            { 
                name: "Harmonic Minor",
                rootRatio: 1.0, // A (220 * 1)
                scale: [0, 2, 3, 5, 7, 8, 11] 
            },
            { 
                name: "Lydian",
                rootRatio: 0.8, // F (approx, going down a major 3rd)
                scale: [0, 1, 3, 5, 6, 8, 10] 
            },
            { 
                name: "Major",
                rootRatio: 1.189, // C (approx, up a minor 3rd)
                scale: [0, 1, 4, 5, 6, 9, 10]
            },
            { 
                name: "Phrygian Dominant",
                rootRatio: 1.498, // E (approx, up a 5th)
                scale: [0, 1, 3, 5, 7, 8, 10]
            }
        ];
            this.lengths = {
            expo: 4,     // I made this longer (was 2) to let the theme breathe
            episode: 4,  // Standard length
            recursive: 1,
            development: 1,
            cadenza: 2,   // Standard length
            finale:0
        };
        this.sequence = ['expo', 'episode','expo',  'episode', 'cadenza','recursive'];
        this.currentMovementIndex = 0;

        // --- MIXER ---
        this.master = ctx.createGain();
        this.master.gain.value = 2;

        // 1. COMPRESSOR 
        this.compressor = ctx.createDynamicsCompressor();
        this.compressor.threshold.value = -18;
        this.compressor.ratio.value = 8;
        this.compressor.attack.value = 0.05;

        // 2. WARMTH FILTER 
        this.warmthFilter = ctx.createBiquadFilter();
        this.warmthFilter.type = 'lowpass';
        this.warmthFilter.frequency.value = 2200; 
        this.warmthFilter.Q.value = 0.5;

        // 3. REVERB 
        this.reverb = ctx.createConvolver();
        this.reverb.buffer = this.createImpulse(2.8);
        this.revGain = ctx.createGain();
        this.revGain.gain.value = 2.05;

        // CHAIN
        this.compressor.connect(this.warmthFilter);
        this.warmthFilter.connect(this.master);
        this.master.connect(this.dest);
        this.warmthFilter.connect(this.reverb);
        this.reverb.connect(this.revGain);
        this.revGain.connect(this.dest);
    }

    createImpulse(duration) {
        const rate = this.ctx.sampleRate;
        const len = rate * duration;
        const buf = this.ctx.createBuffer(2, len, rate);
        for (let i = 0; i < len; i++) {
            const k = Math.pow(1 - i / len, 2.0); 
            buf.getChannelData(0)[i] = (Math.random() * 2 - 1) * k * 0.5;
            buf.getChannelData(1)[i] = (Math.random() * 2 - 1) * k * 0.5;
        }
        return buf;
    }

    start() {
        if (this.isPlaying) return;
        this.ctx.resume();
        this.isPlaying = true;
        this.nextNoteTime = this.ctx.currentTime + 0.1;
        this.tick = 0;
        this.scheduler();
    }

    stop() {
        this.isPlaying = false;
        if (this.timer) clearTimeout(this.timer);
        this.master.gain.cancelScheduledValues(this.ctx.currentTime);
        this.master.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.5);
        setTimeout(() => {
            this.master.gain.setValueAtTime(0.4, this.ctx.currentTime);
        }, 600);
    }

    scheduler() {
        while (this.nextNoteTime < this.ctx.currentTime + this.scheduleAheadTime) {
            this.scheduleNote(this.tick, this.nextNoteTime);
            this.advanceNote();
        }
        if (this.isPlaying) {
            this.timer = setTimeout(() => this.scheduler(), this.lookahead);
        }
    }

    advanceNote() {
        const secondsPerBeat = 60.0 / this.tempo;
        this.nextNoteTime += 0.25 * secondsPerBeat;
        this.tick++;
    }

    scheduleNote(tick, t) {
        // 1. Calculate the total length of the entire sequence in bars
        let totalSequenceBars = 0;
        for (let i = 0; i < this.sequence.length; i++) {
            const sectionName = this.sequence[i];
            totalSequenceBars += this.lengths[sectionName];
        }
        
        const totalTicks = totalSequenceBars * 16;
        
        // --- NEW CODE: KEY CHANGE LOGIC ---
        // We calculate how many full loops we've completed.
        // As 'tick' increases forever, this math automatically cycles the index (0, 1, 2, 3, 0...)
        const currentLoopIteration = Math.floor(tick / totalTicks);
        const previousIndex = this.currentMovementIndex;
        
        this.currentMovementIndex = currentLoopIteration % this.movements.length;

        // Optional: Log the change so you can see it happening in the console
        if (this.currentMovementIndex !== previousIndex) {
            console.log(`Modulating to: ${this.movements[this.currentMovementIndex].name}`);
        }
        // ----------------------------------

        // 2. Determine where we are in the main loop
        let loopTick = tick % totalTicks;
        let currentTickPointer = 0;

        // 3. Find which step of the sequence we are currently in
        for (let i = 0; i < this.sequence.length; i++) {
            const sectionName = this.sequence[i];
            const sectionLenBars = this.lengths[sectionName];
            const sectionLenTicks = sectionLenBars * 16;

            // Check if our current position falls inside this section
            if (loopTick < currentTickPointer + sectionLenTicks) {
                
                // We found the active section!
                const localTick = loopTick - currentTickPointer;
                const localBar = Math.floor(localTick / 16);
                const step = localTick % 16;

                if (sectionName === 'expo') {
                    this.playExposition(t, localBar, step);
                } 
                else if (sectionName === 'episode') {
                    this.playEpisode(t, localBar, step);
                } 
                else if (sectionName === 'cadenza') {
                    this.playCadenza(t, localBar, step);
                }
                else if (sectionName === 'development') {
                  this.playDevelopment(t, localBar, step);
                  }
                  else if (sectionName === 'recursive') {
                  this.playRecursive(t, localBar, step);
                  }
                break; 
            }

            currentTickPointer += sectionLenTicks;
        }
    }

    // --- ORCHESTRATION LOGIC ---
    playRecursive(t, sectionBar, step) {
    const patternBar = sectionBar % 4;
    const mov = this.movements[this.currentMovementIndex];
    
    // 1. THE "HALLWAY" DRIVE (Bass/Cello)
    // We keep the constant 8th note pulse from the Episode 
    // but we make it follow a descending "Lament" pattern
    if (step % 2 === 0) {
        const bassNotes = [0, -1, -2, -3]; // Descending tension
        this.playStrings(t, bassNotes[patternBar], -1, 'spiccato_heavy', 0.2);
    }

    // 2. THE MELODIC SEQUENCE (The "Storm")
    // We play fast 16th notes that circle around a central tone.
    // This is the same "Treatment" as your Expo but with more movement.
    
    // Pattern: A "winding" 16th note figure
    const sequence = [0, 1, 2, 1, 4, 3, 2, 3, 5, 4, 3, 4, 2, 1, 0, null];
    
    const note = sequence[step];
    if (note !== null) {
        // High Violins playing the sequence
        this.playStrings(t, note, 0, 'spiccato', 0.15);
        
        // Counter-rhythm on the off-beats (The "Whisper")
        if (step % 4 === 2) {
            this.playStrings(t, note + 2, 1, 'marcato', 0.2);
        }
    }

    // 3. THE "RISING" VARIATION
    // On Bars 2 and 3, we add a second voice an octave higher to build "Castle" height
    if (patternBar >= 2 && step % 4 === 0) {
        this.playStrings(t, note + 7, 1, 'legato', 0.8);
    }
}
playDevelopment(t, bar, step) {
    const secondsPerBeat = 60 / this.tempo;
    const isSecondHalf = (bar >= 4);
    
    // 1. THE "FOOTSTEPS" (Low Bass)
    // Only on Beat 1 and 3. Heavy, resonant, and slow.
    if (step === 0 || step === 8) {
        this.playStrings(t, 0, -2, 'basso_profundo', 2.0);
    }

    // 2. THE "CREEPING" CHORDS
    // Every 2 bars, the chord shifts down by one semitone.
    // This is a classic "Castle" technique for psychological unease.
    if (step === 0 && bar % 2 === 0) {
        const root = 0 - Math.floor(bar / 2); // Sinking feeling
        
        // Stack a "Haunted" chord: Root, Flat 5th, and Octave
        const chord = [root, root + 6, root + 12]; 
        chord.forEach(n => {
            this.playStrings(t, n, 0, 'legato_swell', 8.0); // 2-bar hold
        });
    }

    // 3. THE "ECHO" (High Violin)
    // Random, sparse notes that sound like they are bouncing off stone walls.
    if (step % 4 === 0 && Math.random() > 0.7) {
        const highNote = [7, 8, 11, 12][Math.floor(Math.random() * 4)];
        this.playStrings(t, highNote, 1, 'legato', 1.5);
    }
}
playExposition(t, sectionBar, step) {
        const patternBar = sectionBar % 4; 
        let subject, counterSubject;

        // --- PATTERN SELECTION ---
        // We swap the "sheet music" based on the current movement
        switch(this.currentMovementIndex) {
            case 1: // LYDIAN (Magical/Flowing)
                // A continuous stream of 16th notes running up and down
                subject = [0, 1, 2, 3, 4, 3, 2, 1, 0, 1, 2, 4, 2, 1, 0, null];
                // Sustained harmony notes
                counterSubject = [4, null, null, null, 6, null, null, null, 2, null, null, null, 0, null, null, null];
                break;

            case 2: // MAJOR (Heroic/Fanfare)
                // Bold leaps (Arpeggios) with pauses
                subject = [0, null, 0, 2, 4, null, 7, null, 4, 5, 4, 2, 0, null, 4, null];
                counterSubject = [4, null, 2, null, 0, null, -3, null, 0, null, 2, null, 4, null, 7, null];
                break;
            
            case 3: // PHRYGIAN (Exotic/Tension)
                // Circling the root note with that exotic flat 2nd (index 1)
                subject = [0, 1, 0, null, 0, 1, 4, 1, 0, 1, 0, -1, 0, 1, 0, null];
                counterSubject = [4, 5, 4, null, 1, 2, 1, null, 0, 1, 0, null, -3, -1, 0, null];
                break;

            default: // HARMONIC MINOR (Original)
                // The jagged, Bach-like counterpoint
                subject = [7, null, 5, null, 6, null, 4, null, 5, null, 3, null, 4, null, 2, null];
                counterSubject = [4, null, null, null, 5, null, null, null, 3, null, null, null, 6, null, 2, null];
                break;
        }

        // --- PLAYBACK LOGIC ---
        
        // Bar 0: Main Theme
        if (patternBar === 0) {
             if (subject[step] !== null) this.playStrings(t, subject[step], 0, 'marcato', 0.25);
        } 
        // Bar 1: Counterpoint enters
        else if (patternBar === 1) {
             if (counterSubject[step] !== null) this.playStrings(t, counterSubject[step], 0, 'legato', 0.9);
             if (subject[step] !== null) this.playStrings(t, subject[step], -1, 'marcato', 0.25);
        } 
        // Bars 2 & 3: Harmony (Procedural Falls)
        else if (patternBar === 2 || patternBar === 3) {
            if (step % 2 === 0) {
                // We keep this procedural math because descending scales sound good in every mode
                const scalar = 7 - (step/2) - ((patternBar-2)*8); 
                this.playStrings(t, scalar, 0, 'spiccato', 0.25); 
                this.playStrings(t, scalar - 2, -1, 'spiccato', 0.25); 
            }
        }
    }

   playEpisode(t, sectionBar, step) {
        const patternBar = sectionBar % 4;
        
        // Root offsets (Chord progression: i - VI - iv - V usually, but adapts to scale)
        let rootOffset = 0;
        if (patternBar === 0) rootOffset = 3; 
        if (patternBar === 1) rootOffset = 1; 
        if (patternBar === 2) rootOffset = 2; 
        if (patternBar === 3) rootOffset = 4; 

        // --- VARY THE CELLO ARPEGGIO ---
        let arpeggioPattern;
        switch(this.currentMovementIndex) {
            case 1: // Lydian: Open 5ths and 7ths for a dreamy feel
                 arpeggioPattern = [0, 4, 6, 4]; 
                 break;
            case 3: // Phrygian: Aggressive alternation
                 arpeggioPattern = [0, 1, 0, 4]; 
                 break;
            default: // Minor/Major: Standard Triad
                 arpeggioPattern = [0, 4, 2, 4]; 
                 break;
        }

        const noteIdx = arpeggioPattern[step % 4];
        
        // CELLOS (Bassline)
        if (step % 2 === 0) {
             const degree = rootOffset + (noteIdx===4?4:noteIdx===2?2:noteIdx===6?6:noteIdx===1?1:0);
             this.playStrings(t, degree, -1, 'spiccato_heavy', 0.2); 
        }

        // SOLO VIOLIN (High Melody)
        if (step === 0 || step === 8) {
            // Descending melody
            const melodyNote = 9 - patternBar; 
            // In Phrygian, let's make the violin cry a bit longer
            const dur = (this.currentMovementIndex === 3) ? 3.5 : 2.0; 
            this.playStrings(t, melodyNote, 0, 'legato', dur); 
        }
    }

   playCadenza(t, sectionBar, step) {
        const totalLen = this.lengths.cadenza;
        const finaleLen = this.lengths.finale;

        // Calculate trigger point
        const isFinale = sectionBar >= (totalLen - finaleLen);

        // --- PART A: THE BUILDUP (Procedural Arpeggios) ---
        if (!isFinale) {
            
            // 1. The Low Drone (Bass)
            // We pulse the dominant (5th degree) low in the bass to build anticipation
            if (step === 0) {
                // In scale degrees, -3 is usually the 5th below the root
                this.playStrings(t, -3, -2, 'basso_profundo', 4.0);
            }

            // 2. The Fast Arpeggios (Violins)
            if (step % 2 === 0) {
                let arpPattern;
                
                switch(this.currentMovementIndex) {
                    case 1: // LYDIAN (Magical)
                        // Major 7th chord (0, 2, 4, 6 in scale degrees = 1, 3, 5, 7)
                        // This sounds "sparkly" and floaty
                        arpPattern = [0, 2, 4, 6]; 
                        break;

                    case 2: // MAJOR (Heroic)
                        // Open structure: Root, 5th, Octave, 3rd (high)
                        // This sounds like a trumpet fanfare
                        arpPattern = [0, 4, 7, 9]; 
                        break;

                    case 3: // PHRYGIAN (Exotic)
                        // Emphasize the Flat 2nd (index 1) and the gap to the 3rd
                        // Very tense, snake-charming sound
                        arpPattern = [0, 1, 4, 7]; 
                        break;

                    default: // HARMONIC MINOR (Dark)
                        // Diminished pattern (The original code)
                        // Creates maximal tension
                        arpPattern = [1, 3, 5, 7]; 
                        break;
                }

                // Select the note from the pattern
                // We add a shift: every other bar, we move the whole pattern up 2 scale steps
                // to make the buildup feel like it's "climbing"
                const shift = (sectionBar % 2 === 0) ? 0 : 2;
                const note = arpPattern[step % 4] + shift;
                
                this.playStrings(t, note, 0, 'spiccato', 0.25);
            }
        } 
        
        // --- PART B: THE BIG FINISH (Optional) ---
        // Only triggers if finaleLen > 0
        else if (sectionBar === (totalLen - finaleLen) && step === 0) {
             const durationInBeats = finaleLen * 4; 

             // For the big final chord, we stack Root, 3rd, and 5th
             this.playStrings(t, 0, -1, 'legato_swell', durationInBeats); 
             this.playStrings(t, 2, 0, 'legato_swell', durationInBeats);
             this.playStrings(t, 4, -1, 'legato_swell', durationInBeats);
        }
    }

    getFrequency(degree, octave) {
        // --- NEW MODULATION LOGIC ---
        const mov = this.movements[this.currentMovementIndex];
        const scaleMap = mov.scale;
        const currentRoot = this.baseRoot * mov.rootRatio;

        let idx = degree;
        let octOffset = octave;
        const len = scaleMap.length;

        // Wrap around the scale degrees (e.g., degree 8 becomes degree 1 + 1 octave)
        while (idx < 0) { idx += len; octOffset--; }
        while (idx >= len) { idx -= len; octOffset++; }

        const semi = scaleMap[idx];
        
        // Calculate frequency based on the DYNAMIC root and DYNAMIC scale
        return currentRoot * Math.pow(2, (semi + (octOffset * 12)) / 12);
    }

    playStrings(t, degree, octave, articulation, durationInBeats) {
        const freq = this.getFrequency(degree, octave);
        this.playDualOscillator(t, freq, 0.3, articulation, durationInBeats);
    }

    playDualOscillator(t, freq, baseVol, articulation, durationInBeats) {
        const secondsPerBeat = 60.0 / this.tempo;
        const dur = durationInBeats * secondsPerBeat;

        let attack = 0.1, release = 0.2, detuneAmount = 10, filterCutoff = 1200;
        
        if (articulation === 'legato') {
            attack = 0.4; release = 0.5; filterCutoff = 900; detuneAmount = 8;
        } 
        else if (articulation === 'legato_swell') {
            attack = 1.0; release = 2.0; filterCutoff = 800; detuneAmount = 12;
        }
        else if (articulation === 'marcato') {
            attack = 0.08; release = 0.2; filterCutoff = 1500;
        } 
        else if (articulation === 'spiccato') {
            attack = 0.02; release = 0.1; filterCutoff = 1800;
            if (dur > 0.2) dur = 0.15; 
        }
        else if (articulation === 'spiccato_heavy') {
            attack = 0.03; release = 0.15; filterCutoff = 1000;
        }
        else if (articulation === 'basso_profundo') {
            attack = 0.8; release = 0.8; filterCutoff = 400; detuneAmount = 5;
        }

        this.createVoice(t, freq, 'sawtooth', -detuneAmount, baseVol * 0.5, attack, dur, release, filterCutoff);
        this.createVoice(t, freq, 'sawtooth', detuneAmount, baseVol * 0.5, attack, dur, release, filterCutoff);
    }

    createVoice(t, freq, type, detune, vol, att, dur, rel, cutoff) {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();

        osc.type = type;
        osc.frequency.value = freq;
        osc.detune.value = detune;

        filter.type = 'lowpass';
        filter.frequency.value = cutoff;
        filter.Q.value = 1; 

        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.compressor);

        if (dur < att + rel) {
             const scale = dur / (att + rel);
             att *= scale; rel *= scale;
        }

        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(vol, t + att);
        gain.gain.setValueAtTime(vol, t + dur - rel);
        gain.gain.linearRampToValueAtTime(0, t + dur);

        osc.start(t);
        osc.stop(t + dur + 0.2); 

        osc.onended = () => {
            osc.disconnect();
            filter.disconnect();
            gain.disconnect();
        };
    }
}
// MODULE 35: King Battle
class KingBattleModule {
  constructor(ctx, dest) {
    this.ctx = ctx;
    this.dest = dest;
    this.timer = null;
    this.isPlaying = false;

    // Default Tempo (used as fallback)
    this.tempo = 170; 
    
    this.tick = 0;
    this.nextNoteTime = 0.0;
    this.scheduleAheadTime = 0.1;
    this.lookahead = 25.0;

    this.baseRoot = 261.63; 

    // --- 2. SEQUENCE & STRUCTURE CONTROL ---
    // NEW: We store 'bars' and specific 'tempo' for each section
    this.sectionData = {
        INTRO:            { bars: 4, tempo: 160 }, // Slow, heavy, crushing
        THEME_A_SPARSE:   { bars: 4, tempo: 165 }, // Speed up for the fight
        THEME_A_FULL:     { bars: 4, tempo: 170 }, // Maintain speed
        THEME_B:          { bars: 4, tempo: 165 }, // Slightly faster (Panic)
        THEME_C:          { bars: 2, tempo: 170 }, // New Melodic Section
        THEME_D:          { bars: 4, tempo: 170 }, // New Sustained Section
        THEME_E:          { bars: 4, tempo: 175 }, // SUSTAINED / FULL (Tutti)
        THEME_F:          { bars: 6, tempo: 160 }, // The "Rising Storm"
        BRIDGE:           { bars: 1.25, tempo: 155 }, // The "Cool Down"
        CLIMAX:           { bars: 2, tempo: 180 }, // The fastest, most intense part
        TRANSITION:       { bars: 1, tempo: 160 }  // SUDDEN drop to half-time feel
    };

    // The Sequence
    this.sequence = [
      
        'INTRO', 
        'THEME_A_SPARSE', 
        'THEME_A_FULL', 
        'THEME_C',
        'THEME_D',
        'THEME_E',
        'BRIDGE',
        'CLIMAX', 
        
        'THEME_B',
        'THEME_F',
        
        'TRANSITION'
    ];

    // --- 3. MODULATION ENGINE ---
    this.movements = [];
    const semitoneRatio = 1.059463;
    const noteNames = ["C", "C#", "D", "Eb", "E", "F", "F#", "G", "Ab", "A", "Bb", "B"];
    
    for (let i = 0; i < 12; i++) {
        this.movements.push({
            name: `${noteNames[i]} Minor`,
            rootRatio: Math.pow(semitoneRatio, i) 
        });
    }
    this.currentMovementIndex = 0;

    // --- 4. MIXER ---
    this.master = ctx.createGain();
    this.master.gain.value = 1;

    this.reverb = ctx.createConvolver();
    this.reverb.buffer = this.createImpulse(2.0);
    this.revGain = ctx.createGain();
    this.revGain.gain.value = 0.3;

    this.master.connect(this.dest);
    this.master.connect(this.reverb);
    this.reverb.connect(this.revGain);
    this.revGain.connect(this.dest);
  }

  createImpulse(duration) {
    const rate = this.ctx.sampleRate;
    const len = rate * duration;
    const buf = this.ctx.createBuffer(2, len, rate);
    for (let i = 0; i < 2; i++) {
      const ch = buf.getChannelData(i);
      for (let j = 0; j < len; j++) {
        ch[j] = (Math.random() * 2 - 1) * Math.pow(1 - j / len, 3); 
      }
    }
    return buf;
  }

  start() {
    if (this.isPlaying) return;
    this.ctx.resume();
    this.isPlaying = true;
    this.nextNoteTime = this.ctx.currentTime + 0.1;
    this.tick = 0;
    this.scheduler();
  }

  stop() {
    this.isPlaying = false;
    if (this.timer) clearTimeout(this.timer);
    this.master.gain.cancelScheduledValues(this.ctx.currentTime);
    this.master.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.4);
    setTimeout(() => {
        this.master.gain.setValueAtTime(0.5, this.ctx.currentTime);
    }, 500);
  }

  // --- THE SCHEDULER ENGINE (From DarkCastle) ---
  
  scheduler() {
    while (this.nextNoteTime < this.ctx.currentTime + this.scheduleAheadTime) {
      this.scheduleNote(this.tick, this.nextNoteTime);
      this.advanceNote();
    }
    if (this.isPlaying) {
      this.timer = setTimeout(() => this.scheduler(), this.lookahead);
    }
  }

  advanceNote() {
    // 16th note resolution
    const secondsPerBeat = 60.0 / this.tempo;
    this.nextNoteTime += 0.25 * secondsPerBeat;
    this.tick++;
  }

  scheduleNote(tick, t) {
    // 1. Calculate Total Loop Length using the new object structure
    let totalSequenceBars = 0;
    this.sequence.forEach(sec => totalSequenceBars += this.sectionData[sec].bars);
    const totalTicks = totalSequenceBars * 16;

    // 2. Handle Key Change
    const currentLoopIteration = Math.floor(tick / totalTicks);
    const prevIndex = this.currentMovementIndex;
    this.currentMovementIndex = currentLoopIteration % this.movements.length;

    if (this.currentMovementIndex !== prevIndex) {
        console.log(`Modulating to: ${this.movements[this.currentMovementIndex].name}`);
    }

    // 3. Locate Current Section & UPDATE TEMPO
    let loopTick = tick % totalTicks;
    let currentTickPointer = 0;

    for (let i = 0; i < this.sequence.length; i++) {
        const sectionName = this.sequence[i];
        const data = this.sectionData[sectionName]; // Get the data object
        
        const sectionLenBars = data.bars;
        const sectionLenTicks = sectionLenBars * 16;

        if (loopTick < currentTickPointer + sectionLenTicks) {
            
            // --- NEW: TEMPO CHANGE LOGIC ---
            // If this section has a defined tempo, update the engine immediately
            if (data.tempo) {
                this.tempo = data.tempo;
            }

            // Found active section logic
            const localTick = loopTick - currentTickPointer;
            const localBar = Math.floor(localTick / 16);
            const step = localTick % 16;

            if (sectionName === 'INTRO') this.playIntro(t, localBar, step);
            else if (sectionName === 'THEME_A_SPARSE') this.playThemeA(t, localBar, step, 0);
            else if (sectionName === 'THEME_A_FULL') this.playThemeA(t, localBar, step, 1);
            else if (sectionName === 'THEME_B') this.playThemeB(t, localBar, step);
            else if (sectionName === 'TRANSITION') this.playTransition(t, localBar, step);
            else if (sectionName === 'CLIMAX') this.playClimax(t, localBar, step); // Add this line
            else if (sectionName === 'THEME_C') this.playThemeC(t, localBar, step); // Add this
            else if (sectionName === 'THEME_D') this.playThemeD(t, localBar, step);
            else if (sectionName === 'THEME_E') this.playThemeE(t, localBar, step); // Add this
            else if (sectionName === 'BRIDGE') this.playBridge(t, localBar, step); // Add this
            else if (sectionName === 'THEME_F') this.playThemeF(t, localBar, step);
            break;
        }
        currentTickPointer += sectionLenTicks;
    }
  }

  // --- MUSICAL SECTIONS (The "Sugiyama" Logic) ---
  playThemeF(t, bar, step) {
    const localBar = bar % 3; 
    const isSecondPhrase = (bar >= 2);
    const secondsPerBeat = 60 / this.tempo;
    
    // Stabs are 2 beats; the 4th note is 10 beats to bridge the 4-bar gap
    const stabDur = secondsPerBeat * 2; 
    const holdDuration = secondsPerBeat * 6; 

    // 1. HAMMER BASS
    if (step % 4 === 0) {
        this.playBass(t, 0, 0.7);
        this.playBass(t, -12, 0.5); 
        this.playTimpani(t, -12);
    }

    // 2. THE UNIFIED SEQUENCE (No playBrass allowed here)
    let note = null;
    let currentDur = stabDur;

    if (localBar === 0) {
        if (step === 0) note = 0;      
        if (step === 8) note = 2;      
    } 
    else if (localBar === 1) {
        if (step === 0) note = 3;      
        
        if (step === 8) {
            note = isSecondPhrase ? 7.25 : -5; 
            currentDur = holdDuration; 
        }
    }

    if (note !== null) {
        const chord = [note, note + 3, note + 7];
        chord.forEach(n => {
            // ONLY playTrueHold is called. Brass is gone.
            this.playTrueHold(t, n, currentDur);
            // Strings are kept as a soft "shimmer" on top of the hold
            this.playHighStrings(t, n + 12, 0.1); 
        });
    }

    // 3. TEXTURE
    const stringScale = [12, 10, 8, 7, 5, 3, 2, 0]; 
    this.playHighStrings(t, stringScale[step % 8] + (isSecondPhrase ? 24 : 12), 0.1);
    this.playSnare(t, (step % 2 === 0) ? 0.2 : 0.05);
}

// Ensure this is the ONLY version of this function in your code
playTrueHold(t, note, duration) {
    const freq = this.getFreq(note, -1);
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    const f = this.ctx.createBiquadFilter();

    osc.type = 'sawtooth';
    osc.frequency.value = freq;

    f.type = 'lowpass';
    // Lower frequency (1000) makes it sound more like a "Horn" and less like "Brass"
    f.frequency.setValueAtTime(1000, t);
    f.frequency.linearRampToValueAtTime(1400, t + duration); 

    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(0.4, t + 0.05); 
    
    // Flat sustain line
    g.gain.setValueAtTime(0.4, t + duration - 0.05); 
    g.gain.linearRampToValueAtTime(0, t + duration); 

    osc.connect(f);
    f.connect(g);
    g.connect(this.master);
    
    osc.start(t);
    osc.stop(t + duration);
}
  playBridge(t, bar, step) {
    // 1. Remove the heavy bass! 
    // We only play a very soft, low G (The Dominant) on the first beat of each bar
    if (step === 0) {
        this.playBass(t, -5, 0.2); 
    }

    // 2. High String Dissonance (The "Ghostly" layer)
    // We play two notes that are very close together (a Minor 2nd)
    // This creates a "beating" effect that sounds like anxiety.
    if (step % 8 === 0) {
        this.playHighStrings(t, 7, 0.1); // G
        this.playHighStrings(t, 8, 0.1); // Ab (Cruel dissonance)
    }

    // 3. The "Clock" Ticking
    // Instead of a snare drum, we use a tiny, short hit
    // This sounds like a timer counting down to the Climax.
    if (step % 2 === 0) {
        this.playSnare(t, 0.05);
    }

    // 4. Melodic Fragment (Solo Brass)
    // A tiny 3-note reminder of Theme A, played very softly
    const fragment = { 4: 0, 6: 2, 8: 3 }; 
    if (fragment[step] !== undefined) {
        this.playBrass(t, fragment[step], 0.1);
    }
}
  playThemeE(t, bar, step) {
    // 1. "The Hammer" Bass
    // Octave-doubled bass on every quarter note for massive weight
    if (step % 4 === 0) {
        this.playBass(t, 0, 0.7);
        this.playBass(t, -12, 0.5); // The low rumble
        this.playTimpani(t, -12);
    }

    // 2. The Tutti Chorale (Same Chords as D, but Louder)
    const melodyD = { 0: [0, 3, 7], 8: [2, 5, 8] };
    const melodyD2 = { 0: [-2, 2, 5], 8: [-5, -2, 2] };
    const currentMap = (bar % 2 === 0) ? melodyD : melodyD2;

    if (currentMap[step] !== undefined) {
        currentMap[step].forEach(note => {
            // "Fat" Brass - double triggering to simulate multiple players
            this.playBrass(t, note, 0.8);
            this.playBrass(t, note + 0.1, 0.8); // Tiny detune for thickness
        });
    }

    // 3. The "Waterfall" Strings (The "Full" element)
    // Fast 16th notes that descend over the slow chords
    // This provides the "Complexity" you wanted from the Baramos theme
    const stringScale = [12, 10, 8, 7, 5, 3, 2, 0]; 
    const stringNote = stringScale[step % 8] + 12; // High octave
    this.playHighStrings(t, stringNote, 0.15);

    // 4. Double-Time Snare
    // Constant 8th notes with accents on the 16ths
    const snareVol = (step % 2 === 0) ? 0.2 : 0.05;
    this.playSnare(t, snareVol);
}
  playThemeD(t, bar, step) {
    // 1. The "Imperial" Bass
    // Heavy, stomping quarter notes (1, 2, 3, 4)
    if (step % 4 === 0) {
        this.playBass(t, 0, 0.6); // Pedal root for stability
        this.playTimpani(t, -12);
    }

    // 2. The Grand Chorale Melody (Long Half Notes)
    // We only trigger every 8 steps (Half Note resolution)
    const melodyD = {
        0: [0, 3, 7],   // Bar 1, Beat 1: C minor triad (C, Eb, G)
        8: [2, 5, 8],   // Bar 1, Beat 3: D diminished triad (tension)
    };
    
    // Bar 2 variation
    const melodyD2 = {
        0: [-2, 2, 5],  // Bb Major feel
        8: [-5, -2, 2]  // G Major (Dominant) leading to next bar
    };

    const currentMap = (bar % 2 === 0) ? melodyD : melodyD2;

    if (currentMap[step] !== undefined) {
        const chord = currentMap[step];
        chord.forEach(note => {
            // We use long Brass notes for that "Pipe Organ" feel
            // We pass a longer duration (0.8) to playBrass
            this.playBrass(t, note, 0.8); 
            // Add Strings for a "sheen" on top
            this.playHighStrings(t, note + 12, 0.2); 
        });
    }

    // 3. The "Driving" Force (Inner Counterpoint)
    // While the melody is slow, the Snare plays a frantic 16th note roll
    // to remind the player they are still in a fight.
    const snarePattern = [1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1];
    this.playSnare(t, snarePattern[step] ? 0.1 : 0);
}
playThemeC(t, bar, step) {
    // 1. A more melodic "Basso Continuo"
    // Instead of chromatic descent, it follows a Circle of Fifths pattern
    const chordProgression = [0, -5, -2, -7]; // i - v - ii - vi feel
    const currentBass = chordProgression[bar % 4];
    
    if (step % 2 === 0) {
        this.playBass(t, currentBass, 0.4);
    }

    // 2. The "Lyrical" Melody (Sweeping Strings)
    // This is more connected (legato) than Theme A
    const melodyC = {
        0: 15, 2: 14, 4: 12, 6: 10,  // Eb -> D -> C -> Bb (Grand descent)
        8: 8,  10: 7, 12: 3, 14: 2   // Ab -> G -> Eb -> D
    };

    if (melodyC[step] !== undefined) {
        const note = melodyC[step];
        // We use Strings for the main melody here to contrast Theme A's Brass
        this.playHighStrings(t, note + 12, 0.25);
        // Add a soft Brass harmony underneath
        this.playBrass(t, note, 0.1); 
    }

    // 3. Counterpoint: Answering Brass
    // The brass "responds" to the strings on the off-beats
    if (step === 4 || step === 12) {
        this.playBrass(t, currentBass + 7, 0.2); // Harmonizing the 5th
    }

    // 4. Constant Snare March
    if (step % 4 === 0 || step === 14) {
        this.playSnare(t, 0.15);
    }
}
  playIntro(t, bar, step) {
    const isDownbeat = (step === 0);
    const bassNote = -Math.floor(bar / 2); // Slow chromatic descent

    // Timpani + Bass
    if (step % 2 === 0) this.playBass(t, bassNote, 0.6);
    if (isDownbeat) this.playTimpani(t, bassNote - 12);

    // Terror Stabs (Diminished 7th)
    if (step === 0 || step === 6 || step === 12) {
        this.playStab(t, 0);
        this.playStab(t, 3);
        this.playStab(t, 6);
    }
  }

  playThemeA(t, bar, step, intensity) {
    // 1. Bass (Walking Chromatic)
    // Resets every 8 bars relative to the section start
    const bassNote = -Math.floor((bar % 8) / 2);
    
    if (step % 2 === 0) {
        this.playBass(t, bassNote, 0.5);
        if (intensity === 1) this.playBass(t, bassNote - 12, 0.4); // Octave double
    }

    // 2. Brass Melody
    const melodyMap = { 0: 12, 2: 12, 3: 14, 4: 15, 6: 12, 8: 7, 10: 7, 12: 8 };
    if (melodyMap[step] !== undefined) {
        const note = melodyMap[step];
        this.playBrass(t, note, 0.1); 
        if (intensity === 1) {
            this.playBrass(t, note + 12, 0.08); // High Octave
            this.playBrass(t, note + 4, 0.05);  // Harmony
        }
    }

    // 3. Counterpoint Strings (Only in FULL intensity)
    if (intensity === 1) {
        const counterNotes = [7, 8, 10, 8, 7, 5, 7, 8, 7, 5, 4, 5, 7, 5, 4, 3];
        this.playHighStrings(t, counterNotes[step] + 12, 0.1);
    }

    // 4. Military Snare (Only in FULL intensity)
    if (intensity === 1) {
        const snarePattern = [1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0];
        if (snarePattern[step]) {
            const vol = (step % 4 === 0) ? 0.3 : 0.1;
            this.playSnare(t, vol);
        }
    }
  }

  playThemeB(t, bar, step) {
    // Pedal point on Bass (stays on root or moves very slowly)
    const bassNote = -Math.floor((bar % 4) / 2);
    
    if (step % 2 === 0) this.playBass(t, bassNote, 0.5);
    if (step % 4 === 0) this.playSnare(t, 0.2); // Simple march beat

    // High Tension Tremolo (Diminished Arpeggios)
    const arp = [0, 3, 6, 9]; 
    const note = arp[step % 4] + 12;
    this.playHighStrings(t, note + bassNote, 0.2);
  }

  playTransition(t, bar, step) {
    const isDownbeat = (step === 0);
    const bassNote = -5; // Dominant Pedal (G) - creates tension before loop reset

    if (step % 2 === 0) this.playBass(t, bassNote, 0.6);
    if (isDownbeat) this.playTimpani(t, bassNote - 12);
  }

  // --- INSTRUMENT DEFINITIONS (Using Dynamic Frequency) ---

  getFreq(semitoneOffset, octaveOffset) {
    // MODULATION MAGIC HAPPENS HERE
    const movement = this.movements[this.currentMovementIndex];
    const currentRoot = this.baseRoot * movement.rootRatio;
    
    // Calculate final frequency
    return currentRoot * Math.pow(2, (semitoneOffset + (octaveOffset * 12)) / 12);
  }
playClimax(t, bar, step) {
    const isEighth = (step % 2 === 0);
    
    // 1. Aggressive Galloping Bass (16th note rhythm: DUM-da-da DUM-da-da)
    const bassPattern = [1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1];
    if (bassPattern[step]) {
        this.playBass(t, 0, 0.5); // Pedal C for power
    }

    // 2. High Speed "Woodwind" Runs (16th notes)
    // This creates that frantic Baroque energy
    const run = [0, 1, 4, 5, 7, 8, 11, 12]; // Harmonic Minor / Phrygian scale
    const note = run[step % 8] + 12;
    this.playHighStrings(t, note, 0.15);

    // 3. The "Evil" Fanfare (Brass)
    // Plays on Beats 1 and 3
    if (step === 0 || step === 8) {
        // Power chords (Root + Fifth)
        this.playBrass(t, 0, 0.4); 
        this.playBrass(t, 7, 0.3);
    }
    
    // 4. Chaotic Percussion
    if (step % 4 === 0) {
        this.playSnare(t, 0.4);
    }
}
  playBass(t, note, vol) {
    const freq = this.getFreq(note, -2);
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    
    osc.type = 'square'; 
    osc.frequency.value = freq;

    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(vol, t + 0.01);
    g.gain.exponentialRampToValueAtTime(0.001, t + 0.25);

    osc.connect(g);
    g.connect(this.master);
    osc.start(t);
    osc.stop(t + 0.3);
  }

  playBrass(t, note, len) {
    const freq = this.getFreq(note, -1);
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    const f = this.ctx.createBiquadFilter();

    osc.type = 'sawtooth';
    osc.frequency.value = freq;
    
    // "Bwah" Filter Envelope
    f.type = 'lowpass';
    f.Q.value = 4; 
    f.frequency.setValueAtTime(800, t);
    f.frequency.linearRampToValueAtTime(2000, t + 0.05);
    f.frequency.exponentialRampToValueAtTime(600, t + 0.4);

    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(0.3, t + 0.02);
    g.gain.linearRampToValueAtTime(0.2, t + 0.2);
    g.gain.linearRampToValueAtTime(0, t + 0.4);

    osc.connect(f);
    f.connect(g);
    g.connect(this.master);
    osc.start(t);
    osc.stop(t + 0.45);
  }

  playHighStrings(t, note, vol) {
    const freq = this.getFreq(note, 0);
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();

    osc.type = 'sawtooth';
    osc.frequency.value = freq;

    // Vibrato
    const vib = this.ctx.createOscillator();
    const vibG = this.ctx.createGain();
    vib.frequency.value = 6; 
    vibG.gain.setValueAtTime(0, t);
    vibG.gain.linearRampToValueAtTime(5, t + 0.1); 
    vib.connect(vibG);
    vibG.connect(osc.frequency);
    vib.start(t);

    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(vol, t + 0.05);
    g.gain.linearRampToValueAtTime(0, t + 0.2);

    osc.connect(g);
    g.connect(this.master);
    osc.start(t);
    osc.stop(t + 0.25);
  }

  playSnare(t, vol) {
    const rate = this.ctx.sampleRate;
    const len = rate * 0.1;
    const buf = this.ctx.createBuffer(1, len, rate);
    const data = buf.getChannelData(0);
    for(let i=0; i<len; i++) data[i] = (Math.random() * 2 - 1);

    const src = this.ctx.createBufferSource();
    src.buffer = buf;
    
    const f = this.ctx.createBiquadFilter();
    f.type = 'highpass';
    f.frequency.value = 1000;

    const g = this.ctx.createGain();
    g.gain.setValueAtTime(vol, t);
    g.gain.exponentialRampToValueAtTime(0.01, t + 0.08);

    src.connect(f);
    f.connect(g);
    g.connect(this.master);
    src.start(t);
  }

  playTimpani(t, noteIndex) {
    const freq = this.getFreq(noteIndex, -3); 
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    
    osc.type = 'sine';
    osc.frequency.value = freq;
    osc.frequency.linearRampToValueAtTime(freq * 0.8, t + 0.3);

    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(0.8, t + 0.01); 
    g.gain.exponentialRampToValueAtTime(0.01, t + 0.5);

    osc.connect(g);
    g.connect(this.master);
    osc.start(t);
    osc.stop(t + 0.6);
  }

  playStab(t, note) {
    const freq = this.getFreq(note, 0);
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    
    osc.type = 'sawtooth';
    osc.frequency.value = freq;
    osc.detune.value = (Math.random() * 10) - 5; 

    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(0.15, t + 0.01);
    g.gain.exponentialRampToValueAtTime(0.001, t + 0.3);

    osc.connect(g);
    g.connect(this.master);
    osc.start(t);
    osc.stop(t + 0.35);
  }
}
// MODULE 36: Stormy Sea
class StormModule {
    constructor(ctx, dest) {
        this.ctx = ctx;
        this.dest = dest;
        this.timer = null;
        // --- NEW: Separate timer for chaotic lightning ---
        this.lightningTimer = null; 
        this.isPlaying = false;

        // --- STORM BODY (Slow & Heavy) ---
        this.tempo = 90; 
        this.baseRoot = 110.00; // A2 (Low, Deep)
        
        this.nextNoteTime = 0.0;
        this.tick = 0;
        this.scheduleAheadTime = 0.1;
        this.lookahead = 25.0;

        // --- STORM AMBIENCE NODES ---
        this.rainNode = null;
        this.windNode = null;
        this.windFilter = null;

        // --- CASTLE BRAIN (Complex Scales) ---
        this.movements = [
            { 
                name: "Harmonic Minor", // The Original Storm
                rootRatio: 1.0, 
                scale: [0, 2, 3, 5, 7, 8, 11] 
            },
            { 
                name: "Lydian", // The Eye of the Storm (Eerie calm)
                rootRatio: 0.8, 
                scale: [0, 1, 3, 5, 6, 8, 10] 
            },
            { 
                name: "Phrygian Dominant", // The Kraken (Danger)
                rootRatio: 1.498, 
                scale: [0, 1, 3, 5, 7, 8, 10]
            }
        ];

        // --- CASTLE STRUCTURE ---
        this.lengths = {
            expo: 4,      
            episode: 4,   
            recursive: 2, // Shortened for intensity
            cadenza: 2 
        };
        // Complex song structure
        this.sequence = ['expo', 'episode', 'expo', 'recursive', 'cadenza'];
        this.currentMovementIndex = 0;

        // --- MIXER (Storm Configuration) ---
        this.master = ctx.createGain();
        this.master.gain.value = 0.6; 

        this.compressor = ctx.createDynamicsCompressor();
        // Huge Reverb for the "Ocean" feel
        this.reverb = ctx.createConvolver();
        this.reverb.buffer = this.createImpulse(4.0); 
        this.revGain = ctx.createGain();
        this.revGain.gain.value = 1.5;

        this.compressor.connect(this.master);
        this.master.connect(this.dest);
        this.master.connect(this.reverb);
        this.reverb.connect(this.revGain);
        this.revGain.connect(this.dest);
    }

    createImpulse(duration) {
        const rate = this.ctx.sampleRate;
        const len = rate * duration;
        const buf = this.ctx.createBuffer(2, len, rate);
        for (let i = 0; i < len; i++) {
            const k = Math.pow(1 - i / len, 2.0); 
            buf.getChannelData(0)[i] = (Math.random() * 2 - 1) * k * 0.8;
            buf.getChannelData(1)[i] = (Math.random() * 2 - 1) * k * 0.8;
        }
        return buf;
    }

    // --- AMBIENCE (Rain & Wind) ---
    startAmbience() {
        const t = this.ctx.currentTime;
        var lastOut = 0;

        // 1. RAIN
        const rainBufSize = this.ctx.sampleRate * 2;
        const rainBuf = this.ctx.createBuffer(1, rainBufSize, this.ctx.sampleRate);
        const rData = rainBuf.getChannelData(0);
        for(let i=0; i<rainBufSize; i++) {
            const white = Math.random() * 2 - 1;
            rData[i] = (lastOut + (0.02 * white)) / 1.02;
            lastOut = rData[i];
            rData[i] *= 3.5; 
        }

        this.rainNode = this.ctx.createBufferSource();
        this.rainNode.buffer = rainBuf;
        this.rainNode.loop = true;
        const rainFilter = this.ctx.createBiquadFilter();
        rainFilter.type = 'lowpass';
        rainFilter.frequency.value = 800;
        const rainGain = this.ctx.createGain();
        rainGain.gain.value = 0.15;

        this.rainNode.connect(rainFilter);
        rainFilter.connect(rainGain);
        rainGain.connect(this.dest);
        this.rainNode.start(t);

        // 2. WIND
        const windBufSize = this.ctx.sampleRate * 4;
        const windBuf = this.ctx.createBuffer(1, windBufSize, this.ctx.sampleRate);
        const wData = windBuf.getChannelData(0);
        for(let i=0; i<windBufSize; i++) wData[i] = Math.random() * 2 - 1;

        this.windNode = this.ctx.createBufferSource();
        this.windNode.buffer = windBuf;
        this.windNode.loop = true;
        this.windFilter = this.ctx.createBiquadFilter();
        this.windFilter.type = 'bandpass';
        this.windFilter.frequency.value = 200;
        this.windFilter.Q.value = 2;
        const windGain = this.ctx.createGain();
        windGain.gain.value = 0.1;

        this.windNode.connect(this.windFilter);
        this.windFilter.connect(windGain);
        windGain.connect(this.dest);
        this.windNode.start(t);

        this.animateWind();
    }

    animateWind() {
        if(!this.isPlaying) return;
        const t = this.ctx.currentTime;
        const randomFreq = 150 + Math.random() * 400;
        const randomTime = 2 + Math.random() * 3;
        this.windFilter.frequency.linearRampToValueAtTime(randomFreq, t + randomTime);
        setTimeout(() => this.animateWind(), randomTime * 1000);
    }

    stopAmbience() {
        if (this.rainNode) { this.rainNode.stop(); this.rainNode = null; }
        if (this.windNode) { this.windNode.stop(); this.windNode = null; }
    }

    // --- NEW: CHAOTIC LIGHTNING LOOP ---
    scheduleRandomLightning() {
        if (!this.isPlaying) return;

        // 1. Calculate random characteristics
        // Time until next strike: anywhere between 2s and 15s. Highly variable.
        const timeUntilStrike = 2.0 + Math.random() * 13.0;
        const t = this.ctx.currentTime + timeUntilStrike;

        // Pitch: Lower = distant rumble (40Hz), Higher = close crack (100Hz)
        const freq = 40 + Math.random() * 60;

        // Volume: Related to pitch (closer tends to be louder)
        // Map the frequency range roughly to volume range (0.3 - 0.6)
        const vol = 0.3 + ((freq - 40) / 60) * 0.3;

        // 2. Schedule the sound
        // We schedule it slightly in the future so the playDrum processing has time
        this.playDrum(t + 0.1, freq, vol);

        // 3. Schedule next recursive call independently of musical tempo
        if (this.lightningTimer) clearTimeout(this.lightningTimer);
        this.lightningTimer = setTimeout(() => this.scheduleRandomLightning(), timeUntilStrike * 1000);
    }

    // --- SEQUENCER ---

    start() {
        if (this.isPlaying) return;
        this.ctx.resume();
        this.isPlaying = true;
        this.startAmbience();
        // Start the independent lightning loop
        this.scheduleRandomLightning(); 
        this.nextNoteTime = this.ctx.currentTime + 0.1;
        this.tick = 0;
        this.scheduler();
    }

    stop() {
        this.isPlaying = false;
        this.stopAmbience();
        if (this.timer) clearTimeout(this.timer);
        // Stop the lightning loop
        if (this.lightningTimer) clearTimeout(this.lightningTimer);
        this.master.gain.cancelScheduledValues(this.ctx.currentTime);
        this.master.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.5);
    }

    scheduler() {
        while (this.nextNoteTime < this.ctx.currentTime + this.scheduleAheadTime) {
            this.scheduleNote(this.tick, this.nextNoteTime);
            this.advanceNote();
        }
        if (this.isPlaying) {
            this.timer = setTimeout(() => this.scheduler(), this.lookahead);
        }
    }

    advanceNote() {
        const secondsPerBeat = 60.0 / this.tempo;
        this.nextNoteTime += 0.25 * secondsPerBeat;
        this.tick++;
    }

    scheduleNote(tick, t) {
        // (Removed old grid-based lightning trigger here)

        // --- SEQUENCE LOGIC (From Dark Castle) ---
        let totalSequenceBars = 0;
        for (let i = 0; i < this.sequence.length; i++) totalSequenceBars += this.lengths[this.sequence[i]];
        const totalTicks = totalSequenceBars * 16;
        
        const currentLoopIteration = Math.floor(tick / totalTicks);
        this.currentMovementIndex = currentLoopIteration % this.movements.length;

        let loopTick = tick % totalTicks;
        let currentTickPointer = 0;

        for (let i = 0; i < this.sequence.length; i++) {
            const sectionName = this.sequence[i];
            const sectionLenTicks = this.lengths[sectionName] * 16;

            if (loopTick < currentTickPointer + sectionLenTicks) {
                const localTick = loopTick - currentTickPointer;
                const localBar = Math.floor(localTick / 16);
                const step = localTick % 16;

                // Routing to Orchestration Logic
                if (sectionName === 'expo') this.playExposition(t, localBar, step);
                else if (sectionName === 'episode') this.playEpisode(t, localBar, step);
                else if (sectionName === 'recursive') this.playRecursive(t, localBar, step);
                else if (sectionName === 'cadenza') this.playCadenza(t, localBar, step);
                
                break; 
            }
            currentTickPointer += sectionLenTicks;
        }
    }

    // --- ORCHESTRATION TRANSLATION LAYER ---
    // Here we take Dark Castle logic but play it with Storm Instruments

    playExposition(t, sectionBar, step) {
        const patternBar = sectionBar % 4; 
        let subject, counterSubject;

        // Determine Theme based on current Scale (Movement)
        switch(this.currentMovementIndex) {
            case 1: // LYDIAN (The Magical Sea)
                subject = [0, 1, 2, 3, 4, 3, 2, 1, 0, 1, 2, 4, 2, 1, 0, null];
                counterSubject = [4, null, null, null, 6, null, null, null, 2, null, null, null, 0, null, null, null];
                break;
            case 2: // PHRYGIAN (The Monster)
                subject = [0, 1, 0, null, 0, 1, 4, 1, 0, 1, 0, -1, 0, 1, 0, null];
                counterSubject = [4, 5, 4, null, 1, 2, 1, null, 0, 1, 0, null, -3, -1, 0, null];
                break;
            default: // HARMONIC MINOR (The Storm)
                subject = [7, null, 5, null, 6, null, 4, null, 5, null, 3, null, 4, null, 2, null];
                counterSubject = [4, null, null, null, 5, null, null, null, 3, null, null, null, 6, null, 2, null];
                break;
        }

        // MAPPING:
        // Subject (Fast) -> 'cello_spic' (Rolling waves)
        // CounterSubject (Slow) -> 'horn_swell' (Foghorns)

        if (patternBar === 0) {
            if (subject[step] !== null) this.playInstrument(t, subject[step], -1, 'cello_spic', 0.25);
        } 
        else if (patternBar === 1) {
            if (counterSubject[step] !== null) this.playInstrument(t, counterSubject[step], -1, 'horn_swell', 2.0); // Long Foghorn
            if (subject[step] !== null) this.playInstrument(t, subject[step], -2, 'cello_spic', 0.25);
        } 
        else if (patternBar >= 2) {
             // Falling Scales
            if (step % 2 === 0) {
                const scalar = 7 - (step/2) - ((patternBar-2)*8); 
                this.playInstrument(t, scalar, -1, 'cello_spic', 0.25); 
                // Add a brass hit on the first beat of the fall for impact
                if(step === 0) this.playInstrument(t, scalar, -2, 'brass_hit', 0.5);
            }
        }
    }

    playEpisode(t, sectionBar, step) {
        const patternBar = sectionBar % 4;
        let rootOffset = [3, 1, 2, 4][patternBar]; // Standard progression

        let arpeggioPattern;
        // Vary arpeggio by movement
        if(this.currentMovementIndex === 1) arpeggioPattern = [0, 4, 6, 4]; 
        else if(this.currentMovementIndex === 2) arpeggioPattern = [0, 1, 0, 4]; 
        else arpeggioPattern = [0, 4, 2, 4];

        const noteIdx = arpeggioPattern[step % 4];

        // MAPPING:
        // Arpeggio -> 'string_trem' (Shivering/Anxiety high up)
        // Bass -> 'pad' (Deep ocean pressure)

        if (step % 2 === 0) {
             const degree = rootOffset + (noteIdx===4?4:noteIdx===2?2:noteIdx===6?6:noteIdx===1?1:0);
             // High tremolo strings for the arpeggio
             this.playInstrument(t, degree, 1, 'string_trem', 0.2); 
        }

        // On bar start, play a deep pad
        if (step === 0) {
            const melodyNote = 9 - patternBar; 
            this.playInstrument(t, melodyNote, -1, 'pad', 4.0);
        }
    }

    playRecursive(t, sectionBar, step) {
        const patternBar = sectionBar % 4;
        
        // MAPPING:
        // This is the "Hallway Drive" or "Kraken Awakening"
        // We use Brass Hits for the aggressive rhythm

        if (step % 2 === 0) {
            const bassNotes = [0, -1, -2, -3]; 
            this.playInstrument(t, bassNotes[patternBar], -2, 'cello_spic', 0.2);
        }

        const sequence = [0, 1, 2, 1, 4, 3, 2, 3, 5, 4, 3, 4, 2, 1, 0, null];
        const note = sequence[step];

        if (note !== null) {
            // Main riff
            this.playInstrument(t, note, 0, 'string_stab', 0.15);
            
            // Off-beat Brass accents
            if (step % 4 === 2) {
                this.playInstrument(t, note - 2, -1, 'brass_hit', 0.2);
            }
        }
    }

    playCadenza(t, sectionBar, step) {
        // Procedural buildup using plucks ('string_stab')
        
        // 1. Low Drone
        if (step === 0) {
            this.playInstrument(t, -3, -2, 'horn_swell', 4.0);
        }

        // 2. Rising Plucks
        if (step % 2 === 0) {
            let arpPattern = [1, 3, 5, 7]; // Default Diminished
            if (this.currentMovementIndex === 1) arpPattern = [0, 2, 4, 6]; // Lydian sparkle
            
            const shift = (sectionBar % 2 === 0) ? 0 : 2;
            const note = arpPattern[step % 4] + shift;
            
            // Use 'string_stab' for a pizzicato feel
            this.playInstrument(t, note, 0, 'string_stab', 0.25);
        }
    }


    // --- SYNTHESIS ENGINE (Storm Instruments) ---

    getFrequency(degree, octave) {
        const mov = this.movements[this.currentMovementIndex];
        const scaleMap = mov.scale;
        const currentRoot = this.baseRoot * mov.rootRatio;
        let idx = degree;
        let octOffset = octave;
        const len = scaleMap.length;
        while (idx < 0) { idx += len; octOffset--; }
        while (idx >= len) { idx -= len; octOffset++; }
        const semi = scaleMap[idx];
        return currentRoot * Math.pow(2, (semi + (octOffset * 12)) / 12);
    }

    playInstrument(t, degree, octave, type, durBeats) {
        const freq = this.getFrequency(degree, octave);
        const secondsPerBeat = 60.0 / this.tempo;
        const dur = durBeats * secondsPerBeat;

        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();

        osc.frequency.setValueAtTime(freq, t); 
        osc.detune.value = (Math.random() * 10) - 5; // Analog drift

        // INSTRUMENT PATCHES
        if (type === 'horn_swell') {
            osc.type = 'sawtooth';
            filter.frequency.setValueAtTime(200, t);
            filter.frequency.linearRampToValueAtTime(2000, t + 0.05); 
            filter.frequency.exponentialRampToValueAtTime(200, t + 0.5); 
            
            gain.gain.setValueAtTime(0, t);
            gain.gain.linearRampToValueAtTime(0.4, t + dur * 0.5);
            gain.gain.linearRampToValueAtTime(0, t + dur);
        } 
        else if (type === 'cello_spic') {
            osc.type = 'sawtooth';
            filter.frequency.value = 600;
            gain.gain.setValueAtTime(0.3, t);
            gain.gain.exponentialRampToValueAtTime(0.01, t + 0.25); // Slightly longer for 90BPM
        }
        else if (type === 'string_trem') {
            osc.type = 'triangle';
            osc.detune.value = Math.random() * 30 - 15; // More Wobble
            filter.frequency.value = 2000;
            gain.gain.setValueAtTime(0, t);
            gain.gain.linearRampToValueAtTime(0.2, t + 0.05);
            gain.gain.linearRampToValueAtTime(0, t + 0.25);
        }
        else if (type === 'brass_hit') {
            osc.type = 'sawtooth';
            filter.frequency.setValueAtTime(200, t);
            filter.frequency.exponentialRampToValueAtTime(2000, t + 0.05); 
            filter.frequency.exponentialRampToValueAtTime(200, t + 0.5);
            gain.gain.setValueAtTime(0.5, t);
            gain.gain.exponentialRampToValueAtTime(0.01, t + 0.4);
        }
        else if (type === 'pad') {
            osc.type = 'sine';
            gain.gain.setValueAtTime(0, t);
            gain.gain.linearRampToValueAtTime(0.3, t + 2);
            gain.gain.linearRampToValueAtTime(0, t + dur);
        }
        else if (type === 'string_stab') {
             osc.type = 'square'; // Sharper sound for stabs
             filter.frequency.value = 3000;
             filter.type = 'lowpass';
             gain.gain.setValueAtTime(0.3, t);
             gain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
        }

        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.compressor);

        osc.start(t);
        osc.stop(t + dur + 1); 
    }

    playDrum(t, freq, vol) {
        // Synthesized Thunder/Impact
        // We increase the pitch drop duration for a longer rumble
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.frequency.setValueAtTime(freq, t);
        osc.frequency.exponentialRampToValueAtTime(10, t + 1.5); // Longer rumble
        gain.gain.setValueAtTime(vol, t);
        gain.gain.exponentialRampToValueAtTime(0.001, t + 2.0); // Longer tail
        osc.connect(gain);
        gain.connect(this.compressor);
        osc.start(t);
        osc.stop(t + 2.5);
    }
}
// MODULE 37: Otherworld
class OtherworldModule {
  constructor(ctx, dest) {
    this.ctx = ctx;
    this.dest = dest;
    this.isPlaying = false;
    this.timer = null;

    // --- 1. SETTINGS ---
    this.tempo = 40; 
    this.rootFreq = 349.23; // Start at F4
        
    // --- SCALE LIBRARY ---
    this.scales = {
      // Your Requests (Octatonic / Diminished Symmetrical):
        MAJOR:          [0, 2, 3, 5, 7, 9, 11],       // Serene, Open
        HARMONIC_MINOR: [0, 2, 3, 5, 7, 8, 11],       // Sorrowful, Classical
       LYDIAN:         [0, 2, 4, 6, 7, 9, 11],       // Dreamy, Floating
        
      OCTATONIC_1:    [0, 1, 3, 4, 6, 7, 9, 10],    // Tension, Mystery (Half-Whole)
        OCTATONIC_2:    [0, 2, 3, 5, 6, 8, 9, 11]     // Magic, Unstable (Whole-Half)
    };
    
    // Start with Major
    this.currentScaleName = 'OCTATONIC_1';
    this.scaleIntervals = this.scales.OCTATONIC_1;

    // STATE
    this.tick = 0;
    this.barIndex = 0;
    this.currentPhrase = [];

    // --- 2. MIXER ---
    this.master = ctx.createGain();
    this.master.gain.value = 0.5;

    this.reverb = ctx.createConvolver();
    this.reverb.buffer = this.createImpulse(5.0); 
    
    this.revFilter = ctx.createBiquadFilter();
    this.revFilter.type = 'lowpass';
    this.revFilter.frequency.value = 800; 

    this.revGain = ctx.createGain();
    this.revGain.gain.value = 0.4; 

    this.master.connect(this.dest);
    this.master.connect(this.reverb);
    this.reverb.connect(this.revFilter);
    this.revFilter.connect(this.revGain);
    this.revGain.connect(this.dest);
  }

  createImpulse(duration) {
    const rate = this.ctx.sampleRate;
    const len = rate * duration;
    const buf = this.ctx.createBuffer(2, len, rate);
    for (let i = 0; i < 2; i++) {
      const ch = buf.getChannelData(i);
      for (let j = 0; j < len; j++) {
        ch[j] = (Math.random() * 2 - 1) * Math.pow(1 - j / len, 2.5); 
      }
    }
    return buf;
  }

  start() {
    if (this.isPlaying) return;
    
    if (this.ctx.state === 'suspended') {
        this.ctx.resume();
    }

    this.isPlaying = true;
    this.barIndex = 0;
    this.tick = 0;
    
    this.currentPhrase = this.composePhrase();
    this.playNextBar();
  }

  stop() {
    this.isPlaying = false;
    if (this.timer) clearTimeout(this.timer);
    
    this.master.gain.cancelScheduledValues(this.ctx.currentTime);
    this.master.gain.setValueAtTime(this.master.gain.value, this.ctx.currentTime);
    this.master.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 2.0);
    
    setTimeout(() => { 
        this.master.disconnect(); 
        this.revGain.disconnect(); 
    }, 2100);
  }

  // --- THE MOZART BRAIN ---

  composePhrase() {
    // 4-Bar Phrase Generator
    // We use indices 0 (I), 3 (IV), 4 (V) relative to scale length
    // This works for 7-note scales perfectly. 
    // For 8-note scales, it picks interesting "alien" chords automatically.
    const prog = [0, 3, 4, 0];
    
    const textureType = Math.random() > 0.5 ? 'STRUM_AND_MELODY' : 'ARPEGGIO_FLOW';

    return prog.map(root => ({
        root: root,
        texture: textureType
    }));
  }

  // --- THE ORPHEUS HANDS ---

  playNextBar() {
    if (!this.isPlaying) return;

    const barData = this.currentPhrase[this.barIndex];
    const t = this.ctx.currentTime;
    const beatDur = 60 / this.tempo;
    
    // IMPORTANT: Get current scale length for modulo math
    const scaleLen = this.scaleIntervals.length;

    // --- HAND 1: THUMB ---
    this.scheduleThumb(t, barData, beatDur, scaleLen);

    // --- HAND 2: FINGERS ---
    if (barData.texture === 'STRUM_AND_MELODY') {
        this.scheduleStrumTexture(t, barData, beatDur, scaleLen);
    } else {
        this.scheduleArpeggioTexture(t, barData, beatDur, scaleLen);
    }

    // Schedule next bar
    const barDuration = beatDur * 4; 
    this.timer = setTimeout(() => {
        this.advanceBar();
        this.playNextBar();
    }, barDuration * 1000);
  }

  scheduleThumb(t, barData, beatDur, scaleLen) {
    // Root on Beat 1
    this.playHarpString(t, barData.root, -2, 2.0, 0.6);

    // Syncopation (Fifth)
    // We use +4 for the "Fifth" feel. In Octatonic scales (8 notes), 
    // +4 is a Tritone, creating that requested "Otherworld" dissonance.
    const fifth = (barData.root + 4) % scaleLen;
    const syncopationTime = t + (beatDur * 1.5); 
    this.playHarpString(syncopationTime, fifth, -1, 1.5, 0.4);
  }

  scheduleStrumTexture(t, barData, beatDur, scaleLen) {
    // Beat 1: Rolled Chord
    // We build chords by skipping notes (Tertian harmony)
    // Root, +2, +4, +1(9th)
    const chord = [
        { d: barData.root, o: 0 },
        { d: (barData.root + 2) % scaleLen, o: 0 },
        { d: (barData.root + 4) % scaleLen, o: 0 },
        { d: (barData.root + 1) % scaleLen, o: 1 } 
    ];

    chord.forEach((note, i) => {
        const strumDelay = i * 0.05; 
        this.playHarpString(t + strumDelay, note.d, note.o, 3.0, 0.3);
    });

    // Beat 3: Melody (The 3rd)
    const melodyNote = (barData.root + 2) % scaleLen; 
    this.playHarpString(t + (beatDur * 2), melodyNote, 1, 1.5, 0.5);

    // Beat 4: Resolution
    const resNote = barData.root;
    this.playHarpString(t + (beatDur * 3), resNote, 1, 1.5, 0.4);
  }

  scheduleArpeggioTexture(t, barData, beatDur, scaleLen) {
    // Flowing 8th notes
    const notes = [
        { d: barData.root, o: 0 },         
        { d: (barData.root + 4) % scaleLen, o: 0 }, 
        { d: (barData.root + 2) % scaleLen, o: 1 }, 
        { d: (barData.root + 6) % scaleLen, o: 1 }  
    ];

    for (let i = 0; i < 8; i++) {
        const note = notes[i % 4];
        const time = t + (i * (beatDur / 2));
        
        // Humanize
        const swing = (Math.random() * 0.03) - 0.015;
        const vol = (i % 4 === 0) ? 0.4 : 0.25;

        this.playHarpString(time + swing, note.d, note.o, 1.0, vol);
    }
  }

  advanceBar() {
    this.barIndex++;
    if (this.barIndex >= 4) {
        this.barIndex = 0;
        // 30% Chance to modulate Key AND Scale
        if (Math.random() < 0.3) this.modulateKeyAndScale();
        this.currentPhrase = this.composePhrase();
    }
  }

  modulateKeyAndScale() {
    // 1. Change Root Frequency
    const ratio = (Math.random() > 0.5) ? 1.5 : 0.66667;
    this.rootFreq *= ratio;
    
    // Safety clamp
    if (this.rootFreq < 250) this.rootFreq *= 2;
    if (this.rootFreq > 500) this.rootFreq /= 2;

    // 2. Change Scale Type
    const scaleKeys = Object.keys(this.scales);
    const newScaleName = scaleKeys[Math.floor(Math.random() * scaleKeys.length)];
    this.currentScaleName = newScaleName;
    this.scaleIntervals = this.scales[newScaleName];

    console.log(`Modulated to: ${Math.round(this.rootFreq)}Hz using ${newScaleName} scale`);
  }

  // --- THE INSTRUMENT ---

  playHarpString(t, degree, octave, duration, velocity) {
    const freq = this.getFreq(degree, octave);
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    const filter = this.ctx.createBiquadFilter();

    osc.type = 'triangle';
    osc.frequency.setValueAtTime(freq, t);

    // Pitch Envelope (Pluck)
    osc.detune.setValueAtTime(15, t);
    osc.detune.linearRampToValueAtTime(0, t + 0.1);

    // Filter Envelope (Snap)
    filter.type = 'lowpass';
    const brightness = (octave >= 1) ? 3500 : 2000;
    
    filter.frequency.setValueAtTime(brightness, t); 
    filter.frequency.exponentialRampToValueAtTime(brightness * 0.3, t + 0.05); 
    filter.frequency.exponentialRampToValueAtTime(200, t + duration);

    // Volume Envelope
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(velocity, t + 0.01); 
    g.gain.exponentialRampToValueAtTime(0.001, t + duration); 

    osc.connect(filter);
    filter.connect(g);
    g.connect(this.master);

    osc.start(t);
    osc.stop(t + duration + 0.1);
  }

  getFreq(scaleDegree, octaveOffset) {
    // Dynamic Scale Handling
    let d = scaleDegree;
    let o = octaveOffset;
    const len = this.scaleIntervals.length;

    // Wrap around based on current scale length (7 or 8)
    while (d < 0) { d += len; o -= 1; }
    while (d >= len) { d -= len; o += 1; }
    
    const semitone = this.scaleIntervals[d];
    return this.rootFreq * Math.pow(2, (semitone + (o * 12)) / 12);
  }
}
// MODULE 38: Dragon's Lair
class DragonLairModule {
  constructor(ctx, dest) {
    this.ctx = ctx;
    this.dest = dest;
    this.timer = null;
    this.isPlaying = false;

    // --- 1. SETTINGS ---
    // TEMPO: Extremely Slow (Largo). The looming darkness takes its time.
    this.tempo = 40; 
    this.tick = 0;
    
    // SCALE: C Minor (The key of tragedy and epic fate)
    // We use the "Harmonic Minor" for that ancient/magical flavor
    // C, D, Eb, F, G, Ab, B, C
    this.rootFreq = 65.41; // Low C2 (Deep Bass)
    this.scale = [0, 2, 3, 5, 7, 8, 11]; 

    // --- 2. MIXER ---
    this.master = ctx.createGain();
    this.master.gain.value = 0.4; // Keep it heavy but not clipping

    // "The Golden Hall" Reverb (Massive, stone cathedral sound)
    this.reverb = ctx.createConvolver();
    this.reverb.buffer = this.createStoneImpulse(6.0); // 6 seconds tail!
    
    this.revGain = ctx.createGain();
    this.revGain.gain.value = 0.6; 

    this.master.connect(this.dest);
    this.master.connect(this.reverb);
    this.reverb.connect(this.revGain);
    this.revGain.connect(this.dest);

    // --- 3. HARMONY (The Looming Chords) ---
    // We cycle through slow, heavy chords.
    // i (Cm) -> VI (Ab) -> V (G Major) -> i (Cm)
    this.progression = [
        [0, 3, 7],   // Cm (Tragedy)
        [8, 12, 15], // Ab Major (The Flash of Hope)
        [7, 11, 14], // G Major (The Tension/Dominant)
        [0, 3, 7]    // Cm (Return to Darkness)
    ];
  }

  createStoneImpulse(duration) {
    const rate = this.ctx.sampleRate;
    const len = rate * duration;
    const buf = this.ctx.createBuffer(2, len, rate);
    for (let i = 0; i < 2; i++) {
      const ch = buf.getChannelData(i);
      for (let j = 0; j < len; j++) {
        // Linear decay with no noise bursts (Smooth Stone)
        ch[j] = (Math.random() * 2 - 1) * (1 - j / len);
      }
    }
    return buf;
  }

  start() {
    if (this.isPlaying) return;
    this.isPlaying = true;
    this.tick = 0;
    this.loop();
  }

  stop() {
    this.isPlaying = false;
    if (this.timer) clearTimeout(this.timer);
    // Slow fade out (Cinematic)
    this.master.gain.setTargetAtTime(0, this.ctx.currentTime, 1.0);
    setTimeout(() => { 
        this.master.disconnect(); 
        this.revGain.disconnect(); 
    }, 1200);
  }

  loop() {
    if (!this.isPlaying) return;

    // SLOW BREATHING RHYTHM
    // We only change chords every 8 seconds (very slow swells)
    const beatDur = 60 / this.tempo; 
    this.timer = setTimeout(() => this.loop(), beatDur * 1000);

    const t = this.ctx.currentTime;
    
    // 1. THE BRASS SECTION (Every 4 beats, play a new chord)
    if (this.tick % 4 === 0) {
        const chordIdx = Math.floor(this.tick / 4) % this.progression.length;
        const chord = this.progression[chordIdx];
        this.playBrassChord(t, chord);
    }

    // 2. THE LONELY WOODWIND (Random melodic phrases)
    // Only plays during the silence between chords
    if (this.tick % 4 === 2 && Math.random() > 0.4) {
        this.playLonelyMelody(t);
    }

    this.tick++;
  }

  // --- INSTRUMENTS ---

  playBrassChord(t, intervals) {
    // This simulates a brass section swelling in and out
    intervals.forEach((interval, i) => {
        // Stagger the entry slightly (Humanize)
        const start = t + (i * 0.05); 
        const freq = this.rootFreq * Math.pow(2, interval / 12);

        // Double Oscillators for "Thick" sound
        const osc1 = this.ctx.createOscillator();
        const osc2 = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();

        osc1.type = 'sawtooth';
        osc1.frequency.value = freq;
        osc1.detune.value = -10; // Slight detune

        osc2.type = 'sawtooth';
        osc2.frequency.value = freq;
        osc2.detune.value = 10; 

        // BRASS FILTER ENVELOPE (The "Bwahhh" sound)
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(100, start);
        // Swell up to bright brass, then settle
        filter.frequency.linearRampToValueAtTime(800, start + 2.0); 
        filter.frequency.linearRampToValueAtTime(400, start + 6.0);

        // VOLUME ENVELOPE (Slow Swell)
        gain.gain.setValueAtTime(0, start);
        gain.gain.linearRampToValueAtTime(0.3, start + 2.0); // Slow attack
        gain.gain.linearRampToValueAtTime(0, start + 8.0);   // Long fade

        osc1.connect(filter);
        osc2.connect(filter);
        filter.connect(gain);
        gain.connect(this.master);

        osc1.start(start); osc1.stop(start + 8.5);
        osc2.start(start); osc2.stop(start + 8.5);
    });
  }

  playLonelyMelody(t) {
    // A high, mournful sound (Recorders/Oboe)
    // Pick a note from the scale, high octave
    const noteIdx = Math.floor(Math.random() * this.scale.length);
    const interval = this.scale[noteIdx];
    const freq = (this.rootFreq * 4) * Math.pow(2, interval / 12); // 2 Octaves up

    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    const vibrato = this.ctx.createOscillator();
    const vibGain = this.ctx.createGain();

    osc.type = 'triangle'; // Pure, hollow sound
    osc.frequency.value = freq;

    // Wobbly Vibrato (like an old tape or nervous player)
    vibrato.frequency.value = 4; 
    vibGain.gain.value = 5;
    vibrato.connect(vibGain);
    vibGain.connect(osc.frequency);
    vibrato.start(t);

    gain.gain.setValueAtTime(0, t);
    gain.gain.linearRampToValueAtTime(0.1, t + 0.5);
    gain.gain.linearRampToValueAtTime(0, t + 3.0);

    osc.connect(gain);
    gain.connect(this.master);
    
    osc.start(t);
    osc.stop(t + 3.0);
    vibrato.stop(t + 3.0);
  }
}
// MODULE 39: Dragon's Lair
class TombModule {
  constructor(ctx, dest) {
    this.ctx = ctx;
    this.dest = dest;
    this.timer = null;
    this.isPlaying = false;

    // --- 1. SETTINGS ---
    this.tempo = 220; 
    this.tick = 0;
    
    // MODULATION SETTINGS
    this.keyTick = 0; // Counts beats to next key change
    this.keyChangeInterval = 12; // Change key every ~30 seconds
    
    // Base Frequencies for Modulation (Eb Minor, Bb Minor, Ab Minor, B Major)
    // We store frequencies to drift between distinct "Moods"
    this.keys = [155.56, 116.54, 233.08, 185.00]; 
    this.currentKeyIndex = 0;
    this.rootFreq = this.keys[0]; // Start at Eb3

    // Scale Intervals (Minor Natural)
    this.scale = [0, 2, 3, 5, 7, 8, 10]; 

    // --- 2. MIXER ---
    this.master = ctx.createGain();
    // BOOSTED: Increased from 1.0 (internal 0.5) to full volume capability
    this.master.gain.value = 1.0; 

    // "The Weeping Hall" Reverb
    this.reverb = ctx.createConvolver();
    this.reverb.buffer = this.createEtherealImpulse(4.0); 
    
    this.revGain = ctx.createGain();
    this.revGain.gain.value = 1.1; 

    this.master.connect(this.dest);
    this.master.connect(this.reverb);
    this.reverb.connect(this.revGain);
    this.revGain.connect(this.dest);
  }

  createEtherealImpulse(duration) {
    const rate = this.ctx.sampleRate;
    const len = rate * duration;
    const buf = this.ctx.createBuffer(2, len, rate);
    for (let i = 0; i < len; i++) {
        const decay = Math.pow(1 - i / len, 4);
        buf.getChannelData(0)[i] = (Math.random() * 2 - 1) * decay;
        buf.getChannelData(1)[i] = (Math.random() * 2 - 1) * decay;
    }
    return buf;
  }

  start() {
    if (this.isPlaying) return;
    this.isPlaying = true;
    this.tick = 0;
    this.keyTick = 0;
    
    // Reset Master Volume
    this.master.gain.setValueAtTime(0, this.ctx.currentTime);
    // BOOSTED: Ramp to 0.8 instead of 0.5 for more headroom
    this.master.gain.linearRampToValueAtTime(0.8, this.ctx.currentTime + 2.0);
    
    this.loop();
  }

  stop() {
    this.isPlaying = false;
    if (this.timer) clearTimeout(this.timer);
    
    const t = this.ctx.currentTime;
    this.master.gain.cancelScheduledValues(t);
    this.master.gain.setValueAtTime(this.master.gain.value, t);
    this.master.gain.linearRampToValueAtTime(0, t + 1.5);

    setTimeout(() => { 
        this.master.disconnect(); 
        this.revGain.disconnect(); 
    }, 1600);
  }

  loop() {
    if (!this.isPlaying) return;

    const stepTime = (60 / this.tempo); 
    this.timer = setTimeout(() => this.loop(), stepTime * 1000);

    const t = this.ctx.currentTime;
    const beat = this.tick % 3; 

    // --- KEY MODULATION CHECK ---
    this.keyTick++;
    if (this.keyTick > this.keyChangeInterval) {
        this.modulateKey(t);
        this.keyTick = 0;
    }

    // --- 1. THE MOURNFUL BASS (Beat 1) ---
    if (beat === 0) {
        const note = (Math.random() > 0.7) ? 7 : 0; 
       // this.playBassSwell(t, note);
    }

    // --- 2. THE QUEEN'S SIGH (Melody) ---
    if (beat > 0 && Math.random() > 0.4) {
        this.playMelodyNote(t);
    }

    this.tick++;
  }

  // --- NEW: Key Modulation Logic ---
  modulateKey(t) {
    // Pick a new key that isn't the current one
    let newIdx;
    do {
        newIdx = Math.floor(Math.random() * this.keys.length);
    } while (newIdx === this.currentKeyIndex);
    
    this.currentKeyIndex = newIdx;
    this.rootFreq = this.keys[this.currentKeyIndex];
    
    // Optional: Log it so you know it happened
    console.log(`Modulating to freq: ${this.rootFreq}Hz`);
  }

  // --- AUDIO ENGINE ---

  playBassSwell(t, interval) {
    const freq = (this.rootFreq / 2) * Math.pow(2, interval / 12); 
    
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    const filter = this.ctx.createBiquadFilter();

    osc.type = 'sine'; 
    osc.frequency.value = freq;

    // FIX 1: FILTER ADJUSTMENT
    // Previous setting: 200Hz (Way too low for most speakers)
    // New setting: Starts at 150Hz, opens to 600Hz to let "growl" through
    filter.type = 'lowpass';
    filter.frequency.setValueAtTime(150, t); 
    filter.frequency.linearRampToValueAtTime(600, t + 1.5); 

    // FIX 2: GAIN BOOST
    g.gain.setValueAtTime(0, t);
    // Boosted from 0.3 to 0.75 so the bass is actually audible
    g.gain.linearRampToValueAtTime(0.75, t + 1.5); 
    g.gain.linearRampToValueAtTime(0, t + 4.5);

    osc.connect(filter);
    filter.connect(g);
    g.connect(this.master);
    
    osc.start(t);
    osc.stop(t + 5.0); 
  }

  playMelodyNote(t) {
    const idx = Math.floor(Math.random() * this.scale.length);
    const interval = this.scale[idx];
    const freq = this.rootFreq * Math.pow(2, interval / 12);

    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    
    osc.type = 'triangle'; 
    osc.frequency.value = freq;

    const filter = this.ctx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.value = 800; // Opened slightly from 600

    g.gain.setValueAtTime(0, t);
    // Boosted from 0.15 to 0.25 to match new bass volume
    g.gain.linearRampToValueAtTime(0.25, t + 0.5); 
    g.gain.linearRampToValueAtTime(0, t + 2.0); 

    const vib = this.ctx.createOscillator();
    vib.frequency.value = 4.5; 
    const vibG = this.ctx.createGain();
    vibG.gain.value = 5; 
    vib.connect(vibG);
    vibG.connect(osc.frequency);
    vib.start(t);

    osc.connect(filter);
    filter.connect(g);
    g.connect(this.master);
    
    osc.start(t);
    osc.stop(t + 2.1);
    vib.stop(t + 2.1);
  }
}//Module 40: High King BattleModule
// MODULE 40: Dragon's Lair
class HighKingModule {
  constructor(ctx, dest) {
    this.ctx = ctx;
    this.dest = dest;
    this.timer = null;
    this.isPlaying = false;

    // FF Style is faster and more frantic
    this.tempo = 178; 
    
    this.tick = 0;
    this.nextNoteTime = 0.0;
    this.scheduleAheadTime = 0.1;
    this.lookahead = 25.0;

    this.baseRoot = 261.63; // Middle C

    // --- 2. SEQUENCE & STRUCTURE CONTROL ---
    this.sectionData = {
        // Uematsu Intros are usually a chaotic fanfare
        INTRO:            { bars: 2, tempo: 170 }, 
        THEME_A_SPARSE:   { bars: 4, tempo: 178 }, 
        THEME_A_FULL:     { bars: 4, tempo: 178 }, 
        // The "Panic" Arpeggios
        THEME_B:          { bars: 2, tempo: 180 }, 
        // The "Heroic" Melody (The melodic emotional core)
        THEME_C:          { bars: 2, tempo: 175 }, 
        // The Tension/Sustain
        THEME_D:          { bars: 1, tempo: 178 }, 
        THEME_E:          { bars: 1, tempo: 178 }, 
        // The "Crisis" - Chromatic climbing
        THEME_F:          { bars: 1, tempo: 170 }, 
        BRIDGE:           { bars: 1, tempo: 160 }, 
        CLIMAX:           { bars: 3, tempo: 185 }, 
        TRANSITION:       { bars: 0, tempo: 160 }  
    };

    this.sequence = [
        'INTRO', 
        'THEME_A_SPARSE', 
        'THEME_A_FULL', 
        'THEME_B', // Panic comes early in FF style
        'THEME_C',
        'THEME_D',
        'THEME_E',
        'THEME_F',
        'BRIDGE',
        'CLIMAX', 
        'TRANSITION'
    ];

    // --- 3. MODULATION ENGINE ---
    this.movements = [];
    const semitoneRatio = 1.059463;
    const noteNames = ["C", "C#", "D", "Eb", "E", "F", "F#", "G", "Ab", "A", "Bb", "B"];
    
    for (let i = 0; i < 12; i++) {
        this.movements.push({
            name: `${noteNames[i]} Minor`,
            rootRatio: Math.pow(semitoneRatio, i) 
        });
    }
    this.currentMovementIndex = 0;

    // --- 4. MIXER ---
    this.master = ctx.createGain();
    this.master.gain.value = 1;

    this.reverb = ctx.createConvolver();
    this.reverb.buffer = this.createImpulse(1.5); // Shorter reverb for tighter rock feel
    this.revGain = ctx.createGain();
    this.revGain.gain.value = 0.25;

    this.master.connect(this.dest);
    this.master.connect(this.reverb);
    this.reverb.connect(this.revGain);
    this.revGain.connect(this.dest);
  }

  createImpulse(duration) {
    const rate = this.ctx.sampleRate;
    const len = rate * duration;
    const buf = this.ctx.createBuffer(2, len, rate);
    for (let i = 0; i < 2; i++) {
      const ch = buf.getChannelData(i);
      for (let j = 0; j < len; j++) {
        ch[j] = (Math.random() * 2 - 1) * Math.pow(1 - j / len, 3); 
      }
    }
    return buf;
  }

  start() {
    if (this.isPlaying) return;
    this.ctx.resume();
    this.isPlaying = true;
    this.nextNoteTime = this.ctx.currentTime + 0.1;
    this.tick = 0;
    this.scheduler();
  }

  stop() {
    this.isPlaying = false;
    if (this.timer) clearTimeout(this.timer);
    this.master.gain.cancelScheduledValues(this.ctx.currentTime);
    this.master.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.4);
    setTimeout(() => {
        this.master.gain.setValueAtTime(0.5, this.ctx.currentTime);
    }, 500);
  }

  scheduler() {
    while (this.nextNoteTime < this.ctx.currentTime + this.scheduleAheadTime) {
      this.scheduleNote(this.tick, this.nextNoteTime);
      this.advanceNote();
    }
    if (this.isPlaying) {
      this.timer = setTimeout(() => this.scheduler(), this.lookahead);
    }
  }

  advanceNote() {
    const secondsPerBeat = 60.0 / this.tempo;
    this.nextNoteTime += 0.25 * secondsPerBeat;
    this.tick++;
  }

  scheduleNote(tick, t) {
    let totalSequenceBars = 0;
    this.sequence.forEach(sec => totalSequenceBars += this.sectionData[sec].bars);
    const totalTicks = totalSequenceBars * 16;

    const currentLoopIteration = Math.floor(tick / totalTicks);
    const prevIndex = this.currentMovementIndex;
    this.currentMovementIndex = currentLoopIteration % this.movements.length;

    if (this.currentMovementIndex !== prevIndex) {
        console.log(`Modulating to: ${this.movements[this.currentMovementIndex].name}`);
    }

    let loopTick = tick % totalTicks;
    let currentTickPointer = 0;

    for (let i = 0; i < this.sequence.length; i++) {
        const sectionName = this.sequence[i];
        const data = this.sectionData[sectionName]; 
        
        const sectionLenBars = data.bars;
        const sectionLenTicks = sectionLenBars * 16;

        if (loopTick < currentTickPointer + sectionLenTicks) {
            
            if (data.tempo) this.tempo = data.tempo;

            const localTick = loopTick - currentTickPointer;
            const localBar = Math.floor(localTick / 16);
            const step = localTick % 16;

            // Route to the NEW composers logic
            if (sectionName === 'INTRO') this.playIntro(t, localBar, step);
            else if (sectionName === 'THEME_A_SPARSE') this.playThemeA(t, localBar, step, 0);
            else if (sectionName === 'THEME_A_FULL') this.playThemeA(t, localBar, step, 1);
            else if (sectionName === 'THEME_B') this.playThemeB(t, localBar, step); // The Arpeggios
            else if (sectionName === 'THEME_C') this.playThemeC(t, localBar, step); // The Melody
            else if (sectionName === 'THEME_D') this.playThemeD(t, localBar, step); // The Organ
            else if (sectionName === 'THEME_E') this.playThemeE(t, localBar, step); 
            else if (sectionName === 'THEME_F') this.playThemeF(t, localBar, step); // The Crisis
            else if (sectionName === 'BRIDGE') this.playBridge(t, localBar, step);
            else if (sectionName === 'CLIMAX') this.playClimax(t, localBar, step);
            else if (sectionName === 'TRANSITION') this.playTransition(t, localBar, step);
            
            break;
        }
        currentTickPointer += sectionLenTicks;
    }
  }

  // --- THE "FF2/FF3" COMPOSITION LOGIC ---

  playIntro(t, bar, step) {
    // A Classic "Crisis" Fanfare - Rapid triplets
    // Bar 0: BOM-BOM-BOM (Pause) BOM-BOM-BOM
    const triplet = [0, 2, 4, 8, 10, 12];
    
    if (triplet.includes(step)) {
        this.playStab(t, 0); // Root Stab
        this.playBass(t, -12, 0.4);
        this.playSnare(t, 0.3);
    }
    
    // Bar 1: A chaotic descending run
    if (bar === 1) {
        // High speed chromatic descent
        const run = [12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, -1, -2, -5];
        this.playHighStrings(t, run[step], 0.2);
    }
  }

  playThemeA(t, bar, step, intensity) {
    // THE "PROG ROCK" BASSLINE
    // Instead of walking, it drives on the root with rhythmic gaps
    const bassRhythm = [1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0];
    
    if (bassRhythm[step]) {
        // Use a Minor Pentatonic riff for the bass
        const bassNote = (step === 14) ? 3 : (step === 12 ? -2 : 0);
        this.playBass(t, bassNote, 0.5);
    }

    // THE MELODY - Syncopated Brass Stabs
    // This is very FF3 Battle 2 style
    const melody = { 0: 0, 3: 3, 6: 7, 10: 5, 12: 3, 14: 0 };
    if (melody[step] !== undefined) {
        this.playBrass(t, melody[step], 0.15);
        if (intensity === 1) {
            this.playBrass(t, melody[step] + 7, 0.1); // Harmony
        }
    }

    // Snare - Driving Backbeat
    if (step === 4 || step === 12) this.playSnare(t, 0.25);
    // Ghost notes
    if (step % 2 === 0 && step !== 4 && step !== 12 && intensity === 1) this.playSnare(t, 0.05);
  }

  playThemeB(t, bar, step) {
    // THE "PRELUDE" ARPEGGIOS (But Evil)
    // Fast 16th note arpeggios in the strings are a Uematsu staple
    
    // Bar 0/2: C Minor, Bar 1/3: Ab Major (The "Heroic" lift)
    const chord = (bar % 2 === 0) ? [0, 3, 7, 12] : [-4, 0, 3, 8];
    const noteIndex = step % 4;
    const currentNote = chord[noteIndex] + 12; // High octave

    this.playHighStrings(t, currentNote, 0.15);

    // Bass just holds the root of the chord
    if (step === 0) this.playBass(t, (bar % 2 === 0) ? 0 : -4, 0.6);

    // Constant 16th note Snare roll (building tension)
    this.playSnare(t, (step % 4 === 0) ? 0.15 : 0.05);
  }

  playThemeC(t, bar, step) {
    // MELODIC / HEROIC SECTION
    // Moving to relative Major (Eb) or VI (Ab)
    
    // Lyrical Brass Melody (Slower)
    const melody = {
        0: 3,  // Eb
        4: 2,  // D
        6: 0,  // C
        8: -2, // Bb
        12: 0, // C
        14: 5  // F
    };

    if (melody[step] !== undefined) {
        this.playBrass(t, melody[step], 0.3);
        // Harmony in strings
        this.playHighStrings(t, melody[step] + 12, 0.1);
    }

    // Walking Bass (More melodic here)
    if (step % 4 === 0) {
        // Circle of fifths movement
        const bassMoves = [0, -5, -2, -7];
        this.playBass(t, bassMoves[bar % 4], 0.4);
    }
  }

  playThemeD(t, bar, step) {
    // THE "ORGAN" GRIND
    // Simulating the dense chord textures of 8-bit organs
    
    if (step % 8 === 0) {
        // Diminished chords for tension
        const notes = [0, 3, 6, 9]; 
        notes.forEach(n => this.playBrass(t, n, 0.4)); // Long brass notes
    }

    // Galloping Bass (The "Iron Maiden" influence on FF music)
    // da-da-DUM da-da-DUM
    const gallop = [0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0];
    if (gallop[step] === 0) { // The 'DUM'
        this.playBass(t, 0, 0.5);
        this.playSnare(t, 0.1);
    }
  }

  playThemeE(t, bar, step) {
     // TUTTI - Full chaos
     // Combining the Gallop Bass with the Arpeggios
     this.playThemeB(t, bar, step); // Strings
     this.playThemeD(t, bar, step); // Bass/Brass foundation
  }

  playThemeF(t, bar, step) {
    // THE "RISING STORM" / CRISIS
    // Chromatic ascent in octaves (very dramatic)
    
    const risingNote = Math.floor(step / 2) + (bar * 8); // Chromatic climb
    
    if (step % 2 === 0) {
        // Play unison in Bass and Brass
        // Wrap around if it gets too high
        const note = (risingNote % 12); 
        this.playBass(t, note - 12, 0.6);
        this.playBrass(t, note, 0.1);
        this.playStab(t, note + 3); // Minor 3rd above for dissonance
    }
    
    // Violent Snare
    this.playSnare(t, 0.2);
  }

  playBridge(t, bar, step) {
    // THE "CRYSTAL" MOMENT
    // Silence the bass, high pitched "tinkling" only
    
    // High random-sounding pentatonic notes
    const magic = [12, 15, 17, 19, 24];
    if (step % 2 === 0) {
        const note = magic[Math.floor(Math.random() * magic.length)];
        this.playHighStrings(t, note, 0.1);
    }
    
    // Very quiet snare ticking
    if (step % 4 === 0) this.playSnare(t, 0.05);
  }

  playClimax(t, bar, step) {
    // DOUBLE TIME FEEL
    // Simulating double-kick drumming
    
    if (step % 2 === 0) this.playBass(t, 0, 0.6);
    this.playSnare(t, (step % 4 === 2) ? 0.3 : 0.05);

    // Screaming melody
    const melody = { 0: 12, 2: 15, 4: 12, 6: 19, 8: 12, 12: 7 };
    if (melody[step]) {
        this.playBrass(t, melody[step], 0.2);
        this.playStab(t, melody[step] + 12);
    }
  }

  playTransition(t, bar, step) {
    // The "Loop Reset" - Big Trill
    if (step % 2 === 0) {
        this.playTimpani(t, -5); // Dominant pedal
        this.playBrass(t, (step % 4 === 0) ? 0 : 1, 0.1); // Trill 0-1
    }
  }

  // --- INSTRUMENT DEFINITIONS (Standardized for the new style) ---

  getFreq(semitoneOffset, octaveOffset) {
    const movement = this.movements[this.currentMovementIndex];
    const currentRoot = this.baseRoot * movement.rootRatio;
    return currentRoot * Math.pow(2, (semitoneOffset + (octaveOffset * 12)) / 12);
  }

  playBass(t, note, vol) {
    const freq = this.getFreq(note, -2);
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    
    // Square wave for that NES/Famicom rock bass
    osc.type = 'square'; 
    osc.frequency.value = freq;

    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(vol, t + 0.01);
    // Shorter decay for "driving" rock feel
    g.gain.exponentialRampToValueAtTime(0.001, t + 0.15); 

    osc.connect(g);
    g.connect(this.master);
    osc.start(t);
    osc.stop(t + 0.2);
  }

  playBrass(t, note, len) {
    const freq = this.getFreq(note, -1);
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    const f = this.ctx.createBiquadFilter();

    osc.type = 'sawtooth';
    osc.frequency.value = freq;
    
    // Tighter filter envelope for "Punchy" brass
    f.type = 'lowpass';
    f.Q.value = 2; 
    f.frequency.setValueAtTime(800, t);
    f.frequency.linearRampToValueAtTime(2500, t + 0.03); // Faster attack
    f.frequency.exponentialRampToValueAtTime(600, t + 0.3);

    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(0.3, t + 0.01);
    g.gain.linearRampToValueAtTime(0.2, t + 0.1);
    g.gain.linearRampToValueAtTime(0, t + 0.3);

    osc.connect(f);
    f.connect(g);
    g.connect(this.master);
    osc.start(t);
    osc.stop(t + 0.35);
  }

  playHighStrings(t, note, vol) {
    const freq = this.getFreq(note, 0);
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();

    osc.type = 'sawtooth';
    osc.frequency.value = freq;

    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(vol, t + 0.02);
    // Very short decay to handle the fast Arpeggios without muddying
    g.gain.linearRampToValueAtTime(0, t + 0.15); 

    osc.connect(g);
    g.connect(this.master);
    osc.start(t);
    osc.stop(t + 0.2);
  }

  playSnare(t, vol) {
    const rate = this.ctx.sampleRate;
    const len = rate * 0.08; // Shorter sample for tighter beat
    const buf = this.ctx.createBuffer(1, len, rate);
    const data = buf.getChannelData(0);
    for(let i=0; i<len; i++) data[i] = (Math.random() * 2 - 1);

    const src = this.ctx.createBufferSource();
    src.buffer = buf;
    
    const f = this.ctx.createBiquadFilter();
    f.type = 'highpass';
    f.frequency.value = 800; // Crunchier

    const g = this.ctx.createGain();
    g.gain.setValueAtTime(vol, t);
    g.gain.exponentialRampToValueAtTime(0.01, t + 0.06);

    src.connect(f);
    f.connect(g);
    g.connect(this.master);
    src.start(t);
  }

  playTimpani(t, noteIndex) {
    const freq = this.getFreq(noteIndex, -3); 
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    
    osc.type = 'triangle'; // Clearer impact
    osc.frequency.value = freq;
    osc.frequency.linearRampToValueAtTime(freq * 0.8, t + 0.2);

    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(0.8, t + 0.01); 
    g.gain.exponentialRampToValueAtTime(0.01, t + 0.4);

    osc.connect(g);
    g.connect(this.master);
    osc.start(t);
    osc.stop(t + 0.5);
  }

  playStab(t, note) {
    const freq = this.getFreq(note, 0);
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    
    osc.type = 'sawtooth';
    osc.frequency.value = freq;
    // Wider detune for that "Orchestra Hit" sample feel
    osc.detune.value = (Math.random() * 14) - 7; 

    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(0.2, t + 0.01);
    g.gain.exponentialRampToValueAtTime(0.001, t + 0.15); // Very short

    osc.connect(g);
    g.connect(this.master);
    osc.start(t);
    osc.stop(t + 0.2);
  }
}
// MODULE 41: Dragon's Lair
class StormAbienceModule {
    constructor(ctx, dest) {
        this.ctx = ctx;
        this.dest = dest;
        this.timer = null;
        this.isPlaying = false;

        // SLOW TEMPO: Heavy, heaving waves
        this.tempo = 90; 
        this.nextNoteTime = 0.0;
        this.tick = 0;
        this.scheduleAheadTime = 0.1;
        this.lookahead = 25.0;
        
        // DEEP PITCH: A2 (Low)
        this.baseRoot = 110.00; 

        // AMBIENCE NODES
        this.rainNode = null;
        this.windNode = null;
        this.windFilter = null;

        // SCALES: Dark, Unstable, Ancient
        this.movements = [
            { 
                name: "Phrygian Dark", // Ancient Sea
                rootRatio: 1.0, 
                scale: [0, 1, 3, 5, 7, 8, 10] 
            },
            { 
                name: "Locrian", // The Deep / Danger
                rootRatio: 1.059, // Up a semitone (Tension)
                scale: [0, 1, 3, 5, 6, 8, 10] 
            },
            { 
                name: "Minor Pentatonic", // The Hero's Fear
                rootRatio: 1.498, // Up a 5th
                scale: [0, 3, 5, 7, 10]
            }
        ];
        
        // Structure
        this.lengths = { intro: 4, swell: 1, kraken: 2, calm: 4 };
        this.sequence = ['intro', 'swell', 'kraken', 'calm'];
        this.currentMovementIndex = 0;

        // MIXER setup (Same as Castle, slightly darker reverb)
        this.master = ctx.createGain();
        this.master.gain.value = 0.6; // Lower overall volume to let SFX shine

        this.compressor = ctx.createDynamicsCompressor();
        this.reverb = ctx.createConvolver();
        this.reverb.buffer = this.createImpulse(4.0); // Huge space
        this.revGain = ctx.createGain();
        this.revGain.gain.value = 1.5;

        this.compressor.connect(this.master);
        this.master.connect(this.dest);
        this.master.connect(this.reverb);
        this.reverb.connect(this.revGain);
        this.revGain.connect(this.dest);
    }

    createImpulse(duration) {
        // (Standard Impulse Generator)
        const rate = this.ctx.sampleRate;
        const len = rate * duration;
        const buf = this.ctx.createBuffer(2, len, rate);
        for (let i = 0; i < len; i++) {
            const k = Math.pow(1 - i / len, 2.0); 
            buf.getChannelData(0)[i] = (Math.random() * 2 - 1) * k * 0.8;
            buf.getChannelData(1)[i] = (Math.random() * 2 - 1) * k * 0.8;
        }
        return buf;
    }

    // --- AMBIENCE GENERATORS ---
    startAmbience() {
        const t = this.ctx.currentTime;
        var lastOut = 0;

        // 1. RAIN (Pink Noise + Lowpass)
        const rainBufSize = this.ctx.sampleRate * 2; // 2 sec loop
        const rainBuf = this.ctx.createBuffer(1, rainBufSize, this.ctx.sampleRate);
        const rData = rainBuf.getChannelData(0);
        for(let i=0; i<rainBufSize; i++) {
            // Simple Pink Noise approximation
            const white = Math.random() * 2 - 1;
            rData[i] = (lastOut + (0.02 * white)) / 1.02;
            lastOut = rData[i];
            rData[i] *= 3.5; 
        }

        this.rainNode = this.ctx.createBufferSource();
        this.rainNode.buffer = rainBuf;
        this.rainNode.loop = true;
        
        const rainFilter = this.ctx.createBiquadFilter();
        rainFilter.type = 'lowpass';
        rainFilter.frequency.value = 800; // Muffled rain

        const rainGain = this.ctx.createGain();
        rainGain.gain.value = 0.15; // Background level

        this.rainNode.connect(rainFilter);
        rainFilter.connect(rainGain);
        rainGain.connect(this.dest);
        this.rainNode.start(t);


        // 2. WIND (Howling Bandpass)
        const windBufSize = this.ctx.sampleRate * 4;
        const windBuf = this.ctx.createBuffer(1, windBufSize, this.ctx.sampleRate);
        const wData = windBuf.getChannelData(0);
        for(let i=0; i<windBufSize; i++) wData[i] = Math.random() * 2 - 1;

        this.windNode = this.ctx.createBufferSource();
        this.windNode.buffer = windBuf;
        this.windNode.loop = true;

        this.windFilter = this.ctx.createBiquadFilter();
        this.windFilter.type = 'bandpass';
        this.windFilter.frequency.value = 200;
        this.windFilter.Q.value = 2; // Resonant wind

        const windGain = this.ctx.createGain();
        windGain.gain.value = 0.1;

        this.windNode.connect(this.windFilter);
        this.windFilter.connect(windGain);
        windGain.connect(this.dest);
        this.windNode.start(t);

        this.animateWind();
    }

    animateWind() {
        // Constantly shift the wind frequency to make it "howl"
        if(!this.isPlaying) return;
        const t = this.ctx.currentTime;
        const randomFreq = 150 + Math.random() * 400;
        const randomTime = 2 + Math.random() * 3;
        
        this.windFilter.frequency.linearRampToValueAtTime(randomFreq, t + randomTime);
        
        setTimeout(() => this.animateWind(), randomTime * 1000);
    }

    stopAmbience() {
        if (this.rainNode) { this.rainNode.stop(); this.rainNode = null; }
        if (this.windNode) { this.windNode.stop(); this.windNode = null; }
    }
    // ---------------------------

    start() {
        if (this.isPlaying) return;
        this.ctx.resume();
        this.isPlaying = true;
        this.startAmbience(); // START THE STORM
        this.nextNoteTime = this.ctx.currentTime + 0.1;
        this.tick = 0;
        this.scheduler();
    }

    stop() {
        this.isPlaying = false;
        this.stopAmbience(); // STOP THE STORM
        if (this.timer) clearTimeout(this.timer);
        this.master.gain.cancelScheduledValues(this.ctx.currentTime);
        this.master.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.5);
    }

    scheduler() {
        while (this.nextNoteTime < this.ctx.currentTime + this.scheduleAheadTime) {
            this.scheduleNote(this.tick, this.nextNoteTime);
            this.advanceNote();
        }
        if (this.isPlaying) {
            this.timer = setTimeout(() => this.scheduler(), this.lookahead);
        }
    }

    advanceNote() {
        const secondsPerBeat = 60.0 / this.tempo;
        this.nextNoteTime += 0.25 * secondsPerBeat;
        this.tick++;
    }

    scheduleNote(tick, t) {
        // --- RANDOM LIGHTNING TRIGGER ---
        // Every beat (4 ticks), 5% chance of lightning
        if (tick % 4 === 0 && Math.random() > 0.1) {
            if(MusicEngine && MusicEngine.playSFX) MusicEngine.playSFX('lightning');
        }

        // --- SEQUENCE LOGIC ---
        let totalSequenceBars = 0;
        for (let i = 0; i < this.sequence.length; i++) totalSequenceBars += this.lengths[this.sequence[i]];
        const totalTicks = totalSequenceBars * 16;
        
        // Change key every full loop
        const currentLoopIteration = Math.floor(tick / totalTicks);
        this.currentMovementIndex = currentLoopIteration % this.movements.length;

        let loopTick = tick % totalTicks;
        let currentTickPointer = 0;

        for (let i = 0; i < this.sequence.length; i++) {
            const sectionName = this.sequence[i];
            const sectionLenTicks = this.lengths[sectionName] * 16;

            if (loopTick < currentTickPointer + sectionLenTicks) {
                const localTick = loopTick - currentTickPointer;
                const localBar = Math.floor(localTick / 16);
                const step = localTick % 16;

                // ROUTING
                if (sectionName === 'intro') this.playIntro(t, localBar, step);
                else if (sectionName === 'swell') this.playSwell(t, localBar, step);
                else if (sectionName === 'kraken') this.playKraken(t, localBar, step);
                else if (sectionName === 'calm') this.playCalm(t, localBar, step);
                break; 
            }
            currentTickPointer += sectionLenTicks;
        }
    }

    // --- ORCHESTRATION SECTIONS ---

    playIntro(t, bar, step) {
        // Deep, pulsing drone. Minimal movement.
        // Bar 1 & 3: Root note
        if (step === 0 && bar % 2 === 0) {
            this.playInstrument(t, 0, -2, 'horn_swell', 8.0); // 2-bar drone
        }
        // Random "Foghorn" intervals
        if (step === 0 && bar % 2 !== 0) {
             this.playInstrument(t, 4, -2, 'horn_swell', 4.0); // The 5th
        }
    }

    playSwell(t, bar, step) {
        // The waves are rising. 
        // 1. Rolling Bass (8th notes)
        if (step % 2 === 0) {
            const note = (bar % 2 === 0) ? 0 : -1; // Root then down a step (Wave motion)
            this.playInstrument(t, note, -2, 'cello_spic', 0.2);
        }

        // 2. High Tremolo Strings (Tension)
        // Fast 16th note repetition on a single high note
        if (step % 2 === 0) {
            // Slowly climb up the scale every bar
            const highNote = 4 + bar; 
            this.playInstrument(t, highNote, 1, 'string_trem', 0.2);
        }
    }

    playKraken(t, bar, step) {
        // CHAOS. Loud.
        // 1. The "Danger" motif (Low Brass)
        // Jaws-like: 0 -> 1 -> 0
        if (step === 0) this.playInstrument(t, 0, -2, 'brass_hit', 0.5);
        if (step === 2) this.playInstrument(t, 1, -2, 'brass_hit', 0.5);
        if (step === 4) this.playInstrument(t, 0, -2, 'brass_hit', 0.5);

        // 2. Dissonant clusters (High)
        if (step === 0 || step === 8) {
             const cluster = [4, 5, 8]; // Dissonant intervals
             cluster.forEach(n => this.playInstrument(t, n, 1, 'string_stab', 0.5));
        }

        // 3. Thunderous Percussion (Synthesized Toms)
        if (step === 12) {
             this.playDrum(t, 80, 0.4); // Boom
        }
    }

    playCalm(t, bar, step) {
        // The eye of the storm.
        if (step === 0) {
            this.playInstrument(t, 0, -1, 'pad', 16.0); // Long hold
            this.playInstrument(t, 4, 0, 'pad', 16.0);
        }
    }

    // --- SYNTHESIS ---

    getFrequency(degree, octave) {
        const mov = this.movements[this.currentMovementIndex];
        const scaleMap = mov.scale;
        const currentRoot = this.baseRoot * mov.rootRatio;
        let idx = degree;
        let octOffset = octave;
        const len = scaleMap.length;
        while (idx < 0) { idx += len; octOffset--; }
        while (idx >= len) { idx -= len; octOffset++; }
        const semi = scaleMap[idx];
        return currentRoot * Math.pow(2, (semi + (octOffset * 12)) / 12);
    }

    playInstrument(t, degree, octave, type, durBeats) {
        const freq = this.getFrequency(degree, octave);
        
        const secondsPerBeat = 60.0 / this.tempo;
        const dur = durBeats * secondsPerBeat;

        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();

        // --- MISSING LINE WAS HERE ---
        // Apply the calculated frequency to the oscillator
        osc.frequency.setValueAtTime(freq, t); 
// Add subtle pitch drift to all instruments for a darker feel
osc.detune.value = (Math.random() * 10) - 5;
        // INSTRUMENT DEFINITIONS
        if (type === 'horn_swell') {
            // Foghorn / French Horn
            osc.type = 'sawtooth';
            filter.frequency.setValueAtTime(200, t);
            filter.frequency.linearRampToValueAtTime(2000, t + 0.05); 
            filter.frequency.exponentialRampToValueAtTime(200, t + 0.5); 
            
            gain.gain.setValueAtTime(0, t);
            gain.gain.linearRampToValueAtTime(0.4, t + dur * 0.5);
            gain.gain.linearRampToValueAtTime(0, t + dur);
        } 
        else if (type === 'cello_spic') {
            osc.type = 'sawtooth';
            filter.frequency.value = 600;
            gain.gain.setValueAtTime(0.3, t);
            gain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
        }
        else if (type === 'string_trem') {
            osc.type = 'triangle';
            osc.detune.value = Math.random() * 20 - 10; // Wobbly
            filter.frequency.value = 2000;
            
            // Fast attack/decay for tremolo picking
            gain.gain.setValueAtTime(0, t);
            gain.gain.linearRampToValueAtTime(0.2, t + 0.05);
            gain.gain.linearRampToValueAtTime(0, t + 0.25);
        }
        else if (type === 'brass_hit') {
            osc.type = 'sawtooth';
            filter.frequency.setValueAtTime(200, t);
            filter.frequency.exponentialRampToValueAtTime(2000, t + 0.05); // Brass "Blat"
            filter.frequency.exponentialRampToValueAtTime(200, t + 0.5);
            
            gain.gain.setValueAtTime(0.5, t);
            gain.gain.exponentialRampToValueAtTime(0.01, t + 0.4);
        }
        else if (type === 'pad') {
            osc.type = 'sine';
            gain.gain.setValueAtTime(0, t);
            gain.gain.linearRampToValueAtTime(0.3, t + 2);
            gain.gain.linearRampToValueAtTime(0, t + dur);
        }
        else if (type === 'string_stab') {
             osc.type = 'sawtooth';
             filter.frequency.value = 3000;
             gain.gain.setValueAtTime(0.3, t);
             gain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
        }

        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.compressor);

        osc.start(t);
        osc.stop(t + dur + 1); // Extra time for release
    }
    playDrum(t, freq, vol) {
        // Synthesized Impact/Tom
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.frequency.setValueAtTime(freq, t);
        osc.frequency.exponentialRampToValueAtTime(20, t + 0.5); // Pitch Drop

        gain.gain.setValueAtTime(vol, t);
        gain.gain.exponentialRampToValueAtTime(0.001, t + 0.5);

        osc.connect(gain);
        gain.connect(this.compressor);
        osc.start(t);
        osc.stop(t + 0.5);
    }
}

class MegaBattleModule {
  constructor(ctx, dest) {
    this.ctx = ctx;
    this.dest = dest;
    this.timer = null;
    this.isPlaying = false;

    // Mega Man X style is Fast Rock
    this.tempo = 175; 
    
    this.tick = 0;
    this.nextNoteTime = 0.0;
    this.scheduleAheadTime = 0.1;
    this.lookahead = 25.0;

    this.baseRoot = 261.63; // Middle C

    // --- 2. SEQUENCE & STRUCTURE CONTROL ---
    this.sectionData = {
        // The "Warning" Siren
        INTRO:            { bars: 1, tempo: 175 }, 
        // The Main Riff (Power Chords)
        RIFF_A:           { bars: 2, tempo: 175 }, 
        // The Verse (Driving Bass + Staccato Melody)
        THEME_A:          { bars: 2, tempo: 175 }, 
        // The Chorus (Soaring, Heroic, Sustained)
        THEME_B:          { bars: 2, tempo: 175 }, 
        // The Guitar Solo (Shredding)
        SOLO:             { bars: 4, tempo: 180 }, 
        // The Loop Reset
        TRANSITION:       { bars: 1, tempo: 175 } 
    };

    this.sequence = [
        'INTRO', 
        'RIFF_A', 
         'THEME_B',
        'THEME_A', 
         'THEME_B',
        'RIFF_A', // Return to riff before solo
        'SOLO',
        'TRANSITION'
    ];

    // --- 3. MODULATION ENGINE ---
    this.movements = [];
    const semitoneRatio = 1.059463;
    // We stick to common Rock keys (E Minor, A Minor)
    const rockKeys = [4, 9, 2, 7]; // E, A, D, G
    
    for (let i = 0; i < 4; i++) {
        this.movements.push({
            name: `Key Variant ${i}`,
            rootRatio: Math.pow(semitoneRatio, rockKeys[i]) 
        });
    }
    this.currentMovementIndex = 0;

    // --- 4. MIXER (Your "King" Module Setup) ---
    this.master = ctx.createGain();
    this.master.gain.value = 1;

    this.reverb = ctx.createConvolver();
    this.reverb.buffer = this.createImpulse(1.5); // Tighter reverb for speed
    this.revGain = ctx.createGain();
    this.revGain.gain.value = 0.25;

    this.master.connect(this.dest);
    this.master.connect(this.reverb);
    this.reverb.connect(this.revGain);
    this.revGain.connect(this.dest);
  }

  createImpulse(duration) {
    const rate = this.ctx.sampleRate;
    const len = rate * duration;
    const buf = this.ctx.createBuffer(2, len, rate);
    for (let i = 0; i < 2; i++) {
      const ch = buf.getChannelData(i);
      for (let j = 0; j < len; j++) {
        ch[j] = (Math.random() * 2 - 1) * Math.pow(1 - j / len, 3); 
      }
    }
    return buf;
  }

  start() {
    if (this.isPlaying) return;
    this.ctx.resume();
    this.isPlaying = true;
    this.nextNoteTime = this.ctx.currentTime + 0.1;
    this.tick = 0;
    this.scheduler();
  }

  stop() {
    this.isPlaying = false;
    if (this.timer) clearTimeout(this.timer);
    this.master.gain.cancelScheduledValues(this.ctx.currentTime);
    this.master.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.4);
    setTimeout(() => {
        this.master.gain.setValueAtTime(0.5, this.ctx.currentTime);
    }, 500);
  }

  scheduler() {
    while (this.nextNoteTime < this.ctx.currentTime + this.scheduleAheadTime) {
      this.scheduleNote(this.tick, this.nextNoteTime);
      this.advanceNote();
    }
    if (this.isPlaying) {
      this.timer = setTimeout(() => this.scheduler(), this.lookahead);
    }
  }

  advanceNote() {
    const secondsPerBeat = 60.0 / this.tempo;
    this.nextNoteTime += 0.25 * secondsPerBeat;
    this.tick++;
  }

  scheduleNote(tick, t) {
    let totalSequenceBars = 0;
    this.sequence.forEach(sec => totalSequenceBars += this.sectionData[sec].bars);
    const totalTicks = totalSequenceBars * 16;

    // Key Change on Loop
    const currentLoopIteration = Math.floor(tick / totalTicks);
    this.currentMovementIndex = currentLoopIteration % this.movements.length;

    let loopTick = tick % totalTicks;
    let currentTickPointer = 0;

    for (let i = 0; i < this.sequence.length; i++) {
        const sectionName = this.sequence[i];
        const data = this.sectionData[sectionName]; 
        
        if (data.tempo) this.tempo = data.tempo;

        const sectionLenTicks = data.bars * 16;

        if (loopTick < currentTickPointer + sectionLenTicks) {
            const localTick = loopTick - currentTickPointer;
            const localBar = Math.floor(localTick / 16);
            const step = localTick % 16;

            if (sectionName === 'INTRO') this.playIntro(t, localBar, step);
            else if (sectionName === 'RIFF_A') this.playRiff(t, localBar, step);
            else if (sectionName === 'THEME_A') this.playThemeA(t, localBar, step);
            else if (sectionName === 'THEME_B') this.playThemeB(t, localBar, step);
            else if (sectionName === 'SOLO') this.playSolo(t, localBar, step);
            else if (sectionName === 'TRANSITION') this.playTransition(t, localBar, step);
            
            break;
        }
        currentTickPointer += sectionLenTicks;
    }
  }

  // --- MEGA MAN COMPOSITION LOGIC ---

  playIntro(t, bar, step) {
    // The "WARNING" Siren
    // Alternating octaves on the beat
    if (step % 4 === 0) {
        this.playBrass(t, 12, 0.1); // High Alert
        this.playStab(t, 0); // Impact
        this.playTimpani(t, -12);
    }
    
    // Snare roll build up
    this.playSnare(t, (step % 2 === 0) ? 0.2 : 0.05);
  }

  playRiff(t, bar, step) {
    // THE MAIN RIFF - Power Chords
    // Rhythm: DUM DUM (pause) DUM-da-DUM
    
    const riff = { 0: 0, 2: 0, 6: 3, 8: 5, 10: 3, 12: 0 };
    
    if (riff[step] !== undefined) {
        // Play Root + Fifth (Power Chord)
        const root = riff[step];
        this.playBrass(t, root, 0.15);
        this.playBrass(t, root + 7, 0.15); // The Fifth
        
        // Heavy Bass double
        this.playBass(t, root - 12, 0.2);
    }
    
    // Constant Driving Hi-Hat/Snare
    if (step % 4 === 0) this.playSnare(t, 0.1); // Kick
    if (step % 4 === 2) this.playSnare(t, 0.3); // Snare
  }

  playThemeA(t, bar, step) {
    // VERSE - The "Chug"
    
    // 1. Bass: 16th note chugging (Palm Mute style)
    // Plays the root note constantly
    const bassNote = (bar < 4) ? 0 : (bar < 6 ? 5 : 7); // i -> IV -> V progression
    
    // Skips specific beats to create groove
    if (step !== 4 && step !== 12) {
        this.playBass(t, bassNote - 12, 0.4);
    }

    // 2. Melody: Short, staccato, "Robotic"
    // Pentatonic Minor: 0, 3, 5, 7, 10
    const melody = { 0: 12, 2: 12, 6: 15, 8: 17, 10: 15, 14: 12 };
    
    // Variation every other bar
    if (bar % 2 !== 0 && step === 14) melody[14] = 7; // Drop down

    if (melody[step]) {
        // High Strings acting as "Synth Lead"
        this.playHighStrings(t, melody[step], 0.15);
    }

    // 3. Brass Hits (Counterpoint)
    if (step === 4 || step === 12) {
        this.playBrass(t, bassNote, 0.1);
    }

    // 4. Rock Beat
    if (step % 4 === 0) this.playSnare(t, 0.15);
    if (step % 4 === 2) this.playSnare(t, 0.35);
  }

  playThemeB(t, bar, step) {
    // CHORUS - Melodic, Sustained, "Heroic"
    
    // Progression: VI - VII - i (The "Iron Maiden" Gallop)
    // Bars 0-1: Ab (8), Bars 2-3: Bb (10), Bars 4-7: C (12/0)
    let root = 0;
    if (bar < 2) root = 8;      // VI
    else if (bar < 4) root = 10; // VII
    else root = 0;              // i

    // Bass Gallop: da-da-DUM
    const gallop = [1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0];
    if (gallop[step]) {
        this.playBass(t, root - 12, 0.4);
    }

    // Soaring Melody (Strings)
    // Long notes
    if (step === 0) {
        this.playHighStrings(t, root + 12, 0.8); // Long sustain
        this.playBrass(t, root, 0.4); // Pad underneath
    }
    
    // Add a melodic fill at the end of the bar
    if (step === 12 || step === 14) {
        this.playHighStrings(t, root + 15, 0.2);
    }

    // Drum Fills
    if (step % 4 === 2) this.playSnare(t, 0.3);
  }

  playSolo(t, bar, step) {
    // THE SHRED
    // High speed arpeggios
    
    // Pentatonic scale array
    const scale = [0, 3, 5, 7, 10, 12, 15, 17, 19, 22];
    
    // Generate a pseudo-random run based on step and bar
    // This creates that "Arpeggiator" feel
    const index = (step * 3 + bar * 5) % scale.length;
    const note = scale[index];

    // High Strings shredding
    this.playHighStrings(t, note + 12, 0.1);
    
    // Bass holds pedal point tension
    if (step % 4 === 0) this.playBass(t, 0, 0.5);
    
    // Double time drums
    if (step % 2 === 0) this.playSnare(t, 0.2);
  }

  playTransition(t, bar, step) {
    // Descending Power Line
    // Unison hits
    if (step % 2 === 0) {
        const note = 12 - step; // Chromatic down
        this.playBrass(t, note, 0.1);
        this.playBass(t, note - 12, 0.5);
        this.playSnare(t, 0.3);
    }
  }

  // --- INSTRUMENTS (High Fidelity from King Module) ---

  getFreq(semitoneOffset, octaveOffset) {
    const movement = this.movements[this.currentMovementIndex];
    const currentRoot = this.baseRoot * movement.rootRatio;
    return currentRoot * Math.pow(2, (semitoneOffset + (octaveOffset * 12)) / 12);
  }

  playBass(t, note, vol) {
    const freq = this.getFreq(note, -2);
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    
    // Mix Square and Sawtooth for a "Synth Bass" / "Distorted Bass" tone
    osc.type = 'sawtooth'; 
    osc.frequency.value = freq;

    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(vol, t + 0.01);
    g.gain.exponentialRampToValueAtTime(0.001, t + 0.2); // Tight decay for fast tempos

    osc.connect(g);
    g.connect(this.master);
    osc.start(t);
    osc.stop(t + 0.25);
  }

  playBrass(t, note, len) {
    const freq = this.getFreq(note, -1);
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    const f = this.ctx.createBiquadFilter();

    osc.type = 'sawtooth';
    osc.frequency.value = freq;
    // Slight detune for "Synth Brass" feel
    osc.detune.value = Math.random() * 4 - 2;

    f.type = 'lowpass';
    f.Q.value = 3; 
    f.frequency.setValueAtTime(600, t);
    f.frequency.linearRampToValueAtTime(2500, t + 0.05); // Sharp attack
    f.frequency.exponentialRampToValueAtTime(800, t + len);

    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(0.4, t + 0.02);
    g.gain.linearRampToValueAtTime(0.3, t + 0.1);
    g.gain.linearRampToValueAtTime(0, t + len);

    osc.connect(f);
    f.connect(g);
    g.connect(this.master);
    osc.start(t);
    osc.stop(t + len + 0.1);
  }

  playHighStrings(t, note, vol) {
    const freq = this.getFreq(note, 0);
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();

    osc.type = 'square'; // Switch to Square for a "Game Lead" sound, or Saw for Strings
    // Let's stick to Sawtooth for that "Symphonic" feel
    osc.type = 'sawtooth';
    osc.frequency.value = freq;

    // Vibrato (essential for the Lead Guitar feel)
    const vib = this.ctx.createOscillator();
    const vibG = this.ctx.createGain();
    vib.frequency.value = 6; 
    vibG.gain.setValueAtTime(0, t);
    vibG.gain.linearRampToValueAtTime(10, t + 0.2); 
    vib.connect(vibG);
    vibG.connect(osc.frequency);
    vib.start(t);

    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(vol, t + 0.02);
    g.gain.linearRampToValueAtTime(vol * 0.5, t + 0.1); // Sustain level
    g.gain.linearRampToValueAtTime(0, t + 0.3);

    osc.connect(g);
    g.connect(this.master);
    osc.start(t);
    osc.stop(t + 0.35);
  }

  playSnare(t, vol) {
    // Synth Snare (White Noise + Filter Pop)
    const rate = this.ctx.sampleRate;
    const len = rate * 0.1;
    const buf = this.ctx.createBuffer(1, len, rate);
    const data = buf.getChannelData(0);
    for(let i=0; i<len; i++) data[i] = (Math.random() * 2 - 1);

    const src = this.ctx.createBufferSource();
    src.buffer = buf;
    
    const f = this.ctx.createBiquadFilter();
    f.type = 'bandpass';
    f.frequency.value = 1500; // Higher pitch for "Rock" snare

    const g = this.ctx.createGain();
    g.gain.setValueAtTime(vol, t);
    g.gain.exponentialRampToValueAtTime(0.01, t + 0.08);

    src.connect(f);
    f.connect(g);
    g.connect(this.master);
    src.start(t);
  }

  playTimpani(t, noteIndex) {
    // Used for Impacts
    const freq = this.getFreq(noteIndex, -3); 
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    
    osc.type = 'sine';
    osc.frequency.value = freq;
    osc.frequency.linearRampToValueAtTime(freq * 0.8, t + 0.3); // Pitch drop

    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(0.8, t + 0.01); 
    g.gain.exponentialRampToValueAtTime(0.01, t + 0.5);

    osc.connect(g);
    g.connect(this.master);
    osc.start(t);
    osc.stop(t + 0.6);
  }

  playStab(t, note) {
    // Orchestra Hit style
    const freq = this.getFreq(note, 0);
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    
    osc.type = 'sawtooth';
    osc.frequency.value = freq;
    osc.detune.value = (Math.random() * 20) - 10; 

    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(0.2, t + 0.01);
    g.gain.exponentialRampToValueAtTime(0.001, t + 0.2);

    osc.connect(g);
    g.connect(this.master);
    osc.start(t);
    osc.stop(t + 0.25);
  }
}
// MODULE 42: Emperor Battle (Neo-Classical Shred)
class EmperorBattleModule {
  constructor(ctx, dest) {
    this.ctx = ctx;
    this.dest = dest;
    this.timer = null;
    this.isPlaying = false;
    this.generatedSoloData = null; 
    this.lastSoloGenerationIndex = -1; // Tracks when to regenerate
    this.generatedHarpsichordData = null;
    this.lastHarpsichordId = null;
    this.lastLoopIteration = -1;
    // Very fast, frantic tempo
    this.tempo = 185; 
    
    this.tick = 0;
    this.nextNoteTime = 0.0;
    this.scheduleAheadTime = 0.1;
    this.lookahead = 25.0;

    this.baseRoot = 163.91; // Middle C

    // --- 2. SEQUENCE & STRUCTURE ---
    this.sectionData = {
        INTRO:            { bars: 2, tempo: 160 }, 
        TOCCATA_A:        { bars: 2, tempo: 185 }, 
        TOCCATA_B:        { bars: 2, tempo: 185 }, 
        // NEW: The "Heroic" soaring melody
        MELODIC_SOLO:     { bars: 4.25, tempo: 190 },
        MELODIC_SOLO_B:   { bars: 4.25, tempo: 195 },
        CHOIR_SECTION:    { bars: 4, tempo: 170 }, 
        // NEW: Syncopated Prog-Metal stabs
        MATH_BREAKDOWN:   { bars: .5, tempo: 180 },
        // NEW: Harpsichord trading solos
        HARPSICHORD_DUEL: { bars: 4, tempo: 190 },
        RISING_ARPS:      { bars: 2, tempo: 195 }, // Speeding up
        SPEED_METAL:      { bars: 2.5, tempo: 200 }, // Max speed
        TRANSITION:       { bars: 1, tempo: 160 } 

    };

    this.sequence = [
        'INTRO', 
        'TOCCATA_A', 
        'TOCCATA_B', 
        
        'CHOIR_SECTION',
        
        
        'RISING_ARPS',
        
        'SPEED_METAL',
        
        'MATH_BREAKDOWN',  // New
        'MATH_BREAKDOWN',  // New
        'HARPSICHORD_DUEL',// New
        
        'MELODIC_SOLO', 
         'MELODIC_SOLO_B',  // The High Solo (Climax
        
        
        'MATH_BREAKDOWN',  // New
        
        'TRANSITION',
    ];

    // --- 3. MODULATION ENGINE (Chromatic Ascension) ---
    this.movements = [];
    const semitoneRatio = 1.059463;
    const noteNames = ["C", "C#", "D", "Eb", "E", "F", "F#", "G", "Ab", "A", "Bb", "B"];
    
    // We generate 12 steps. Every time the song loops, it goes up 1 semitone.
    // This creates the "Endless Staircase" of tension.
    for (let i = 0; i < 12; i++) {
        this.movements.push({
            name: `${noteNames[i]} Minor`,
            rootRatio: Math.pow(semitoneRatio, i) 
        });
    }
    this.currentMovementIndex = 0;

    // --- 4. MIXER ---
    this.master = ctx.createGain();
    this.master.gain.value = 0.8; // Slightly lower master to prevent distortion from organ layers

    this.reverb = ctx.createConvolver();
    // Long cathedral reverb for that "Dracula's Castle" vibe
    this.reverb.buffer = this.createImpulse(2.5); 
    this.revGain = ctx.createGain();
    this.revGain.gain.value = 0.35;

    this.master.connect(this.dest);
    this.master.connect(this.reverb);
    this.reverb.connect(this.revGain);
    this.revGain.connect(this.dest);
  }

  createImpulse(duration) {
    const rate = this.ctx.sampleRate;
    const len = rate * duration;
    const buf = this.ctx.createBuffer(2, len, rate);
    for (let i = 0; i < 2; i++) {
      const ch = buf.getChannelData(i);
      for (let j = 0; j < len; j++) {
        ch[j] = (Math.random() * 2 - 1) * Math.pow(1 - j / len, 2.5); 
      }
    }
    return buf;
  }
  generateHarpsichordDuel(seedInput) {
    const melody = {};
    const scale = [0, 2, 3, 5, 7, 8, 11, 12, 14, 15, 17, 20]; // Harmonic Minor

    // Same RNG Logic
    let seed = seedInput * 15485863; // Different prime for variance
    const random = () => {
        seed = (seed * 15485863 + 2038074743) % 2147483647;
        return seed / 2147483647;
    };

    for (let bar = 0; bar < 4; bar++) {
        melody[bar] = {};
        
        // Even Bars = Low Player (Question), Odd Bars = High Player (Answer)
        const isHighPlayer = (bar % 2 !== 0);
        const octaveOffset = isHighPlayer ? 12 : 0;
        
        // Choose a Pattern Type for this specific bar
        const patternType = Math.floor(random() * 3);

        if (patternType === 0) {
            // --- PATTERN: PEDAL POINT ---
            // Yngwie style: Alternate between a static "Pedal" note and moving notes
            // e.g. C - D - C - Eb - C - F...
            
            // Pick a pedal note (usually Root or 5th)
            const pedalIdx = (random() > 0.5) ? 0 : 4; 
            const pedalNote = scale[pedalIdx] + octaveOffset;
            
            // Generate the moving line
            let movingIdx = Math.floor(random() * 5); 
            
            for (let s = 0; s < 16; s++) {
                if (s % 2 === 0) {
                    melody[bar][s] = pedalNote; // The Anchor
                } else {
                    // The moving note
                    melody[bar][s] = scale[movingIdx] + octaveOffset;
                    // Move scale index randomly
                    movingIdx += (random() > 0.5 ? 1 : -1);
                    // Boundary checks
                    if (movingIdx < 0) movingIdx = 0;
                    if (movingIdx > 7) movingIdx = 7;
                }
            }

        } else if (patternType === 1) {
            // --- PATTERN: LINEAR RUN ---
            // Straight up or down scales
            const direction = (random() > 0.5) ? 1 : -1;
            let startIdx = (direction === 1) ? 0 : 8; // Start low or high
            
            for (let s = 0; s < 16; s++) {
                let noteIdx = startIdx + (isHighPlayer ? 4 : 0); // Shift range slightly
                
                // Wrap around logic to keep it flowing
                const effectiveIdx = Math.abs(noteIdx % scale.length);
                
                melody[bar][s] = scale[effectiveIdx] + octaveOffset;
                startIdx += direction;
            }

        } else {
            // --- PATTERN: BROKEN CHORDS ---
            // Arpeggios: 1-3-5 patterns
            const root = Math.floor(random() * 3); // Chord offset
            const chordTones = [0, 2, 4]; // Relative to root
            
            for (let s = 0; s < 16; s++) {
                // Triplet feel in 16th notes (3-3-3-3-4 grouping)
                const chordTone = chordTones[s % 3];
                const noteIdx = (root + chordTone) % scale.length;
                
                melody[bar][s] = scale[noteIdx] + octaveOffset;
            }
        }
    }
    return melody;
  }
generateProceduralSolo(seedIndex) {
    const melody = {};
    const scale = [0, 2, 3, 5, 7, 8, 11, 12, 14, 15, 17, 20]; // Harmonic Minor Extended
    
    // A simple seeded random function (so the solo is consistent within the loop)
    // We use the seedIndex (the loop counter) to make it unique every time
    let seed = seedIndex * 9301 + 49297;
    const random = () => {
        seed = (seed * 9301 + 49297) % 233280;
        return seed / 233280;
    };

    // Generate 4 bars
    for (let bar = 0; bar < 4; bar++) {
        melody[bar] = {};
        
        // DECISION: What style is this bar?
        // 0 = Sustained Heroic Notes
        // 1 = Fast Scalar Run
        // 2 = Arpeggios
        const style = Math.floor(random() * 3); 

        if (style === 0) { 
            // --- HEROIC SUSTAINS ---
            // Pick a note on the downbeat (step 0) and maybe the middle (step 8)
            const noteIdx = Math.floor(random() * 6); // Lower part of scale
            melody[bar][0] = { note: scale[noteIdx] + 12, dur: 2.0 }; // Long note
            
            if (random() > 0.5) {
                 const noteIdx2 = Math.floor(random() * 6);
                 melody[bar][8] = { note: scale[noteIdx2] + 12, dur: 1.0 };
            }

        } else if (style === 1) {
            // --- SHRED RUN ---
            // Fill every even step (8th notes) or every step (16th notes)
            let currentScaleIndex = Math.floor(random() * 8) + 2;
            const direction = random() > 0.5 ? 1 : -1; // Up or Down
            
            for (let s = 0; s < 16; s++) {
                // 16th notes
                if (currentScaleIndex < 0) currentScaleIndex = 0;
                if (currentScaleIndex >= scale.length) currentScaleIndex = scale.length - 1;
                
                melody[bar][s] = { note: scale[currentScaleIndex] + 12, dur: 0.15 };
                
                // Move the index for the next note
                if (random() > 0.2) currentScaleIndex += direction; 
            }

        } else {
            // --- ARPEGGIOS ---
            // Root - 3rd - 5th pattern
            const rootOffset = Math.floor(random() * 3); // Start on different chord tones
            const arpPattern = [0, 2, 4, 7, 4, 2]; // Indices in the scale array (Triad-ish)
            
            for (let s = 0; s < 16; s+=2) { // 8th notes
                const scaleNoteIdx = arpPattern[(s/2) % 6] + rootOffset;
                const safeIdx = Math.min(scaleNoteIdx, scale.length - 1);
                melody[bar][s] = { note: scale[safeIdx] + 12, dur: 0.3 };
            }
        }
    }
    
    // Always force the very last note of the last bar to resolve to Root or 5th
    melody[3][12] = { note: 12, dur: 0.8 }; // High Root resolution

    return melody;
}
  start() {
    if (this.isPlaying) return;
    this.ctx.resume();
    this.isPlaying = true;
    this.nextNoteTime = this.ctx.currentTime + 0.1;
    this.tick = 0;
    this.scheduler();
  }

  stop() {
    this.isPlaying = false;
    if (this.timer) clearTimeout(this.timer);
    this.master.gain.cancelScheduledValues(this.ctx.currentTime);
    this.master.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.4);
    setTimeout(() => {
        this.master.gain.setValueAtTime(0.5, this.ctx.currentTime);
    }, 500);
  }

  scheduler() {
    while (this.nextNoteTime < this.ctx.currentTime + this.scheduleAheadTime) {
      this.scheduleNote(this.tick, this.nextNoteTime);
      this.advanceNote();
    }
    if (this.isPlaying) {
      this.timer = setTimeout(() => this.scheduler(), this.lookahead);
    }
  }

  advanceNote() {
    const secondsPerBeat = 60.0 / this.tempo;
    this.nextNoteTime += 0.25 * secondsPerBeat;
    this.tick++;
  }

  scheduleNote(tick, t) {
    // 1. Calculate Loop Length
    let totalSequenceBars = 0;
    this.sequence.forEach(sec => totalSequenceBars += this.sectionData[sec].bars);
    const totalTicks = totalSequenceBars * 16;

    // 2. MODULATION LOGIC (RANDOMIZED)
    const currentLoopIteration = Math.floor(tick / totalTicks);

    // Check if we have entered a new loop
    if (currentLoopIteration > this.lastLoopIteration) {
        
        // Pick a random key index (0 to 11)
        let newIndex = Math.floor(Math.random() * this.movements.length);

        // OPTIONAL: Prevent playing the exact same key twice in a row
        // If the random number matches the current key, pick again
        while (newIndex === this.currentMovementIndex) {
            newIndex = Math.floor(Math.random() * this.movements.length);
        }

        this.currentMovementIndex = newIndex;
        this.lastLoopIteration = currentLoopIteration;

        console.log(`%c THE EMPEROR WARPS TO: ${this.movements[this.currentMovementIndex].name}`, 'color: #ff0000; font-weight: bold;');
    }

    // 3. Section Logic
    let loopTick = tick % totalTicks;
    let currentTickPointer = 0;

    for (let i = 0; i < this.sequence.length; i++) {
        const sectionName = this.sequence[i];
        const data = this.sectionData[sectionName]; 
        
        const sectionLenBars = data.bars;
        const sectionLenTicks = sectionLenBars * 16;

        if (loopTick < currentTickPointer + sectionLenTicks) {
            
            if (data.tempo) this.tempo = data.tempo;

            const localTick = loopTick - currentTickPointer;
            const localBar = Math.floor(localTick / 16);
            const step = localTick % 16;

            // Route to Composers
            if (sectionName === 'INTRO') this.playIntro(t, localBar, step);
            else if (sectionName === 'TOCCATA_A') this.playToccata(t, localBar, step, 0); // Low octave
            else if (sectionName === 'TOCCATA_B') this.playToccata(t, localBar, step, 1); // High octave
            else if (sectionName === 'CHOIR_SECTION') this.playChoirSection(t, localBar, step);
            else if (sectionName === 'RISING_ARPS') this.playArps(t, localBar, step);
            else if (sectionName === 'SPEED_METAL') this.playSpeedMetal(t, localBar, step);
            else if (sectionName === 'TRANSITION') this.playTransition(t, localBar, step);
            else if (sectionName === 'MELODIC_SOLO') this.playMelodicSolo(t, localBar, step,i);
            else if (sectionName === 'MATH_BREAKDOWN') this.playMathBreakdown(t, localBar, step);
            else if (sectionName === 'HARPSICHORD_DUEL') this.playHarpsichordDuel(t, localBar, step,i);
            else if (sectionName === 'MELODIC_SOLO_B') this.playMelodicSolo(t, localBar, step, i, true);
            break;
        }
        currentTickPointer += sectionLenTicks;
    }
  }

  // --- COMPOSITION LOGIC ---

  playIntro(t, bar, step) {
    // DRAMATIC ORGAN CHORDS
    // C Minor -> Ab Major -> G Major -> C Minor (The "Power" cadence)
    const chords = {
        0: [0, 3, 7, 12],   // Cm
        8: [-4, 0, 3, 8],   // Ab
    };
    
    // Bar 1: G -> Cm
    const chords2 = {
        0: [-5, -1, 2, 7],  // G Major
        8: [0, 3, 7, 12]    // Cm
    };

    const currentMap = (bar === 0) ? chords : chords2;

    if (currentMap[step]) {
        currentMap[step].forEach(n => this.playOrgan(t, n, 1.2)); // Long sustain
        this.playTimpani(t, -12);
        this.playCrash(t);
    }
  }
 playMelodicSolo(t, bar, step, sequenceIndex, isClimax = false) {
    // 1. Check ID and Generate if needed
    // We add the isClimax flag to the ID to ensure Solo B generates a different melody than Solo A
    const uniqueId = `${this.currentMovementIndex}_${sequenceIndex}_SOLO${isClimax ? 'B' : 'A'}`;

    if (this.lastSoloGenerationId !== uniqueId) {
        // Use a different modifier for the seed to ensure B is distinct from A
        const seedModifier = isClimax ? 613 : 91;
        const numericSeed = this.currentMovementIndex + (sequenceIndex * seedModifier);
        
        console.log(`%c COMPOSING SOLO ${isClimax ? 'B (High)' : 'A (Low)'}`, 'color: #00ffff');
        this.generatedSoloData = this.generateProceduralSolo(numericSeed);
        this.lastSoloGenerationId = uniqueId;
    }

    // 2. Play the Rhythm Section
    this.playKick(t);
    // Solo B gets a faster snare pattern (double time feel)
    if (isClimax) {
        if (step % 4 === 2) this.playSnare(t, 0.3); // Backbeat on 2 and 4
    } else {
        if (step === 4 || step === 12) this.playSnare(t, 0.3); // Half time feel
    }
    
    if (step % 2 === 0) this.playBass(t, 0, 0.4);
    
    // Harmony Chords
    if (step === 0) {
        const roots = [0, -4, -7, -2]; 
        this.playOrgan(t, roots[bar % 4], 0.7);
    }

    // 3. Play the Generated Melody
    const barData = this.generatedSoloData[bar];
    if (barData && barData[step]) {
        const event = barData[step];
        
        // Base Note
        let noteToPlay = event.note;
        
        // --- CLIMAX LOGIC ---
        if (isClimax) {
            //noteToPlay -= 12; // Shift up an octave
            
            // HARMONY LAYER (Twin Guitars)
            // We play a second note a 3rd down (-4 semitones roughly) at lower volume
            // Panned slightly right
           
        }

        // Main Lead
        this.playSawLead(t, noteToPlay, event.dur, 0.25);
    }
  }
  playMathBreakdown(t, bar, step) {
    // PROG METAL STABS
    // Rhythmic unison: 3 + 3 + 3 + 3 + 4 pattern
    // Kick, Snare, and Guitar hit exactly together.
    
    const pattern = [
        1, 0, 0, // 1
        1, 0, 0, // 2
        1, 0, 0, // 3
        1, 0, 0, // 4
        1, 0, 1, 0 // 4 (Double hit at end)
    ];

    if (pattern[step]) {
        // Heavy Stabs
        this.playKick(t);
        this.playSnare(t, 0.5); // Hard snare
        this.playCrash(t);
        
        // Chromatic dissonant chords (0 and 1 played together)
        this.playDistortedGuitar(t, -12);
        this.playDistortedGuitar(t, -11); 
    } else {
        // Silence creates the "Djent" feel
    }
  }

  playHarpsichordDuel(t, bar, step, sequenceIndex) {
    // 1. Check ID and Generate if needed
    const uniqueId = `${this.currentMovementIndex}_${sequenceIndex}_HARP`;

    if (this.lastHarpsichordId !== uniqueId) {
        // Create a unique seed different from the guitar solo
        const numericSeed = this.currentMovementIndex + (sequenceIndex * 500) + 99;
        
        console.log(`%c HARPSICHORD DUEL (Variation ${sequenceIndex})`, 'color: #ff00ff');
        this.generatedHarpsichordData = this.generateHarpsichordDuel(numericSeed);
        this.lastHarpsichordId = uniqueId;
    }

    // 2. Drums (Blast Beat Lite)
    // Kick on all downbeats + "and" of 3
    if (step % 4 === 0 || step === 10) this.playKick(t);
    // Snare on 2 and 4, plus ghost notes
    if (step === 4 || step === 12) this.playSnare(t, 0.25);
    if (step === 7 || step === 15) this.playSnare(t, 0.05); // Ghost notes

    // 3. Play Generated Notes
    const barData = this.generatedHarpsichordData[bar];
    if (barData && barData[step] !== undefined) {
        const note = barData[step];
        
        // Panning Logic:
        // Since we are simulating a duel, let's pan them slightly!
        // Even Bars (Low Player) -> Left
        // Odd Bars (High Player) -> Right
        const pan = (bar % 2 === 0) ? -0.3 : 0.3;
        
        // Pass pan to playHarpsichord (We need to update the instrument function slightly)
        this.playHarpsichord(t, note, 0.1, pan);
    }
  }
  playToccata(t, bar, step, octaveShift) {
    // THE "BACH" SHRED
    // Pedal point style: Moving notes against a static root
    
    // Bass: Driving 8th notes
    if (step % 2 === 0) this.playBass(t, 0, 0.6);

    // Melody: Constant 16th notes
    // Harmonic Minor Scale: 0, 2, 3, 5, 7, 8, 11, 12
    const scale = [0, 2, 3, 5, 7, 8, 11, 12, 14, 15, 17, 20];
    
    // A math-based pattern to generate "Baroque" runs
    // 0-4-2-6-4-8...
    let noteIndex = (step * 2) % 7; 
    if (bar % 2 === 1) noteIndex += 2; // Climb up in second bar

    const note = scale[noteIndex] + (octaveShift * 12);
    this.playOrgan(t, note, 0.15); // Short, staccato organ

    // Snare: Standard rock beat to keep it modern
    if (step === 4 || step === 12) this.playSnare(t, 0.2);
  }

  playChoirSection(t, bar, step) {
    // HALF TIME FEEL
    // Big, ominous choir pads
    
    const isDownbeat = (step === 0);
    
    if (isDownbeat) {
        // Chord Progression: Cm - Bb - Ab - G (The "Andalusian Cadence" of death)
        const roots = [0, -2, -4, -5];
        const root = roots[bar % 4];
        
        // Construct triads
        const chord = [root, root + 3, root + 7]; // Minor-ish feel
        if (bar === 3) chord[1] = root + 4; // Make the last one Major (Dominant)

        chord.forEach(n => this.playChoir(t, n, 2.0)); // 2 second hold
        this.playBass(t, root - 12, 0.5);
        this.playTimpani(t, root - 12);
    }

    // Orchestral Bells (The "Omen")
    if (step % 8 === 0) {
        this.playBell(t, 12);
    }
  }

  playArps(t, bar, step) {
    // BUILDING TENSION
    // Fast triplets? No, 32nd note simulation using 16ths at high tempo
    
    // Diminished Run: 0, 3, 6, 9...
    const note = (step * 3) % 12 + (bar * 3); 
    
    this.playHighStrings(t, note, 0.2);
    this.playBass(t, 0, 0.5); // Pedal C
    
    // Snare roll getting louder
    this.playSnare(t, 0.05 + (bar * 0.1));
  }

  playSpeedMetal(t, bar, step) {
    // DOUBLE KICK DRUM
    // The "Iron Maiden" Gallop on drums
    
    // Kick Drum (simulated by low Bass Pop)
    this.playKick(t);

    // Snare on 2 and 4
    if (step === 4 || step === 12) this.playSnare(t, 0.4);

    // Fast Power Chords on Organ
    if (step % 4 === 0) {
        const root = (bar % 2 === 0) ? 0 : 3; // Cm -> Eb
        this.playDistortedGuitar(t, root); // Root
        this.playDistortedGuitar(t, root + 7); // Fifth
    }

    // High screaming lead
    if (step % 2 === 0) {
        const lead = (bar % 2 === 0) ? 12 : 15;
        this.playSawLead(t, lead + (step%4));
    }
  }

  playTransition(t, bar, step) {
    // The "Stop" before the modulation
    if (step === 0) {
        this.playTimpani(t, -5);
        this.playCrash(t);
        this.playChoir(t, 0, 0.5); // Quick stab
    }
  }

  // --- INSTRUMENTS ---

  getFreq(semitoneOffset, octaveOffset) {
    const movement = this.movements[this.currentMovementIndex];
    const currentRoot = this.baseRoot * movement.rootRatio;
    return currentRoot * Math.pow(2, (semitoneOffset + (octaveOffset * 12)) / 12);
  }
  playHarpsichord(t, note, duration) {
    const freq = this.getFreq(note, 0);
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    
    // Sawtooth is good for harpsichord, but needs to be thin
    osc.type = 'sawtooth';
    osc.frequency.value = freq;

    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(0.25, t + 0.005); // Instant attack (pluck)
    g.gain.exponentialRampToValueAtTime(0.01, t + 0.3); // Fast decay, no sustain

    // Highpass filter to remove "body" and make it "plucky"
    const f = this.ctx.createBiquadFilter();
    f.type = 'highpass';
    f.frequency.value = 800;

    osc.connect(f);
    f.connect(g);
    g.connect(this.master);
    
    osc.start(t);
    osc.stop(t + 0.4);
  }
  playOrgan(t, note, duration) {
    // CHURCH ORGAN SIMULATION
    // Stacked octaves + fifths
    const harmonics = [0, 12, 19]; // Root, Octave, Octave+5th
    
    harmonics.forEach((offset, idx) => {
        const freq = this.getFreq(note + offset, -1);
        const osc = this.ctx.createOscillator();
        const g = this.ctx.createGain();

        // Triangle for low, Sawtooth for high/nasal
        osc.type = idx === 0 ? 'triangle' : 'sawtooth';
        osc.frequency.value = freq;
        // Slight detune for "Chorus" effect
        osc.detune.value = (Math.random() * 10) - 5; 

        g.gain.setValueAtTime(0, t);
        g.gain.linearRampToValueAtTime(0.15 / (idx + 1), t + 0.05); // Attack
        g.gain.setValueAtTime(0.15 / (idx + 1), t + duration - 0.05); // Sustain
        g.gain.linearRampToValueAtTime(0, t + duration); // Release

        osc.connect(g);
        g.connect(this.master);
        osc.start(t);
        osc.stop(t + duration + 0.1);
    });
  }

  playChoir(t, note, duration) {
    // SYNTH CHOIR PAD
    // Slow attack, multiple detuned saws, low pass filter
    const freq = this.getFreq(note, 0);
    const osc1 = this.ctx.createOscillator();
    const osc2 = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    const f = this.ctx.createBiquadFilter();

    osc1.type = 'sawtooth';
    osc2.type = 'sawtooth';
    
    osc1.frequency.value = freq;
    osc2.frequency.value = freq;
    
    osc1.detune.value = 15; // Heavy detune
    osc2.detune.value = -15;

    f.type = 'lowpass';
    f.frequency.setValueAtTime(400, t);
    f.frequency.linearRampToValueAtTime(900, t + (duration/2)); // "Aaaah" swelling vowel sound

    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(0.15, t + 0.5); // Very slow attack
    g.gain.linearRampToValueAtTime(0, t + duration);

    osc1.connect(f);
    osc2.connect(f);
    f.connect(g);
    g.connect(this.master);
    
    osc1.start(t);
    osc2.start(t);
    osc1.stop(t + duration + 0.5);
    osc2.stop(t + duration + 0.5);
  }

  // Changed signature to accept duration, defaulting to 0.2 if not passed
  // Updated signature: added 'vol' parameter defaulting to 0.2
  playSawLead(t, note, duration = 0.2, vol = 0.2) { 
    const freq = this.getFreq(note, 1);
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    
    osc.type = 'sawtooth';
    osc.frequency.value = freq;
    
    // Vibrato
    osc.detune.setValueAtTime(0, t);
    osc.detune.linearRampToValueAtTime(15, t + duration); 

    g.gain.setValueAtTime(0, t);
    // Use the passed 'vol' here
    g.gain.linearRampToValueAtTime(vol, t + 0.05);
    g.gain.linearRampToValueAtTime(0, t + duration); 

    osc.connect(g);
    g.connect(this.master);
    osc.start(t);
    osc.stop(t + duration + 0.1);
  }
  playBass(t, note, vol) {
    const freq = this.getFreq(note, -2);
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    
    osc.type = 'square'; 
    osc.frequency.value = freq;

    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(vol, t + 0.01);
    g.gain.exponentialRampToValueAtTime(0.001, t + 0.2);

    osc.connect(g);
    g.connect(this.master);
    osc.start(t);
    osc.stop(t + 0.25);
  }

  playDistortedGuitar(t, note) {
      // Simulating "Chugs" using saw + highpass
    const freq = this.getFreq(note, -1);
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    const f = this.ctx.createBiquadFilter();

    osc.type = 'sawtooth';
    osc.frequency.value = freq;
    
    f.type = 'lowpass';
    f.frequency.value = 2000;
    f.Q.value = 5; // Resonant crunch

    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(0.2, t + 0.01);
    g.gain.exponentialRampToValueAtTime(0.001, t + 0.15);

    osc.connect(f);
    f.connect(g);
    g.connect(this.master);
    osc.start(t);
    osc.stop(t + 0.2);
  }

  playSnare(t, vol) {
    const rate = this.ctx.sampleRate;
    const len = rate * 0.1;
    const buf = this.ctx.createBuffer(1, len, rate);
    const data = buf.getChannelData(0);
    for(let i=0; i<len; i++) data[i] = (Math.random() * 2 - 1);

    const src = this.ctx.createBufferSource();
    src.buffer = buf;
    
    const f = this.ctx.createBiquadFilter();
    f.type = 'highpass';
    f.frequency.value = 1000;

    const g = this.ctx.createGain();
    g.gain.setValueAtTime(vol, t);
    g.gain.exponentialRampToValueAtTime(0.01, t + 0.08);

    src.connect(f);
    f.connect(g);
    g.connect(this.master);
    src.start(t);
  }

  playKick(t) {
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    
    osc.frequency.setValueAtTime(150, t);
    osc.frequency.exponentialRampToValueAtTime(0.01, t + 0.1);

    g.gain.setValueAtTime(0.8, t);
    g.gain.exponentialRampToValueAtTime(0.01, t + 0.1);

    osc.connect(g);
    g.connect(this.master);
    osc.start(t);
    osc.stop(t + 0.15);
  }

  playTimpani(t, noteIndex) {
    const freq = this.getFreq(noteIndex, -3); 
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    
    osc.type = 'triangle';
    osc.frequency.value = freq;
    osc.frequency.linearRampToValueAtTime(freq * 0.8, t + 0.3);

    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(0.8, t + 0.01); 
    g.gain.exponentialRampToValueAtTime(0.01, t + 0.6);

    osc.connect(g);
    g.connect(this.master);
    osc.start(t);
    osc.stop(t + 0.7);
  }
  
  playCrash(t) {
    const rate = this.ctx.sampleRate;
    const len = rate * 1.0; // Long decay
    const buf = this.ctx.createBuffer(1, len, rate);
    const data = buf.getChannelData(0);
    for(let i=0; i<len; i++) data[i] = (Math.random() * 2 - 1);

    const src = this.ctx.createBufferSource();
    src.buffer = buf;
    
    const f = this.ctx.createBiquadFilter();
    f.type = 'highpass';
    f.frequency.value = 3000; // Sizzle

    const g = this.ctx.createGain();
    g.gain.setValueAtTime(0.3, t);
    g.gain.exponentialRampToValueAtTime(0.01, t + 0.8);

    src.connect(f);
    f.connect(g);
    g.connect(this.master);
    src.start(t);
  }
  
  playBell(t, note) {
    const freq = this.getFreq(note, 1);
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    
    osc.type = 'sine'; // Pure tone
    osc.frequency.value = freq;
    
    // Bell envelope
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(0.3, t + 0.01);
    g.gain.exponentialRampToValueAtTime(0.01, t + 1.5); // Long ring

    osc.connect(g);
    g.connect(this.master);
    osc.start(t);
    osc.stop(t + 2.0);
  }
  
  playHighStrings(t, note, vol) {
    const freq = this.getFreq(note, 1);
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();

    osc.type = 'sawtooth';
    osc.frequency.value = freq;

    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(vol, t + 0.02);
    g.gain.linearRampToValueAtTime(0, t + 0.15); 

    osc.connect(g);
    g.connect(this.master);
    osc.start(t);
    osc.stop(t + 0.2);
  }
}


class GenVoice {
    constructor(module, id) {
        this.mod = module; // Reference to main module
        this.id = id;      // 0 or 1
        this.remainingTicks = 0; // How long current note lasts
        this.currentScaleIndex = -1; // What note am I playing?
    }

    process(t, tickStep) {
        // 1. If we are currently playing a note, countdown
        if (this.remainingTicks > 0) {
            this.remainingTicks--;
            return;
        }

        // 2. Time to generate a new note!
        // Roll 1d7 for Note Index (0-6)
        // Roll 1d8 for Duration (in 16th notes)
        
        let attempts = 0;
        let validNote = false;
        let selectedIndex = 0;
        let octaveOffset = 0;

        while (!validNote && attempts < 10) {
            attempts++;
            
            // ROLL THE DICE (1d7)
            selectedIndex = Math.floor(Math.random() * 7);
            
            // Random Octave (0 or 1)
            octaveOffset = Math.random() > 0.6 ? 1 : 0;

            // CHECK CONSTRAINTS against other voices
            validNote = this.checkHarmony(selectedIndex);
        }

        if (validNote) {
            // ROLL DURATION (Slower = higher multiplier)
            // Roll 1d4 * 4 (So durations are 4, 8, 12, 16 ticks) - Quarter notes minimum
            const durRoll = (Math.floor(Math.random() * 4) + 1) * 4;
            this.remainingTicks = durRoll;
            this.currentScaleIndex = selectedIndex;

            // PLAY IT
            this.playSound(t, selectedIndex, octaveOffset, durRoll);
        } else {
            // If we couldn't find a valid note in 10 tries, REST this turn.
            this.remainingTicks = 4; // Rest for a beat
            this.currentScaleIndex = -1; // Not playing
        }
    }

    checkHarmony(myIndex) {
        // If I am the only voice, I am always valid (unless we want to check melodic intervals)
        if (this.mod.voices.length < 2) return true;

        // Check against all OTHER voices
        for (let otherVoice of this.mod.voices) {
            if (otherVoice === this) continue; // Don't check self
            if (otherVoice.currentScaleIndex === -1) continue; // Other voice is resting

            const dist = Math.abs(myIndex - otherVoice.currentScaleIndex);

            // RULE 1: No Unison (Same note)
            if (dist === 0) return false;

            // RULE 2: No Seconds (Adjacent notes are dissonant)
            if (dist === 1) return false;

            // RULE 3: No Perfect Fifths (The Composer's Ban - optional but requested)
            // In a 7 note scale, index diff 4 is usually a fifth.
            if (dist === 4) return false;
            
            // RULE 4: Octaves (Same index, different octave is still index diff 0 usually, 
            // but strict octave check is covered by Unison if we ignore octave offset, 
            // strictly we should check total pitch, but index check is usually enough for "color")
        }

        return true;
    }

    playSound(t, scaleIndex, octave, durationTicks) {
        // Calculate Frequency
        // Base + Modulation + Scale Degree
        const scale = this.mod.arabicScale;
        const semitones = scale[scaleIndex] + (octave * 12) + this.mod.currentTransposition;
        
        // Convert semitones to frequency relative to D3
        // fn = f0 * (a)^n
        const freq = this.mod.keyBase * Math.pow(2, semitones / 12);
        
        // DURATION in Seconds
        // (60 / BPM) / 4 * ticks
        const durSeconds = (60 / this.mod.tempo) / 4 * durationTicks;

        // SYNTHESIS (Simulating a Nay Flute / Reed)
        const osc = this.mod.ctx.createOscillator();
        // Sawtooth filtered down sounds like a reed instrument
        osc.type = 'sawtooth'; 
        osc.frequency.value = freq;

        // Lowpass Filter (The "Mouth")
        const filter = this.mod.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 400; // Start closed

        const gain = this.mod.ctx.createGain();
        gain.gain.setValueAtTime(0, t);
        
        // ENVELOPE (Slow Attack for "Slow Authentic" feel)
        gain.gain.linearRampToValueAtTime(0.3, t + (durSeconds * 0.2)); 
        gain.gain.linearRampToValueAtTime(0, t + durSeconds);

        // FILTER MOVEMENT (Breath)
        filter.frequency.setValueAtTime(400, t);
        filter.frequency.linearRampToValueAtTime(1200, t + (durSeconds * 0.1)); // Open up
        filter.frequency.linearRampToValueAtTime(400, t + durSeconds); // Close down

        // VIBRATO (Essential for Arabic feel)
        const vibOsc = this.mod.ctx.createOscillator();
        vibOsc.frequency.value = 5; // 5Hz vibrato
        const vibGain = this.mod.ctx.createGain();
        vibGain.gain.value = 3; // Depth
        vibOsc.connect(vibGain);
        vibGain.connect(osc.frequency);
        vibOsc.start(t);
        vibOsc.stop(t + durSeconds);

        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.mod.melodyBus); // Connect to the Reverb/Delay Bus

        osc.start(t);
        osc.stop(t + durSeconds);
        osc.onended = () => {
            // Disconnect Main Chain
            osc.disconnect();
            filter.disconnect();
            gain.disconnect();

            // Disconnect Vibrato Chain (CRITICAL: These leak easily)
            vibOsc.stop(); // Ensure it's stopped
            vibOsc.disconnect();
            vibGain.disconnect();
        };
    }
}
////////////////////////////////
function drawField(){
  //////////////main game timer///////
  let now = Date.now();
  let dt = (now - lastFrameTime) / 1000; 
  globalDt = (now - lastFrameTime) / 1000; 
  lastFrameTime = now;
  if (dt > 0.1) dt = 0.1; // Safety cap
  if (globalDt > 0.1) globalDt = 0.1;
  //x,y,z,l,h,type='frame',visible = 1
  
  ////////////////////////////////////
  if (startGame == 0){//intro message
    ctx.fillStyle = "rgba(0,6,13,1)";
    ctx.fillRect(0,0,wX,wY);
    //draw a new portrait every 3 secs
    if (now - lastTriggerTime > 3000) {
        lastrandom = rnd(0,77)
        lastTriggerTime = now;
    }
    else {
      drawPortrait(lastrandom,2.5,3,.5);
      drawShape('rec',1.9,2.9,1,5,5,0,0,0,0,0,0,'gold',0);
    }
    //page text
    drawText(0, .25, 10, .5, "Welcome to Runestones Online!", `rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)})`, 1,'center');
    drawText(.5, 1, 9, 1.75, "Warning! There are many bugs! Proceed at your own risk! Feel free to reach out via Instagram DM (@suncat.meow) or email (suncat.data@gmail.com) with any questions, comments, or concerns. - Suncat", `rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)})`, 1);
    drawText(0, 8.5, 10, 0.8, "Tap to continue", `rgba(60,60,60,${0.6 + 0.4 * Math.sin(Date.now() / 400)})`, 1,'center');
  }
  else if (startGame == 1){//suncat studios 
    ctx.fillStyle = "rgba(0,6,13,1)";
	  ctx.fillRect(0,0,wX,wY);
    //music timer
    if (!MusicEngine.isPlaying()) {
        console.log("Audio failsafe triggered: Restarting music...");
        
  
        
        // Pick a song and play
           song = rnd(0,10)
    
   
        MusicEngine.play(9);
  
         
        lastSongTime = now; // Reset timer so it doesn't skip immediately
    }
    if (now - lastSongTime > 60000) {
      MusicEngine.stop();
      MusicEngine.play(rnd(0,songcount - 1));
      lastSongTime = now;
    }
    //dice formation
    Player[0].d4.animate(5,1,1,1,dt);
    Player[0].d6.animate(2,2,1,1,dt);
    Player[0].d8.animate(8,2,1,1,dt);
    Player[0].d10.animate(2,6.5,1,1,dt);
    Player[0].d12.animate(8,6.5,1,1,dt);
    Player[0].d20.animate(5,7.5,1,1,dt);
    //Coin animation
    if (now - lastTriggerTime > 100) {
      lastTriggerTime = now;
      coinswitch = rnd(0,9)
      if (coinswitch == 0){
        coinanix = coinanix- .1;
        coinaniy = coinaniy - .1;
        coinaniz = coinaniz -.1;
      }
      if (coinswitch == 1){
        coinanix = coinanix + .1;
        coinaniy = coinaniy + .1;
        coinaniz = coinaniz + .1;
      }
      if (coinswitch == 2){
        coinanix = coinanix - .1;
        coinaniy = coinaniy + .1;
        coinaniz = coinaniz + .1;
      }
      if (coinswitch == 3){
        coinanix = coinanix + .1;
        coinaniy = coinaniy - .1;
        coinaniz = coinaniz + .1;
      }
      if (coinswitch == 4){
        coinanix = coinanix + .1;
        coinaniy = coinaniy + .1;
        coinaniz = coinaniz - .1;
      }
      if (coinswitch == 5){
        coinanix = coinanix - .1;
        coinaniy = coinaniy - .1;
        coinaniz = coinaniz + .1;
      }
      if (coinswitch == 8){
        coinanix = coinanix - .1;
        coinaniy = coinaniy + .1;
        coinaniz = coinaniz - .1;
      }
      if (coinswitch == 9){
        coinanix = coinanix + .1;
        coinaniy = coinaniy - .1;
        coinaniz = coinaniz - .1;
      }
      coinanir = coinanir + rnd(-1,1);
      Player[0].d2.animate(coinanix,coinaniy,coinaniz,coinanir,dt);
    }
    else { Player[0].d2.animate(coinanix,coinaniy,coinaniz,coinanir,dt);}
    //page text
    drawText(0, 2.5, 10, 0.6, "A", "rgba(100,100,100,1)", 1,'center');
    drawText(0, 3.5, 10, 2.0, "SUNCAT STUDIO", `rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)})`, 1,'center');
    drawText(0, 5.5, 10, 0.6, "PRODUCTION", "rgba(100,100,100,1)", 1,'center');
    drawText(0, 8.5, 10, 0.8, "Tap to continue", `rgba(60,60,60,${0.6 + 0.4 * Math.sin(Date.now() / 400)})`, 1,'center');
  }
  else if (startGame == 2){//runestones tcg
	//musictimer
   if (!MusicEngine.isPlaying()) {
        console.log("Audio failsafe triggered: Restarting music...");
        
  
        
        // Pick a song and play
           song = rnd(0,10)
    
      if (song == 0) MusicEngine.play(3);
      if (song == 1) MusicEngine.play(6);
      if (song == 2) MusicEngine.play(9);
      if (song == 3) MusicEngine.play(11);
      if (song == 4) MusicEngine.play(12);
      if (song == 5) MusicEngine.play(18);
      if (song == 6) MusicEngine.play(19);
      if (song == 7) MusicEngine.play(20);
      if (song == 8) MusicEngine.play(21);
      if (song == 9) MusicEngine.play(22);
      if (song == 10) MusicEngine.play(24);
         
        lastSongTime = now; // Reset timer so it doesn't skip immediately
    }
  if (now - lastSongTime > 90000) {
    MusicEngine.stop();
    MusicEngine.play(rnd(0,songcount - 1))
    lastSongTime = now;
  }
	ctx.fillStyle = "rgba(0,6,13,1)";
	ctx.fillRect(0,0,wX,wY);
  drawPortrait(-4,1,1.25,.15)//sword
  drawPortrait(-5,3,1.25,.15)//wand
  drawPortrait(-6,5.45,1.25,.15)////shield
  drawPortrait(-7,7.63,1.25,.15)////hourglass
  drawText(0,3.5,10,2,"Runestones TCG",`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)})`,1,'center');
  drawText(0, 5.5, 10, 0.6, "DIGITAL DEMO", "rgba(100,100,100,1)", 1,'center');
  drawText(0,7.5,10,.8,"Tap to start",`rgba(60,60,60,${0.6 + 0.4 * Math.sin(Date.now() / 400)})`,1,'center');
}
  else if (startGame == 3){//selection screen
    ctx.fillStyle = "rgba(0,6,13,1)";
	  ctx.fillRect(0,0,wX,wY);
    //music timer
    if (now - lastSongTime > 90000) {
      MusicEngine.stop();
      MusicEngine.play(rnd(0,songcount - 1))
      lastSongTime = now;
    }  
    //4 suit symbols
    drawPortrait(-4,1,1.25,.15)//sword
    drawPortrait(-5,3,1.25,.15)//wand
    drawPortrait(-6,5.45,1.25,.15)////shield
    drawPortrait(-7,7.63,1.25,.15)////hourglass
    //page text
    drawText(0,3.5,10,2,"Runestones TCG",`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)})`,1,'center');
    drawText(0, 5.5, 10, 0.6, "DIGITAL DEMO", "rgba(100,100,100,1)", 1,'center');
    drawText(0,7,5,.8,"vs CPU",`rgba(60,60,60,${0.6 + 0.4 * Math.sin(Date.now() / 400)})`,1,'center');
    drawText(5,7,5,.8,"vs Local",`rgba(60,60,60,${0.6 + 0.4 * Math.sin(Date.now() / 400)})`,1,'center');
    drawText(0,8.75,5,.8,"Tutorial",`rgba(60,60,60,${0.6 + 0.4 * Math.sin(Date.now() / 400)})`,1,'center');
    drawText(5,8.75,5,.8,"Options",`rgba(60,60,60,${0.6 + 0.4 * Math.sin(Date.now() / 400)})`,1,'center');

}
  else if (startGame > 3){//main game loop
    //standby and after battle
    if ((Player[0].option <= 5 && Player[1].option <= 5) || (Player[0].option > 7 || Player[1].option > 7)){
      //draw padding
	    ctx.fillStyle = "rgba(39,39,39,1)";
	    ctx.fillRect(0,0,wX,wY);
	    //draw table
	    ctx.fillStyle = "rgba(0,6,13,1)";
	    ctx.fillRect(tX,tY,tL,tH);
  
	    //REFRESH PLAYER AND FOE FIELDS
      Player[0].refresh(dt);
	    Player[1].refresh(dt);
      sRune.refresh(dt);
      cRune.refresh(dt);
      iRune.refresh(dt);
      aRune.refresh(dt);
      Player[1].react(dt);
    }
    //during battle
    if ((Player[0].option > 5 && Player[1].option > 5) && (Player[0].option <= 7 || Player[1].option <= 7)){
	    //draw padding
	    ctx.fillStyle = "rgba(39,39,39,1)";
	    ctx.fillRect(0,0,wX,wY);
	    //draw table
	    ctx.fillStyle = "rgba(0,6,13,1)";
	    ctx.fillRect(tX,tY,tL,tH);
      sRune.refresh(dt);
      cRune.refresh(dt);
      iRune.refresh(dt);
      aRune.refresh(dt);
      drawShape('rec',0,0,1,0,0,10,10,0,0,0,0,'rgba(0,0,0,.9)',1);
	  //REFRESH PLAYER AND FOE FIELDS
    }
    //react handles player input throughout options
    Player[0].react(dt);
    
    if (cardIDO ==1){
      view = new Card(cardIDI, 613);
      view.place(1.9,.2,2.75);
      drawShape('arc',view.x,view.y,2.75,0,1.69,.3,0,6,0,0,0,'rgba(255,255,255,.5)',1);//left
      drawShape('tri',view.x,view.y,2.75,.1,1.45,.1,1.9,-.25,1.69,0,0,'rgba(0,0,0,.5)',1);//left
      drawShape('arc',view.x,view.y,2.75,2.25,1.69,.3,0,6,0,0,0,'rgba(255,255,255,.5)',1);//right
      drawShape('tri',view.x,view.y,2.75,2.15,1.45,2.15,1.9,2.5,1.69,0,0,'rgba(0,0,0,.5)',1);//right
      drawText(8.25,.2,1,1,'X','white',1.63);
    }
  
  }//end else startgame == 1
  else if(startGame == 'jukebox'){
    ctx.fillStyle = "rgba(0,6,13,1)";
	  ctx.fillRect(0,0,wX,wY);
    //Coin animation
    if (now - lastTriggerTime > 100) {
      lastTriggerTime = now;
      coinswitch = rnd(0,9)
      if (coinswitch == 0){
        coinanix = coinanix- .1;
        coinaniy = coinaniy - .1;
        coinaniz = coinaniz -.1;
      }
      if (coinswitch == 1){
        coinanix = coinanix + .1;
        coinaniy = coinaniy + .1;
        coinaniz = coinaniz + .1;
      }
      if (coinswitch == 2){
        coinanix = coinanix - .1;
        coinaniy = coinaniy + .1;
        coinaniz = coinaniz + .1;
      }
      if (coinswitch == 3){
        coinanix = coinanix + .1;
        coinaniy = coinaniy - .1;
        coinaniz = coinaniz + .1;
      }
      if (coinswitch == 4){
        coinanix = coinanix + .1;
        coinaniy = coinaniy + .1;
        coinaniz = coinaniz - .1;
      }
      if (coinswitch == 5){
        coinanix = coinanix - .1;
        coinaniy = coinaniy - .1;
        coinaniz = coinaniz + .1;
      }
      if (coinswitch == 8){
        coinanix = coinanix - .1;
        coinaniy = coinaniy + .1;
        coinaniz = coinaniz - .1;
      }
      if (coinswitch == 9){
        coinanix = coinanix + .1;
        coinaniy = coinaniy - .1;
        coinaniz = coinaniz - .1;
      }
      coinanir = coinanir + rnd(-1,1);
      Player[0].d2.animate(coinanix,coinaniy,coinaniz,coinanir,dt);
    }
    else { 
      Player[0].d2.animate(coinanix,coinaniy,coinaniz,coinanir,dt);
    }
    //portrait animation
    if (now - lastTriggerTime2 > 10000) {
      lastrandom = rnd(0,77)
      lastTriggerTime2 = now;
    }
    else {
      drawPortrait(lastrandom,2.5,5,.5);
      
    }

    if (song == 'shuffle'){
      if (now - lastSongTime > 60000) {
      MusicEngine.stop();
      cursong = rnd(0,songcount - 1);
      MusicEngine.play(cursong);
      lastSongTime = now;
    }
    drawText(0, 2.8, 10, 0.6, cursong + ' / ' + (songcount-1), "rgba(100,100,100,1)", 1,'center');
    drawText(0, 1.35, 10, 0.6, 'Shuffle', `rgba(${Math.random*255},${Math.random*255},${Math.random*255},1)`, 1,'center');
    drawText(0, 2.15, 10, 0.5, MusicEngine.style, "rgba(100,100,100,1)", 1,'center');
    
  }else{
      drawText(0, 2.8, 10, 0.6, song + ' / ' + (songcount-1), "rgba(100,100,100,1)", 1,'center')
        
      drawText(0, 1.75, 10, 0.5, MusicEngine.style, "rgba(100,100,100,1)", 1,'center');
      
    }
    

    drawText(0, .5, 10, 0.6, "Jukebox", "rgba(100,100,100,1)", 1,'center');
    drawText(0, 8.75, 2, 1, '<<Back', "rgba(100,100,100,1)", 1);
    drawPortrait(-1,1,3,.2);
    drawPortrait(-2,7,3,.2);
    MessageBox.show(4.4,3.37,1,1.25,1.25,'','jrpg_btn',1,0)
  }
  else if (startGame == 'options'){
    ctx.fillStyle = "rgba(0,6,13,1)";
	  ctx.fillRect(0,0,wX,wY);
    //music timer
    if (now - lastSongTime > 90000) {
      MusicEngine.stop();
      MusicEngine.play(rnd(0,songcount - 1))
      lastSongTime = now;
    }  
    //4 suit symbols
    drawPortrait(-4,1,1.25,.15)//sword
    drawPortrait(-5,3,1.25,.15)//wand
    drawPortrait(-6,5.45,1.25,.15)////shield
    drawPortrait(-7,7.63,1.25,.15)////hourglass
    //page text
    drawText(0,3.5,10,2,"Runestones TCG",`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)})`,1,'center');
    drawText(0, 5.5, 10, 0.6, "DIGITAL DEMO", "rgba(100,100,100,1)", 1,'center');
    drawText(0,7,5,.8,"Jukebox",`rgba(60,60,60,${0.6 + 0.4 * Math.sin(Date.now() / 400)})`,1,'center');
    drawText(5,7,5,.8,"Card Gallery",`rgba(60,60,60,${0.6 + 0.4 * Math.sin(Date.now() / 400)})`,1,'center');
    drawText(5,8.75,5,.8,"Tarot",`rgba(60,60,60,${0.6 + 0.4 * Math.sin(Date.now() / 400)})`,1,'center');

    drawText(0,8.75,2,.8,"<<Back",`rgba(60,60,60,${0.6 + 0.4 * Math.sin(Date.now() / 400)})`,1,'center');
    //drawText(5.75,8.75,8,.8,"Adventure",`rgba(60,60,60,${0.6 + 0.4 * Math.sin(Date.now() / 400)})`,1);

  }
  else if (startGame == 'grimoire'){
    
    ctx.fillStyle = "rgba(0,6,13,1)";
	  ctx.fillRect(0,0,wX,wY);
    //music timer
    if(preGame != 'explore'){
    if (now - lastSongTime > 90000) {
      MusicEngine.stop();
      MusicEngine.play(rnd(0,songcount - 1))
      lastSongTime = now;
    }  
  }
    Player[0].cardID(playlistIndex);//example of using card zoom
    //drawText(5.75,8.75,8,.8,"Adventure",`rgba(60,60,60,${0.6 + 0.4 * Math.sin(Date.now() / 400)})`,1);

  }
  else if (startGame == 'charSelect') {
    switch(ps){
      case 0:
        playerSprite = 0;
        break;
        case 1:
          playerSprite = 1;
        break;
        case 2:
          playerSprite = 2;
        break;
        case 3:
          playerSprite = 3;
        break;
        case 4:
          playerSprite = 4;
        break;
        case 5:
        playerSprite = 5;
        break;
        case 6:
          playerSprite = 8;
        break;
        case 7:
          playerSprite = 9.1;
        break;
        case 8:
          playerSprite = 10;
        break;
        case 9:
          playerSprite = 13;
        break;
        case 10:
          playerSprite = 23.1;
        break;
        case 11:
           playerSprite = 32.1;
        break;
        case 12:
           playerSprite = 33.1;
        break;
        case 13:
           playerSprite = 34.1;
        break;
        case 14:
           playerSprite = 35.1;
        break;
        case 15:
           playerSprite = 37.1;
        break;
        case 16:
           playerSprite = 46.1;
        break;
        case 17:
           playerSprite = 48.1;
        break;
        case 18:
           playerSprite = 54;
        break;
        case 19:
           playerSprite = 56.1;
        break;
        case 20:
           playerSprite = 57.1;
        break;
        case 21:
           playerSprite = 60.1;
        break;
        case 22:
           playerSprite = 61.1;
        break;
        case 23:
           playerSprite = 61.2;
        break;
        case 24:
           playerSprite = 50;
        break;
        case 25:
           playerSprite = 23;
        break;
        case 26:
           playerSprite = 77.1;
        break;
        case 27:
           playerSprite = 77.2;
        break;
        case 28:
           playerSprite = 75.1;
        break;
        case 29:
           playerSprite = 81;
        break;
        case 30:
           playerSprite = 82;
        break;
        case 31:
           playerSprite = 56;
        break;
        case 32:
           playerSprite = 28888;
        break;
        case 33:
           playerSprite = 62.1;
        break;

    }
    ctx.fillStyle = "rgba(0,6,13,1)";
    ctx.fillRect(0,0,wX,wY);

    // 1. Draw Title
    drawText(0, 1, 10, 1, "Who are you?", "white", 1, 'center');

    // 2. Draw Sprite Selector (Jukebox Style)
    // Left Arrow
    drawPortrait(-1, 1.5, 4, 0.2); 
    // Right Arrow
    drawPortrait(-2, 7.5, 4, 0.2); 
    
    // The Sprite Itself (Center) - Animating!
    // We use your 'drawPortrait' but maybe you have a specific 'drawActor' function? 
    // Assuming drawPortrait takes (id, x, y, zoom):
    drawPortrait(playerSprite, 3.5, 2.5, .39); 
    
    // 3. Name Input
    drawText(0, 6.5, 10, 0.6, "Enter Name:", "gray", 1, 'center');
    
    // VISUAL TRICK: If they are typing, show the draft. If not, show the saved name.
    let nameDisplay = isChatActive ? chatDraft + "_" : playerName;
    
    // Draw the Name Box
    drawShape('rec', 2, 7.2, 1, 7.2, 8.2, 6, 6, 0,0,0,0, 'white', 0); // Underline/Box
    drawText(0, 7.3, 10, 0.8, nameDisplay, "yellow", 1, 'center');

    // 4. Confirm Button
    // We use the 'jrpg_btn' style you used in jukebox
    MessageBox.show(3.5, 8.5, 1, 3, 1, '', 'jrpg_btn', 1, 0); 
    drawText(0, 8.65, 10, 0.6, "BEGIN FATE", "white", 1, 'center');
  }
  else if (startGame == 'tarot'){
    ctx.fillStyle = "rgba(0,6,13,1)";
    ctx.fillRect(0,0,wX,wY);
    if (spread == 0){
      
      drawPortrait(-4,1.25,5.25,.25)//sword
      drawPortrait(-5,1.25,2.25,.25)//wand
      drawPortrait(-6,6.25,5.25,.25)////shield
      drawPortrait(-7,6.25,2.25,.25)////hourglass
      drawText(0,0.5,10,1,"Select a Spread:",`gray`,1,'center');

    }
    //wands
    if (spread == 1){
      drawPortrait(-5,0,0,1)//wand
      drawText(0,0.25,10,1,"One Truth",`gray`,1,'center');
      drawText(0,1.5,10,1,"Focus on a specific issue, relationship, or decision, asking, 'What is the one truth I need to know about this situation?'",`gray`,1,'center');
      Oracle.deck[0].place(3.75,3.6,1,false)
      Oracle.deck[0].location = 'field'

      
      
      
      
    }
    //cups
    if (spread == 2){

      drawPortrait(-7,0,0,1)////hourglass

      drawText(0,9.35,10,.5,"Situation",`gray`,1,'center');
      Oracle.deck[0].place(3.88,.75,1,false)
      Oracle.deck[0].location = 'field'

      drawText(0,0.2,10,.5,"Challenge",`gray`,1,'center');
      Oracle.deck[1].place(3.88,5.8,1,false)
      Oracle.deck[1].location = 'field'

      
      drawText(0,3.75,3,3,"Focus on a dilemma, conflict, or bottleneck.",`gray`,1,'center');
      drawText(7,3.75,3,3,"Ask, 'What is the true nature of my current reality, and what is the primary obstacle that I must navigate?'",`gray`,1,'center');

      
    }
    //swords
    if (spread == 3){

      drawPortrait(-4,0,0,1)//sword
      Oracle.deck[0].place(1,.5,1,false)
      Oracle.deck[0].location = 'field'
      drawShape('rec',0,0,1,Oracle.deck[0].x,Oracle.deck[0].y-.48,2.25,.4,0,0,0,0,'rgba(0,0,0,.5)',1)
      drawShape('rec',0,0,1,Oracle.deck[0].x,Oracle.deck[0].y+3.5,2.25,.42,0,0,0,0,'rgba(0,0,0,.5)',1)
      drawText(Oracle.deck[0].x,Oracle.deck[0].y-.5,2.25,.5,"Mind",`gray`,1,'center');
      drawText(Oracle.deck[0].x,Oracle.deck[0].y+3.5,2.25,.5,"Past",`gray`,1,'center');

      Oracle.deck[1].place(4,3.25,1,false)
      Oracle.deck[1].location = 'field'
      drawShape('rec',0,0,1,Oracle.deck[1].x,Oracle.deck[1].y-.48,2.25,.4,0,0,0,0,'rgba(0,0,0,.5)',1)
      drawShape('rec',0,0,1,Oracle.deck[1].x,Oracle.deck[1].y+3.5,2.25,.42,0,0,0,0,'rgba(0,0,0,.5)',1)
      drawText(Oracle.deck[1].x,Oracle.deck[1].y-.5,2.25,.5,"Body",`gray`,1,'center');
      drawText(Oracle.deck[1].x,Oracle.deck[1].y+3.5,2.25,.5,"Present",`gray`,1,'center');
      
      Oracle.deck[2].place(7.5,6,1,false)
      Oracle.deck[2].location = 'field'
      drawShape('rec',0,0,1,Oracle.deck[2].x,Oracle.deck[2].y-.48,2.25,.4,0,0,0,0,'rgba(0,0,0,.5)',1)
      drawShape('rec',0,0,1,Oracle.deck[2].x,Oracle.deck[2].y+3.5,2.25,.42,0,0,0,0,'rgba(0,0,0,.5)',1)
      drawText(Oracle.deck[2].x,Oracle.deck[2].y-.5,2.25,.5,"Spirit",`gray`,1,'center');
      drawText(Oracle.deck[2].x,Oracle.deck[2].y+3.5,2.25,.5,"Future",`gray`,1,'center');
      
      drawText(0,5.5,3.6,3.1,"Focus on a specific journey, project, or relationship.",`gray`,1,'left');
      drawText(6.75,.5,3.25,3.5,"Ask, 'How did the past manifest into my present, and what is forming for the future?'",`gray`,1,'left');

    }
    //pentacle
    if (spread == 4){
      drawPortrait(-6,0,0,1)////shield
      Oracle.deck[0].place(3.88,.075,1,false)
      Oracle.deck[0].location = 'field'
      drawShape('rec',0,0,1,Oracle.deck[0].x,Oracle.deck[0].y+3.5,2.25,.42,0,0,0,0,'rgba(0,0,0,.5)',1)
      drawText(Oracle.deck[0].x,Oracle.deck[0].y+3.5,2.25,.5,"Air/Mind",`gray`,1,'center');
      
      Oracle.deck[1].place(1,3.25,1,false)
      Oracle.deck[1].location = 'field'
      drawShape('rec',0,0,1,Oracle.deck[1].x,Oracle.deck[1].y-.48,2.25,.4,0,0,0,0,'rgba(0,0,0,.5)',1)
      drawText(Oracle.deck[1].x,Oracle.deck[1].y-.5,2.25,.5,"Fire/Will",`gray`,1,'center');
      
      Oracle.deck[2].place(6.75,3.25,1,false)
      Oracle.deck[2].location = 'field'
      drawShape('rec',0,0,1,Oracle.deck[2].x,Oracle.deck[2].y-.48,2.25,.4,0,0,0,0,'rgba(0,0,0,.5)',1)
      drawText(Oracle.deck[2].x,Oracle.deck[2].y-.5,2.25,.5,"Earth/Body",`gray`,1,'center');
      
      Oracle.deck[3].place(3.88,6.45,1,false)
      Oracle.deck[3].location = 'field'
      drawShape('rec',0,0,1,Oracle.deck[3].x,Oracle.deck[3].y-.48,2.25,.4,0,0,0,0,'rgba(0,0,0,.5)',1)
      drawText(Oracle.deck[3].x,Oracle.deck[3].y-.5,2.25,.5,"Water/Heart",`gray`,1,'center');
      
      drawText(0,0,3,2,"Focus on your current state of balance.",`gray`,1,'center');
      drawText(7,0,3,2,"Ask, 'How is my energy flowing through my Mind, Heart, Body, and Spirit?'",`gray`,1,'left');
      

    }
    drawText(0,8.75,2,.8,"<<Back",`rgba(60,60,60,${0.6 + 0.4 * Math.sin(Date.now() / 400)})`,1,'center');

  }
  if (startGame == 'explore'||startGame == 'dialogue'||startGame == 'tutorial'){
    ctx.fillStyle = "rgba(0,6,13,1)";
    ctx.fillRect(0,0,wX,wY);
    Dungeon.render(globalDt);
    drawChatInterface();
  }
  if(startGame == 'dialogue'){ // NEW
    Dungeon.dialogue();
  }
  if(startGame == 'tutorial'){ // NEW
    Dungeon.tutorial(dt);
    if (now - lastTriggerTime > 5000) {
      //intro to monsters and attack
      if (Dungeon.option == 7 && ( (Dungeon.dCounter >0 && Dungeon.dCounter <2) || (Dungeon.dCounter >2 &&Dungeon.dCounter <= 3) || (Dungeon.dCounter >4 && Dungeon.dCounter <6) ) ){}
      else{
        if (Dungeon.dCounter != 6 ||Dungeon.option == 6||Dungeon.option == 7||Dungeon.option == 9){Dungeon.dCounter = Dungeon.dCounter + 1;}
      }
      //Agility tutotial
      if(Dungeon.option == 4&&Dungeon.at >= 36){Dungeon.at = Dungeon.at + 1;}
      if(Dungeon.option == 4&&Dungeon.at == 31){Dungeon.at = 36;}
      //fool attacks, high priestess defends, fool is slain
      if(Dungeon.option == 5&&Dungeon.at >= 75){Dungeon.at = Dungeon.at + 1;}
      if(Dungeon.option == 5&&Dungeon.at == 69){Dungeon.at = 76;}
      //Agility ROUND 2 
      if(Dungeon.option == 8&&Dungeon.at >= 36){Dungeon.at = Dungeon.at + 1;}
      if(Dungeon.option == 8&&Dungeon.at == 31){Dungeon.at = 36;}
      lastTriggerTime = now;
    }
  }
  if(startGame == 'battle'){
    if (resize == 0){
      resizeCanvas()
      resize = 1
    }
      //Dungeon.battle(); 
      
      if ((Player[0].option <= 5 && Player[1].option <= 5) || (Player[0].option > 7 && Player[1].option > 7)){
      //draw padding
	    ctx.fillStyle = "rgba(39,39,39,1)";
	    ctx.fillRect(0,0,wX,wY);
	    //draw table
	    ctx.fillStyle = "rgba(0,6,13,1)";
	    ctx.fillRect(tX,tY,tL,tH);
  
	    //REFRESH PLAYER AND FOE FIELDS
      Player[0].refresh(dt);
	    Player[1].refresh(dt);
      sRune.refresh(dt);
      cRune.refresh(dt);
      iRune.refresh(dt);
      aRune.refresh(dt);
      Player[1].react(dt);
    }
    //during battle
    if ((Player[0].option > 5 ) && (Player[0].option <= 7 || Player[1].option <= 7)){
	    //draw padding
	    ctx.fillStyle = "rgba(39,39,39,1)";
	    ctx.fillRect(0,0,wX,wY);
	    //draw table
	    ctx.fillStyle = "rgba(0,6,13,1)";
	    ctx.fillRect(tX,tY,tL,tH);
      sRune.refresh(dt);
      cRune.refresh(dt);
      iRune.refresh(dt);
      aRune.refresh(dt);
      drawShape('rec',0,0,1,0,0,10,10,0,0,0,0,'rgba(0,0,0,.9)',1);
      
	  //REFRESH PLAYER AND FOE FIELDS
    }
          Player[0].react(dt);

    //react handles player input throughout options
    if((Player[0].option > 5&&Player[1].option == 5)){
      Player[0].react(dt);
      Player[1].react(dt);
    }
    
    
    
     if (cardIDO ==1){
      view = new Card(cardIDI, 613);
      view.place(1.9,.2,2.75);
      drawShape('arc',view.x,view.y,2.75,0,1.69,.3,0,6,0,0,0,'rgba(255,255,255,.5)',1);//left
      drawShape('tri',view.x,view.y,2.75,.1,1.45,.1,1.9,-.25,1.69,0,0,'rgba(0,0,0,.5)',1);//left
      drawShape('arc',view.x,view.y,2.75,2.25,1.69,.3,0,6,0,0,0,'rgba(255,255,255,.5)',1);//right
      drawShape('tri',view.x,view.y,2.75,2.15,1.45,2.15,1.9,2.5,1.69,0,0,'rgba(0,0,0,.5)',1);//right
      drawText(8.25,.2,1,1,'X','white',1.63);
    }
  
        drawChatInterface();

    }
  
  requestAnimationFrame(drawField);
  
  if (debug == 2){
    ctx.fillStyle = "rgba(0,6,13,1)";
    ctx.fillRect(0,0,wX,wY);
	  drawPortrait(portrait,0,0,1);
    //drawText(7.7,8,2,2,''+Player[0].at,'white',1);
  }
  if (debug == 1 || debug == 2){
	  for(h=0;h<20;h++){ //grid lines
		  drawShape('lin',0,0,.5,h,0,h,20,0,0,0,0,'green',0);
		  drawShape('lin',0,0,.5,0,h,20,h,0,0,0,0,'green',0);
      if (h < 10){    
        drawText(h-.25,0,.5,.5,'' + (h),'blue',1);
        drawText(-.25,h,.5,.5,'' + (h),'blue',1); 
      }
      if (h%2 == 0){
        drawShape('lin',0,0,.5,h,0,h,20,0,0,0,0,'red',0);
        drawShape('lin',0,0,.5,0,h,20,h,0,0,0,0,'red',0);
      }
	  }
   // drawText(8,2,2,1,'Dir:' + Dungeon.dir,'white',1)
  }
  if (debug == 3){
    if (now - lastSongTime > 90000) {
      MusicEngine.stop();
      MusicEngine.play(rnd(0,22))
      lastSongTime = now;
    }  
	  for(h=0;h<10;h++){ //grid lines
		  drawShape('lin',0,0,1,0,h,5,5, 0,0,0,0,'green',0);//x line
		  drawShape('lin',0,0,1,10,h,5,5,0,0,0,0,'green',0);
      
      
        drawShape('lin',0,0,1,h,0,5,5,0,0,0,0,'red',0);
        drawShape('lin',0,0,1,h,10,5,5,0,0,0,0,'red',0);
      
	  }
  }
}//END FUNCTION
/////////////////////[END MAIN GAME LOOP]////////////////////////


////////////////////////[FUNCTION CALLS]//////////////////////////
// Add this at the very start of cardID

drawField();//starts the game loop
  /*
  example of moving message boxes with dt
  if (MessageBox.visible == 1){
    MessageBox.show(MessageBox.x + dt,2,MessageBox.z-dt*.1,2,2,'frame',1,3,3,2)
    if (MessageBox.x+MessageBox.l*MessageBox.z >= 10){
      MessageBox.show(MessageBox.originx,2,MessageBox.z,2,2,'frame',1,3,3,2)
      MessageBox.visible = 2;
    }
  }
  if (MessageBox.visible == 2){
    MessageBox.show(MessageBox.originx,2,MessageBox.z - dt*.1,2,2,'frame',1,3,3,2)
    if (MessageBox.z <=0){
      MessageBox.show(MessageBox.originx,2,MessageBox.originz,2,2,'frame',1,3,3,2)
      MessageBox.visible = 3
    }
  }
  if (MessageBox.visible == 3){
    MessageBox.show(MessageBox.originx,2,MessageBox.originz,2,2,'frame',1,3,3,2)
  }*/
/////////////////////////[END OF SCRIPT]//////////////////////////
</script>
</body>
</html>>